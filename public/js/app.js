/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __commonJS = (callback, module) => () => {\n  if (!module) {\n    module = {exports: {}};\n    callback(module.exports, module);\n  }\n  return module.exports;\n};\nvar __exportStar = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);\n};\n\n// node_modules/@vue/shared/dist/shared.cjs.js\nvar require_shared_cjs = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  function makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(\",\");\n    for (let i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n  }\n  var PatchFlagNames = {\n    [1]: `TEXT`,\n    [2]: `CLASS`,\n    [4]: `STYLE`,\n    [8]: `PROPS`,\n    [16]: `FULL_PROPS`,\n    [32]: `HYDRATE_EVENTS`,\n    [64]: `STABLE_FRAGMENT`,\n    [128]: `KEYED_FRAGMENT`,\n    [256]: `UNKEYED_FRAGMENT`,\n    [512]: `NEED_PATCH`,\n    [1024]: `DYNAMIC_SLOTS`,\n    [2048]: `DEV_ROOT_FRAGMENT`,\n    [-1]: `HOISTED`,\n    [-2]: `BAIL`\n  };\n  var slotFlagsText = {\n    [1]: \"STABLE\",\n    [2]: \"DYNAMIC\",\n    [3]: \"FORWARDED\"\n  };\n  var GLOBALS_WHITE_LISTED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt\";\n  var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);\n  var range = 2;\n  function generateCodeFrame(source, start2 = 0, end = source.length) {\n    const lines = source.split(/\\r?\\n/);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start2) {\n        for (let j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length)\n            continue;\n          const line = j + 1;\n          res.push(`${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n          const lineLength = lines[j].length;\n          if (j === i) {\n            const pad = start2 - (count - lineLength) + 1;\n            const length = Math.max(1, end > count ? lineLength - pad : end - start2);\n            res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n          } else if (j > i) {\n            if (end > count) {\n              const length = Math.max(Math.min(end - count, lineLength), 1);\n              res.push(`   |  ` + \"^\".repeat(length));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break;\n      }\n    }\n    return res.join(\"\\n\");\n  }\n  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\n  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\n  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\n  var unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\n  var attrValidationCache = {};\n  function isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n      return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n      console.error(`unsafe attribute name: ${name}`);\n    }\n    return attrValidationCache[name] = !isUnsafe;\n  }\n  var propsToAttrMap = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\"\n  };\n  var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);\n  var isKnownAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);\n  function normalizeStyle(value) {\n    if (isArray(value)) {\n      const res = {};\n      for (let i = 0; i < value.length; i++) {\n        const item = value[i];\n        const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\n        if (normalized) {\n          for (const key in normalized) {\n            res[key] = normalized[key];\n          }\n        }\n      }\n      return res;\n    } else if (isObject(value)) {\n      return value;\n    }\n  }\n  var listDelimiterRE = /;(?![^(]*\\))/g;\n  var propertyDelimiterRE = /:(.+)/;\n  function parseStringStyle(cssText) {\n    const ret = {};\n    cssText.split(listDelimiterRE).forEach((item) => {\n      if (item) {\n        const tmp = item.split(propertyDelimiterRE);\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return ret;\n  }\n  function stringifyStyle(styles) {\n    let ret = \"\";\n    if (!styles) {\n      return ret;\n    }\n    for (const key in styles) {\n      const value = styles[key];\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      if (isString(value) || typeof value === \"number\" && isNoUnitNumericStyleProp(normalizedKey)) {\n        ret += `${normalizedKey}:${value};`;\n      }\n    }\n    return ret;\n  }\n  function normalizeClass(value) {\n    let res = \"\";\n    if (isString(value)) {\n      res = value;\n    } else if (isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const normalized = normalizeClass(value[i]);\n        if (normalized) {\n          res += normalized + \" \";\n        }\n      }\n    } else if (isObject(value)) {\n      for (const name in value) {\n        if (value[name]) {\n          res += name + \" \";\n        }\n      }\n    }\n    return res.trim();\n  }\n  var HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\n  var SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\n  var VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\n  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\n  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\n  var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n  var escapeRE = /[\"'&<>]/;\n  function escapeHtml(string) {\n    const str = \"\" + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n      return str;\n    }\n    let html = \"\";\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n      switch (str.charCodeAt(index)) {\n        case 34:\n          escaped = \"&quot;\";\n          break;\n        case 38:\n          escaped = \"&amp;\";\n          break;\n        case 39:\n          escaped = \"&#39;\";\n          break;\n        case 60:\n          escaped = \"&lt;\";\n          break;\n        case 62:\n          escaped = \"&gt;\";\n          break;\n        default:\n          continue;\n      }\n      if (lastIndex !== index) {\n        html += str.substring(lastIndex, index);\n      }\n      lastIndex = index + 1;\n      html += escaped;\n    }\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n  }\n  var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\n  function escapeHtmlComment(src) {\n    return src.replace(commentStripRE, \"\");\n  }\n  function looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n      return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n      equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n  }\n  function looseEqual(a, b) {\n    if (a === b)\n      return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n      if (!aValidType || !bValidType) {\n        return false;\n      }\n      const aKeysCount = Object.keys(a).length;\n      const bKeysCount = Object.keys(b).length;\n      if (aKeysCount !== bKeysCount) {\n        return false;\n      }\n      for (const key in a) {\n        const aHasKey = a.hasOwnProperty(key);\n        const bHasKey = b.hasOwnProperty(key);\n        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n    return String(a) === String(b);\n  }\n  function looseIndexOf(arr, val) {\n    return arr.findIndex((item) => looseEqual(item, val));\n  }\n  var toDisplayString = (val) => {\n    return val == null ? \"\" : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);\n  };\n  var replacer = (_key, val) => {\n    if (isMap(val)) {\n      return {\n        [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {\n          entries[`${key} =>`] = val2;\n          return entries;\n        }, {})\n      };\n    } else if (isSet(val)) {\n      return {\n        [`Set(${val.size})`]: [...val.values()]\n      };\n    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n      return String(val);\n    }\n    return val;\n  };\n  var babelParserDefaultPlugins = [\n    \"bigInt\",\n    \"optionalChaining\",\n    \"nullishCoalescingOperator\"\n  ];\n  var EMPTY_OBJ = Object.freeze({});\n  var EMPTY_ARR = Object.freeze([]);\n  var NOOP = () => {\n  };\n  var NO = () => false;\n  var onRE = /^on[^a-z]/;\n  var isOn = (key) => onRE.test(key);\n  var isModelListener = (key) => key.startsWith(\"onUpdate:\");\n  var extend = Object.assign;\n  var remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n      arr.splice(i, 1);\n    }\n  };\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var hasOwn = (val, key) => hasOwnProperty.call(val, key);\n  var isArray = Array.isArray;\n  var isMap = (val) => toTypeString(val) === \"[object Map]\";\n  var isSet = (val) => toTypeString(val) === \"[object Set]\";\n  var isDate = (val) => val instanceof Date;\n  var isFunction = (val) => typeof val === \"function\";\n  var isString = (val) => typeof val === \"string\";\n  var isSymbol = (val) => typeof val === \"symbol\";\n  var isObject = (val) => val !== null && typeof val === \"object\";\n  var isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n  };\n  var objectToString = Object.prototype.toString;\n  var toTypeString = (value) => objectToString.call(value);\n  var toRawType = (value) => {\n    return toTypeString(value).slice(8, -1);\n  };\n  var isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\n  var isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\n  var isReservedProp = /* @__PURE__ */ makeMap(\",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\");\n  var cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return (str) => {\n      const hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  };\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n  });\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\n  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n  var invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n      fns[i](arg);\n    }\n  };\n  var def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      enumerable: false,\n      value\n    });\n  };\n  var toNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  };\n  var _globalThis;\n  var getGlobalThis = () => {\n    return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : {});\n  };\n  exports.EMPTY_ARR = EMPTY_ARR;\n  exports.EMPTY_OBJ = EMPTY_OBJ;\n  exports.NO = NO;\n  exports.NOOP = NOOP;\n  exports.PatchFlagNames = PatchFlagNames;\n  exports.babelParserDefaultPlugins = babelParserDefaultPlugins;\n  exports.camelize = camelize;\n  exports.capitalize = capitalize;\n  exports.def = def;\n  exports.escapeHtml = escapeHtml;\n  exports.escapeHtmlComment = escapeHtmlComment;\n  exports.extend = extend;\n  exports.generateCodeFrame = generateCodeFrame;\n  exports.getGlobalThis = getGlobalThis;\n  exports.hasChanged = hasChanged;\n  exports.hasOwn = hasOwn;\n  exports.hyphenate = hyphenate;\n  exports.invokeArrayFns = invokeArrayFns;\n  exports.isArray = isArray;\n  exports.isBooleanAttr = isBooleanAttr2;\n  exports.isDate = isDate;\n  exports.isFunction = isFunction;\n  exports.isGloballyWhitelisted = isGloballyWhitelisted;\n  exports.isHTMLTag = isHTMLTag;\n  exports.isIntegerKey = isIntegerKey;\n  exports.isKnownAttr = isKnownAttr;\n  exports.isMap = isMap;\n  exports.isModelListener = isModelListener;\n  exports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;\n  exports.isObject = isObject;\n  exports.isOn = isOn;\n  exports.isPlainObject = isPlainObject;\n  exports.isPromise = isPromise;\n  exports.isReservedProp = isReservedProp;\n  exports.isSSRSafeAttrName = isSSRSafeAttrName;\n  exports.isSVGTag = isSVGTag;\n  exports.isSet = isSet;\n  exports.isSpecialBooleanAttr = isSpecialBooleanAttr;\n  exports.isString = isString;\n  exports.isSymbol = isSymbol;\n  exports.isVoidTag = isVoidTag;\n  exports.looseEqual = looseEqual;\n  exports.looseIndexOf = looseIndexOf;\n  exports.makeMap = makeMap;\n  exports.normalizeClass = normalizeClass;\n  exports.normalizeStyle = normalizeStyle;\n  exports.objectToString = objectToString;\n  exports.parseStringStyle = parseStringStyle;\n  exports.propsToAttrMap = propsToAttrMap;\n  exports.remove = remove;\n  exports.slotFlagsText = slotFlagsText;\n  exports.stringifyStyle = stringifyStyle;\n  exports.toDisplayString = toDisplayString;\n  exports.toHandlerKey = toHandlerKey;\n  exports.toNumber = toNumber;\n  exports.toRawType = toRawType;\n  exports.toTypeString = toTypeString;\n});\n\n// node_modules/@vue/shared/index.js\nvar require_shared = __commonJS((exports, module) => {\n  \"use strict\";\n  if (false) {} else {\n    module.exports = require_shared_cjs();\n  }\n});\n\n// node_modules/@vue/reactivity/dist/reactivity.cjs.js\nvar require_reactivity_cjs = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  var shared = require_shared();\n  var targetMap = new WeakMap();\n  var effectStack = [];\n  var activeEffect;\n  var ITERATE_KEY = Symbol(\"iterate\");\n  var MAP_KEY_ITERATE_KEY = Symbol(\"Map key iterate\");\n  function isEffect(fn) {\n    return fn && fn._isEffect === true;\n  }\n  function effect3(fn, options = shared.EMPTY_OBJ) {\n    if (isEffect(fn)) {\n      fn = fn.raw;\n    }\n    const effect4 = createReactiveEffect(fn, options);\n    if (!options.lazy) {\n      effect4();\n    }\n    return effect4;\n  }\n  function stop2(effect4) {\n    if (effect4.active) {\n      cleanup(effect4);\n      if (effect4.options.onStop) {\n        effect4.options.onStop();\n      }\n      effect4.active = false;\n    }\n  }\n  var uid = 0;\n  function createReactiveEffect(fn, options) {\n    const effect4 = function reactiveEffect() {\n      if (!effect4.active) {\n        return fn();\n      }\n      if (!effectStack.includes(effect4)) {\n        cleanup(effect4);\n        try {\n          enableTracking();\n          effectStack.push(effect4);\n          activeEffect = effect4;\n          return fn();\n        } finally {\n          effectStack.pop();\n          resetTracking();\n          activeEffect = effectStack[effectStack.length - 1];\n        }\n      }\n    };\n    effect4.id = uid++;\n    effect4.allowRecurse = !!options.allowRecurse;\n    effect4._isEffect = true;\n    effect4.active = true;\n    effect4.raw = fn;\n    effect4.deps = [];\n    effect4.options = options;\n    return effect4;\n  }\n  function cleanup(effect4) {\n    const {deps} = effect4;\n    if (deps.length) {\n      for (let i = 0; i < deps.length; i++) {\n        deps[i].delete(effect4);\n      }\n      deps.length = 0;\n    }\n  }\n  var shouldTrack = true;\n  var trackStack = [];\n  function pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n  }\n  function enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n  }\n  function resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === void 0 ? true : last;\n  }\n  function track(target, type, key) {\n    if (!shouldTrack || activeEffect === void 0) {\n      return;\n    }\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Set());\n    }\n    if (!dep.has(activeEffect)) {\n      dep.add(activeEffect);\n      activeEffect.deps.push(dep);\n      if (activeEffect.options.onTrack) {\n        activeEffect.options.onTrack({\n          effect: activeEffect,\n          target,\n          type,\n          key\n        });\n      }\n    }\n  }\n  function trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n      return;\n    }\n    const effects = new Set();\n    const add2 = (effectsToAdd) => {\n      if (effectsToAdd) {\n        effectsToAdd.forEach((effect4) => {\n          if (effect4 !== activeEffect || effect4.allowRecurse) {\n            effects.add(effect4);\n          }\n        });\n      }\n    };\n    if (type === \"clear\") {\n      depsMap.forEach(add2);\n    } else if (key === \"length\" && shared.isArray(target)) {\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 >= newValue) {\n          add2(dep);\n        }\n      });\n    } else {\n      if (key !== void 0) {\n        add2(depsMap.get(key));\n      }\n      switch (type) {\n        case \"add\":\n          if (!shared.isArray(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n            if (shared.isMap(target)) {\n              add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (shared.isIntegerKey(key)) {\n            add2(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!shared.isArray(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n            if (shared.isMap(target)) {\n              add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (shared.isMap(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n    const run = (effect4) => {\n      if (effect4.options.onTrigger) {\n        effect4.options.onTrigger({\n          effect: effect4,\n          target,\n          key,\n          type,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      }\n      if (effect4.options.scheduler) {\n        effect4.options.scheduler(effect4);\n      } else {\n        effect4();\n      }\n    };\n    effects.forEach(run);\n  }\n  var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);\n  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(shared.isSymbol));\n  var get2 = /* @__PURE__ */ createGetter();\n  var shallowGet = /* @__PURE__ */ createGetter(false, true);\n  var readonlyGet = /* @__PURE__ */ createGetter(true);\n  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\n  var arrayInstrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    const method = Array.prototype[key];\n    arrayInstrumentations[key] = function(...args) {\n      const arr = toRaw2(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = method.apply(arr, args);\n      if (res === -1 || res === false) {\n        return method.apply(arr, args.map(toRaw2));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    const method = Array.prototype[key];\n    arrayInstrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = method.apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  function createGetter(isReadonly2 = false, shallow = false) {\n    return function get3(target, key, receiver) {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n        return target;\n      }\n      const targetIsArray = shared.isArray(target);\n      if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      const res = Reflect.get(target, key, receiver);\n      if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n        return res;\n      }\n      if (!isReadonly2) {\n        track(target, \"get\", key);\n      }\n      if (shallow) {\n        return res;\n      }\n      if (isRef(res)) {\n        const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);\n        return shouldUnwrap ? res.value : res;\n      }\n      if (shared.isObject(res)) {\n        return isReadonly2 ? readonly(res) : reactive3(res);\n      }\n      return res;\n    };\n  }\n  var set2 = /* @__PURE__ */ createSetter();\n  var shallowSet = /* @__PURE__ */ createSetter(true);\n  function createSetter(shallow = false) {\n    return function set3(target, key, value, receiver) {\n      let oldValue = target[key];\n      if (!shallow) {\n        value = toRaw2(value);\n        oldValue = toRaw2(oldValue);\n        if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\n          oldValue.value = value;\n          return true;\n        }\n      }\n      const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);\n      const result = Reflect.set(target, key, value, receiver);\n      if (target === toRaw2(receiver)) {\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (shared.hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n      }\n      return result;\n    };\n  }\n  function deleteProperty(target, key) {\n    const hadKey = shared.hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  function has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  function ownKeys(target) {\n    track(target, \"iterate\", shared.isArray(target) ? \"length\" : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n  }\n  var mutableHandlers = {\n    get: get2,\n    set: set2,\n    deleteProperty,\n    has,\n    ownKeys\n  };\n  var readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n      {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n      }\n      return true;\n    },\n    deleteProperty(target, key) {\n      {\n        console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n      }\n      return true;\n    }\n  };\n  var shallowReactiveHandlers = shared.extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n  });\n  var shallowReadonlyHandlers = shared.extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n  });\n  var toReactive = (value) => shared.isObject(value) ? reactive3(value) : value;\n  var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;\n  var toShallow = (value) => value;\n  var getProto = (v) => Reflect.getPrototypeOf(v);\n  function get$1(target, key, isReadonly2 = false, isShallow = false) {\n    target = target[\"__v_raw\"];\n    const rawTarget = toRaw2(target);\n    const rawKey = toRaw2(key);\n    if (key !== rawKey) {\n      !isReadonly2 && track(rawTarget, \"get\", key);\n    }\n    !isReadonly2 && track(rawTarget, \"get\", rawKey);\n    const {has: has2} = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    if (has2.call(rawTarget, key)) {\n      return wrap(target.get(key));\n    } else if (has2.call(rawTarget, rawKey)) {\n      return wrap(target.get(rawKey));\n    } else if (target !== rawTarget) {\n      target.get(key);\n    }\n  }\n  function has$1(key, isReadonly2 = false) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw2(target);\n    const rawKey = toRaw2(key);\n    if (key !== rawKey) {\n      !isReadonly2 && track(rawTarget, \"has\", key);\n    }\n    !isReadonly2 && track(rawTarget, \"has\", rawKey);\n    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n  }\n  function size(target, isReadonly2 = false) {\n    target = target[\"__v_raw\"];\n    !isReadonly2 && track(toRaw2(target), \"iterate\", ITERATE_KEY);\n    return Reflect.get(target, \"size\", target);\n  }\n  function add(value) {\n    value = toRaw2(value);\n    const target = toRaw2(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n      target.add(value);\n      trigger(target, \"add\", value, value);\n    }\n    return this;\n  }\n  function set$1(key, value) {\n    value = toRaw2(value);\n    const target = toRaw2(this);\n    const {has: has2, get: get3} = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw2(key);\n      hadKey = has2.call(target, key);\n    } else {\n      checkIdentityKeys(target, has2, key);\n    }\n    const oldValue = get3.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n      trigger(target, \"add\", key, value);\n    } else if (shared.hasChanged(value, oldValue)) {\n      trigger(target, \"set\", key, value, oldValue);\n    }\n    return this;\n  }\n  function deleteEntry(key) {\n    const target = toRaw2(this);\n    const {has: has2, get: get3} = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw2(key);\n      hadKey = has2.call(target, key);\n    } else {\n      checkIdentityKeys(target, has2, key);\n    }\n    const oldValue = get3 ? get3.call(target, key) : void 0;\n    const result = target.delete(key);\n    if (hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  function clear() {\n    const target = toRaw2(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);\n    const result = target.clear();\n    if (hadItems) {\n      trigger(target, \"clear\", void 0, void 0, oldTarget);\n    }\n    return result;\n  }\n  function createForEach(isReadonly2, isShallow) {\n    return function forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw2(target);\n      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    };\n  }\n  function createIterableMethod(method, isReadonly2, isShallow) {\n    return function(...args) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw2(target);\n      const targetIsMap = shared.isMap(rawTarget);\n      const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n      const isKeyOnly = method === \"keys\" && targetIsMap;\n      const innerIterator = target[method](...args);\n      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n      return {\n        next() {\n          const {value, done} = innerIterator.next();\n          return done ? {value, done} : {\n            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n            done\n          };\n        },\n        [Symbol.iterator]() {\n          return this;\n        }\n      };\n    };\n  }\n  function createReadonlyMethod(type) {\n    return function(...args) {\n      {\n        const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n        console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw2(this));\n      }\n      return type === \"delete\" ? false : this;\n    };\n  }\n  var mutableInstrumentations = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  var shallowInstrumentations = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  var readonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  var shallowReadonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  var iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  function createInstrumentationGetter(isReadonly2, shallow) {\n    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;\n    return (target, key, receiver) => {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\") {\n        return target;\n      }\n      return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n    };\n  }\n  var mutableCollectionHandlers = {\n    get: createInstrumentationGetter(false, false)\n  };\n  var shallowCollectionHandlers = {\n    get: createInstrumentationGetter(false, true)\n  };\n  var readonlyCollectionHandlers = {\n    get: createInstrumentationGetter(true, false)\n  };\n  var shallowReadonlyCollectionHandlers = {\n    get: createInstrumentationGetter(true, true)\n  };\n  function checkIdentityKeys(target, has2, key) {\n    const rawKey = toRaw2(key);\n    if (rawKey !== key && has2.call(target, rawKey)) {\n      const type = shared.toRawType(target);\n      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n    }\n  }\n  var reactiveMap = new WeakMap();\n  var shallowReactiveMap = new WeakMap();\n  var readonlyMap = new WeakMap();\n  var shallowReadonlyMap = new WeakMap();\n  function targetTypeMap(rawType) {\n    switch (rawType) {\n      case \"Object\":\n      case \"Array\":\n        return 1;\n      case \"Map\":\n      case \"Set\":\n      case \"WeakMap\":\n      case \"WeakSet\":\n        return 2;\n      default:\n        return 0;\n    }\n  }\n  function getTargetType(value) {\n    return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));\n  }\n  function reactive3(target) {\n    if (target && target[\"__v_isReadonly\"]) {\n      return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n  }\n  function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n  }\n  function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n  }\n  function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n  }\n  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n    if (!shared.isObject(target)) {\n      {\n        console.warn(`value cannot be made reactive: ${String(target)}`);\n      }\n      return target;\n    }\n    if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n      return target;\n    }\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n      return existingProxy;\n    }\n    const targetType = getTargetType(target);\n    if (targetType === 0) {\n      return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n  }\n  function isReactive2(value) {\n    if (isReadonly(value)) {\n      return isReactive2(value[\"__v_raw\"]);\n    }\n    return !!(value && value[\"__v_isReactive\"]);\n  }\n  function isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\"]);\n  }\n  function isProxy(value) {\n    return isReactive2(value) || isReadonly(value);\n  }\n  function toRaw2(observed) {\n    return observed && toRaw2(observed[\"__v_raw\"]) || observed;\n  }\n  function markRaw(value) {\n    shared.def(value, \"__v_skip\", true);\n    return value;\n  }\n  var convert = (val) => shared.isObject(val) ? reactive3(val) : val;\n  function isRef(r) {\n    return Boolean(r && r.__v_isRef === true);\n  }\n  function ref(value) {\n    return createRef(value);\n  }\n  function shallowRef(value) {\n    return createRef(value, true);\n  }\n  var RefImpl = class {\n    constructor(_rawValue, _shallow = false) {\n      this._rawValue = _rawValue;\n      this._shallow = _shallow;\n      this.__v_isRef = true;\n      this._value = _shallow ? _rawValue : convert(_rawValue);\n    }\n    get value() {\n      track(toRaw2(this), \"get\", \"value\");\n      return this._value;\n    }\n    set value(newVal) {\n      if (shared.hasChanged(toRaw2(newVal), this._rawValue)) {\n        this._rawValue = newVal;\n        this._value = this._shallow ? newVal : convert(newVal);\n        trigger(toRaw2(this), \"set\", \"value\", newVal);\n      }\n    }\n  };\n  function createRef(rawValue, shallow = false) {\n    if (isRef(rawValue)) {\n      return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n  }\n  function triggerRef(ref2) {\n    trigger(toRaw2(ref2), \"set\", \"value\", ref2.value);\n  }\n  function unref(ref2) {\n    return isRef(ref2) ? ref2.value : ref2;\n  }\n  var shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n      const oldValue = target[key];\n      if (isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      } else {\n        return Reflect.set(target, key, value, receiver);\n      }\n    }\n  };\n  function proxyRefs(objectWithRefs) {\n    return isReactive2(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n  }\n  var CustomRefImpl = class {\n    constructor(factory) {\n      this.__v_isRef = true;\n      const {get: get3, set: set3} = factory(() => track(this, \"get\", \"value\"), () => trigger(this, \"set\", \"value\"));\n      this._get = get3;\n      this._set = set3;\n    }\n    get value() {\n      return this._get();\n    }\n    set value(newVal) {\n      this._set(newVal);\n    }\n  };\n  function customRef(factory) {\n    return new CustomRefImpl(factory);\n  }\n  function toRefs(object) {\n    if (!isProxy(object)) {\n      console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = shared.isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n      ret[key] = toRef(object, key);\n    }\n    return ret;\n  }\n  var ObjectRefImpl = class {\n    constructor(_object, _key) {\n      this._object = _object;\n      this._key = _key;\n      this.__v_isRef = true;\n    }\n    get value() {\n      return this._object[this._key];\n    }\n    set value(newVal) {\n      this._object[this._key] = newVal;\n    }\n  };\n  function toRef(object, key) {\n    return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);\n  }\n  var ComputedRefImpl = class {\n    constructor(getter, _setter, isReadonly2) {\n      this._setter = _setter;\n      this._dirty = true;\n      this.__v_isRef = true;\n      this.effect = effect3(getter, {\n        lazy: true,\n        scheduler: () => {\n          if (!this._dirty) {\n            this._dirty = true;\n            trigger(toRaw2(this), \"set\", \"value\");\n          }\n        }\n      });\n      this[\"__v_isReadonly\"] = isReadonly2;\n    }\n    get value() {\n      const self2 = toRaw2(this);\n      if (self2._dirty) {\n        self2._value = this.effect();\n        self2._dirty = false;\n      }\n      track(self2, \"get\", \"value\");\n      return self2._value;\n    }\n    set value(newValue) {\n      this._setter(newValue);\n    }\n  };\n  function computed(getterOrOptions) {\n    let getter;\n    let setter;\n    if (shared.isFunction(getterOrOptions)) {\n      getter = getterOrOptions;\n      setter = () => {\n        console.warn(\"Write operation failed: computed value is readonly\");\n      };\n    } else {\n      getter = getterOrOptions.get;\n      setter = getterOrOptions.set;\n    }\n    return new ComputedRefImpl(getter, setter, shared.isFunction(getterOrOptions) || !getterOrOptions.set);\n  }\n  exports.ITERATE_KEY = ITERATE_KEY;\n  exports.computed = computed;\n  exports.customRef = customRef;\n  exports.effect = effect3;\n  exports.enableTracking = enableTracking;\n  exports.isProxy = isProxy;\n  exports.isReactive = isReactive2;\n  exports.isReadonly = isReadonly;\n  exports.isRef = isRef;\n  exports.markRaw = markRaw;\n  exports.pauseTracking = pauseTracking;\n  exports.proxyRefs = proxyRefs;\n  exports.reactive = reactive3;\n  exports.readonly = readonly;\n  exports.ref = ref;\n  exports.resetTracking = resetTracking;\n  exports.shallowReactive = shallowReactive;\n  exports.shallowReadonly = shallowReadonly;\n  exports.shallowRef = shallowRef;\n  exports.stop = stop2;\n  exports.toRaw = toRaw2;\n  exports.toRef = toRef;\n  exports.toRefs = toRefs;\n  exports.track = track;\n  exports.trigger = trigger;\n  exports.triggerRef = triggerRef;\n  exports.unref = unref;\n});\n\n// node_modules/@vue/reactivity/index.js\nvar require_reactivity = __commonJS((exports, module) => {\n  \"use strict\";\n  if (false) {} else {\n    module.exports = require_reactivity_cjs();\n  }\n});\n\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction dequeueJob(job) {\n  const index = queue.indexOf(job);\n  if (index !== -1) {\n    queue.splice(index, 1);\n  }\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, {scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  }});\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n  };\n  return [wrappedEffect, () => {\n    cleanup();\n  }];\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(callback) {\n  onElRemoveds.push(callback);\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, {subtree: true, childList: true, attributes: true, attributeOldValue: true});\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar recordQueue = [];\nvar willProcessRecordQueue = false;\nfunction flushObserver() {\n  recordQueue = recordQueue.concat(observer.takeRecords());\n  if (recordQueue.length && !willProcessRecordQueue) {\n    willProcessRecordQueue = true;\n    queueMicrotask(() => {\n      processRecordQueue();\n      willProcessRecordQueue = false;\n    });\n  }\n}\nfunction processRecordQueue() {\n  onMutate(recordQueue);\n  recordQueue.length = 0;\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = [];\n  let removedNodes = [];\n  let addedAttributes = new Map();\n  let removedAttributes = new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({name, value: el.getAttribute(name)});\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.includes(node))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n  }\n  addedNodes.forEach((node) => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n  for (let node of addedNodes) {\n    if (removedNodes.includes(node))\n      continue;\n    if (!node.isConnected)\n      continue;\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n    onElAddeds.forEach((i) => i(node));\n    node._x_ignore = true;\n    node._x_ignoreSelf = true;\n  }\n  addedNodes.forEach((node) => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction scope(node) {\n  return mergeProxies(closestDataStack(node));\n}\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction refreshScope(element, scope2) {\n  let existingScope = element._x_dataStack[0];\n  Object.entries(scope2).forEach(([key, value]) => {\n    existingScope[key] = value;\n  });\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  let thisProxy = new Proxy({}, {\n    ownKeys: () => {\n      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));\n    },\n    has: (target, name) => {\n      return objects.some((obj) => obj.hasOwnProperty(name));\n    },\n    get: (target, name) => {\n      return (objects.find((obj) => {\n        if (obj.hasOwnProperty(name)) {\n          let descriptor = Object.getOwnPropertyDescriptor(obj, name);\n          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {\n            return true;\n          }\n          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\n            let getter = descriptor.get;\n            let setter = descriptor.set;\n            let property = descriptor;\n            getter = getter && getter.bind(thisProxy);\n            setter = setter && setter.bind(thisProxy);\n            if (getter)\n              getter._x_alreadyBound = true;\n            if (setter)\n              setter._x_alreadyBound = true;\n            Object.defineProperty(obj, name, {\n              ...property,\n              get: getter,\n              set: setter\n            });\n          }\n          return true;\n        }\n        return false;\n      }) || {})[name];\n    },\n    set: (target, name, value) => {\n      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));\n      if (closestObjectWithKey) {\n        closestObjectWithKey[name] = value;\n      } else {\n        objects[objects.length - 1][name] = value;\n      }\n      return true;\n    }\n  });\n  return thisProxy;\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, {value, enumerable}]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  Object.entries(magics).forEach(([name, callback]) => {\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, {Alpine: alpine_default, interceptor});\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  Object.assign(error2, {el, expression});\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  if (typeof expression === \"function\") {\n    return generateEvaluatorFromFunction(dataStack, expression);\n  }\n  let evaluator = generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, {scope: scope2 = {}, params = []} = {}) => {\n    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression) || /^(let|const)\\s/.test(expression) ? `(() => { ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      return new AsyncFunction([\"__self\", \"scope\"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, {scope: scope2 = {}, params = []} = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope2, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\n  if (typeof value === \"function\") {\n    let result = value.apply(scope2, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  let transformedAttributeMap = {};\n  let directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler3 = directiveHandlers[directive2.type] || noop;\n  let cleanups = [];\n  let cleanup = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  onAttributeRemoved(el, directive2.original, doCleanup);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler3.inline && handler3.inline(el, directive2, utilities);\n    handler3 = handler3.bind(handler3, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();\n  };\n  fullHandler.runCleanups = doCleanup;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({name, value}) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return {name, value};\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({name, value}) => {\n    let {name: newName, value: newValue} = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, {name, value});\n    if (newName !== name)\n      callback(newName, name);\n    return {name: newName, value: newValue};\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({name}) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({name, value}) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"id\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"modelable\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"teleport\",\n  \"element\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(new CustomEvent(name, {\n    detail,\n    bubbles: true,\n    composed: true,\n    cancelable: true\n  }));\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback) {\n  tickStack.push(callback);\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nfunction start() {\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => destroyTree(el));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  return findClosest(el, (element) => {\n    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n    if (selectors.some((selector) => element.matches(selector)))\n      return true;\n  });\n}\nfunction findClosest(el, callback) {\n  if (!el)\n    return;\n  if (callback(el))\n    return el;\n  if (el._x_teleportBack)\n    el = el._x_teleportBack;\n  if (!el.parentElement)\n    return;\n  return findClosest(el.parentElement, callback);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nfunction initTree(el, walker = walk) {\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root) {\n  walk(root, (el) => cleanupAttributes(el));\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    if (!key.startsWith(\"--\")) {\n      key = kebabCase(key);\n    }\n    el.style.setProperty(key, value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache || \"\");\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, {value, modifiers, expression}, {evaluate: evaluate2}) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (!expression) {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    enter: (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    leave: (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0);\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: {during: defaultValue, start: defaultValue, end: defaultValue},\n      leave: {during: defaultValue, start: defaultValue, end: defaultValue},\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  let clickAwayCompatibleShow = () => {\n    document.visibilityState === \"visible\" ? requestAnimationFrame(show) : setTimeout(show);\n  };\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning.beforeCancel(() => reject({isFromCancelledTransition: true}));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      queueMicrotask(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, {during, start: start2, end} = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (el.type === \"radio\") {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      el.checked = checkedAttrLooseCompare(el.value, value);\n    }\n  } else if (el.type === \"checkbox\") {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isBooleanAttr(attrName) {\n  const booleanAttributes = [\n    \"disabled\",\n    \"checked\",\n    \"required\",\n    \"readonly\",\n    \"hidden\",\n    \"open\",\n    \"selected\",\n    \"autofocus\",\n    \"itemscope\",\n    \"multiple\",\n    \"novalidate\",\n    \"allowfullscreen\",\n    \"allowpaymentrequest\",\n    \"formnovalidate\",\n    \"autoplay\",\n    \"controls\",\n    \"loop\",\n    \"muted\",\n    \"playsinline\",\n    \"default\",\n    \"ismap\",\n    \"reversed\",\n    \"async\",\n    \"defer\",\n    \"nomodule\"\n  ];\n  return booleanAttributes.includes(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\n}\nfunction getBinding(el, name, fallback) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  let attr = el.getAttribute(name);\n  if (attr === null)\n    return typeof fallback === \"function\" ? fallback() : fallback;\n  if (isBooleanAttr(name)) {\n    return !![name, \"true\"].includes(attr);\n  }\n  if (attr === \"\")\n    return true;\n  return attr;\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/plugin.js\nfunction plugin(callback) {\n  callback(alpine_default);\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n  initInterceptors(stores[name]);\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/binds.js\nvar binds = {};\nfunction bind2(name, object) {\n  binds[name] = typeof object !== \"function\" ? () => object : object;\n}\nfunction injectBindingProviders(obj) {\n  Object.entries(binds).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback(...args);\n        };\n      }\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.9.0\",\n  flushAndStopDeferringMutations,\n  disableEffectScheduling,\n  setReactivityEngine,\n  closestDataStack,\n  skipDuringClone,\n  addRootSelector,\n  addInitSelector,\n  addScopeToNode,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  setEvaluator,\n  mergeProxies,\n  findClosest,\n  closestRoot,\n  interceptor,\n  transition,\n  setStyles,\n  mutateDom,\n  directive,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefixed: prefix,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  bound: getBinding,\n  $data: scope,\n  data,\n  bind: bind2\n};\nvar alpine_default = Alpine;\n\n// packages/alpinejs/src/index.js\nvar import_reactivity9 = __toModule(require_reactivity());\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el) => (key, callback) => {\n  let evaluate2 = evaluateLater(el, key);\n  let firstTime = true;\n  let oldValue;\n  effect(() => evaluate2((value) => {\n    JSON.stringify(value);\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => scope(el));\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  let currentEl = el;\n  while (currentEl) {\n    if (currentEl._x_refs)\n      refObjects.push(currentEl._x_refs);\n    currentEl = currentEl.parentNode;\n  }\n  return refObjects;\n}\n\n// packages/alpinejs/src/ids.js\nvar globalIdMemo = {};\nfunction findAndIncrementId(name) {\n  if (!globalIdMemo[name])\n    globalIdMemo[name] = 0;\n  return ++globalIdMemo[name];\n}\nfunction closestIdRoot(el, name) {\n  return findClosest(el, (element) => {\n    if (element._x_ids && element._x_ids[name])\n      return true;\n  });\n}\nfunction setIdRoot(el, name) {\n  if (!el._x_ids)\n    el._x_ids = {};\n  if (!el._x_ids[name])\n    el._x_ids[name] = findAndIncrementId(name);\n}\n\n// packages/alpinejs/src/magics/$id.js\nmagic(\"id\", (el) => (name, key = null) => {\n  let root = closestIdRoot(el, name);\n  let id = root ? root._x_ids[name] : findAndIncrementId(name);\n  return key ? `${name}-${id}-${key}` : `${name}-${id}`;\n});\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/directives/x-modelable.js\ndirective(\"modelable\", (el, {expression}, {effect: effect3, evaluate: evaluate2, evaluateLater: evaluateLater2}) => {\n  let func = evaluateLater2(expression);\n  let innerGet = () => {\n    let result;\n    func((i) => result = i);\n    return result;\n  };\n  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);\n  let innerSet = (val) => evaluateInnerSet(() => {\n  }, {scope: {__placeholder: val}});\n  let initialValue = innerGet();\n  if (el._x_modelable_hook)\n    initialValue = el._x_modelable_hook(initialValue);\n  innerSet(initialValue);\n  queueMicrotask(() => {\n    if (!el._x_model)\n      return;\n    let outerGet = el._x_model.get;\n    let outerSet = el._x_model.set;\n    effect3(() => innerSet(outerGet()));\n    effect3(() => outerSet(innerGet()));\n  });\n});\n\n// packages/alpinejs/src/directives/x-teleport.js\ndirective(\"teleport\", (el, {expression}, {cleanup}) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-teleport can only be used on a <template> tag\", el);\n  let target = document.querySelector(expression);\n  if (!target)\n    warn(`Cannot find x-teleport element for selector: \"${expression}\"`);\n  let clone2 = el.content.cloneNode(true).firstElementChild;\n  el._x_teleport = clone2;\n  clone2._x_teleportBack = el;\n  if (el._x_forwardEvents) {\n    el._x_forwardEvents.forEach((eventName) => {\n      clone2.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        el.dispatchEvent(new e.constructor(e.type, e));\n      });\n    });\n  }\n  addScopeToNode(clone2, {}, el);\n  mutateDom(() => {\n    target.appendChild(clone2);\n    initTree(clone2);\n    clone2._x_ignore = true;\n  });\n  cleanup(() => clone2.remove());\n});\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, {modifiers}, {cleanup}) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", (el, {expression}, {effect: effect3}) => effect3(evaluateLater(el, expression)));\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler3 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"prevent\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"self\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler3 = wrapHandler(handler3, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  handler3 = wrapHandler(handler3, (next, e) => {\n    if (isKeyEvent(event)) {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n    }\n    next(e);\n  });\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = debounce(handler3, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = throttle(handler3, wait);\n  }\n  if (modifiers.includes(\"once\")) {\n    handler3 = wrapHandler(handler3, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler3, options);\n    });\n  }\n  listenerTarget.addEventListener(event, handler3, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler3, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    ctrl: \"control\",\n    slash: \"/\",\n    space: \"-\",\n    spacebar: \"-\",\n    cmd: \"meta\",\n    esc: \"escape\",\n    up: \"arrow-up\",\n    down: \"arrow-down\",\n    left: \"arrow-left\",\n    right: \"arrow-right\",\n    period: \".\",\n    equal: \"=\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, {modifiers, expression}, {effect: effect3, cleanup}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n  let evaluateAssignment = evaluateLater(el, assignmentExpression);\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);\n  let removeListener = on(el, event, modifiers, (e) => {\n    evaluateAssignment(() => {\n    }, {scope: {\n      $event: e,\n      rightSideOfExpression: assigmentFunction\n    }});\n  });\n  cleanup(() => removeListener());\n  let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);\n  el._x_model = {\n    get() {\n      let result;\n      evaluate2((value) => result = value);\n      return result;\n    },\n    set(value) {\n      evaluateSetModel(() => {\n      }, {scope: {__placeholder: value}});\n    }\n  };\n  el._x_forceModelUpdate = () => {\n    evaluate2((value) => {\n      if (value === void 0 && expression.match(/\\./))\n        value = \"\";\n      window.fromModel = true;\n      mutateDom(() => bind(el, \"value\", value));\n      delete window.fromModel;\n    });\n  };\n  effect3(() => {\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate();\n  });\n});\nfunction generateAssignmentFunction(el, modifiers, expression) {\n  if (el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  return (event, currentValue) => {\n    return mutateDom(() => {\n      if (event instanceof CustomEvent && event.detail !== void 0) {\n        return event.detail || event.target.value;\n      } else if (el.type === \"checkbox\") {\n        if (Array.isArray(currentValue)) {\n          let newValue = modifiers.includes(\"number\") ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n        return modifiers.includes(\"number\") ? Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map((option) => {\n          return option.value || option.text;\n        });\n      } else {\n        let rawValue = event.target.value;\n        return modifiers.includes(\"number\") ? safeParseNumber(rawValue) : modifiers.includes(\"trim\") ? rawValue.trim() : rawValue;\n      }\n    });\n  };\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, {expression}) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate(el, expression, {}, false);\n  }\n  return evaluate(el, expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      el.innerHTML = value;\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\ndirective(\"bind\", (el, {value, modifiers, expression, original}, {effect: effect3}) => {\n  if (!value) {\n    return applyBindingsObject(el, expression, original, effect3);\n  }\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && expression.match(/\\./))\n      result = \"\";\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n});\nfunction applyBindingsObject(el, expression, original, effect3) {\n  let bindingProviders = {};\n  injectBindingProviders(bindingProviders);\n  let getBindings = evaluateLater(el, expression);\n  let cleanupRunners = [];\n  while (cleanupRunners.length)\n    cleanupRunners.pop()();\n  getBindings((bindings) => {\n    let attributes = Object.entries(bindings).map(([name, value]) => ({name, value}));\n    let staticAttributes = attributesOnly(attributes);\n    attributes = attributes.map((attribute) => {\n      if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n        return {\n          name: `x-bind:${attribute.name}`,\n          value: `\"${attribute.value}\"`\n        };\n      }\n      return attribute;\n    });\n    directives(el, attributes, original).map((handle) => {\n      cleanupRunners.push(handle.runCleanups);\n      handle();\n    });\n  }, {scope: bindingProviders});\n}\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", skipDuringClone((el, {expression}, {cleanup}) => {\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, {scope: dataProviderContext});\n  if (data2 === void 0)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup(() => {\n    undo();\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n  });\n}));\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, {modifiers, expression}, {effect: effect3}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let hide = () => mutateDom(() => {\n    el.style.display = \"none\";\n    el._x_isShown = false;\n  });\n  let show = () => mutateDom(() => {\n    if (el.style.length === 1 && el.style.display === \"none\") {\n      el.removeAttribute(\"style\");\n    } else {\n      el.style.removeProperty(\"display\");\n    }\n    el._x_isShown = true;\n  });\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once((value) => value ? show() : hide(), (value) => {\n    if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n      el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n    } else {\n      value ? clickAwayCompatibleShow() : hide();\n    }\n  });\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, {expression}, {effect: effect3, cleanup}) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(el, el._x_keyExpression || \"index\");\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup(() => {\n    Object.values(el._x_lookup).forEach((el2) => el2.remove());\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => keys.push(value2), {scope: {index: key, ...scope2}});\n        scopes.push(scope2);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => keys.push(value), {scope: {index: i, ...scope2}});\n        scopes.push(scope2);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      if (!!lookup[key]._x_effects) {\n        lookup[key]._x_effects.forEach(dequeueJob);\n      }\n      lookup[key].remove();\n      lookup[key] = null;\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\n        marker.before(elInSpot);\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\n        marker.remove();\n      });\n      refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      if (lastEl._x_currentIfEl)\n        lastEl = lastEl._x_currentIfEl;\n      let scope2 = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      addScopeToNode(clone2, reactive(scope2), templateEl);\n      mutateDom(() => {\n        lastEl.after(clone2);\n        initTree(clone2);\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler2() {\n}\nhandler2.inline = (el, {expression}, {cleanup}) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler2);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, {expression}, {effect: effect3, cleanup}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      initTree(clone2);\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      walk(clone2, (node) => {\n        if (!!node._x_effects) {\n          node._x_effects.forEach(dequeueJob);\n        }\n      });\n      clone2.remove();\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-id.js\ndirective(\"id\", (el, {expression}, {evaluate: evaluate2}) => {\n  let names = evaluate2(expression);\n  names.forEach((name) => setIdRoot(el, name));\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, {value, modifiers, expression}, {cleanup}) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  if (el.tagName.toLowerCase() === \"template\") {\n    if (!el._x_forwardEvents)\n      el._x_forwardEvents = [];\n    if (!el._x_forwardEvents.includes(value))\n      el._x_forwardEvents.push(value);\n  }\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, {scope: {$event: e}, params: [e]});\n  });\n  cleanup(() => removeListener());\n}));\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({reactive: import_reactivity9.reactive, effect: import_reactivity9.effect, release: import_reactivity9.stop, raw: import_reactivity9.toRaw});\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0ZBQStGO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLG1FQUFtRSw2Q0FBNkMsR0FBRyxnQ0FBZ0M7QUFDdFA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxFQUFFLGlEQUFpRCxLQUFLLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssRUFBRSxFQUVWLENBQUM7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0RBQWdEO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELHdCQUF3Qix5QkFBeUIsWUFBWSxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxnRUFBZ0UsaUNBQWlDO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLLEVBQUUsRUFFVixDQUFDO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQTBFO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxrQkFBa0I7QUFDNUY7QUFDQTtBQUNBLDRDQUE0QyxTQUFTLEdBQUcsSUFBSTtBQUM1RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QywyQ0FBMkM7O0FBRTNDLEVBQUUseURBQXlEO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRyxrQkFBa0IsZUFBZSxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVIQUF1SCxFQUFFLGFBQWE7QUFDdEk7QUFDQTtBQUNBLG9FQUFvRSxrQkFBa0IsNEJBQTRCLHdCQUF3QixxQkFBcUI7QUFDL0osTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUcsa0JBQWtCLGVBQWUsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsV0FBVyxZQUFZO0FBQ3ZCLFNBQVMsZ0NBQWdDO0FBQ3pDO0FBQ0EsS0FBSyxHQUFHLFlBQVk7QUFDcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksT0FBTyxLQUFLLEdBQUcsR0FBRztBQUN0RCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsV0FBVyxHQUFHLG9FQUFvRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBLEdBQUcsR0FBRyxRQUFRLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSw0QkFBNEIsV0FBVyxHQUFHLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVUsR0FBRyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFdBQVcsR0FBRyxnQkFBZ0I7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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SSxhQUFhLElBQUk7QUFDckIsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLEdBQUcsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLEdBQUcseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxzQkFBc0IsV0FBVyxHQUFHLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esc0NBQXNDLDZCQUE2QixHQUFHLFFBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUcsUUFBUSxVQUFVLGNBQWM7QUFDeEMsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0Esb0NBQW9DLDBJQUEwSTtBQUM5Szs7QUFFQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzPzAyN2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbnZhciBfX2NvbW1vbkpTID0gKGNhbGxiYWNrLCBtb2R1bGUpID0+ICgpID0+IHtcbiAgaWYgKCFtb2R1bGUpIHtcbiAgICBtb2R1bGUgPSB7ZXhwb3J0czoge319O1xuICAgIGNhbGxiYWNrKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUpO1xuICB9XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRhcmdldCwgbW9kdWxlLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwge2dldDogKCkgPT4gbW9kdWxlW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGV9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZSkgPT4ge1xuICByZXR1cm4gX19leHBvcnRTdGFyKF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZSA/IHtnZXQ6ICgpID0+IG1vZHVsZS5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlfSA6IHt2YWx1ZTogbW9kdWxlLCBlbnVtZXJhYmxlOiB0cnVlfSkpLCBtb2R1bGUpO1xufTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmNqcy5qc1xudmFyIHJlcXVpcmVfc2hhcmVkX2NqcyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIGZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KFwiLFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gKHZhbCkgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogKHZhbCkgPT4gISFtYXBbdmFsXTtcbiAgfVxuICB2YXIgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gICAgWzFdOiBgVEVYVGAsXG4gICAgWzJdOiBgQ0xBU1NgLFxuICAgIFs0XTogYFNUWUxFYCxcbiAgICBbOF06IGBQUk9QU2AsXG4gICAgWzE2XTogYEZVTExfUFJPUFNgLFxuICAgIFszMl06IGBIWURSQVRFX0VWRU5UU2AsXG4gICAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gICAgWzEyOF06IGBLRVlFRF9GUkFHTUVOVGAsXG4gICAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICAgIFsxMDI0XTogYERZTkFNSUNfU0xPVFNgLFxuICAgIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgICBbLTFdOiBgSE9JU1RFRGAsXG4gICAgWy0yXTogYEJBSUxgXG4gIH07XG4gIHZhciBzbG90RmxhZ3NUZXh0ID0ge1xuICAgIFsxXTogXCJTVEFCTEVcIixcbiAgICBbMl06IFwiRFlOQU1JQ1wiLFxuICAgIFszXTogXCJGT1JXQVJERURcIlxuICB9O1xuICB2YXIgR0xPQkFMU19XSElURV9MSVNURUQgPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludFwiO1xuICB2YXIgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuICB2YXIgcmFuZ2UgPSAyO1xuICBmdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0MiA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgIGlmIChjb3VudCA+PSBzdGFydDIpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydDIgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDIpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbiAgfVxuICB2YXIgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuICB2YXIgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbiAgdmFyIGlzQm9vbGVhbkF0dHIyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xuICB2YXIgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuICB2YXIgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuICBmdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICAgIH1cbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgICBpZiAoaXNVbnNhZmUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZTtcbiAgfVxuICB2YXIgcHJvcHNUb0F0dHJNYXAgPSB7XG4gICAgYWNjZXB0Q2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICAgIGh0bWxGb3I6IFwiZm9yXCIsXG4gICAgaHR0cEVxdWl2OiBcImh0dHAtZXF1aXZcIlxuICB9O1xuICB2YXIgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsYm9yZGVyLWltYWdlLW91dHNldCxib3JkZXItaW1hZ2Utc2xpY2UsYm9yZGVyLWltYWdlLXdpZHRoLGJveC1mbGV4LGJveC1mbGV4LWdyb3VwLGJveC1vcmRpbmFsLWdyb3VwLGNvbHVtbi1jb3VudCxjb2x1bW5zLGZsZXgsZmxleC1ncm93LGZsZXgtcG9zaXRpdmUsZmxleC1zaHJpbmssZmxleC1uZWdhdGl2ZSxmbGV4LW9yZGVyLGdyaWQtcm93LGdyaWQtcm93LWVuZCxncmlkLXJvdy1zcGFuLGdyaWQtcm93LXN0YXJ0LGdyaWQtY29sdW1uLGdyaWQtY29sdW1uLWVuZCxncmlkLWNvbHVtbi1zcGFuLGdyaWQtY29sdW1uLXN0YXJ0LGZvbnQtd2VpZ2h0LGxpbmUtY2xhbXAsbGluZS1oZWlnaHQsb3BhY2l0eSxvcmRlcixvcnBoYW5zLHRhYi1zaXplLHdpZG93cyx6LWluZGV4LHpvb20sZmlsbC1vcGFjaXR5LGZsb29kLW9wYWNpdHksc3RvcC1vcGFjaXR5LHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoYCk7XG4gIHZhciBpc0tub3duQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcGApO1xuICBmdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVN0eWxlKGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IGl0ZW0pO1xuICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICB2YXIgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xuICBmdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gICAgbGV0IHJldCA9IFwiXCI7XG4gICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9IFwiXCI7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmVzID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy50cmltKCk7XG4gIH1cbiAgdmFyIEhUTUxfVEFHUyA9IFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCI7XG4gIHZhciBTVkdfVEFHUyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbmNlTGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuICB2YXIgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuICB2YXIgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbiAgdmFyIGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuICB2YXIgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcbiAgdmFyIGVzY2FwZVJFID0gL1tcIicmPD5dLztcbiAgZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgICBjb25zdCBzdHIgPSBcIlwiICsgc3RyaW5nO1xuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGxldCBodG1sID0gXCJcIjtcbiAgICBsZXQgZXNjYXBlZDtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgZXNjYXBlZCA9IFwiJnF1b3Q7XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgZXNjYXBlZCA9IFwiJmFtcDtcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBlc2NhcGVkID0gXCImIzM5O1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgIGVzY2FwZWQgPSBcIiZsdDtcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICBlc2NhcGVkID0gXCImZ3Q7XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgICB9XG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICBodG1sICs9IGVzY2FwZWQ7XG4gICAgfVxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xuICB9XG4gIHZhciBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuICBmdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cbiAgZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbiAgfVxuICBmdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbiAgfVxuICB2YXIgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc09iamVjdCh2YWwpID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMikgOiBTdHJpbmcodmFsKTtcbiAgfTtcbiAgdmFyIHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICAgIGlmIChpc01hcCh2YWwpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsMl0pID0+IHtcbiAgICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sIHt9KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIHZhciBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zID0gW1xuICAgIFwiYmlnSW50XCIsXG4gICAgXCJvcHRpb25hbENoYWluaW5nXCIsXG4gICAgXCJudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yXCJcbiAgXTtcbiAgdmFyIEVNUFRZX09CSiA9IE9iamVjdC5mcmVlemUoe30pO1xuICB2YXIgRU1QVFlfQVJSID0gT2JqZWN0LmZyZWV6ZShbXSk7XG4gIHZhciBOT09QID0gKCkgPT4ge1xuICB9O1xuICB2YXIgTk8gPSAoKSA9PiBmYWxzZTtcbiAgdmFyIG9uUkUgPSAvXm9uW15hLXpdLztcbiAgdmFyIGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcbiAgdmFyIGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpO1xuICB2YXIgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbiAgdmFyIHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgdmFyIGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG4gIHZhciBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuICB2YXIgaXNEYXRlID0gKHZhbCkgPT4gdmFsIGluc3RhbmNlb2YgRGF0ZTtcbiAgdmFyIGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG4gIHZhciBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG4gIHZhciBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG4gIHZhciBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuICB2YXIgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbiAgfTtcbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHZhciB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG4gIH07XG4gIHZhciBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gIHZhciBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuICB2YXIgaXNSZXNlcnZlZFByb3AgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcIixrZXkscmVmLG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIik7XG4gIHZhciBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoc3RyKSA9PiB7XG4gICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH07XG4gIH07XG4gIHZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuICB2YXIgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbiAgfSk7XG4gIHZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG4gIHZhciBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgdmFyIGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG4gIHZhciB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XG4gIHZhciBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gdmFsdWUgIT09IG9sZFZhbHVlICYmICh2YWx1ZSA9PT0gdmFsdWUgfHwgb2xkVmFsdWUgPT09IG9sZFZhbHVlKTtcbiAgdmFyIGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZuc1tpXShhcmcpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfTtcbiAgdmFyIHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbiAgfTtcbiAgdmFyIF9nbG9iYWxUaGlzO1xuICB2YXIgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG4gIH07XG4gIGV4cG9ydHMuRU1QVFlfQVJSID0gRU1QVFlfQVJSO1xuICBleHBvcnRzLkVNUFRZX09CSiA9IEVNUFRZX09CSjtcbiAgZXhwb3J0cy5OTyA9IE5PO1xuICBleHBvcnRzLk5PT1AgPSBOT09QO1xuICBleHBvcnRzLlBhdGNoRmxhZ05hbWVzID0gUGF0Y2hGbGFnTmFtZXM7XG4gIGV4cG9ydHMuYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyA9IGJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnM7XG4gIGV4cG9ydHMuY2FtZWxpemUgPSBjYW1lbGl6ZTtcbiAgZXhwb3J0cy5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgZXhwb3J0cy5kZWYgPSBkZWY7XG4gIGV4cG9ydHMuZXNjYXBlSHRtbCA9IGVzY2FwZUh0bWw7XG4gIGV4cG9ydHMuZXNjYXBlSHRtbENvbW1lbnQgPSBlc2NhcGVIdG1sQ29tbWVudDtcbiAgZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG4gIGV4cG9ydHMuZ2VuZXJhdGVDb2RlRnJhbWUgPSBnZW5lcmF0ZUNvZGVGcmFtZTtcbiAgZXhwb3J0cy5nZXRHbG9iYWxUaGlzID0gZ2V0R2xvYmFsVGhpcztcbiAgZXhwb3J0cy5oYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZDtcbiAgZXhwb3J0cy5oYXNPd24gPSBoYXNPd247XG4gIGV4cG9ydHMuaHlwaGVuYXRlID0gaHlwaGVuYXRlO1xuICBleHBvcnRzLmludm9rZUFycmF5Rm5zID0gaW52b2tlQXJyYXlGbnM7XG4gIGV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG4gIGV4cG9ydHMuaXNCb29sZWFuQXR0ciA9IGlzQm9vbGVhbkF0dHIyO1xuICBleHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgZXhwb3J0cy5pc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQ7XG4gIGV4cG9ydHMuaXNIVE1MVGFnID0gaXNIVE1MVGFnO1xuICBleHBvcnRzLmlzSW50ZWdlcktleSA9IGlzSW50ZWdlcktleTtcbiAgZXhwb3J0cy5pc0tub3duQXR0ciA9IGlzS25vd25BdHRyO1xuICBleHBvcnRzLmlzTWFwID0gaXNNYXA7XG4gIGV4cG9ydHMuaXNNb2RlbExpc3RlbmVyID0gaXNNb2RlbExpc3RlbmVyO1xuICBleHBvcnRzLmlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcDtcbiAgZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuICBleHBvcnRzLmlzT24gPSBpc09uO1xuICBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICBleHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbiAgZXhwb3J0cy5pc1Jlc2VydmVkUHJvcCA9IGlzUmVzZXJ2ZWRQcm9wO1xuICBleHBvcnRzLmlzU1NSU2FmZUF0dHJOYW1lID0gaXNTU1JTYWZlQXR0ck5hbWU7XG4gIGV4cG9ydHMuaXNTVkdUYWcgPSBpc1NWR1RhZztcbiAgZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuICBleHBvcnRzLmlzU3BlY2lhbEJvb2xlYW5BdHRyID0gaXNTcGVjaWFsQm9vbGVhbkF0dHI7XG4gIGV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICBleHBvcnRzLmlzVm9pZFRhZyA9IGlzVm9pZFRhZztcbiAgZXhwb3J0cy5sb29zZUVxdWFsID0gbG9vc2VFcXVhbDtcbiAgZXhwb3J0cy5sb29zZUluZGV4T2YgPSBsb29zZUluZGV4T2Y7XG4gIGV4cG9ydHMubWFrZU1hcCA9IG1ha2VNYXA7XG4gIGV4cG9ydHMubm9ybWFsaXplQ2xhc3MgPSBub3JtYWxpemVDbGFzcztcbiAgZXhwb3J0cy5ub3JtYWxpemVTdHlsZSA9IG5vcm1hbGl6ZVN0eWxlO1xuICBleHBvcnRzLm9iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG4gIGV4cG9ydHMucGFyc2VTdHJpbmdTdHlsZSA9IHBhcnNlU3RyaW5nU3R5bGU7XG4gIGV4cG9ydHMucHJvcHNUb0F0dHJNYXAgPSBwcm9wc1RvQXR0ck1hcDtcbiAgZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG4gIGV4cG9ydHMuc2xvdEZsYWdzVGV4dCA9IHNsb3RGbGFnc1RleHQ7XG4gIGV4cG9ydHMuc3RyaW5naWZ5U3R5bGUgPSBzdHJpbmdpZnlTdHlsZTtcbiAgZXhwb3J0cy50b0Rpc3BsYXlTdHJpbmcgPSB0b0Rpc3BsYXlTdHJpbmc7XG4gIGV4cG9ydHMudG9IYW5kbGVyS2V5ID0gdG9IYW5kbGVyS2V5O1xuICBleHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gIGV4cG9ydHMudG9SYXdUeXBlID0gdG9SYXdUeXBlO1xuICBleHBvcnRzLnRvVHlwZVN0cmluZyA9IHRvVHlwZVN0cmluZztcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvaW5kZXguanNcbnZhciByZXF1aXJlX3NoYXJlZCA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgaWYgKGZhbHNlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9zaGFyZWRfY2pzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5janMuanNcbnZhciByZXF1aXJlX3JlYWN0aXZpdHlfY2pzID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgdmFyIHNoYXJlZCA9IHJlcXVpcmVfc2hhcmVkKCk7XG4gIHZhciB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgZWZmZWN0U3RhY2sgPSBbXTtcbiAgdmFyIGFjdGl2ZUVmZmVjdDtcbiAgdmFyIElURVJBVEVfS0VZID0gU3ltYm9sKFwiaXRlcmF0ZVwiKTtcbiAgdmFyIE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXCJNYXAga2V5IGl0ZXJhdGVcIik7XG4gIGZ1bmN0aW9uIGlzRWZmZWN0KGZuKSB7XG4gICAgcmV0dXJuIGZuICYmIGZuLl9pc0VmZmVjdCA9PT0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBlZmZlY3QzKGZuLCBvcHRpb25zID0gc2hhcmVkLkVNUFRZX09CSikge1xuICAgIGlmIChpc0VmZmVjdChmbikpIHtcbiAgICAgIGZuID0gZm4ucmF3O1xuICAgIH1cbiAgICBjb25zdCBlZmZlY3Q0ID0gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5sYXp5KSB7XG4gICAgICBlZmZlY3Q0KCk7XG4gICAgfVxuICAgIHJldHVybiBlZmZlY3Q0O1xuICB9XG4gIGZ1bmN0aW9uIHN0b3AyKGVmZmVjdDQpIHtcbiAgICBpZiAoZWZmZWN0NC5hY3RpdmUpIHtcbiAgICAgIGNsZWFudXAoZWZmZWN0NCk7XG4gICAgICBpZiAoZWZmZWN0NC5vcHRpb25zLm9uU3RvcCkge1xuICAgICAgICBlZmZlY3Q0Lm9wdGlvbnMub25TdG9wKCk7XG4gICAgICB9XG4gICAgICBlZmZlY3Q0LmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICB2YXIgdWlkID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlZmZlY3Q0ID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XG4gICAgICBpZiAoIWVmZmVjdDQuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfVxuICAgICAgaWYgKCFlZmZlY3RTdGFjay5pbmNsdWRlcyhlZmZlY3Q0KSkge1xuICAgICAgICBjbGVhbnVwKGVmZmVjdDQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVuYWJsZVRyYWNraW5nKCk7XG4gICAgICAgICAgZWZmZWN0U3RhY2sucHVzaChlZmZlY3Q0KTtcbiAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3Q0O1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3RTdGFja1tlZmZlY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZWZmZWN0NC5pZCA9IHVpZCsrO1xuICAgIGVmZmVjdDQuYWxsb3dSZWN1cnNlID0gISFvcHRpb25zLmFsbG93UmVjdXJzZTtcbiAgICBlZmZlY3Q0Ll9pc0VmZmVjdCA9IHRydWU7XG4gICAgZWZmZWN0NC5hY3RpdmUgPSB0cnVlO1xuICAgIGVmZmVjdDQucmF3ID0gZm47XG4gICAgZWZmZWN0NC5kZXBzID0gW107XG4gICAgZWZmZWN0NC5vcHRpb25zID0gb3B0aW9ucztcbiAgICByZXR1cm4gZWZmZWN0NDtcbiAgfVxuICBmdW5jdGlvbiBjbGVhbnVwKGVmZmVjdDQpIHtcbiAgICBjb25zdCB7ZGVwc30gPSBlZmZlY3Q0O1xuICAgIGlmIChkZXBzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdDQpO1xuICAgICAgfVxuICAgICAgZGVwcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICB2YXIgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICB2YXIgdHJhY2tTdGFjayA9IFtdO1xuICBmdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG4gIH1cbiAgZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrIHx8IGFjdGl2ZUVmZmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBpZiAoIWRlcC5oYXMoYWN0aXZlRWZmZWN0KSkge1xuICAgICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xuICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xuICAgICAgaWYgKGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2spIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjayh7XG4gICAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3QsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICAgIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVmZmVjdHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYWRkMiA9IChlZmZlY3RzVG9BZGQpID0+IHtcbiAgICAgIGlmIChlZmZlY3RzVG9BZGQpIHtcbiAgICAgICAgZWZmZWN0c1RvQWRkLmZvckVhY2goKGVmZmVjdDQpID0+IHtcbiAgICAgICAgICBpZiAoZWZmZWN0NCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdDQuYWxsb3dSZWN1cnNlKSB7XG4gICAgICAgICAgICBlZmZlY3RzLmFkZChlZmZlY3Q0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgICAgZGVwc01hcC5mb3JFYWNoKGFkZDIpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImxlbmd0aFwiICYmIHNoYXJlZC5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPj0gbmV3VmFsdWUpIHtcbiAgICAgICAgICBhZGQyKGRlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgYWRkMihkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgaWYgKCFzaGFyZWQuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoc2hhcmVkLmlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzaGFyZWQuaXNJbnRlZ2VyS2V5KGtleSkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgIGlmICghc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKHNoYXJlZC5pc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlmIChzaGFyZWQuaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcnVuID0gKGVmZmVjdDQpID0+IHtcbiAgICAgIGlmIChlZmZlY3Q0Lm9wdGlvbnMub25UcmlnZ2VyKSB7XG4gICAgICAgIGVmZmVjdDQub3B0aW9ucy5vblRyaWdnZXIoe1xuICAgICAgICAgIGVmZmVjdDogZWZmZWN0NCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVmZmVjdDQub3B0aW9ucy5zY2hlZHVsZXIpIHtcbiAgICAgICAgZWZmZWN0NC5vcHRpb25zLnNjaGVkdWxlcihlZmZlY3Q0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVmZmVjdDQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGVmZmVjdHMuZm9yRWFjaChydW4pO1xuICB9XG4gIHZhciBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gc2hhcmVkLm1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuICB2YXIgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoc2hhcmVkLmlzU3ltYm9sKSk7XG4gIHZhciBnZXQyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcigpO1xuICB2YXIgc2hhbGxvd0dldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xuICB2YXIgcmVhZG9ubHlHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xuICB2YXIgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcbiAgdmFyIGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xuICBbXCJpbmNsdWRlc1wiLCBcImluZGV4T2ZcIiwgXCJsYXN0SW5kZXhPZlwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcbiAgICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFyciA9IHRvUmF3Mih0aGlzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJhY2soYXJyLCBcImdldFwiLCBpICsgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkoYXJyLCBhcmdzKTtcbiAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShhcnIsIGFyZ3MubWFwKHRvUmF3MikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwidW5zaGlmdFwiLCBcInNwbGljZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcbiAgICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5MiA9IGZhbHNlLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0Myh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgJiYgcmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5MiA/IHNoYWxsb3cgPyBzaGFsbG93UmVhZG9ubHlNYXAgOiByZWFkb25seU1hcCA6IHNoYWxsb3cgPyBzaGFsbG93UmVhY3RpdmVNYXAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBzaGFyZWQuaXNBcnJheSh0YXJnZXQpO1xuICAgICAgaWYgKCFpc1JlYWRvbmx5MiAmJiB0YXJnZXRJc0FycmF5ICYmIHNoYXJlZC5oYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgIGlmIChzaGFyZWQuaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFVud3JhcCA9ICF0YXJnZXRJc0FycmF5IHx8ICFzaGFyZWQuaXNJbnRlZ2VyS2V5KGtleSk7XG4gICAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcmVkLmlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyID8gcmVhZG9ubHkocmVzKSA6IHJlYWN0aXZlMyhyZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9XG4gIHZhciBzZXQyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNldHRlcigpO1xuICB2YXIgc2hhbGxvd1NldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0Myh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgIGlmICghc2hhbGxvdykge1xuICAgICAgICB2YWx1ZSA9IHRvUmF3Mih2YWx1ZSk7XG4gICAgICAgIG9sZFZhbHVlID0gdG9SYXcyKG9sZFZhbHVlKTtcbiAgICAgICAgaWYgKCFzaGFyZWQuaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaGFkS2V5ID0gc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSAmJiBzaGFyZWQuaXNJbnRlZ2VyS2V5KGtleSkgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGggOiBzaGFyZWQuaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHRhcmdldCA9PT0gdG9SYXcyKHJlY2VpdmVyKSkge1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFyZWQuaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgaGFkS2V5ID0gc2hhcmVkLmhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xuICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghc2hhcmVkLmlzU3ltYm9sKGtleSkgfHwgIWJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiLCBzaGFyZWQuaXNBcnJheSh0YXJnZXQpID8gXCJsZW5ndGhcIiA6IElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH1cbiAgdmFyIG11dGFibGVIYW5kbGVycyA9IHtcbiAgICBnZXQ6IGdldDIsXG4gICAgc2V0OiBzZXQyLFxuICAgIGRlbGV0ZVByb3BlcnR5LFxuICAgIGhhcyxcbiAgICBvd25LZXlzXG4gIH07XG4gIHZhciByZWFkb25seUhhbmRsZXJzID0ge1xuICAgIGdldDogcmVhZG9ubHlHZXQsXG4gICAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IHNoYXJlZC5leHRlbmQoe30sIG11dGFibGVIYW5kbGVycywge1xuICAgIGdldDogc2hhbGxvd0dldCxcbiAgICBzZXQ6IHNoYWxsb3dTZXRcbiAgfSk7XG4gIHZhciBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IHNoYXJlZC5leHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxuICB9KTtcbiAgdmFyIHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IHNoYXJlZC5pc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZTModmFsdWUpIDogdmFsdWU7XG4gIHZhciB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBzaGFyZWQuaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG4gIHZhciB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xuICB2YXIgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcbiAgZnVuY3Rpb24gZ2V0JDEodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkyID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1JhdzIodGFyZ2V0KTtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdzIoa2V5KTtcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gICAgY29uc3Qge2hhczogaGFzMn0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICAgIH0gZWxzZSBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuZ2V0KGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seTIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3Mih0YXJnZXQpO1xuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3MihrZXkpO1xuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICB9XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcbiAgICByZXR1cm4ga2V5ID09PSByYXdLZXkgPyB0YXJnZXQuaGFzKGtleSkgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5MiA9IGZhbHNlKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiXTtcbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2sodG9SYXcyKHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgXCJzaXplXCIsIHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0b1JhdzIodmFsdWUpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3Mih0aGlzKTtcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIHZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRvUmF3Mih2YWx1ZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcyKHRoaXMpO1xuICAgIGNvbnN0IHtoYXM6IGhhczIsIGdldDogZ2V0M30gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgIGxldCBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICBrZXkgPSB0b1JhdzIoa2V5KTtcbiAgICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNoYXJlZC5oYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3Mih0aGlzKTtcbiAgICBjb25zdCB7aGFzOiBoYXMyLCBnZXQ6IGdldDN9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAga2V5ID0gdG9SYXcyKGtleSk7XG4gICAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0MyA/IGdldDMuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICAgIGlmIChoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3Mih0aGlzKTtcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICAgIGNvbnN0IG9sZFRhcmdldCA9IHNoYXJlZC5pc01hcCh0YXJnZXQpID8gbmV3IE1hcCh0YXJnZXQpIDogbmV3IFNldCh0YXJnZXQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICAgIGlmIChoYWRJdGVtcykge1xuICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiwgdm9pZCAwLCB2b2lkIDAsIG9sZFRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5MiwgaXNTaGFsbG93KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3Mih0YXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5MiwgaXNTaGFsbG93KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcyKHRhcmdldCk7XG4gICAgICBjb25zdCB0YXJnZXRJc01hcCA9IHNoYXJlZC5pc01hcChyYXdUYXJnZXQpO1xuICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSBcImVudHJpZXNcIiB8fCBtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcDtcbiAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIGRvbmUgPyB7dmFsdWUsIGRvbmV9IDoge1xuICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgICBkb25lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7c2hhcmVkLmNhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1JhdzIodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHRoaXM7XG4gICAgfTtcbiAgfVxuICB2YXIgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzOiBoYXMkMSxcbiAgICBhZGQsXG4gICAgc2V0OiBzZXQkMSxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxuICB9O1xuICB2YXIgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhczogaGFzJDEsXG4gICAgYWRkLFxuICAgIHNldDogc2V0JDEsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICB9O1xuICB2YXIgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiKSxcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKSxcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxuICB9O1xuICB2YXIgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxuICB9O1xuICB2YXIgaXRlcmF0b3JNZXRob2RzID0gW1wia2V5c1wiLCBcInZhbHVlc1wiLCBcImVudHJpZXNcIiwgU3ltYm9sLml0ZXJhdG9yXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIGZhbHNlKTtcbiAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5Miwgc2hhbGxvdykge1xuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93ID8gaXNSZWFkb25seTIgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgOiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xuICAgIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQoc2hhcmVkLmhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXQgPyBpbnN0cnVtZW50YXRpb25zIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICB9O1xuICB9XG4gIHZhciBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcbiAgfTtcbiAgdmFyIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXG4gIH07XG4gIHZhciByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcbiAgfTtcbiAgdmFyIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxuICB9O1xuICBmdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSkge1xuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3MihrZXkpO1xuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMyLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2hhcmVkLnRvUmF3VHlwZSh0YXJnZXQpO1xuICAgICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcbiAgICB9XG4gIH1cbiAgdmFyIHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNoYWxsb3dSZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciByZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzaGFsbG93UmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgXCJNYXBcIjpcbiAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCA6IHRhcmdldFR5cGVNYXAoc2hhcmVkLnRvUmF3VHlwZSh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWN0aXZlMyh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcIl9fdl9pc1JlYWRvbmx5XCJdKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XG4gIH1cbiAgZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycywgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWN0aXZlTWFwKTtcbiAgfVxuICBmdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgcmVhZG9ubHlNYXApO1xuICB9XG4gIGZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlNYXApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seTIsIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICAgIGlmICghc2hhcmVkLmlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seTIgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIl0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRUeXBlID09PSAwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xuICAgIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWFjdGl2ZTIodmFsdWUpIHtcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBpc1JlYWN0aXZlMih2YWx1ZVtcIl9fdl9yYXdcIl0pO1xuICAgIH1cbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiXSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCJdKTtcbiAgfVxuICBmdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUyKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiB0b1JhdzIob2JzZXJ2ZWQpIHtcbiAgICByZXR1cm4gb2JzZXJ2ZWQgJiYgdG9SYXcyKG9ic2VydmVkW1wiX192X3Jhd1wiXSkgfHwgb2JzZXJ2ZWQ7XG4gIH1cbiAgZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICAgIHNoYXJlZC5kZWYodmFsdWUsIFwiX192X3NraXBcIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBjb252ZXJ0ID0gKHZhbCkgPT4gc2hhcmVkLmlzT2JqZWN0KHZhbCkgPyByZWFjdGl2ZTModmFsKSA6IHZhbDtcbiAgZnVuY3Rpb24gaXNSZWYocikge1xuICAgIHJldHVybiBCb29sZWFuKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZih2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbiAgfVxuICB2YXIgUmVmSW1wbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihfcmF3VmFsdWUsIF9zaGFsbG93ID0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gX3Jhd1ZhbHVlO1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IF9zaGFsbG93O1xuICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgdGhpcy5fdmFsdWUgPSBfc2hhbGxvdyA/IF9yYXdWYWx1ZSA6IGNvbnZlcnQoX3Jhd1ZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgdHJhY2sodG9SYXcyKHRoaXMpLCBcImdldFwiLCBcInZhbHVlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICBpZiAoc2hhcmVkLmhhc0NoYW5nZWQodG9SYXcyKG5ld1ZhbCksIHRoaXMuX3Jhd1ZhbHVlKSkge1xuICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9zaGFsbG93ID8gbmV3VmFsIDogY29udmVydChuZXdWYWwpO1xuICAgICAgICB0cmlnZ2VyKHRvUmF3Mih0aGlzKSwgXCJzZXRcIiwgXCJ2YWx1ZVwiLCBuZXdWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgICByZXR1cm4gcmF3VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYyKSB7XG4gICAgdHJpZ2dlcih0b1JhdzIocmVmMiksIFwic2V0XCIsIFwidmFsdWVcIiwgcmVmMi52YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdW5yZWYocmVmMikge1xuICAgIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xuICB9XG4gIHZhciBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUyKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xuICB9XG4gIHZhciBDdXN0b21SZWZJbXBsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHtnZXQ6IGdldDMsIHNldDogc2V0M30gPSBmYWN0b3J5KCgpID0+IHRyYWNrKHRoaXMsIFwiZ2V0XCIsIFwidmFsdWVcIiksICgpID0+IHRyaWdnZXIodGhpcywgXCJzZXRcIiwgXCJ2YWx1ZVwiKSk7XG4gICAgICB0aGlzLl9nZXQgPSBnZXQzO1xuICAgICAgdGhpcy5fc2V0ID0gc2V0MztcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICB0aGlzLl9zZXQobmV3VmFsKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xuICB9XG4gIGZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgICBpZiAoIWlzUHJveHkob2JqZWN0KSkge1xuICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gc2hhcmVkLmlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgdmFyIE9iamVjdFJlZkltcGwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSkge1xuICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcbiAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBpc1JlZihvYmplY3Rba2V5XSkgPyBvYmplY3Rba2V5XSA6IG5ldyBPYmplY3RSZWZJbXBsKG9iamVjdCwga2V5KTtcbiAgfVxuICB2YXIgQ29tcHV0ZWRSZWZJbXBsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGdldHRlciwgX3NldHRlciwgaXNSZWFkb25seTIpIHtcbiAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XG4gICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDMoZ2V0dGVyLCB7XG4gICAgICAgIGxhenk6IHRydWUsXG4gICAgICAgIHNjaGVkdWxlcjogKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyaWdnZXIodG9SYXcyKHRoaXMpLCBcInNldFwiLCBcInZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIl0gPSBpc1JlYWRvbmx5MjtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgY29uc3Qgc2VsZjIgPSB0b1JhdzIodGhpcyk7XG4gICAgICBpZiAoc2VsZjIuX2RpcnR5KSB7XG4gICAgICAgIHNlbGYyLl92YWx1ZSA9IHRoaXMuZWZmZWN0KCk7XG4gICAgICAgIHNlbGYyLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdHJhY2soc2VsZjIsIFwiZ2V0XCIsIFwidmFsdWVcIik7XG4gICAgICByZXR1cm4gc2VsZjIuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcbiAgICBsZXQgZ2V0dGVyO1xuICAgIGxldCBzZXR0ZXI7XG4gICAgaWYgKHNoYXJlZC5pc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcbiAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICAgIHNldHRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIHNoYXJlZC5pc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykgfHwgIWdldHRlck9yT3B0aW9ucy5zZXQpO1xuICB9XG4gIGV4cG9ydHMuSVRFUkFURV9LRVkgPSBJVEVSQVRFX0tFWTtcbiAgZXhwb3J0cy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICBleHBvcnRzLmN1c3RvbVJlZiA9IGN1c3RvbVJlZjtcbiAgZXhwb3J0cy5lZmZlY3QgPSBlZmZlY3QzO1xuICBleHBvcnRzLmVuYWJsZVRyYWNraW5nID0gZW5hYmxlVHJhY2tpbmc7XG4gIGV4cG9ydHMuaXNQcm94eSA9IGlzUHJveHk7XG4gIGV4cG9ydHMuaXNSZWFjdGl2ZSA9IGlzUmVhY3RpdmUyO1xuICBleHBvcnRzLmlzUmVhZG9ubHkgPSBpc1JlYWRvbmx5O1xuICBleHBvcnRzLmlzUmVmID0gaXNSZWY7XG4gIGV4cG9ydHMubWFya1JhdyA9IG1hcmtSYXc7XG4gIGV4cG9ydHMucGF1c2VUcmFja2luZyA9IHBhdXNlVHJhY2tpbmc7XG4gIGV4cG9ydHMucHJveHlSZWZzID0gcHJveHlSZWZzO1xuICBleHBvcnRzLnJlYWN0aXZlID0gcmVhY3RpdmUzO1xuICBleHBvcnRzLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gIGV4cG9ydHMucmVmID0gcmVmO1xuICBleHBvcnRzLnJlc2V0VHJhY2tpbmcgPSByZXNldFRyYWNraW5nO1xuICBleHBvcnRzLnNoYWxsb3dSZWFjdGl2ZSA9IHNoYWxsb3dSZWFjdGl2ZTtcbiAgZXhwb3J0cy5zaGFsbG93UmVhZG9ubHkgPSBzaGFsbG93UmVhZG9ubHk7XG4gIGV4cG9ydHMuc2hhbGxvd1JlZiA9IHNoYWxsb3dSZWY7XG4gIGV4cG9ydHMuc3RvcCA9IHN0b3AyO1xuICBleHBvcnRzLnRvUmF3ID0gdG9SYXcyO1xuICBleHBvcnRzLnRvUmVmID0gdG9SZWY7XG4gIGV4cG9ydHMudG9SZWZzID0gdG9SZWZzO1xuICBleHBvcnRzLnRyYWNrID0gdHJhY2s7XG4gIGV4cG9ydHMudHJpZ2dlciA9IHRyaWdnZXI7XG4gIGV4cG9ydHMudHJpZ2dlclJlZiA9IHRyaWdnZXJSZWY7XG4gIGV4cG9ydHMudW5yZWYgPSB1bnJlZjtcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2luZGV4LmpzXG52YXIgcmVxdWlyZV9yZWFjdGl2aXR5ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBpZiAoZmFsc2UpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX3JlYWN0aXZpdHlfY2pzKCk7XG4gIH1cbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvc2NoZWR1bGVyLmpzXG52YXIgZmx1c2hQZW5kaW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gc2NoZWR1bGVyKGNhbGxiYWNrKSB7XG4gIHF1ZXVlSm9iKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGpvYikpXG4gICAgcXVldWUucHVzaChqb2IpO1xuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBkZXF1ZXVlSm9iKGpvYikge1xuICBjb25zdCBpbmRleCA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghZmx1c2hpbmcgJiYgIWZsdXNoUGVuZGluZykge1xuICAgIGZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soZmx1c2hKb2JzKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hKb2JzKCkge1xuICBmbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKTtcbiAgfVxuICBxdWV1ZS5sZW5ndGggPSAwO1xuICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcmVhY3Rpdml0eS5qc1xudmFyIHJlYWN0aXZlO1xudmFyIGVmZmVjdDtcbnZhciByZWxlYXNlO1xudmFyIHJhdztcbnZhciBzaG91bGRTY2hlZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyhjYWxsYmFjaykge1xuICBzaG91bGRTY2hlZHVsZSA9IGZhbHNlO1xuICBjYWxsYmFjaygpO1xuICBzaG91bGRTY2hlZHVsZSA9IHRydWU7XG59XG5mdW5jdGlvbiBzZXRSZWFjdGl2aXR5RW5naW5lKGVuZ2luZSkge1xuICByZWFjdGl2ZSA9IGVuZ2luZS5yZWFjdGl2ZTtcbiAgcmVsZWFzZSA9IGVuZ2luZS5yZWxlYXNlO1xuICBlZmZlY3QgPSAoY2FsbGJhY2spID0+IGVuZ2luZS5lZmZlY3QoY2FsbGJhY2ssIHtzY2hlZHVsZXI6ICh0YXNrKSA9PiB7XG4gICAgaWYgKHNob3VsZFNjaGVkdWxlKSB7XG4gICAgICBzY2hlZHVsZXIodGFzayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhc2soKTtcbiAgICB9XG4gIH19KTtcbiAgcmF3ID0gZW5naW5lLnJhdztcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlRWZmZWN0KG92ZXJyaWRlKSB7XG4gIGVmZmVjdCA9IG92ZXJyaWRlO1xufVxuZnVuY3Rpb24gZWxlbWVudEJvdW5kRWZmZWN0KGVsKSB7XG4gIGxldCBjbGVhbnVwID0gKCkgPT4ge1xuICB9O1xuICBsZXQgd3JhcHBlZEVmZmVjdCA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCBlZmZlY3RSZWZlcmVuY2UgPSBlZmZlY3QoY2FsbGJhY2spO1xuICAgIGlmICghZWwuX3hfZWZmZWN0cykge1xuICAgICAgZWwuX3hfZWZmZWN0cyA9IG5ldyBTZXQoKTtcbiAgICAgIGVsLl94X3J1bkVmZmVjdHMgPSAoKSA9PiB7XG4gICAgICAgIGVsLl94X2VmZmVjdHMuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGVsLl94X2VmZmVjdHMuYWRkKGVmZmVjdFJlZmVyZW5jZSk7XG4gICAgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIGlmIChlZmZlY3RSZWZlcmVuY2UgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZWwuX3hfZWZmZWN0cy5kZWxldGUoZWZmZWN0UmVmZXJlbmNlKTtcbiAgICAgIHJlbGVhc2UoZWZmZWN0UmVmZXJlbmNlKTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gW3dyYXBwZWRFZmZlY3QsICgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gIH1dO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbXV0YXRpb24uanNcbnZhciBvbkF0dHJpYnV0ZUFkZGVkcyA9IFtdO1xudmFyIG9uRWxSZW1vdmVkcyA9IFtdO1xudmFyIG9uRWxBZGRlZHMgPSBbXTtcbmZ1bmN0aW9uIG9uRWxBZGRlZChjYWxsYmFjaykge1xuICBvbkVsQWRkZWRzLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb25FbFJlbW92ZWQoY2FsbGJhY2spIHtcbiAgb25FbFJlbW92ZWRzLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb25BdHRyaWJ1dGVzQWRkZWQoY2FsbGJhY2spIHtcbiAgb25BdHRyaWJ1dGVBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkF0dHJpYnV0ZVJlbW92ZWQoZWwsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXG4gICAgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMgPSB7fTtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSlcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSA9IFtdO1xuICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBuYW1lcykge1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzKVxuICAgIHJldHVybjtcbiAgT2JqZWN0LmVudHJpZXMoZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBpZiAobmFtZXMgPT09IHZvaWQgMCB8fCBuYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICAgIGRlbGV0ZSBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25NdXRhdGUpO1xudmFyIGN1cnJlbnRseU9ic2VydmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlfSk7XG4gIGN1cnJlbnRseU9ic2VydmluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zKCkge1xuICBmbHVzaE9ic2VydmVyKCk7XG4gIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgY3VycmVudGx5T2JzZXJ2aW5nID0gZmFsc2U7XG59XG52YXIgcmVjb3JkUXVldWUgPSBbXTtcbnZhciB3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlID0gZmFsc2U7XG5mdW5jdGlvbiBmbHVzaE9ic2VydmVyKCkge1xuICByZWNvcmRRdWV1ZSA9IHJlY29yZFF1ZXVlLmNvbmNhdChvYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgaWYgKHJlY29yZFF1ZXVlLmxlbmd0aCAmJiAhd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSkge1xuICAgIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHByb2Nlc3NSZWNvcmRRdWV1ZSgpO1xuICAgICAgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVjb3JkUXVldWUoKSB7XG4gIG9uTXV0YXRlKHJlY29yZFF1ZXVlKTtcbiAgcmVjb3JkUXVldWUubGVuZ3RoID0gMDtcbn1cbmZ1bmN0aW9uIG11dGF0ZURvbShjYWxsYmFjaykge1xuICBpZiAoIWN1cnJlbnRseU9ic2VydmluZylcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgc3RvcE9ic2VydmluZ011dGF0aW9ucygpO1xuICBsZXQgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpc0NvbGxlY3RpbmcgPSBmYWxzZTtcbnZhciBkZWZlcnJlZE11dGF0aW9ucyA9IFtdO1xuZnVuY3Rpb24gZGVmZXJNdXRhdGlvbnMoKSB7XG4gIGlzQ29sbGVjdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBmbHVzaEFuZFN0b3BEZWZlcnJpbmdNdXRhdGlvbnMoKSB7XG4gIGlzQ29sbGVjdGluZyA9IGZhbHNlO1xuICBvbk11dGF0ZShkZWZlcnJlZE11dGF0aW9ucyk7XG4gIGRlZmVycmVkTXV0YXRpb25zID0gW107XG59XG5mdW5jdGlvbiBvbk11dGF0ZShtdXRhdGlvbnMpIHtcbiAgaWYgKGlzQ29sbGVjdGluZykge1xuICAgIGRlZmVycmVkTXV0YXRpb25zID0gZGVmZXJyZWRNdXRhdGlvbnMuY29uY2F0KG11dGF0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBhZGRlZE5vZGVzID0gW107XG4gIGxldCByZW1vdmVkTm9kZXMgPSBbXTtcbiAgbGV0IGFkZGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgbGV0IHJlbW92ZWRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtdXRhdGlvbnNbaV0udGFyZ2V0Ll94X2lnbm9yZU11dGF0aW9uT2JzZXJ2ZXIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAobXV0YXRpb25zW2ldLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgIG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDEgJiYgYWRkZWROb2Rlcy5wdXNoKG5vZGUpKTtcbiAgICAgIG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiByZW1vdmVkTm9kZXMucHVzaChub2RlKSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbnNbaV0udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgIGxldCBlbCA9IG11dGF0aW9uc1tpXS50YXJnZXQ7XG4gICAgICBsZXQgbmFtZSA9IG11dGF0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgbGV0IG9sZFZhbHVlID0gbXV0YXRpb25zW2ldLm9sZFZhbHVlO1xuICAgICAgbGV0IGFkZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFhZGRlZEF0dHJpYnV0ZXMuaGFzKGVsKSlcbiAgICAgICAgICBhZGRlZEF0dHJpYnV0ZXMuc2V0KGVsLCBbXSk7XG4gICAgICAgIGFkZGVkQXR0cmlidXRlcy5nZXQoZWwpLnB1c2goe25hbWUsIHZhbHVlOiBlbC5nZXRBdHRyaWJ1dGUobmFtZSl9KTtcbiAgICAgIH07XG4gICAgICBsZXQgcmVtb3ZlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXJlbW92ZWRBdHRyaWJ1dGVzLmhhcyhlbCkpXG4gICAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuc2V0KGVsLCBbXSk7XG4gICAgICAgIHJlbW92ZWRBdHRyaWJ1dGVzLmdldChlbCkucHVzaChuYW1lKTtcbiAgICAgIH07XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKG5hbWUpICYmIG9sZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGFkZCgpO1xuICAgICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGFkZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJzLCBlbCkgPT4ge1xuICAgIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBhdHRycyk7XG4gIH0pO1xuICBhZGRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cnMsIGVsKSA9PiB7XG4gICAgb25BdHRyaWJ1dGVBZGRlZHMuZm9yRWFjaCgoaSkgPT4gaShlbCwgYXR0cnMpKTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgaWYgKGFkZGVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBvbkVsUmVtb3ZlZHMuZm9yRWFjaCgoaSkgPT4gaShub2RlKSk7XG4gIH1cbiAgYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gIH0pO1xuICBmb3IgKGxldCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICBpZiAocmVtb3ZlZE5vZGVzLmluY2x1ZGVzKG5vZGUpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKCFub2RlLmlzQ29ubmVjdGVkKVxuICAgICAgY29udGludWU7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlU2VsZjtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmU7XG4gICAgb25FbEFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKG5vZGUpKTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgfSk7XG4gIGFkZGVkTm9kZXMgPSBudWxsO1xuICByZW1vdmVkTm9kZXMgPSBudWxsO1xuICBhZGRlZEF0dHJpYnV0ZXMgPSBudWxsO1xuICByZW1vdmVkQXR0cmlidXRlcyA9IG51bGw7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9zY29wZS5qc1xuZnVuY3Rpb24gc2NvcGUobm9kZSkge1xuICByZXR1cm4gbWVyZ2VQcm94aWVzKGNsb3Nlc3REYXRhU3RhY2sobm9kZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVUb05vZGUobm9kZSwgZGF0YTIsIHJlZmVyZW5jZU5vZGUpIHtcbiAgbm9kZS5feF9kYXRhU3RhY2sgPSBbZGF0YTIsIC4uLmNsb3Nlc3REYXRhU3RhY2socmVmZXJlbmNlTm9kZSB8fCBub2RlKV07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbm9kZS5feF9kYXRhU3RhY2sgPSBub2RlLl94X2RhdGFTdGFjay5maWx0ZXIoKGkpID0+IGkgIT09IGRhdGEyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZnJlc2hTY29wZShlbGVtZW50LCBzY29wZTIpIHtcbiAgbGV0IGV4aXN0aW5nU2NvcGUgPSBlbGVtZW50Ll94X2RhdGFTdGFja1swXTtcbiAgT2JqZWN0LmVudHJpZXMoc2NvcGUyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBleGlzdGluZ1Njb3BlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUpIHtcbiAgaWYgKG5vZGUuX3hfZGF0YVN0YWNrKVxuICAgIHJldHVybiBub2RlLl94X2RhdGFTdGFjaztcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLmhvc3QpO1xuICB9XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUucGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBtZXJnZVByb3hpZXMob2JqZWN0cykge1xuICBsZXQgdGhpc1Byb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgb3duS2V5czogKCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvYmplY3RzLmZsYXRNYXAoKGkpID0+IE9iamVjdC5rZXlzKGkpKSkpO1xuICAgIH0sXG4gICAgaGFzOiAodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gb2JqZWN0cy5zb21lKChvYmopID0+IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiAob2JqZWN0cy5maW5kKChvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLmdldC5feF9hbHJlYWR5Qm91bmQgfHwgZGVzY3JpcHRvci5zZXQgJiYgZGVzY3JpcHRvci5zZXQuX3hfYWxyZWFkeUJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgICBsZXQgc2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgZ2V0dGVyID0gZ2V0dGVyICYmIGdldHRlci5iaW5kKHRoaXNQcm94eSk7XG4gICAgICAgICAgICBzZXR0ZXIgPSBzZXR0ZXIgJiYgc2V0dGVyLmJpbmQodGhpc1Byb3h5KTtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIpXG4gICAgICAgICAgICAgIGdldHRlci5feF9hbHJlYWR5Qm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNldHRlcilcbiAgICAgICAgICAgICAgc2V0dGVyLl94X2FscmVhZHlCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgIC4uLnByb3BlcnR5LFxuICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSB8fCB7fSlbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6ICh0YXJnZXQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBsZXQgY2xvc2VzdE9iamVjdFdpdGhLZXkgPSBvYmplY3RzLmZpbmQoKG9iaikgPT4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICAgIGlmIChjbG9zZXN0T2JqZWN0V2l0aEtleSkge1xuICAgICAgICBjbG9zZXN0T2JqZWN0V2l0aEtleVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0c1tvYmplY3RzLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpc1Byb3h5O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW50ZXJjZXB0b3IuanNcbmZ1bmN0aW9uIGluaXRJbnRlcmNlcHRvcnMoZGF0YTIpIHtcbiAgbGV0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbCAhPT0gbnVsbDtcbiAgbGV0IHJlY3Vyc2UgPSAob2JqLCBiYXNlUGF0aCA9IFwiXCIpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKS5mb3JFYWNoKChba2V5LCB7dmFsdWUsIGVudW1lcmFibGV9XSkgPT4ge1xuICAgICAgaWYgKGVudW1lcmFibGUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gb2JqICYmICEodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgIHJlY3Vyc2UodmFsdWUsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZWN1cnNlKGRhdGEyKTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdG9yKGNhbGxiYWNrLCBtdXRhdGVPYmogPSAoKSA9PiB7XG59KSB7XG4gIGxldCBvYmogPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2b2lkIDAsXG4gICAgX3hfaW50ZXJjZXB0b3I6IHRydWUsXG4gICAgaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5pbml0aWFsVmFsdWUsICgpID0+IGdldChkYXRhMiwgcGF0aCksICh2YWx1ZSkgPT4gc2V0KGRhdGEyLCBwYXRoLCB2YWx1ZSksIHBhdGgsIGtleSk7XG4gICAgfVxuICB9O1xuICBtdXRhdGVPYmoob2JqKTtcbiAgcmV0dXJuIChpbml0aWFsVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpbml0aWFsVmFsdWUgIT09IG51bGwgJiYgaW5pdGlhbFZhbHVlLl94X2ludGVyY2VwdG9yKSB7XG4gICAgICBsZXQgaW5pdGlhbGl6ZSA9IG9iai5pbml0aWFsaXplLmJpbmQob2JqKTtcbiAgICAgIG9iai5pbml0aWFsaXplID0gKGRhdGEyLCBwYXRoLCBrZXkpID0+IHtcbiAgICAgICAgbGV0IGlubmVyVmFsdWUgPSBpbml0aWFsVmFsdWUuaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIuXCIpLnJlZHVjZSgoY2FycnksIHNlZ21lbnQpID0+IGNhcnJ5W3NlZ21lbnRdLCBvYmopO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKVxuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xuICBlbHNlIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBlcnJvcjtcbiAgZWxzZSB7XG4gICAgaWYgKG9ialtwYXRoWzBdXSlcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICBvYmpbcGF0aFswXV0gPSB7fTtcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MuanNcbnZhciBtYWdpY3MgPSB7fTtcbmZ1bmN0aW9uIG1hZ2ljKG5hbWUsIGNhbGxiYWNrKSB7XG4gIG1hZ2ljc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0TWFnaWNzKG9iaiwgZWwpIHtcbiAgT2JqZWN0LmVudHJpZXMobWFnaWNzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgYCQke25hbWV9YCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZWwsIHtBbHBpbmU6IGFscGluZV9kZWZhdWx0LCBpbnRlcmNlcHRvcn0pO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZXJyb3IuanNcbmZ1bmN0aW9uIHRyeUNhdGNoKGVsLCBleHByZXNzaW9uLCBjYWxsYmFjaywgLi4uYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIGVsLCBleHByZXNzaW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbiA9IHZvaWQgMCkge1xuICBPYmplY3QuYXNzaWduKGVycm9yMiwge2VsLCBleHByZXNzaW9ufSk7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIEV4cHJlc3Npb24gRXJyb3I6ICR7ZXJyb3IyLm1lc3NhZ2V9XG5cbiR7ZXhwcmVzc2lvbiA/ICdFeHByZXNzaW9uOiBcIicgKyBleHByZXNzaW9uICsgJ1wiXFxuXFxuJyA6IFwiXCJ9YCwgZWwpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnJvcjI7XG4gIH0sIDApO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZXZhbHVhdG9yLmpzXG5mdW5jdGlvbiBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwgZXh0cmFzID0ge30pIHtcbiAgbGV0IHJlc3VsdDtcbiAgZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikoKHZhbHVlKSA9PiByZXN1bHQgPSB2YWx1ZSwgZXh0cmFzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlTGF0ZXIoLi4uYXJncykge1xuICByZXR1cm4gdGhlRXZhbHVhdG9yRnVuY3Rpb24oLi4uYXJncyk7XG59XG52YXIgdGhlRXZhbHVhdG9yRnVuY3Rpb24gPSBub3JtYWxFdmFsdWF0b3I7XG5mdW5jdGlvbiBzZXRFdmFsdWF0b3IobmV3RXZhbHVhdG9yKSB7XG4gIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbmV3RXZhbHVhdG9yO1xufVxuZnVuY3Rpb24gbm9ybWFsRXZhbHVhdG9yKGVsLCBleHByZXNzaW9uKSB7XG4gIGxldCBvdmVycmlkZGVuTWFnaWNzID0ge307XG4gIGluamVjdE1hZ2ljcyhvdmVycmlkZGVuTWFnaWNzLCBlbCk7XG4gIGxldCBkYXRhU3RhY2sgPSBbb3ZlcnJpZGRlbk1hZ2ljcywgLi4uY2xvc2VzdERhdGFTdGFjayhlbCldO1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnZW5lcmF0ZUV2YWx1YXRvckZyb21GdW5jdGlvbihkYXRhU3RhY2ssIGV4cHJlc3Npb24pO1xuICB9XG4gIGxldCBldmFsdWF0b3IgPSBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiB0cnlDYXRjaC5iaW5kKG51bGwsIGVsLCBleHByZXNzaW9uLCBldmFsdWF0b3IpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tRnVuY3Rpb24oZGF0YVN0YWNrLCBmdW5jKSB7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZTogc2NvcGUyID0ge30sIHBhcmFtcyA9IFtdfSA9IHt9KSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGZ1bmMuYXBwbHkobWVyZ2VQcm94aWVzKFtzY29wZTIsIC4uLmRhdGFTdGFja10pLCBwYXJhbXMpO1xuICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCk7XG4gIH07XG59XG52YXIgZXZhbHVhdG9yTWVtbyA9IHt9O1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcbiAgaWYgKGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0pIHtcbiAgICByZXR1cm4gZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXTtcbiAgfVxuICBsZXQgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpIHtcbiAgfSkuY29uc3RydWN0b3I7XG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24pIHx8IC9eKGxldHxjb25zdClcXHMvLnRlc3QoZXhwcmVzc2lvbikgPyBgKCgpID0+IHsgJHtleHByZXNzaW9ufSB9KSgpYCA6IGV4cHJlc3Npb247XG4gIGNvbnN0IHNhZmVBc3luY0Z1bmN0aW9uID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jRnVuY3Rpb24oW1wiX19zZWxmXCIsIFwic2NvcGVcIl0sIGB3aXRoIChzY29wZSkgeyBfX3NlbGYucmVzdWx0ID0gJHtyaWdodFNpZGVTYWZlRXhwcmVzc2lvbn0gfTsgX19zZWxmLmZpbmlzaGVkID0gdHJ1ZTsgcmV0dXJuIF9fc2VsZi5yZXN1bHQ7YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGxldCBmdW5jID0gc2FmZUFzeW5jRnVuY3Rpb24oKTtcbiAgZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXSA9IGZ1bmM7XG4gIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpIHtcbiAgbGV0IGZ1bmMgPSBnZW5lcmF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZTogc2NvcGUyID0ge30sIHBhcmFtcyA9IFtdfSA9IHt9KSA9PiB7XG4gICAgZnVuYy5yZXN1bHQgPSB2b2lkIDA7XG4gICAgZnVuYy5maW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBjb21wbGV0ZVNjb3BlID0gbWVyZ2VQcm94aWVzKFtzY29wZTIsIC4uLmRhdGFTdGFja10pO1xuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IGZ1bmMoZnVuYywgY29tcGxldGVTY29wZSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpO1xuICAgICAgaWYgKGZ1bmMuZmluaXNoZWQpIHtcbiAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgZnVuYy5yZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xuICAgICAgICBmdW5jLnJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgcmVzdWx0LCBjb21wbGV0ZVNjb3BlLCBwYXJhbXMsIGVsKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpLmZpbmFsbHkoKCkgPT4gZnVuYy5yZXN1bHQgPSB2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHZhbHVlLCBzY29wZTIsIHBhcmFtcywgZWwpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLmFwcGx5KHNjb3BlMiwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmVzdWx0LnRoZW4oKGkpID0+IHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIGksIHNjb3BlMiwgcGFyYW1zKSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZWl2ZXIocmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVjZWl2ZXIodmFsdWUpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzLmpzXG52YXIgcHJlZml4QXNTdHJpbmcgPSBcIngtXCI7XG5mdW5jdGlvbiBwcmVmaXgoc3ViamVjdCA9IFwiXCIpIHtcbiAgcmV0dXJuIHByZWZpeEFzU3RyaW5nICsgc3ViamVjdDtcbn1cbmZ1bmN0aW9uIHNldFByZWZpeChuZXdQcmVmaXgpIHtcbiAgcHJlZml4QXNTdHJpbmcgPSBuZXdQcmVmaXg7XG59XG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7fTtcbmZ1bmN0aW9uIGRpcmVjdGl2ZShuYW1lLCBjYWxsYmFjaykge1xuICBkaXJlY3RpdmVIYW5kbGVyc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlcyhlbCwgYXR0cmlidXRlcywgb3JpZ2luYWxBdHRyaWJ1dGVPdmVycmlkZSkge1xuICBsZXQgdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgbGV0IGRpcmVjdGl2ZXMyID0gQXJyYXkuZnJvbShhdHRyaWJ1dGVzKS5tYXAodG9UcmFuc2Zvcm1lZEF0dHJpYnV0ZXMoKG5ld05hbWUsIG9sZE5hbWUpID0+IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25ld05hbWVdID0gb2xkTmFtZSkpLmZpbHRlcihvdXROb25BbHBpbmVBdHRyaWJ1dGVzKS5tYXAodG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSkuc29ydChieVByaW9yaXR5KTtcbiAgcmV0dXJuIGRpcmVjdGl2ZXMyLm1hcCgoZGlyZWN0aXZlMikgPT4ge1xuICAgIHJldHVybiBnZXREaXJlY3RpdmVIYW5kbGVyKGVsLCBkaXJlY3RpdmUyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGF0dHJpYnV0ZXMpLm1hcCh0b1RyYW5zZm9ybWVkQXR0cmlidXRlcygpKS5maWx0ZXIoKGF0dHIpID0+ICFvdXROb25BbHBpbmVBdHRyaWJ1dGVzKGF0dHIpKTtcbn1cbnZhciBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XG52YXIgZGlyZWN0aXZlSGFuZGxlclN0YWNrcyA9IG5ldyBNYXAoKTtcbnZhciBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcyhjYWxsYmFjaykge1xuICBpc0RlZmVycmluZ0hhbmRsZXJzID0gdHJ1ZTtcbiAgbGV0IGtleSA9IFN5bWJvbCgpO1xuICBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0ga2V5O1xuICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLnNldChrZXksIFtdKTtcbiAgbGV0IGZsdXNoSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgd2hpbGUgKGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGtleSkubGVuZ3RoKVxuICAgICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5zaGlmdCgpKCk7XG4gICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5kZWxldGUoa2V5KTtcbiAgfTtcbiAgbGV0IHN0b3BEZWZlcnJpbmcgPSAoKSA9PiB7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA9IGZhbHNlO1xuICAgIGZsdXNoSGFuZGxlcnMoKTtcbiAgfTtcbiAgY2FsbGJhY2soZmx1c2hIYW5kbGVycyk7XG4gIHN0b3BEZWZlcnJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpIHtcbiAgbGV0IG5vb3AgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBoYW5kbGVyMyA9IGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZTIudHlwZV0gfHwgbm9vcDtcbiAgbGV0IGNsZWFudXBzID0gW107XG4gIGxldCBjbGVhbnVwID0gKGNhbGxiYWNrKSA9PiBjbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgbGV0IFtlZmZlY3QzLCBjbGVhbnVwRWZmZWN0XSA9IGVsZW1lbnRCb3VuZEVmZmVjdChlbCk7XG4gIGNsZWFudXBzLnB1c2goY2xlYW51cEVmZmVjdCk7XG4gIGxldCB1dGlsaXRpZXMgPSB7XG4gICAgQWxwaW5lOiBhbHBpbmVfZGVmYXVsdCxcbiAgICBlZmZlY3Q6IGVmZmVjdDMsXG4gICAgY2xlYW51cCxcbiAgICBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyLmJpbmQoZXZhbHVhdGVMYXRlciwgZWwpLFxuICAgIGV2YWx1YXRlOiBldmFsdWF0ZS5iaW5kKGV2YWx1YXRlLCBlbClcbiAgfTtcbiAgbGV0IGRvQ2xlYW51cCA9ICgpID0+IGNsZWFudXBzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgZGlyZWN0aXZlMi5vcmlnaW5hbCwgZG9DbGVhbnVwKTtcbiAgbGV0IGZ1bGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9pZ25vcmUgfHwgZWwuX3hfaWdub3JlU2VsZilcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVyMy5pbmxpbmUgJiYgaGFuZGxlcjMuaW5saW5lKGVsLCBkaXJlY3RpdmUyLCB1dGlsaXRpZXMpO1xuICAgIGhhbmRsZXIzID0gaGFuZGxlcjMuYmluZChoYW5kbGVyMywgZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA/IGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkpLnB1c2goaGFuZGxlcjMpIDogaGFuZGxlcjMoKTtcbiAgfTtcbiAgZnVsbEhhbmRsZXIucnVuQ2xlYW51cHMgPSBkb0NsZWFudXA7XG4gIHJldHVybiBmdWxsSGFuZGxlcjtcbn1cbnZhciBzdGFydGluZ1dpdGggPSAoc3ViamVjdCwgcmVwbGFjZW1lbnQpID0+ICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShzdWJqZWN0LCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB7bmFtZSwgdmFsdWV9O1xufTtcbnZhciBpbnRvID0gKGkpID0+IGk7XG5mdW5jdGlvbiB0b1RyYW5zZm9ybWVkQXR0cmlidXRlcyhjYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gICAgbGV0IHtuYW1lOiBuZXdOYW1lLCB2YWx1ZTogbmV3VmFsdWV9ID0gYXR0cmlidXRlVHJhbnNmb3JtZXJzLnJlZHVjZSgoY2FycnksIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XG4gICAgfSwge25hbWUsIHZhbHVlfSk7XG4gICAgaWYgKG5ld05hbWUgIT09IG5hbWUpXG4gICAgICBjYWxsYmFjayhuZXdOYW1lLCBuYW1lKTtcbiAgICByZXR1cm4ge25hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZX07XG4gIH07XG59XG52YXIgYXR0cmlidXRlVHJhbnNmb3JtZXJzID0gW107XG5mdW5jdGlvbiBtYXBBdHRyaWJ1dGVzKGNhbGxiYWNrKSB7XG4gIGF0dHJpYnV0ZVRyYW5zZm9ybWVycy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG91dE5vbkFscGluZUF0dHJpYnV0ZXMoe25hbWV9KSB7XG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XG59XG52YXIgYWxwaW5lQXR0cmlidXRlUmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBeJHtwcmVmaXhBc1N0cmluZ30oW146Xi5dKylcXFxcYmApO1xuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIHJldHVybiAoe25hbWUsIHZhbHVlfSkgPT4ge1xuICAgIGxldCB0eXBlTWF0Y2ggPSBuYW1lLm1hdGNoKGFscGluZUF0dHJpYnV0ZVJlZ2V4KCkpO1xuICAgIGxldCB2YWx1ZU1hdGNoID0gbmFtZS5tYXRjaCgvOihbYS16QS1aMC05XFwtOl0rKS8pO1xuICAgIGxldCBtb2RpZmllcnMgPSBuYW1lLm1hdGNoKC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nKSB8fCBbXTtcbiAgICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlIHx8IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKChpKSA9PiBpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlLFxuICAgICAgb3JpZ2luYWxcbiAgICB9O1xuICB9O1xufVxudmFyIERFRkFVTFQgPSBcIkRFRkFVTFRcIjtcbnZhciBkaXJlY3RpdmVPcmRlciA9IFtcbiAgXCJpZ25vcmVcIixcbiAgXCJyZWZcIixcbiAgXCJkYXRhXCIsXG4gIFwiaWRcIixcbiAgXCJiaW5kXCIsXG4gIFwiaW5pdFwiLFxuICBcImZvclwiLFxuICBcIm1vZGVsXCIsXG4gIFwibW9kZWxhYmxlXCIsXG4gIFwidHJhbnNpdGlvblwiLFxuICBcInNob3dcIixcbiAgXCJpZlwiLFxuICBERUZBVUxULFxuICBcInRlbGVwb3J0XCIsXG4gIFwiZWxlbWVudFwiXG5dO1xuZnVuY3Rpb24gYnlQcmlvcml0eShhLCBiKSB7XG4gIGxldCB0eXBlQSA9IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoYS50eXBlKSA9PT0gLTEgPyBERUZBVUxUIDogYS50eXBlO1xuICBsZXQgdHlwZUIgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGIudHlwZSkgPT09IC0xID8gREVGQVVMVCA6IGIudHlwZTtcbiAgcmV0dXJuIGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YodHlwZUEpIC0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQik7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9kaXNwYXRjaC5qc1xuZnVuY3Rpb24gZGlzcGF0Y2goZWwsIG5hbWUsIGRldGFpbCA9IHt9KSB7XG4gIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICBkZXRhaWwsXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlXG4gIH0pKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL25leHRUaWNrLmpzXG52YXIgdGlja1N0YWNrID0gW107XG52YXIgaXNIb2xkaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjaykge1xuICB0aWNrU3RhY2sucHVzaChjYWxsYmFjayk7XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBpc0hvbGRpbmcgfHwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsZWFzZU5leHRUaWNrcygpIHtcbiAgaXNIb2xkaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0aWNrU3RhY2subGVuZ3RoKVxuICAgIHRpY2tTdGFjay5zaGlmdCgpKCk7XG59XG5mdW5jdGlvbiBob2xkTmV4dFRpY2tzKCkge1xuICBpc0hvbGRpbmcgPSB0cnVlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvd2Fsay5qc1xuZnVuY3Rpb24gd2FsayhlbCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgZWwgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZm9yRWFjaCgoZWwyKSA9PiB3YWxrKGVsMiwgY2FsbGJhY2spKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHNraXAgPSBmYWxzZTtcbiAgY2FsbGJhY2soZWwsICgpID0+IHNraXAgPSB0cnVlKTtcbiAgaWYgKHNraXApXG4gICAgcmV0dXJuO1xuICBsZXQgbm9kZSA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAobm9kZSkge1xuICAgIHdhbGsobm9kZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3dhcm4uanNcbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgLi4uYXJncykge1xuICBjb25zb2xlLndhcm4oYEFscGluZSBXYXJuaW5nOiAke21lc3NhZ2V9YCwgLi4uYXJncyk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9saWZlY3ljbGUuanNcbmZ1bmN0aW9uIHN0YXJ0KCkge1xuICBpZiAoIWRvY3VtZW50LmJvZHkpXG4gICAgd2FybihcIlVuYWJsZSB0byBpbml0aWFsaXplLiBUcnlpbmcgdG8gbG9hZCBBbHBpbmUgYmVmb3JlIGA8Ym9keT5gIGlzIGF2YWlsYWJsZS4gRGlkIHlvdSBmb3JnZXQgdG8gYWRkIGBkZWZlcmAgaW4gQWxwaW5lJ3MgYDxzY3JpcHQ+YCB0YWc/XCIpO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdFwiKTtcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRpYWxpemluZ1wiKTtcbiAgc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKTtcbiAgb25FbEFkZGVkKChlbCkgPT4gaW5pdFRyZWUoZWwsIHdhbGspKTtcbiAgb25FbFJlbW92ZWQoKGVsKSA9PiBkZXN0cm95VHJlZShlbCkpO1xuICBvbkF0dHJpYnV0ZXNBZGRlZCgoZWwsIGF0dHJzKSA9PiB7XG4gICAgZGlyZWN0aXZlcyhlbCwgYXR0cnMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xuICB9KTtcbiAgbGV0IG91dE5lc3RlZENvbXBvbmVudHMgPSAoZWwpID0+ICFjbG9zZXN0Um9vdChlbC5wYXJlbnRFbGVtZW50LCB0cnVlKTtcbiAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGFsbFNlbGVjdG9ycygpKSkuZmlsdGVyKG91dE5lc3RlZENvbXBvbmVudHMpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgaW5pdFRyZWUoZWwpO1xuICB9KTtcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRpYWxpemVkXCIpO1xufVxudmFyIHJvb3RTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xudmFyIGluaXRTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xuZnVuY3Rpb24gcm9vdFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFsbFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5jb25jYXQoaW5pdFNlbGVjdG9yQ2FsbGJhY2tzKS5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFkZFJvb3RTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XG4gIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5wdXNoKHNlbGVjdG9yQ2FsbGJhY2spO1xufVxuZnVuY3Rpb24gYWRkSW5pdFNlbGVjdG9yKHNlbGVjdG9yQ2FsbGJhY2spIHtcbiAgaW5pdFNlbGVjdG9yQ2FsbGJhY2tzLnB1c2goc2VsZWN0b3JDYWxsYmFjayk7XG59XG5mdW5jdGlvbiBjbG9zZXN0Um9vdChlbCwgaW5jbHVkZUluaXRTZWxlY3RvcnMgPSBmYWxzZSkge1xuICByZXR1cm4gZmluZENsb3Nlc3QoZWwsIChlbGVtZW50KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gaW5jbHVkZUluaXRTZWxlY3RvcnMgPyBhbGxTZWxlY3RvcnMoKSA6IHJvb3RTZWxlY3RvcnMoKTtcbiAgICBpZiAoc2VsZWN0b3JzLnNvbWUoKHNlbGVjdG9yKSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0KGVsLCBjYWxsYmFjaykge1xuICBpZiAoIWVsKVxuICAgIHJldHVybjtcbiAgaWYgKGNhbGxiYWNrKGVsKSlcbiAgICByZXR1cm4gZWw7XG4gIGlmIChlbC5feF90ZWxlcG9ydEJhY2spXG4gICAgZWwgPSBlbC5feF90ZWxlcG9ydEJhY2s7XG4gIGlmICghZWwucGFyZW50RWxlbWVudClcbiAgICByZXR1cm47XG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbC5wYXJlbnRFbGVtZW50LCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBpc1Jvb3QoZWwpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvcnMoKS5zb21lKChzZWxlY3RvcikgPT4gZWwubWF0Y2hlcyhzZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gaW5pdFRyZWUoZWwsIHdhbGtlciA9IHdhbGspIHtcbiAgZGVmZXJIYW5kbGluZ0RpcmVjdGl2ZXMoKCkgPT4ge1xuICAgIHdhbGtlcihlbCwgKGVsMiwgc2tpcCkgPT4ge1xuICAgICAgZGlyZWN0aXZlcyhlbDIsIGVsMi5hdHRyaWJ1dGVzKS5mb3JFYWNoKChoYW5kbGUpID0+IGhhbmRsZSgpKTtcbiAgICAgIGVsMi5feF9pZ25vcmUgJiYgc2tpcCgpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lUcmVlKHJvb3QpIHtcbiAgd2Fsayhyb290LCAoZWwpID0+IGNsZWFudXBBdHRyaWJ1dGVzKGVsKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9jbGFzc2VzLmpzXG5mdW5jdGlvbiBzZXRDbGFzc2VzKGVsLCB2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2V0Q2xhc3Nlc0Zyb21PYmplY3QoZWwsIHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzZXRDbGFzc2VzKGVsLCB2YWx1ZSgpKTtcbiAgfVxuICByZXR1cm4gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCBjbGFzc1N0cmluZykge1xuICBsZXQgc3BsaXQgPSAoY2xhc3NTdHJpbmcyKSA9PiBjbGFzc1N0cmluZzIuc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IG1pc3NpbmdDbGFzc2VzID0gKGNsYXNzU3RyaW5nMikgPT4gY2xhc3NTdHJpbmcyLnNwbGl0KFwiIFwiKS5maWx0ZXIoKGkpID0+ICFlbC5jbGFzc0xpc3QuY29udGFpbnMoaSkpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGFkZENsYXNzZXNBbmRSZXR1cm5VbmRvID0gKGNsYXNzZXMpID0+IHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXMpO1xuICAgIH07XG4gIH07XG4gIGNsYXNzU3RyaW5nID0gY2xhc3NTdHJpbmcgPT09IHRydWUgPyBjbGFzc1N0cmluZyA9IFwiXCIgOiBjbGFzc1N0cmluZyB8fCBcIlwiO1xuICByZXR1cm4gYWRkQ2xhc3Nlc0FuZFJldHVyblVuZG8obWlzc2luZ0NsYXNzZXMoY2xhc3NTdHJpbmcpKTtcbn1cbmZ1bmN0aW9uIHNldENsYXNzZXNGcm9tT2JqZWN0KGVsLCBjbGFzc09iamVjdCkge1xuICBsZXQgc3BsaXQgPSAoY2xhc3NTdHJpbmcpID0+IGNsYXNzU3RyaW5nLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBmb3JBZGQgPSBPYmplY3QuZW50cmllcyhjbGFzc09iamVjdCkuZmxhdE1hcCgoW2NsYXNzU3RyaW5nLCBib29sXSkgPT4gYm9vbCA/IHNwbGl0KGNsYXNzU3RyaW5nKSA6IGZhbHNlKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBmb3JSZW1vdmUgPSBPYmplY3QuZW50cmllcyhjbGFzc09iamVjdCkuZmxhdE1hcCgoW2NsYXNzU3RyaW5nLCBib29sXSkgPT4gIWJvb2wgPyBzcGxpdChjbGFzc1N0cmluZykgOiBmYWxzZSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgYWRkZWQgPSBbXTtcbiAgbGV0IHJlbW92ZWQgPSBbXTtcbiAgZm9yUmVtb3ZlLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGkpO1xuICAgICAgcmVtb3ZlZC5wdXNoKGkpO1xuICAgIH1cbiAgfSk7XG4gIGZvckFkZC5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoaSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoaSk7XG4gICAgICBhZGRlZC5wdXNoKGkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKChpKSA9PiBlbC5jbGFzc0xpc3QuYWRkKGkpKTtcbiAgICBhZGRlZC5mb3JFYWNoKChpKSA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGkpKTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3N0eWxlcy5qc1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNldFN0eWxlc0Zyb21PYmplY3QoZWwsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gc2V0U3R5bGVzRnJvbVN0cmluZyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0U3R5bGVzRnJvbU9iamVjdChlbCwgdmFsdWUpIHtcbiAgbGV0IHByZXZpb3VzU3R5bGVzID0ge307XG4gIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCB2YWx1ZTJdKSA9PiB7XG4gICAgcHJldmlvdXNTdHlsZXNba2V5XSA9IGVsLnN0eWxlW2tleV07XG4gICAgaWYgKCFrZXkuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICBrZXkgPSBrZWJhYkNhc2Uoa2V5KTtcbiAgICB9XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZTIpO1xuICB9KTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVsLnN0eWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBzZXRTdHlsZXMoZWwsIHByZXZpb3VzU3R5bGVzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKSB7XG4gIGxldCBjYWNoZSA9IGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgZWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgdmFsdWUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGNhY2hlIHx8IFwiXCIpO1xuICB9O1xufVxuZnVuY3Rpb24ga2ViYWJDYXNlKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvb25jZS5qc1xuZnVuY3Rpb24gb25jZShjYWxsYmFjaywgZmFsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtdHJhbnNpdGlvbi5qc1xuZGlyZWN0aXZlKFwidHJhbnNpdGlvblwiLCAoZWwsIHt2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9ufSwge2V2YWx1YXRlOiBldmFsdWF0ZTJ9KSA9PiB7XG4gIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgIGV4cHJlc3Npb24gPSBldmFsdWF0ZTIoZXhwcmVzc2lvbik7XG4gIGlmICghZXhwcmVzc2lvbikge1xuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBleHByZXNzaW9uLCB2YWx1ZSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21DbGFzc1N0cmluZyhlbCwgY2xhc3NTdHJpbmcsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0Q2xhc3NlcywgXCJcIik7XG4gIGxldCBkaXJlY3RpdmVTdG9yYWdlTWFwID0ge1xuICAgIGVudGVyOiAoY2xhc3NlcykgPT4ge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5kdXJpbmcgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJlbnRlci1zdGFydFwiOiAoY2xhc3NlcykgPT4ge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBcImVudGVyLWVuZFwiOiAoY2xhc3NlcykgPT4ge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgbGVhdmU6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmR1cmluZyA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBcImxlYXZlLXN0YXJ0XCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLnN0YXJ0ID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmUtZW5kXCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmVuZCA9IGNsYXNzZXM7XG4gICAgfVxuICB9O1xuICBkaXJlY3RpdmVTdG9yYWdlTWFwW3N0YWdlXShjbGFzc1N0cmluZyk7XG59XG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25zRnJvbUhlbHBlcihlbCwgbW9kaWZpZXJzLCBzdGFnZSkge1xuICByZWdpc3RlclRyYW5zaXRpb25PYmplY3QoZWwsIHNldFN0eWxlcyk7XG4gIGxldCBkb2VzbnRTcGVjaWZ5ID0gIW1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRcIikgJiYgIXN0YWdlO1xuICBsZXQgdHJhbnNpdGlvbmluZ0luID0gZG9lc250U3BlY2lmeSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSB8fCBbXCJlbnRlclwiXS5pbmNsdWRlcyhzdGFnZSk7XG4gIGxldCB0cmFuc2l0aW9uaW5nT3V0ID0gZG9lc250U3BlY2lmeSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRcIikgfHwgW1wibGVhdmVcIl0uaW5jbHVkZXMoc3RhZ2UpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIWRvZXNudFNwZWNpZnkpIHtcbiAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPCBtb2RpZmllcnMuaW5kZXhPZihcIm91dFwiKSk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA+IG1vZGlmaWVycy5pbmRleE9mKFwib3V0XCIpKTtcbiAgfVxuICBsZXQgd2FudHNBbGwgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwib3BhY2l0eVwiKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKFwic2NhbGVcIik7XG4gIGxldCB3YW50c09wYWNpdHkgPSB3YW50c0FsbCB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpO1xuICBsZXQgd2FudHNTY2FsZSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcInNjYWxlXCIpO1xuICBsZXQgb3BhY2l0eVZhbHVlID0gd2FudHNPcGFjaXR5ID8gMCA6IDE7XG4gIGxldCBzY2FsZVZhbHVlID0gd2FudHNTY2FsZSA/IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcInNjYWxlXCIsIDk1KSAvIDEwMCA6IDE7XG4gIGxldCBkZWxheSA9IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcImRlbGF5XCIsIDApO1xuICBsZXQgb3JpZ2luID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwib3JpZ2luXCIsIFwiY2VudGVyXCIpO1xuICBsZXQgcHJvcGVydHkgPSBcIm9wYWNpdHksIHRyYW5zZm9ybVwiO1xuICBsZXQgZHVyYXRpb25JbiA9IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcImR1cmF0aW9uXCIsIDE1MCkgLyAxZTM7XG4gIGxldCBkdXJhdGlvbk91dCA9IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcImR1cmF0aW9uXCIsIDc1KSAvIDFlMztcbiAgbGV0IGVhc2luZyA9IGBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDAuMiwgMSlgO1xuICBpZiAodHJhbnNpdGlvbmluZ0luKSB7XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5kdXJpbmcgPSB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IG9yaWdpbixcbiAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXksXG4gICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtkdXJhdGlvbklufXNgLFxuICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBlYXNpbmdcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuc3RhcnQgPSB7XG4gICAgICBvcGFjaXR5OiBvcGFjaXR5VmFsdWUsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke3NjYWxlVmFsdWV9KWBcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kID0ge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKDEpYFxuICAgIH07XG4gIH1cbiAgaWYgKHRyYW5zaXRpb25pbmdPdXQpIHtcbiAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmR1cmluZyA9IHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSxcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9uT3V0fXNgLFxuICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBlYXNpbmdcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuc3RhcnQgPSB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXG4gICAgfTtcbiAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLmVuZCA9IHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0RnVuY3Rpb24sIGRlZmF1bHRWYWx1ZSA9IHt9KSB7XG4gIGlmICghZWwuX3hfdHJhbnNpdGlvbilcbiAgICBlbC5feF90cmFuc2l0aW9uID0ge1xuICAgICAgZW50ZXI6IHtkdXJpbmc6IGRlZmF1bHRWYWx1ZSwgc3RhcnQ6IGRlZmF1bHRWYWx1ZSwgZW5kOiBkZWZhdWx0VmFsdWV9LFxuICAgICAgbGVhdmU6IHtkdXJpbmc6IGRlZmF1bHRWYWx1ZSwgc3RhcnQ6IGRlZmF1bHRWYWx1ZSwgZW5kOiBkZWZhdWx0VmFsdWV9LFxuICAgICAgaW4oYmVmb3JlID0gKCkgPT4ge1xuICAgICAgfSwgYWZ0ZXIgPSAoKSA9PiB7XG4gICAgICB9KSB7XG4gICAgICAgIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7XG4gICAgICAgICAgZHVyaW5nOiB0aGlzLmVudGVyLmR1cmluZyxcbiAgICAgICAgICBzdGFydDogdGhpcy5lbnRlci5zdGFydCxcbiAgICAgICAgICBlbmQ6IHRoaXMuZW50ZXIuZW5kXG4gICAgICAgIH0sIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgfSxcbiAgICAgIG91dChiZWZvcmUgPSAoKSA9PiB7XG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcbiAgICAgIH0pIHtcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcbiAgICAgICAgICBkdXJpbmc6IHRoaXMubGVhdmUuZHVyaW5nLFxuICAgICAgICAgIHN0YXJ0OiB0aGlzLmxlYXZlLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5sZWF2ZS5lbmRcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICB9XG4gICAgfTtcbn1cbndpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5feF90b2dnbGVBbmRDYXNjYWRlV2l0aFRyYW5zaXRpb25zID0gZnVuY3Rpb24oZWwsIHZhbHVlLCBzaG93LCBoaWRlKSB7XG4gIGxldCBjbGlja0F3YXlDb21wYXRpYmxlU2hvdyA9ICgpID0+IHtcbiAgICBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNob3cpIDogc2V0VGltZW91dChzaG93KTtcbiAgfTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKGVsLl94X3RyYW5zaXRpb24gJiYgKGVsLl94X3RyYW5zaXRpb24uZW50ZXIgfHwgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZSkpIHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIgJiYgKE9iamVjdC5lbnRyaWVzKGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZHVyaW5nKS5sZW5ndGggfHwgT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCkubGVuZ3RoIHx8IE9iamVjdC5lbnRyaWVzKGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kKS5sZW5ndGgpID8gZWwuX3hfdHJhbnNpdGlvbi5pbihzaG93KSA6IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24gPyBlbC5feF90cmFuc2l0aW9uLmluKHNob3cpIDogY2xpY2tBd2F5Q29tcGF0aWJsZVNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsLl94X2hpZGVQcm9taXNlID0gZWwuX3hfdHJhbnNpdGlvbiA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBlbC5feF90cmFuc2l0aW9uLm91dCgoKSA9PiB7XG4gICAgfSwgKCkgPT4gcmVzb2x2ZShoaWRlKSk7XG4gICAgZWwuX3hfdHJhbnNpdGlvbmluZy5iZWZvcmVDYW5jZWwoKCkgPT4gcmVqZWN0KHtpc0Zyb21DYW5jZWxsZWRUcmFuc2l0aW9uOiB0cnVlfSkpO1xuICB9KSA6IFByb21pc2UucmVzb2x2ZShoaWRlKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGxldCBjbG9zZXN0ID0gY2xvc2VzdEhpZGUoZWwpO1xuICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICBpZiAoIWNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuKVxuICAgICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbiA9IFtdO1xuICAgICAgY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4ucHVzaChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgbGV0IGhpZGVBZnRlckNoaWxkcmVuID0gKGVsMikgPT4ge1xuICAgICAgICAgIGxldCBjYXJyeSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGVsMi5feF9oaWRlUHJvbWlzZSxcbiAgICAgICAgICAgIC4uLihlbDIuX3hfaGlkZUNoaWxkcmVuIHx8IFtdKS5tYXAoaGlkZUFmdGVyQ2hpbGRyZW4pXG4gICAgICAgICAgXSkudGhlbigoW2ldKSA9PiBpKCkpO1xuICAgICAgICAgIGRlbGV0ZSBlbDIuX3hfaGlkZVByb21pc2U7XG4gICAgICAgICAgZGVsZXRlIGVsMi5feF9oaWRlQ2hpbGRyZW47XG4gICAgICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgICAgICB9O1xuICAgICAgICBoaWRlQWZ0ZXJDaGlsZHJlbihlbCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBpZiAoIWUuaXNGcm9tQ2FuY2VsbGVkVHJhbnNpdGlvbilcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBjbG9zZXN0SGlkZShlbCkge1xuICBsZXQgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgaWYgKCFwYXJlbnQpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gcGFyZW50Ll94X2hpZGVQcm9taXNlID8gcGFyZW50IDogY2xvc2VzdEhpZGUocGFyZW50KTtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7ZHVyaW5nLCBzdGFydDogc3RhcnQyLCBlbmR9ID0ge30sIGJlZm9yZSA9ICgpID0+IHtcbn0sIGFmdGVyID0gKCkgPT4ge1xufSkge1xuICBpZiAoZWwuX3hfdHJhbnNpdGlvbmluZylcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmNhbmNlbCgpO1xuICBpZiAoT2JqZWN0LmtleXMoZHVyaW5nKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc3RhcnQyKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoZW5kKS5sZW5ndGggPT09IDApIHtcbiAgICBiZWZvcmUoKTtcbiAgICBhZnRlcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdW5kb1N0YXJ0LCB1bmRvRHVyaW5nLCB1bmRvRW5kO1xuICBwZXJmb3JtVHJhbnNpdGlvbihlbCwge1xuICAgIHN0YXJ0KCkge1xuICAgICAgdW5kb1N0YXJ0ID0gc2V0RnVuY3Rpb24oZWwsIHN0YXJ0Mik7XG4gICAgfSxcbiAgICBkdXJpbmcoKSB7XG4gICAgICB1bmRvRHVyaW5nID0gc2V0RnVuY3Rpb24oZWwsIGR1cmluZyk7XG4gICAgfSxcbiAgICBiZWZvcmUsXG4gICAgZW5kKCkge1xuICAgICAgdW5kb1N0YXJ0KCk7XG4gICAgICB1bmRvRW5kID0gc2V0RnVuY3Rpb24oZWwsIGVuZCk7XG4gICAgfSxcbiAgICBhZnRlcixcbiAgICBjbGVhbnVwKCkge1xuICAgICAgdW5kb0R1cmluZygpO1xuICAgICAgdW5kb0VuZCgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVHJhbnNpdGlvbihlbCwgc3RhZ2VzKSB7XG4gIGxldCBpbnRlcnJ1cHRlZCwgcmVhY2hlZEJlZm9yZSwgcmVhY2hlZEVuZDtcbiAgbGV0IGZpbmlzaCA9IG9uY2UoKCkgPT4ge1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgICBpZiAoIXJlYWNoZWRCZWZvcmUpXG4gICAgICAgIHN0YWdlcy5iZWZvcmUoKTtcbiAgICAgIGlmICghcmVhY2hlZEVuZCkge1xuICAgICAgICBzdGFnZXMuZW5kKCk7XG4gICAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICAgIH1cbiAgICAgIHN0YWdlcy5hZnRlcigpO1xuICAgICAgaWYgKGVsLmlzQ29ubmVjdGVkKVxuICAgICAgICBzdGFnZXMuY2xlYW51cCgpO1xuICAgICAgZGVsZXRlIGVsLl94X3RyYW5zaXRpb25pbmc7XG4gICAgfSk7XG4gIH0pO1xuICBlbC5feF90cmFuc2l0aW9uaW5nID0ge1xuICAgIGJlZm9yZUNhbmNlbHM6IFtdLFxuICAgIGJlZm9yZUNhbmNlbChjYWxsYmFjaykge1xuICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnB1c2goY2FsbGJhY2spO1xuICAgIH0sXG4gICAgY2FuY2VsOiBvbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUgKHRoaXMuYmVmb3JlQ2FuY2Vscy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGZpbmlzaCgpO1xuICAgIH0pLFxuICAgIGZpbmlzaFxuICB9O1xuICBtdXRhdGVEb20oKCkgPT4ge1xuICAgIHN0YWdlcy5zdGFydCgpO1xuICAgIHN0YWdlcy5kdXJpbmcoKTtcbiAgfSk7XG4gIGhvbGROZXh0VGlja3MoKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBpZiAoaW50ZXJydXB0ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKC8sLiovLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgbGV0IGRlbGF5ID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EZWxheS5yZXBsYWNlKC8sLiovLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKVxuICAgICAgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24ucmVwbGFjZShcInNcIiwgXCJcIikpICogMWUzO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBzdGFnZXMuYmVmb3JlKCk7XG4gICAgfSk7XG4gICAgcmVhY2hlZEJlZm9yZSA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgc3RhZ2VzLmVuZCgpO1xuICAgICAgfSk7XG4gICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XG4gICAgICBzZXRUaW1lb3V0KGVsLl94X3RyYW5zaXRpb25pbmcuZmluaXNoLCBkdXJhdGlvbiArIGRlbGF5KTtcbiAgICAgIHJlYWNoZWRFbmQgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBrZXksIGZhbGxiYWNrKSB7XG4gIGlmIChtb2RpZmllcnMuaW5kZXhPZihrZXkpID09PSAtMSlcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGNvbnN0IHJhd1ZhbHVlID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAxXTtcbiAgaWYgKCFyYXdWYWx1ZSlcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGlmIChrZXkgPT09IFwic2NhbGVcIikge1xuICAgIGlmIChpc05hTihyYXdWYWx1ZSkpXG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgbGV0IG1hdGNoID0gcmF3VmFsdWUubWF0Y2goLyhbMC05XSspbXMvKTtcbiAgICBpZiAobWF0Y2gpXG4gICAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJvcmlnaW5cIikge1xuICAgIGlmIChbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJib3R0b21cIl0uaW5jbHVkZXMobW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXSkpIHtcbiAgICAgIHJldHVybiBbcmF3VmFsdWUsIG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMl1dLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3VmFsdWU7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9jbG9uZS5qc1xudmFyIGlzQ2xvbmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc2tpcER1cmluZ0Nsb25lKGNhbGxiYWNrLCBmYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBpc0Nsb25pbmcgPyBmYWxsYmFjayguLi5hcmdzKSA6IGNhbGxiYWNrKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gY2xvbmUob2xkRWwsIG5ld0VsKSB7XG4gIGlmICghbmV3RWwuX3hfZGF0YVN0YWNrKVxuICAgIG5ld0VsLl94X2RhdGFTdGFjayA9IG9sZEVsLl94X2RhdGFTdGFjaztcbiAgaXNDbG9uaW5nID0gdHJ1ZTtcbiAgZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cygoKSA9PiB7XG4gICAgY2xvbmVUcmVlKG5ld0VsKTtcbiAgfSk7XG4gIGlzQ2xvbmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2xvbmVUcmVlKGVsKSB7XG4gIGxldCBoYXNSdW5UaHJvdWdoRmlyc3RFbCA9IGZhbHNlO1xuICBsZXQgc2hhbGxvd1dhbGtlciA9IChlbDIsIGNhbGxiYWNrKSA9PiB7XG4gICAgd2FsayhlbDIsIChlbDMsIHNraXApID0+IHtcbiAgICAgIGlmIChoYXNSdW5UaHJvdWdoRmlyc3RFbCAmJiBpc1Jvb3QoZWwzKSlcbiAgICAgICAgcmV0dXJuIHNraXAoKTtcbiAgICAgIGhhc1J1blRocm91Z2hGaXJzdEVsID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVsMywgc2tpcCk7XG4gICAgfSk7XG4gIH07XG4gIGluaXRUcmVlKGVsLCBzaGFsbG93V2Fsa2VyKTtcbn1cbmZ1bmN0aW9uIGRvbnRSZWdpc3RlclJlYWN0aXZlU2lkZUVmZmVjdHMoY2FsbGJhY2spIHtcbiAgbGV0IGNhY2hlID0gZWZmZWN0O1xuICBvdmVycmlkZUVmZmVjdCgoY2FsbGJhY2syLCBlbCkgPT4ge1xuICAgIGxldCBzdG9yZWRFZmZlY3QgPSBjYWNoZShjYWxsYmFjazIpO1xuICAgIHJlbGVhc2Uoc3RvcmVkRWZmZWN0KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH0pO1xuICBjYWxsYmFjaygpO1xuICBvdmVycmlkZUVmZmVjdChjYWNoZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9iaW5kLmpzXG5mdW5jdGlvbiBiaW5kKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzID0gW10pIHtcbiAgaWYgKCFlbC5feF9iaW5kaW5ncylcbiAgICBlbC5feF9iaW5kaW5ncyA9IHJlYWN0aXZlKHt9KTtcbiAgZWwuX3hfYmluZGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgbmFtZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcImNhbWVsXCIpID8gY2FtZWxDYXNlKG5hbWUpIDogbmFtZTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBiaW5kU3R5bGVzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRJbnB1dFZhbHVlKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgaWYgKGVsLmF0dHJpYnV0ZXMudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5mcm9tTW9kZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbC52YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgIVtudWxsLCB2b2lkIDBdLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgZWwudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLnNvbWUoKHZhbCkgPT4gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsLCBlbC52YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgICB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWwudmFsdWUgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcylcbiAgICBlbC5feF91bmRvQWRkZWRDbGFzc2VzKCk7XG4gIGVsLl94X3VuZG9BZGRlZENsYXNzZXMgPSBzZXRDbGFzc2VzKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBiaW5kU3R5bGVzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkU3R5bGVzKVxuICAgIGVsLl94X3VuZG9BZGRlZFN0eWxlcygpO1xuICBlbC5feF91bmRvQWRkZWRTdHlsZXMgPSBzZXRTdHlsZXMoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJpbmRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChbbnVsbCwgdm9pZCAwLCBmYWxzZV0uaW5jbHVkZXModmFsdWUpICYmIGF0dHJpYnV0ZVNob3VsZG50QmVQcmVzZXJ2ZWRJZkZhbHN5KG5hbWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKG5hbWUpKVxuICAgICAgdmFsdWUgPSBuYW1lO1xuICAgIHNldElmQ2hhbmdlZChlbCwgbmFtZSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRJZkNoYW5nZWQoZWwsIGF0dHJOYW1lLCB2YWx1ZSkge1xuICBpZiAoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSAhPSB2YWx1ZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGFycmF5V3JhcHBlZFZhbHVlID0gW10uY29uY2F0KHZhbHVlKS5tYXAoKHZhbHVlMikgPT4ge1xuICAgIHJldHVybiB2YWx1ZTIgKyBcIlwiO1xuICB9KTtcbiAgQXJyYXkuZnJvbShlbC5vcHRpb25zKS5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICBvcHRpb24uc2VsZWN0ZWQgPSBhcnJheVdyYXBwZWRWYWx1ZS5pbmNsdWRlcyhvcHRpb24udmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNhbWVsQ2FzZShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShcXHcpL2csIChtYXRjaCwgY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbHVlQSwgdmFsdWVCKSB7XG4gIHJldHVybiB2YWx1ZUEgPT0gdmFsdWVCO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuQXR0cihhdHRyTmFtZSkge1xuICBjb25zdCBib29sZWFuQXR0cmlidXRlcyA9IFtcbiAgICBcImRpc2FibGVkXCIsXG4gICAgXCJjaGVja2VkXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwicmVhZG9ubHlcIixcbiAgICBcImhpZGRlblwiLFxuICAgIFwib3BlblwiLFxuICAgIFwic2VsZWN0ZWRcIixcbiAgICBcImF1dG9mb2N1c1wiLFxuICAgIFwiaXRlbXNjb3BlXCIsXG4gICAgXCJtdWx0aXBsZVwiLFxuICAgIFwibm92YWxpZGF0ZVwiLFxuICAgIFwiYWxsb3dmdWxsc2NyZWVuXCIsXG4gICAgXCJhbGxvd3BheW1lbnRyZXF1ZXN0XCIsXG4gICAgXCJmb3Jtbm92YWxpZGF0ZVwiLFxuICAgIFwiYXV0b3BsYXlcIixcbiAgICBcImNvbnRyb2xzXCIsXG4gICAgXCJsb29wXCIsXG4gICAgXCJtdXRlZFwiLFxuICAgIFwicGxheXNpbmxpbmVcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImlzbWFwXCIsXG4gICAgXCJyZXZlcnNlZFwiLFxuICAgIFwiYXN5bmNcIixcbiAgICBcImRlZmVyXCIsXG4gICAgXCJub21vZHVsZVwiXG4gIF07XG4gIHJldHVybiBib29sZWFuQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyTmFtZSk7XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVTaG91bGRudEJlUHJlc2VydmVkSWZGYWxzeShuYW1lKSB7XG4gIHJldHVybiAhW1wiYXJpYS1wcmVzc2VkXCIsIFwiYXJpYS1jaGVja2VkXCIsIFwiYXJpYS1leHBhbmRlZFwiLCBcImFyaWEtc2VsZWN0ZWRcIl0uaW5jbHVkZXMobmFtZSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nKGVsLCBuYW1lLCBmYWxsYmFjaykge1xuICBpZiAoZWwuX3hfYmluZGluZ3MgJiYgZWwuX3hfYmluZGluZ3NbbmFtZV0gIT09IHZvaWQgMClcbiAgICByZXR1cm4gZWwuX3hfYmluZGluZ3NbbmFtZV07XG4gIGxldCBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAoYXR0ciA9PT0gbnVsbClcbiAgICByZXR1cm4gdHlwZW9mIGZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKG5hbWUpKSB7XG4gICAgcmV0dXJuICEhW25hbWUsIFwidHJ1ZVwiXS5pbmNsdWRlcyhhdHRyKTtcbiAgfVxuICBpZiAoYXR0ciA9PT0gXCJcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGF0dHI7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9kZWJvdW5jZS5qc1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy90aHJvdHRsZS5qc1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgbGltaXQpIHtcbiAgbGV0IGluVGhyb3R0bGU7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKCFpblRocm90dGxlKSB7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaW5UaHJvdHRsZSA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGluVGhyb3R0bGUgPSBmYWxzZSwgbGltaXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3BsdWdpbi5qc1xuZnVuY3Rpb24gcGx1Z2luKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKGFscGluZV9kZWZhdWx0KTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3N0b3JlLmpzXG52YXIgc3RvcmVzID0ge307XG52YXIgaXNSZWFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gc3RvcmUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc1JlYWN0aXZlKSB7XG4gICAgc3RvcmVzID0gcmVhY3RpdmUoc3RvcmVzKTtcbiAgICBpc1JlYWN0aXZlID0gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzdG9yZXNbbmFtZV07XG4gIH1cbiAgc3RvcmVzW25hbWVdID0gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpICYmIHR5cGVvZiB2YWx1ZS5pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdG9yZXNbbmFtZV0uaW5pdCgpO1xuICB9XG4gIGluaXRJbnRlcmNlcHRvcnMoc3RvcmVzW25hbWVdKTtcbn1cbmZ1bmN0aW9uIGdldFN0b3JlcygpIHtcbiAgcmV0dXJuIHN0b3Jlcztcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2JpbmRzLmpzXG52YXIgYmluZHMgPSB7fTtcbmZ1bmN0aW9uIGJpbmQyKG5hbWUsIG9iamVjdCkge1xuICBiaW5kc1tuYW1lXSA9IHR5cGVvZiBvYmplY3QgIT09IFwiZnVuY3Rpb25cIiA/ICgpID0+IG9iamVjdCA6IG9iamVjdDtcbn1cbmZ1bmN0aW9uIGluamVjdEJpbmRpbmdQcm92aWRlcnMob2JqKSB7XG4gIE9iamVjdC5lbnRyaWVzKGJpbmRzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGF0YXMuanNcbnZhciBkYXRhcyA9IHt9O1xuZnVuY3Rpb24gZGF0YShuYW1lLCBjYWxsYmFjaykge1xuICBkYXRhc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0RGF0YVByb3ZpZGVycyhvYmosIGNvbnRleHQpIHtcbiAgT2JqZWN0LmVudHJpZXMoZGF0YXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKGNvbnRleHQpKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYWxwaW5lLmpzXG52YXIgQWxwaW5lID0ge1xuICBnZXQgcmVhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlO1xuICB9LFxuICBnZXQgcmVsZWFzZSgpIHtcbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfSxcbiAgZ2V0IGVmZmVjdCgpIHtcbiAgICByZXR1cm4gZWZmZWN0O1xuICB9LFxuICBnZXQgcmF3KCkge1xuICAgIHJldHVybiByYXc7XG4gIH0sXG4gIHZlcnNpb246IFwiMy45LjBcIixcbiAgZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zLFxuICBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyxcbiAgc2V0UmVhY3Rpdml0eUVuZ2luZSxcbiAgY2xvc2VzdERhdGFTdGFjayxcbiAgc2tpcER1cmluZ0Nsb25lLFxuICBhZGRSb290U2VsZWN0b3IsXG4gIGFkZEluaXRTZWxlY3RvcixcbiAgYWRkU2NvcGVUb05vZGUsXG4gIGRlZmVyTXV0YXRpb25zLFxuICBtYXBBdHRyaWJ1dGVzLFxuICBldmFsdWF0ZUxhdGVyLFxuICBzZXRFdmFsdWF0b3IsXG4gIG1lcmdlUHJveGllcyxcbiAgZmluZENsb3Nlc3QsXG4gIGNsb3Nlc3RSb290LFxuICBpbnRlcmNlcHRvcixcbiAgdHJhbnNpdGlvbixcbiAgc2V0U3R5bGVzLFxuICBtdXRhdGVEb20sXG4gIGRpcmVjdGl2ZSxcbiAgdGhyb3R0bGUsXG4gIGRlYm91bmNlLFxuICBldmFsdWF0ZSxcbiAgaW5pdFRyZWUsXG4gIG5leHRUaWNrLFxuICBwcmVmaXhlZDogcHJlZml4LFxuICBwcmVmaXg6IHNldFByZWZpeCxcbiAgcGx1Z2luLFxuICBtYWdpYyxcbiAgc3RvcmUsXG4gIHN0YXJ0LFxuICBjbG9uZSxcbiAgYm91bmQ6IGdldEJpbmRpbmcsXG4gICRkYXRhOiBzY29wZSxcbiAgZGF0YSxcbiAgYmluZDogYmluZDJcbn07XG52YXIgYWxwaW5lX2RlZmF1bHQgPSBBbHBpbmU7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xudmFyIGltcG9ydF9yZWFjdGl2aXR5OSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9yZWFjdGl2aXR5KCkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRuZXh0VGljay5qc1xubWFnaWMoXCJuZXh0VGlja1wiLCAoKSA9PiBuZXh0VGljayk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRpc3BhdGNoLmpzXG5tYWdpYyhcImRpc3BhdGNoXCIsIChlbCkgPT4gZGlzcGF0Y2guYmluZChkaXNwYXRjaCwgZWwpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kd2F0Y2guanNcbm1hZ2ljKFwid2F0Y2hcIiwgKGVsKSA9PiAoa2V5LCBjYWxsYmFjaykgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwga2V5KTtcbiAgbGV0IGZpcnN0VGltZSA9IHRydWU7XG4gIGxldCBvbGRWYWx1ZTtcbiAgZWZmZWN0KCgpID0+IGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmaXJzdFRpbWUpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHN0b3JlLmpzXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRhdGEuanNcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHNjb3BlKGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJvb3QuanNcbm1hZ2ljKFwicm9vdFwiLCAoZWwpID0+IGNsb3Nlc3RSb290KGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJlZnMuanNcbm1hZ2ljKFwicmVmc1wiLCAoZWwpID0+IHtcbiAgaWYgKGVsLl94X3JlZnNfcHJveHkpXG4gICAgcmV0dXJuIGVsLl94X3JlZnNfcHJveHk7XG4gIGVsLl94X3JlZnNfcHJveHkgPSBtZXJnZVByb3hpZXMoZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkpO1xuICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbn0pO1xuZnVuY3Rpb24gZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkge1xuICBsZXQgcmVmT2JqZWN0cyA9IFtdO1xuICBsZXQgY3VycmVudEVsID0gZWw7XG4gIHdoaWxlIChjdXJyZW50RWwpIHtcbiAgICBpZiAoY3VycmVudEVsLl94X3JlZnMpXG4gICAgICByZWZPYmplY3RzLnB1c2goY3VycmVudEVsLl94X3JlZnMpO1xuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiByZWZPYmplY3RzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaWRzLmpzXG52YXIgZ2xvYmFsSWRNZW1vID0ge307XG5mdW5jdGlvbiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSkge1xuICBpZiAoIWdsb2JhbElkTWVtb1tuYW1lXSlcbiAgICBnbG9iYWxJZE1lbW9bbmFtZV0gPSAwO1xuICByZXR1cm4gKytnbG9iYWxJZE1lbW9bbmFtZV07XG59XG5mdW5jdGlvbiBjbG9zZXN0SWRSb290KGVsLCBuYW1lKSB7XG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbCwgKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudC5feF9pZHMgJiYgZWxlbWVudC5feF9pZHNbbmFtZV0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRJZFJvb3QoZWwsIG5hbWUpIHtcbiAgaWYgKCFlbC5feF9pZHMpXG4gICAgZWwuX3hfaWRzID0ge307XG4gIGlmICghZWwuX3hfaWRzW25hbWVdKVxuICAgIGVsLl94X2lkc1tuYW1lXSA9IGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kaWQuanNcbm1hZ2ljKFwiaWRcIiwgKGVsKSA9PiAobmFtZSwga2V5ID0gbnVsbCkgPT4ge1xuICBsZXQgcm9vdCA9IGNsb3Nlc3RJZFJvb3QoZWwsIG5hbWUpO1xuICBsZXQgaWQgPSByb290ID8gcm9vdC5feF9pZHNbbmFtZV0gOiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSk7XG4gIHJldHVybiBrZXkgPyBgJHtuYW1lfS0ke2lkfS0ke2tleX1gIDogYCR7bmFtZX0tJHtpZH1gO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGVsLmpzXG5tYWdpYyhcImVsXCIsIChlbCkgPT4gZWwpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LW1vZGVsYWJsZS5qc1xuZGlyZWN0aXZlKFwibW9kZWxhYmxlXCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzLCBldmFsdWF0ZTogZXZhbHVhdGUyLCBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMn0pID0+IHtcbiAgbGV0IGZ1bmMgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcbiAgbGV0IGlubmVyR2V0ID0gKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZnVuYygoaSkgPT4gcmVzdWx0ID0gaSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbGV0IGV2YWx1YXRlSW5uZXJTZXQgPSBldmFsdWF0ZUxhdGVyMihgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgbGV0IGlubmVyU2V0ID0gKHZhbCkgPT4gZXZhbHVhdGVJbm5lclNldCgoKSA9PiB7XG4gIH0sIHtzY29wZToge19fcGxhY2Vob2xkZXI6IHZhbH19KTtcbiAgbGV0IGluaXRpYWxWYWx1ZSA9IGlubmVyR2V0KCk7XG4gIGlmIChlbC5feF9tb2RlbGFibGVfaG9vaylcbiAgICBpbml0aWFsVmFsdWUgPSBlbC5feF9tb2RlbGFibGVfaG9vayhpbml0aWFsVmFsdWUpO1xuICBpbm5lclNldChpbml0aWFsVmFsdWUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaWYgKCFlbC5feF9tb2RlbClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgb3V0ZXJHZXQgPSBlbC5feF9tb2RlbC5nZXQ7XG4gICAgbGV0IG91dGVyU2V0ID0gZWwuX3hfbW9kZWwuc2V0O1xuICAgIGVmZmVjdDMoKCkgPT4gaW5uZXJTZXQob3V0ZXJHZXQoKSkpO1xuICAgIGVmZmVjdDMoKCkgPT4gb3V0ZXJTZXQoaW5uZXJHZXQoKSkpO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRlbGVwb3J0LmpzXG5kaXJlY3RpdmUoXCJ0ZWxlcG9ydFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2NsZWFudXB9KSA9PiB7XG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwidGVtcGxhdGVcIilcbiAgICB3YXJuKFwieC10ZWxlcG9ydCBjYW4gb25seSBiZSB1c2VkIG9uIGEgPHRlbXBsYXRlPiB0YWdcIiwgZWwpO1xuICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihleHByZXNzaW9uKTtcbiAgaWYgKCF0YXJnZXQpXG4gICAgd2FybihgQ2Fubm90IGZpbmQgeC10ZWxlcG9ydCBlbGVtZW50IGZvciBzZWxlY3RvcjogXCIke2V4cHJlc3Npb259XCJgKTtcbiAgbGV0IGNsb25lMiA9IGVsLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICBlbC5feF90ZWxlcG9ydCA9IGNsb25lMjtcbiAgY2xvbmUyLl94X3RlbGVwb3J0QmFjayA9IGVsO1xuICBpZiAoZWwuX3hfZm9yd2FyZEV2ZW50cykge1xuICAgIGVsLl94X2ZvcndhcmRFdmVudHMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICBjbG9uZTIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IGUuY29uc3RydWN0b3IoZS50eXBlLCBlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhZGRTY29wZVRvTm9kZShjbG9uZTIsIHt9LCBlbCk7XG4gIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGNsb25lMik7XG4gICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICBjbG9uZTIuX3hfaWdub3JlID0gdHJ1ZTtcbiAgfSk7XG4gIGNsZWFudXAoKCkgPT4gY2xvbmUyLnJlbW92ZSgpKTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlnbm9yZS5qc1xudmFyIGhhbmRsZXIgPSAoKSA9PiB7XG59O1xuaGFuZGxlci5pbmxpbmUgPSAoZWwsIHttb2RpZmllcnN9LCB7Y2xlYW51cH0pID0+IHtcbiAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGVsLl94X2lnbm9yZVNlbGYgPSB0cnVlIDogZWwuX3hfaWdub3JlID0gdHJ1ZTtcbiAgY2xlYW51cCgoKSA9PiB7XG4gICAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGRlbGV0ZSBlbC5feF9pZ25vcmVTZWxmIDogZGVsZXRlIGVsLl94X2lnbm9yZTtcbiAgfSk7XG59O1xuZGlyZWN0aXZlKFwiaWdub3JlXCIsIGhhbmRsZXIpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWVmZmVjdC5qc1xuZGlyZWN0aXZlKFwiZWZmZWN0XCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4gZWZmZWN0MyhldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvb24uanNcbmZ1bmN0aW9uIG9uKGVsLCBldmVudCwgbW9kaWZpZXJzLCBjYWxsYmFjaykge1xuICBsZXQgbGlzdGVuZXJUYXJnZXQgPSBlbDtcbiAgbGV0IGhhbmRsZXIzID0gKGUpID0+IGNhbGxiYWNrKGUpO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBsZXQgd3JhcEhhbmRsZXIgPSAoY2FsbGJhY2syLCB3cmFwcGVyKSA9PiAoZSkgPT4gd3JhcHBlcihjYWxsYmFjazIsIGUpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZG90XCIpKVxuICAgIGV2ZW50ID0gZG90U3ludGF4KGV2ZW50KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImNhbWVsXCIpKVxuICAgIGV2ZW50ID0gY2FtZWxDYXNlMihldmVudCk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJwYXNzaXZlXCIpKVxuICAgIG9wdGlvbnMucGFzc2l2ZSA9IHRydWU7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJjYXB0dXJlXCIpKVxuICAgIG9wdGlvbnMuY2FwdHVyZSA9IHRydWU7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJ3aW5kb3dcIikpXG4gICAgbGlzdGVuZXJUYXJnZXQgPSB3aW5kb3c7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkb2N1bWVudFwiKSlcbiAgICBsaXN0ZW5lclRhcmdldCA9IGRvY3VtZW50O1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwicHJldmVudFwiKSlcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInN0b3BcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSlcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgZS50YXJnZXQgPT09IGVsICYmIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJhd2F5XCIpIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dHNpZGVcIikpIHtcbiAgICBsaXN0ZW5lclRhcmdldCA9IGRvY3VtZW50O1xuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBpZiAoZWwuY29udGFpbnMoZS50YXJnZXQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZWwub2Zmc2V0V2lkdGggPCAxICYmIGVsLm9mZnNldEhlaWdodCA8IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChlbC5feF9pc1Nob3duID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbmV4dChlKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgIGlmIChpc0tleUV2ZW50KGV2ZW50KSkge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5leHQoZSk7XG4gIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZGVib3VuY2VcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwiZGVib3VuY2VcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjMgPSBkZWJvdW5jZShoYW5kbGVyMywgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInRocm90dGxlXCIpKSB7XG4gICAgbGV0IG5leHRNb2RpZmllciA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihcInRocm90dGxlXCIpICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIjtcbiAgICBsZXQgd2FpdCA9IGlzTnVtZXJpYyhuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgPyBOdW1iZXIobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pIDogMjUwO1xuICAgIGhhbmRsZXIzID0gdGhyb3R0bGUoaGFuZGxlcjMsIHdhaXQpO1xuICB9XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJvbmNlXCIpKSB7XG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIG5leHQoZSk7XG4gICAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcjMsIG9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvdFN5bnRheChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLy0vZywgXCIuXCIpO1xufVxuZnVuY3Rpb24gY2FtZWxDYXNlMihzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShcXHcpL2csIChtYXRjaCwgY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYyhzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5mdW5jdGlvbiBrZWJhYkNhc2UyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS5yZXBsYWNlKC9bX1xcc10vLCBcIi1cIikudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGlzS2V5RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIFtcImtleWRvd25cIiwgXCJrZXl1cFwiXS5pbmNsdWRlcyhldmVudCk7XG59XG5mdW5jdGlvbiBpc0xpc3RlbmluZ0ZvckFTcGVjaWZpY0tleVRoYXRIYXNudEJlZW5QcmVzc2VkKGUsIG1vZGlmaWVycykge1xuICBsZXQga2V5TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSkgPT4ge1xuICAgIHJldHVybiAhW1wid2luZG93XCIsIFwiZG9jdW1lbnRcIiwgXCJwcmV2ZW50XCIsIFwic3RvcFwiLCBcIm9uY2VcIl0uaW5jbHVkZXMoaSk7XG4gIH0pO1xuICBpZiAoa2V5TW9kaWZpZXJzLmluY2x1ZGVzKFwiZGVib3VuY2VcIikpIHtcbiAgICBsZXQgZGVib3VuY2VJbmRleCA9IGtleU1vZGlmaWVycy5pbmRleE9mKFwiZGVib3VuY2VcIik7XG4gICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIikuc3BsaXQoXCJtc1wiKVswXSkgPyAyIDogMSk7XG4gIH1cbiAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBrZXlUb01vZGlmaWVycyhlLmtleSkuaW5jbHVkZXMoa2V5TW9kaWZpZXJzWzBdKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHN5c3RlbUtleU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIiwgXCJjbWRcIiwgXCJzdXBlclwiXTtcbiAgY29uc3Qgc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMgPSBzeXN0ZW1LZXlNb2RpZmllcnMuZmlsdGVyKChtb2RpZmllcikgPT4ga2V5TW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSk7XG4gIGtleU1vZGlmaWVycyA9IGtleU1vZGlmaWVycy5maWx0ZXIoKGkpID0+ICFzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5pbmNsdWRlcyhpKSk7XG4gIGlmIChzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzID0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuZmlsdGVyKChtb2RpZmllcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBcImNtZFwiIHx8IG1vZGlmaWVyID09PSBcInN1cGVyXCIpXG4gICAgICAgIG1vZGlmaWVyID0gXCJtZXRhXCI7XG4gICAgICByZXR1cm4gZVtgJHttb2RpZmllcn1LZXlgXTtcbiAgICB9KTtcbiAgICBpZiAoYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICBpZiAoa2V5VG9Nb2RpZmllcnMoZS5rZXkpLmluY2x1ZGVzKGtleU1vZGlmaWVyc1swXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBrZXlUb01vZGlmaWVycyhrZXkpIHtcbiAgaWYgKCFrZXkpXG4gICAgcmV0dXJuIFtdO1xuICBrZXkgPSBrZWJhYkNhc2UyKGtleSk7XG4gIGxldCBtb2RpZmllclRvS2V5TWFwID0ge1xuICAgIGN0cmw6IFwiY29udHJvbFwiLFxuICAgIHNsYXNoOiBcIi9cIixcbiAgICBzcGFjZTogXCItXCIsXG4gICAgc3BhY2ViYXI6IFwiLVwiLFxuICAgIGNtZDogXCJtZXRhXCIsXG4gICAgZXNjOiBcImVzY2FwZVwiLFxuICAgIHVwOiBcImFycm93LXVwXCIsXG4gICAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gICAgbGVmdDogXCJhcnJvdy1sZWZ0XCIsXG4gICAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgICBwZXJpb2Q6IFwiLlwiLFxuICAgIGVxdWFsOiBcIj1cIlxuICB9O1xuICBtb2RpZmllclRvS2V5TWFwW2tleV0gPSBrZXk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtb2RpZmllclRvS2V5TWFwKS5tYXAoKG1vZGlmaWVyKSA9PiB7XG4gICAgaWYgKG1vZGlmaWVyVG9LZXlNYXBbbW9kaWZpZXJdID09PSBrZXkpXG4gICAgICByZXR1cm4gbW9kaWZpZXI7XG4gIH0pLmZpbHRlcigobW9kaWZpZXIpID0+IG1vZGlmaWVyKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1tb2RlbC5qc1xuZGlyZWN0aXZlKFwibW9kZWxcIiwgKGVsLCB7bW9kaWZpZXJzLCBleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgY2xlYW51cH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgYXNzaWdubWVudEV4cHJlc3Npb24gPSBgJHtleHByZXNzaW9ufSA9IHJpZ2h0U2lkZU9mRXhwcmVzc2lvbigkZXZlbnQsICR7ZXhwcmVzc2lvbn0pYDtcbiAgbGV0IGV2YWx1YXRlQXNzaWdubWVudCA9IGV2YWx1YXRlTGF0ZXIoZWwsIGFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgdmFyIGV2ZW50ID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiIHx8IFtcImNoZWNrYm94XCIsIFwicmFkaW9cIl0uaW5jbHVkZXMoZWwudHlwZSkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwibGF6eVwiKSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCI7XG4gIGxldCBhc3NpZ21lbnRGdW5jdGlvbiA9IGdlbmVyYXRlQXNzaWdubWVudEZ1bmN0aW9uKGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24pO1xuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBvbihlbCwgZXZlbnQsIG1vZGlmaWVycywgKGUpID0+IHtcbiAgICBldmFsdWF0ZUFzc2lnbm1lbnQoKCkgPT4ge1xuICAgIH0sIHtzY29wZToge1xuICAgICAgJGV2ZW50OiBlLFxuICAgICAgcmlnaHRTaWRlT2ZFeHByZXNzaW9uOiBhc3NpZ21lbnRGdW5jdGlvblxuICAgIH19KTtcbiAgfSk7XG4gIGNsZWFudXAoKCkgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG4gIGxldCBldmFsdWF0ZVNldE1vZGVsID0gZXZhbHVhdGVMYXRlcihlbCwgYCR7ZXhwcmVzc2lvbn0gPSBfX3BsYWNlaG9sZGVyYCk7XG4gIGVsLl94X21vZGVsID0ge1xuICAgIGdldCgpIHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiByZXN1bHQgPSB2YWx1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBldmFsdWF0ZVNldE1vZGVsKCgpID0+IHtcbiAgICAgIH0sIHtzY29wZToge19fcGxhY2Vob2xkZXI6IHZhbHVlfX0pO1xuICAgIH1cbiAgfTtcbiAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSA9ICgpID0+IHtcbiAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiBleHByZXNzaW9uLm1hdGNoKC9cXC4vKSlcbiAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgd2luZG93LmZyb21Nb2RlbCA9IHRydWU7XG4gICAgICBtdXRhdGVEb20oKCkgPT4gYmluZChlbCwgXCJ2YWx1ZVwiLCB2YWx1ZSkpO1xuICAgICAgZGVsZXRlIHdpbmRvdy5mcm9tTW9kZWw7XG4gICAgfSk7XG4gIH07XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJ1bmludHJ1c2l2ZVwiKSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZWwpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLl94X2ZvcmNlTW9kZWxVcGRhdGUoKTtcbiAgfSk7XG59KTtcbmZ1bmN0aW9uIGdlbmVyYXRlQXNzaWdubWVudEZ1bmN0aW9uKGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24pIHtcbiAgaWYgKGVsLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZShcIm5hbWVcIikpXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgZXhwcmVzc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChldmVudCwgY3VycmVudFZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBDdXN0b21FdmVudCAmJiBldmVudC5kZXRhaWwgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikgPyBzYWZlUGFyc2VOdW1iZXIoZXZlbnQudGFyZ2V0LnZhbHVlKSA6IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBjdXJyZW50VmFsdWUuY29uY2F0KFtuZXdWYWx1ZV0pIDogY3VycmVudFZhbHVlLmZpbHRlcigoZWwyKSA9PiAhY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUyKGVsMiwgbmV3VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiICYmIGVsLm11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikgPyBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgbGV0IHJhd1ZhbHVlID0gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICAgIHJldHVybiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpO1xuICAgICAgICB9KSA6IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByYXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSkgOiBtb2RpZmllcnMuaW5jbHVkZXMoXCJ0cmltXCIpID8gcmF3VmFsdWUudHJpbSgpIDogcmF3VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIHtcbiAgbGV0IG51bWJlciA9IHJhd1ZhbHVlID8gcGFyc2VGbG9hdChyYXdWYWx1ZSkgOiBudWxsO1xuICByZXR1cm4gaXNOdW1lcmljMihudW1iZXIpID8gbnVtYmVyIDogcmF3VmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZTIodmFsdWVBLCB2YWx1ZUIpIHtcbiAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XG59XG5mdW5jdGlvbiBpc051bWVyaWMyKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1jbG9hay5qc1xuZGlyZWN0aXZlKFwiY2xvYWtcIiwgKGVsKSA9PiBxdWV1ZU1pY3JvdGFzaygoKSA9PiBtdXRhdGVEb20oKCkgPT4gZWwucmVtb3ZlQXR0cmlidXRlKHByZWZpeChcImNsb2FrXCIpKSkpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pbml0LmpzXG5hZGRJbml0U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImluaXRcIil9XWApO1xuZGlyZWN0aXZlKFwiaW5pdFwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7ZXhwcmVzc2lvbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICEhZXhwcmVzc2lvbi50cmltKCkgJiYgZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGV2YWx1YXRlKGVsLCBleHByZXNzaW9uLCB7fSwgZmFsc2UpO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRleHQuanNcbmRpcmVjdGl2ZShcInRleHRcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1odG1sLmpzXG5kaXJlY3RpdmUoXCJodG1sXCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzLCBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMn0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGV4cHJlc3Npb24pO1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgICBlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1iaW5kLmpzXG5tYXBBdHRyaWJ1dGVzKHN0YXJ0aW5nV2l0aChcIjpcIiwgaW50byhwcmVmaXgoXCJiaW5kOlwiKSkpKTtcbmRpcmVjdGl2ZShcImJpbmRcIiwgKGVsLCB7dmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgb3JpZ2luYWx9LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4ge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGV4cHJlc3Npb24sIG9yaWdpbmFsLCBlZmZlY3QzKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwia2V5XCIpXG4gICAgcmV0dXJuIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHJlc3VsdCkgPT4ge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCAmJiBleHByZXNzaW9uLm1hdGNoKC9cXC4vKSlcbiAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgbXV0YXRlRG9tKCgpID0+IGJpbmQoZWwsIHZhbHVlLCByZXN1bHQsIG1vZGlmaWVycykpO1xuICB9KSk7XG59KTtcbmZ1bmN0aW9uIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGV4cHJlc3Npb24sIG9yaWdpbmFsLCBlZmZlY3QzKSB7XG4gIGxldCBiaW5kaW5nUHJvdmlkZXJzID0ge307XG4gIGluamVjdEJpbmRpbmdQcm92aWRlcnMoYmluZGluZ1Byb3ZpZGVycyk7XG4gIGxldCBnZXRCaW5kaW5ncyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgY2xlYW51cFJ1bm5lcnMgPSBbXTtcbiAgd2hpbGUgKGNsZWFudXBSdW5uZXJzLmxlbmd0aClcbiAgICBjbGVhbnVwUnVubmVycy5wb3AoKSgpO1xuICBnZXRCaW5kaW5ncygoYmluZGluZ3MpID0+IHtcbiAgICBsZXQgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGJpbmRpbmdzKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7bmFtZSwgdmFsdWV9KSk7XG4gICAgbGV0IHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBgeC1iaW5kOiR7YXR0cmlidXRlLm5hbWV9YCxcbiAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuICAgIGRpcmVjdGl2ZXMoZWwsIGF0dHJpYnV0ZXMsIG9yaWdpbmFsKS5tYXAoKGhhbmRsZSkgPT4ge1xuICAgICAgY2xlYW51cFJ1bm5lcnMucHVzaChoYW5kbGUucnVuQ2xlYW51cHMpO1xuICAgICAgaGFuZGxlKCk7XG4gICAgfSk7XG4gIH0sIHtzY29wZTogYmluZGluZ1Byb3ZpZGVyc30pO1xufVxuZnVuY3Rpb24gc3RvcmVLZXlGb3JYRm9yKGVsLCBleHByZXNzaW9uKSB7XG4gIGVsLl94X2tleUV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWRhdGEuanNcbmFkZFJvb3RTZWxlY3RvcigoKSA9PiBgWyR7cHJlZml4KFwiZGF0YVwiKX1dYCk7XG5kaXJlY3RpdmUoXCJkYXRhXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHtleHByZXNzaW9ufSwge2NsZWFudXB9KSA9PiB7XG4gIGV4cHJlc3Npb24gPSBleHByZXNzaW9uID09PSBcIlwiID8gXCJ7fVwiIDogZXhwcmVzc2lvbjtcbiAgbGV0IG1hZ2ljQ29udGV4dCA9IHt9O1xuICBpbmplY3RNYWdpY3MobWFnaWNDb250ZXh0LCBlbCk7XG4gIGxldCBkYXRhUHJvdmlkZXJDb250ZXh0ID0ge307XG4gIGluamVjdERhdGFQcm92aWRlcnMoZGF0YVByb3ZpZGVyQ29udGV4dCwgbWFnaWNDb250ZXh0KTtcbiAgbGV0IGRhdGEyID0gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIHtzY29wZTogZGF0YVByb3ZpZGVyQ29udGV4dH0pO1xuICBpZiAoZGF0YTIgPT09IHZvaWQgMClcbiAgICBkYXRhMiA9IHt9O1xuICBpbmplY3RNYWdpY3MoZGF0YTIsIGVsKTtcbiAgbGV0IHJlYWN0aXZlRGF0YSA9IHJlYWN0aXZlKGRhdGEyKTtcbiAgaW5pdEludGVyY2VwdG9ycyhyZWFjdGl2ZURhdGEpO1xuICBsZXQgdW5kbyA9IGFkZFNjb3BlVG9Ob2RlKGVsLCByZWFjdGl2ZURhdGEpO1xuICByZWFjdGl2ZURhdGFbXCJpbml0XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJpbml0XCJdKTtcbiAgY2xlYW51cCgoKSA9PiB7XG4gICAgdW5kbygpO1xuICAgIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0gJiYgZXZhbHVhdGUoZWwsIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0pO1xuICB9KTtcbn0pKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1zaG93LmpzXG5kaXJlY3RpdmUoXCJzaG93XCIsIChlbCwge21vZGlmaWVycywgZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDN9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgbGV0IGhpZGUgPSAoKSA9PiBtdXRhdGVEb20oKCkgPT4ge1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBlbC5feF9pc1Nob3duID0gZmFsc2U7XG4gIH0pO1xuICBsZXQgc2hvdyA9ICgpID0+IG11dGF0ZURvbSgoKSA9PiB7XG4gICAgaWYgKGVsLnN0eWxlLmxlbmd0aCA9PT0gMSAmJiBlbC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG4gICAgZWwuX3hfaXNTaG93biA9IHRydWU7XG4gIH0pO1xuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBzZXRUaW1lb3V0KHNob3cpO1xuICBsZXQgdG9nZ2xlID0gb25jZSgodmFsdWUpID0+IHZhbHVlID8gc2hvdygpIDogaGlkZSgpLCAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZWwuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyhlbCwgdmFsdWUsIHNob3csIGhpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IG9sZFZhbHVlO1xuICBsZXQgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFmaXJzdFRpbWUgJiYgdmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpbW1lZGlhdGVcIikpXG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgdG9nZ2xlKHZhbHVlKTtcbiAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9KSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1mb3IuanNcbmRpcmVjdGl2ZShcImZvclwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgY2xlYW51cH0pID0+IHtcbiAgbGV0IGl0ZXJhdG9yTmFtZXMgPSBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gIGxldCBldmFsdWF0ZUl0ZW1zID0gZXZhbHVhdGVMYXRlcihlbCwgaXRlcmF0b3JOYW1lcy5pdGVtcyk7XG4gIGxldCBldmFsdWF0ZUtleSA9IGV2YWx1YXRlTGF0ZXIoZWwsIGVsLl94X2tleUV4cHJlc3Npb24gfHwgXCJpbmRleFwiKTtcbiAgZWwuX3hfcHJldktleXMgPSBbXTtcbiAgZWwuX3hfbG9va3VwID0ge307XG4gIGVmZmVjdDMoKCkgPT4gbG9vcChlbCwgaXRlcmF0b3JOYW1lcywgZXZhbHVhdGVJdGVtcywgZXZhbHVhdGVLZXkpKTtcbiAgY2xlYW51cCgoKSA9PiB7XG4gICAgT2JqZWN0LnZhbHVlcyhlbC5feF9sb29rdXApLmZvckVhY2goKGVsMikgPT4gZWwyLnJlbW92ZSgpKTtcbiAgICBkZWxldGUgZWwuX3hfcHJldktleXM7XG4gICAgZGVsZXRlIGVsLl94X2xvb2t1cDtcbiAgfSk7XG59KTtcbmZ1bmN0aW9uIGxvb3AoZWwsIGl0ZXJhdG9yTmFtZXMsIGV2YWx1YXRlSXRlbXMsIGV2YWx1YXRlS2V5KSB7XG4gIGxldCBpc09iamVjdCA9IChpKSA9PiB0eXBlb2YgaSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpKTtcbiAgbGV0IHRlbXBsYXRlRWwgPSBlbDtcbiAgZXZhbHVhdGVJdGVtcygoaXRlbXMpID0+IHtcbiAgICBpZiAoaXNOdW1lcmljMyhpdGVtcykgJiYgaXRlbXMgPj0gMCkge1xuICAgICAgaXRlbXMgPSBBcnJheS5mcm9tKEFycmF5KGl0ZW1zKS5rZXlzKCksIChpKSA9PiBpICsgMSk7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKVxuICAgICAgaXRlbXMgPSBbXTtcbiAgICBsZXQgbG9va3VwID0gZWwuX3hfbG9va3VwO1xuICAgIGxldCBwcmV2S2V5cyA9IGVsLl94X3ByZXZLZXlzO1xuICAgIGxldCBzY29wZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGlmIChpc09iamVjdChpdGVtcykpIHtcbiAgICAgIGl0ZW1zID0gT2JqZWN0LmVudHJpZXMoaXRlbXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxldCBzY29wZTIgPSBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCB2YWx1ZSwga2V5LCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZTIpID0+IGtleXMucHVzaCh2YWx1ZTIpLCB7c2NvcGU6IHtpbmRleDoga2V5LCAuLi5zY29wZTJ9fSk7XG4gICAgICAgIHNjb3Blcy5wdXNoKHNjb3BlMik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2NvcGUyID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbXNbaV0sIGksIGl0ZW1zKTtcbiAgICAgICAgZXZhbHVhdGVLZXkoKHZhbHVlKSA9PiBrZXlzLnB1c2godmFsdWUpLCB7c2NvcGU6IHtpbmRleDogaSwgLi4uc2NvcGUyfX0pO1xuICAgICAgICBzY29wZXMucHVzaChzY29wZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYWRkcyA9IFtdO1xuICAgIGxldCBtb3ZlcyA9IFtdO1xuICAgIGxldCByZW1vdmVzID0gW107XG4gICAgbGV0IHNhbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtleSA9IHByZXZLZXlzW2ldO1xuICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXkpID09PSAtMSlcbiAgICAgICAgcmVtb3Zlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHByZXZLZXlzID0gcHJldktleXMuZmlsdGVyKChrZXkpID0+ICFyZW1vdmVzLmluY2x1ZGVzKGtleSkpO1xuICAgIGxldCBsYXN0S2V5ID0gXCJ0ZW1wbGF0ZVwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtleSA9IGtleXNbaV07XG4gICAgICBsZXQgcHJldkluZGV4ID0gcHJldktleXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcHJldktleXMuc3BsaWNlKGksIDAsIGtleSk7XG4gICAgICAgIGFkZHMucHVzaChbbGFzdEtleSwgaV0pO1xuICAgICAgfSBlbHNlIGlmIChwcmV2SW5kZXggIT09IGkpIHtcbiAgICAgICAgbGV0IGtleUluU3BvdCA9IHByZXZLZXlzLnNwbGljZShpLCAxKVswXTtcbiAgICAgICAgbGV0IGtleUZvclNwb3QgPSBwcmV2S2V5cy5zcGxpY2UocHJldkluZGV4IC0gMSwgMSlbMF07XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXlGb3JTcG90KTtcbiAgICAgICAgcHJldktleXMuc3BsaWNlKHByZXZJbmRleCwgMCwga2V5SW5TcG90KTtcbiAgICAgICAgbW92ZXMucHVzaChba2V5SW5TcG90LCBrZXlGb3JTcG90XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzYW1lcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgICBsYXN0S2V5ID0ga2V5O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSByZW1vdmVzW2ldO1xuICAgICAgaWYgKCEhbG9va3VwW2tleV0uX3hfZWZmZWN0cykge1xuICAgICAgICBsb29rdXBba2V5XS5feF9lZmZlY3RzLmZvckVhY2goZGVxdWV1ZUpvYik7XG4gICAgICB9XG4gICAgICBsb29rdXBba2V5XS5yZW1vdmUoKTtcbiAgICAgIGxvb2t1cFtrZXldID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBsb29rdXBba2V5XTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IFtrZXlJblNwb3QsIGtleUZvclNwb3RdID0gbW92ZXNbaV07XG4gICAgICBsZXQgZWxJblNwb3QgPSBsb29rdXBba2V5SW5TcG90XTtcbiAgICAgIGxldCBlbEZvclNwb3QgPSBsb29rdXBba2V5Rm9yU3BvdF07XG4gICAgICBsZXQgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsRm9yU3BvdC5hZnRlcihtYXJrZXIpO1xuICAgICAgICBlbEluU3BvdC5hZnRlcihlbEZvclNwb3QpO1xuICAgICAgICBlbEZvclNwb3QuX3hfY3VycmVudElmRWwgJiYgZWxGb3JTcG90LmFmdGVyKGVsRm9yU3BvdC5feF9jdXJyZW50SWZFbCk7XG4gICAgICAgIG1hcmtlci5iZWZvcmUoZWxJblNwb3QpO1xuICAgICAgICBlbEluU3BvdC5feF9jdXJyZW50SWZFbCAmJiBlbEluU3BvdC5hZnRlcihlbEluU3BvdC5feF9jdXJyZW50SWZFbCk7XG4gICAgICAgIG1hcmtlci5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgcmVmcmVzaFNjb3BlKGVsRm9yU3BvdCwgc2NvcGVzW2tleXMuaW5kZXhPZihrZXlGb3JTcG90KV0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBbbGFzdEtleTIsIGluZGV4XSA9IGFkZHNbaV07XG4gICAgICBsZXQgbGFzdEVsID0gbGFzdEtleTIgPT09IFwidGVtcGxhdGVcIiA/IHRlbXBsYXRlRWwgOiBsb29rdXBbbGFzdEtleTJdO1xuICAgICAgaWYgKGxhc3RFbC5feF9jdXJyZW50SWZFbClcbiAgICAgICAgbGFzdEVsID0gbGFzdEVsLl94X2N1cnJlbnRJZkVsO1xuICAgICAgbGV0IHNjb3BlMiA9IHNjb3Blc1tpbmRleF07XG4gICAgICBsZXQga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBsZXQgY2xvbmUyID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZUVsLmNvbnRlbnQsIHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCByZWFjdGl2ZShzY29wZTIpLCB0ZW1wbGF0ZUVsKTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGxhc3RFbC5hZnRlcihjbG9uZTIpO1xuICAgICAgICBpbml0VHJlZShjbG9uZTIpO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB3YXJuKFwieC1mb3Iga2V5IGNhbm5vdCBiZSBhbiBvYmplY3QsIGl0IG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gaW50ZWdlclwiLCB0ZW1wbGF0ZUVsKTtcbiAgICAgIH1cbiAgICAgIGxvb2t1cFtrZXldID0gY2xvbmUyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZWZyZXNoU2NvcGUobG9va3VwW3NhbWVzW2ldXSwgc2NvcGVzW2tleXMuaW5kZXhPZihzYW1lc1tpXSldKTtcbiAgICB9XG4gICAgdGVtcGxhdGVFbC5feF9wcmV2S2V5cyA9IGtleXM7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VGb3JFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgbGV0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG4gIGxldCBzdHJpcFBhcmVuc1JFID0gL15cXHMqXFwofFxcKVxccyokL2c7XG4gIGxldCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuICBsZXQgaW5NYXRjaCA9IGV4cHJlc3Npb24ubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaClcbiAgICByZXR1cm47XG4gIGxldCByZXMgPSB7fTtcbiAgcmVzLml0ZW1zID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIGxldCBpdGVtID0gaW5NYXRjaFsxXS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsIFwiXCIpLnRyaW0oKTtcbiAgbGV0IGl0ZXJhdG9yTWF0Y2ggPSBpdGVtLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5pdGVtID0gaXRlbS5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsIFwiXCIpLnRyaW0oKTtcbiAgICByZXMuaW5kZXggPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLmNvbGxlY3Rpb24gPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLml0ZW0gPSBpdGVtO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCBpdGVtLCBpbmRleCwgaXRlbXMpIHtcbiAgbGV0IHNjb3BlVmFyaWFibGVzID0ge307XG4gIGlmICgvXlxcWy4qXFxdJC8udGVzdChpdGVyYXRvck5hbWVzLml0ZW0pICYmIEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICBsZXQgbmFtZXMgPSBpdGVyYXRvck5hbWVzLml0ZW0ucmVwbGFjZShcIltcIiwgXCJcIikucmVwbGFjZShcIl1cIiwgXCJcIikuc3BsaXQoXCIsXCIpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgIG5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIHNjb3BlVmFyaWFibGVzW25hbWVdID0gaXRlbVtpXTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICgvXlxcey4qXFx9JC8udGVzdChpdGVyYXRvck5hbWVzLml0ZW0pICYmICFBcnJheS5pc0FycmF5KGl0ZW0pICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKSB7XG4gICAgbGV0IG5hbWVzID0gaXRlcmF0b3JOYW1lcy5pdGVtLnJlcGxhY2UoXCJ7XCIsIFwiXCIpLnJlcGxhY2UoXCJ9XCIsIFwiXCIpLnNwbGl0KFwiLFwiKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBzY29wZVZhcmlhYmxlc1tuYW1lXSA9IGl0ZW1bbmFtZV07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5pdGVtXSA9IGl0ZW07XG4gIH1cbiAgaWYgKGl0ZXJhdG9yTmFtZXMuaW5kZXgpXG4gICAgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5pbmRleF0gPSBpbmRleDtcbiAgaWYgKGl0ZXJhdG9yTmFtZXMuY29sbGVjdGlvbilcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb25dID0gaXRlbXM7XG4gIHJldHVybiBzY29wZVZhcmlhYmxlcztcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYzMoc3ViamVjdCkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXJlZi5qc1xuZnVuY3Rpb24gaGFuZGxlcjIoKSB7XG59XG5oYW5kbGVyMi5pbmxpbmUgPSAoZWwsIHtleHByZXNzaW9ufSwge2NsZWFudXB9KSA9PiB7XG4gIGxldCByb290ID0gY2xvc2VzdFJvb3QoZWwpO1xuICBpZiAoIXJvb3QuX3hfcmVmcylcbiAgICByb290Ll94X3JlZnMgPSB7fTtcbiAgcm9vdC5feF9yZWZzW2V4cHJlc3Npb25dID0gZWw7XG4gIGNsZWFudXAoKCkgPT4gZGVsZXRlIHJvb3QuX3hfcmVmc1tleHByZXNzaW9uXSk7XG59O1xuZGlyZWN0aXZlKFwicmVmXCIsIGhhbmRsZXIyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pZi5qc1xuZGlyZWN0aXZlKFwiaWZcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXB9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgbGV0IHNob3cgPSAoKSA9PiB7XG4gICAgaWYgKGVsLl94X2N1cnJlbnRJZkVsKVxuICAgICAgcmV0dXJuIGVsLl94X2N1cnJlbnRJZkVsO1xuICAgIGxldCBjbG9uZTIgPSBlbC5jb250ZW50LmNsb25lTm9kZSh0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICBhZGRTY29wZVRvTm9kZShjbG9uZTIsIHt9LCBlbCk7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGVsLmFmdGVyKGNsb25lMik7XG4gICAgICBpbml0VHJlZShjbG9uZTIpO1xuICAgIH0pO1xuICAgIGVsLl94X2N1cnJlbnRJZkVsID0gY2xvbmUyO1xuICAgIGVsLl94X3VuZG9JZiA9ICgpID0+IHtcbiAgICAgIHdhbGsoY2xvbmUyLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAoISFub2RlLl94X2VmZmVjdHMpIHtcbiAgICAgICAgICBub2RlLl94X2VmZmVjdHMuZm9yRWFjaChkZXF1ZXVlSm9iKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbG9uZTIucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgZWwuX3hfY3VycmVudElmRWw7XG4gICAgfTtcbiAgICByZXR1cm4gY2xvbmUyO1xuICB9O1xuICBsZXQgaGlkZSA9ICgpID0+IHtcbiAgICBpZiAoIWVsLl94X3VuZG9JZilcbiAgICAgIHJldHVybjtcbiAgICBlbC5feF91bmRvSWYoKTtcbiAgICBkZWxldGUgZWwuX3hfdW5kb0lmO1xuICB9O1xuICBlZmZlY3QzKCgpID0+IGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKTtcbiAgfSkpO1xuICBjbGVhbnVwKCgpID0+IGVsLl94X3VuZG9JZiAmJiBlbC5feF91bmRvSWYoKSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pZC5qc1xuZGlyZWN0aXZlKFwiaWRcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtldmFsdWF0ZTogZXZhbHVhdGUyfSkgPT4ge1xuICBsZXQgbmFtZXMgPSBldmFsdWF0ZTIoZXhwcmVzc2lvbik7XG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHNldElkUm9vdChlbCwgbmFtZSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtb24uanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiQFwiLCBpbnRvKHByZWZpeChcIm9uOlwiKSkpKTtcbmRpcmVjdGl2ZShcIm9uXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHt2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9ufSwge2NsZWFudXB9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBleHByZXNzaW9uID8gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikgOiAoKSA9PiB7XG4gIH07XG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIikge1xuICAgIGlmICghZWwuX3hfZm9yd2FyZEV2ZW50cylcbiAgICAgIGVsLl94X2ZvcndhcmRFdmVudHMgPSBbXTtcbiAgICBpZiAoIWVsLl94X2ZvcndhcmRFdmVudHMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgZWwuX3hfZm9yd2FyZEV2ZW50cy5wdXNoKHZhbHVlKTtcbiAgfVxuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBvbihlbCwgdmFsdWUsIG1vZGlmaWVycywgKGUpID0+IHtcbiAgICBldmFsdWF0ZTIoKCkgPT4ge1xuICAgIH0sIHtzY29wZTogeyRldmVudDogZX0sIHBhcmFtczogW2VdfSk7XG4gIH0pO1xuICBjbGVhbnVwKCgpID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW5kZXguanNcbmFscGluZV9kZWZhdWx0LnNldEV2YWx1YXRvcihub3JtYWxFdmFsdWF0b3IpO1xuYWxwaW5lX2RlZmF1bHQuc2V0UmVhY3Rpdml0eUVuZ2luZSh7cmVhY3RpdmU6IGltcG9ydF9yZWFjdGl2aXR5OS5yZWFjdGl2ZSwgZWZmZWN0OiBpbXBvcnRfcmVhY3Rpdml0eTkuZWZmZWN0LCByZWxlYXNlOiBpbXBvcnRfcmVhY3Rpdml0eTkuc3RvcCwgcmF3OiBpbXBvcnRfcmVhY3Rpdml0eTkudG9SYXd9KTtcbnZhciBzcmNfZGVmYXVsdCA9IGFscGluZV9kZWZhdWx0O1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9idWlsZHMvbW9kdWxlLmpzXG52YXIgbW9kdWxlX2RlZmF1bHQgPSBzcmNfZGVmYXVsdDtcbmV4cG9ydCB7XG4gIG1vZHVsZV9kZWZhdWx0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/module.esm.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vendor_slider_range_js_tmpl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/slider-range/js/tmpl.js */ \"./resources/vendor/slider-range/js/tmpl.js\");\n/* harmony import */ var _vendor_slider_range_js_tmpl_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_slider_range_js_tmpl_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vendor_slider_range_js_jquery_dependClass_0_1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendor/slider-range/js/jquery.dependClass-0.1.js */ \"./resources/vendor/slider-range/js/jquery.dependClass-0.1.js\");\n/* harmony import */ var _vendor_slider_range_js_jquery_dependClass_0_1_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_vendor_slider_range_js_jquery_dependClass_0_1_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _vendor_datatables_jquery_dataTables_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vendor/datatables/jquery.dataTables.min.js */ \"./resources/vendor/datatables/jquery.dataTables.min.js\");\n/* harmony import */ var _vendor_datatables_jquery_dataTables_min_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_vendor_datatables_jquery_dataTables_min_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vendor_datatables_dataTables_bootstrap4_min_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vendor/datatables/dataTables.bootstrap4.min.js */ \"./resources/vendor/datatables/dataTables.bootstrap4.min.js\");\n/* harmony import */ var _vendor_datatables_dataTables_bootstrap4_min_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_vendor_datatables_dataTables_bootstrap4_min_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _vendor_slider_range_js_draggable_0_1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vendor/slider-range/js/draggable-0.1.js */ \"./resources/vendor/slider-range/js/draggable-0.1.js\");\n/* harmony import */ var _vendor_slider_range_js_draggable_0_1_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_vendor_slider_range_js_draggable_0_1_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _vendor_slider_range_js_jquery_slider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../vendor/slider-range/js/jquery.slider.js */ \"./resources/vendor/slider-range/js/jquery.slider.js\");\n/* harmony import */ var _vendor_slider_range_js_jquery_slider_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_vendor_slider_range_js_jquery_slider_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var imask__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! imask */ \"./node_modules/imask/dist/imask.js\");\n/* harmony import */ var imask__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(imask__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/module.esm.js\");\n\n\n\n\n\n\n\n\nwindow.Alpine = alpinejs__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\nalpinejs__WEBPACK_IMPORTED_MODULE_7__[\"default\"].start();\nChart.defaults.global.defaultFontFamily = 'Nunito', '-apple-system,system-ui,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif';\nChart.defaults.global.defaultFontColor = '#858796';\nwindow.livewire.on('chartUpdate', function (chartId, labels, datasets) {\n  var chart = window[chartId].chart;\n  chart.data.datasets.forEach(function (dataset, key) {\n    dataset.data = datasets[key];\n  });\n  chart.data.labels = labels;\n  chart.update();\n});\n$(document).ready(function () {\n  $(\"#page-preloader\").fadeOut();\n});\n$(\".show_hide_password .icon-eye\").on('click', function (event) {\n  if ($('.show_hide_password input').attr(\"type\") == \"text\") {\n    $('.show_hide_password input').attr('type', 'password');\n    $('.show_hide_password i').addClass(\"fa-eye-slash\");\n    $('.show_hide_password i').removeClass(\"fa-eye\");\n  } else if ($('.show_hide_password input').attr(\"type\") == \"password\") {\n    $('.show_hide_password input').attr('type', 'text');\n    $('.show_hide_password i').removeClass(\"fa-eye-slash\");\n    $('.show_hide_password i').addClass(\"fa-eye\");\n  }\n});\n$('#cetak').on('click', function () {\n  $('table').printThis({\n    debug: false,\n    printContainer: true,\n    pageTitle: \"Rekap Data {{ $title }}\",\n    printDelay: 666,\n    header: \"<h3 class=\\\"text-gray-800 mb-4\\\">Rekap Data {{ $title }}</h3>\",\n    footer: $('footer'),\n    base: false,\n    // preserve the BASE tag or accept a string for the URL\n    formValues: true,\n    // preserve input/form values\n    canvas: false,\n    // copy canvas content\n    removeScripts: false,\n    // remove script tags from print content\n    copyTagClasses: false,\n    // copy classes from the html & body tag\n    beforePrintEvent: null,\n    // function for printEvent in iframe\n    beforePrint: null,\n    // function called before iframe is filled\n    afterPrint: null // function called before iframe is removed\n\n  });\n});\n$(\"#sidebarToggle, #sidebarToggleTop\").on('click', function (e) {\n  $(\"body\").toggleClass(\"sidebar-toggled\");\n  $(\".sidebar\").toggleClass(\"toggled\");\n\n  if ($(\".sidebar\").hasClass(\"toggled\")) {\n    $('.sidebar .collapse').collapse('hide');\n  }\n\n  ;\n});\n$(window).resize(function () {\n  if ($(window).width() < 768) {\n    $('.sidebar .collapse').collapse('hide');\n  }\n\n  ;\n\n  if ($(window).width() < 480 && !$(\".sidebar\").hasClass(\"toggled\")) {\n    $(\"body\").addClass(\"sidebar-toggled\");\n    $(\".sidebar\").addClass(\"toggled\");\n    $('.sidebar .collapse').collapse('hide');\n  }\n\n  ;\n});\n$('body.fixed-nav .sidebar').on('mousewheel DOMMouseScroll wheel', function (e) {\n  if ($(window).width() > 768) {\n    var e0 = e.originalEvent,\n        delta = e0.wheelDelta || -e0.detail;\n    this.scrollTop += (delta < 0 ? 1 : -1) * 30;\n    e.preventDefault();\n  }\n});\n$(document).on('scroll', function () {\n  var scrollDistance = $(this).scrollTop();\n\n  if (scrollDistance > 100) {\n    $('.scroll-to-top').fadeIn();\n  } else {\n    $('.scroll-to-top').fadeOut();\n  }\n});\n$(document).on('click', 'a.scroll-to-top', function (e) {\n  var $anchor = $(this);\n  $('html, body').stop().animate({\n    scrollTop: $($anchor.attr('href')).offset().top\n  }, 1000, 'easeInOutExpo');\n  e.preventDefault();\n});\n$(\".back-to-top\").hide();\n$(window).on(\"scroll\", function () {\n  if ($(this).scrollTop() > 400) {\n    $(\".back-to-top\").fadeIn();\n  } else {\n    $(\".back-to-top\").fadeOut();\n  }\n\n  return false;\n});\n$(\".back-to-top a\").on(\"click\", function (e) {\n  e.preventDefault();\n  $(\"html, body\").animate({\n    scrollTop: 0\n  }, 600);\n  return false;\n});\n$(\".dr-slideshow\").nivoSlider({\n  effect: \"random\",\n  animSpeed: 1e3,\n  pauseTime: 5e3,\n  directionNav: true,\n  controlNav: true,\n  pauseOnHover: true\n});\n$(\"ul.menu\").on(\"click\", \".more\", function () {\n  if ($(this).hasClass(\"hide\")) {\n    $(this).text(\"show more\").removeClass(\".hide\");\n  } else {\n    $(this).text(\"hide\").addClass(\"hide\");\n  }\n\n  $(this).siblings(\"li.toggleable\").slideToggle();\n});\n$(\".category-product\").owlCarousel({\n  loop: false,\n  autoplaytimeout: 6e3,\n  margin: 30,\n  autoplay: false,\n  dots: false,\n  autoplayHoverPause: true,\n  responsiveClass: true,\n  nav: true,\n  responsive: {\n    0: {\n      items: 1,\n      navText: [\"<i class='fa fa-angle-left' aria-hidden='true'></i>\", \"<i class='fa fa-angle-right' aria-hidden='true'></i>\"]\n    },\n    600: {\n      items: 3,\n      navText: [\"<i class='fa fa-angle-left' aria-hidden='true'></i>\", \"<i class='fa fa-angle-right' aria-hidden='true'></i>\"]\n    },\n    1e3: {\n      items: 4,\n      navText: [\"<i class='fa fa-angle-left' aria-hidden='true'></i>\", \"<i class='fa fa-angle-right' aria-hidden='true'></i>\"]\n    }\n  }\n});\n$(\"#manufacture\").owlCarousel({\n  loop: false,\n  autoplaytimeout: 6e3,\n  margin: 30,\n  autoplay: true,\n  dots: false,\n  autoplayHoverPause: true,\n  responsiveClass: true,\n  nav: true,\n  responsive: {\n    0: {\n      items: 3\n    },\n    600: {\n      items: 3\n    },\n    1e3: {\n      items: 6\n    }\n  }\n});\n$(\".testimonials\").owlCarousel({\n  loop: false,\n  margin: 10,\n  responsiveClass: true,\n  autoplaytimeout: 6e3,\n  autoplay: true,\n  dots: true,\n  autoplayHoverPause: true,\n  nav: false,\n  responsive: {\n    0: {\n      items: 1\n    },\n    600: {\n      items: 1\n    },\n    1e3: {\n      items: 1\n    }\n  }\n});\n$(\".close\").on(\"click\", function () {\n  $(\".mobile-top-menu\").removeClass(\"active-show\");\n});\n$(\".mobile-menutop\").on(\"click\", function () {\n  $(\"#mobile-pagemenu\").addClass(\"active-pagemenu\");\n});\n$(\".close-box\").on(\"click\", function () {\n  $(\"#mobile-pagemenu\").removeClass(\"active-pagemenu\");\n});\n$(document).on('click', function () {\n  $('.collapse').collapse('hide');\n});\n\nwindow.onload = function () {\n  var name = document.getElementById('name');\n  var cardnumber = document.getElementById('cardnumber');\n  var expirationdate = document.getElementById('expirationdate');\n  var securitycode = document.getElementById('securitycode');\n  var ccicon = document.getElementById('ccicon');\n  var ccsingle = document.getElementById('ccsingle');\n  if (!cardnumber && !expirationdate && !securitycode && !ccicon && !ccsingle) return; //Mask the Credit Card Number Input\n\n  var cardnumber_mask = new (imask__WEBPACK_IMPORTED_MODULE_6___default())(cardnumber, {\n    mask: [{\n      mask: '0000 000000 00000',\n      regex: '^3[47]\\\\d{0,13}',\n      cardtype: 'american express'\n    }, {\n      mask: '0000 0000 0000 0000',\n      regex: '^(?:6011|65\\\\d{0,2}|64[4-9]\\\\d?)\\\\d{0,12}',\n      cardtype: 'discover'\n    }, {\n      mask: '0000 000000 0000',\n      regex: '^3(?:0([0-5]|9)|[689]\\\\d?)\\\\d{0,11}',\n      cardtype: 'diners'\n    }, {\n      mask: '0000 0000 0000 0000',\n      regex: '^(5[1-5]\\\\d{0,2}|22[2-9]\\\\d{0,1}|2[3-7]\\\\d{0,2})\\\\d{0,12}',\n      cardtype: 'mastercard'\n    }, // {\n    //     mask: '0000-0000-0000-0000',\n    //     regex: '^(5019|4175|4571)\\\\d{0,12}',\n    //     cardtype: 'dankort'\n    // },\n    // {\n    //     mask: '0000-0000-0000-0000',\n    //     regex: '^63[7-9]\\\\d{0,13}',\n    //     cardtype: 'instapayment'\n    // },\n    {\n      mask: '0000 000000 00000',\n      regex: '^(?:2131|1800)\\\\d{0,11}',\n      cardtype: 'jcb15'\n    }, {\n      mask: '0000 0000 0000 0000',\n      regex: '^(?:35\\\\d{0,2})\\\\d{0,12}',\n      cardtype: 'jcb'\n    }, {\n      mask: '0000 0000 0000 0000',\n      regex: '^(?:5[0678]\\\\d{0,2}|6304|67\\\\d{0,2})\\\\d{0,12}',\n      cardtype: 'maestro'\n    }, // {\n    //     mask: '0000-0000-0000-0000',\n    //     regex: '^220[0-4]\\\\d{0,12}',\n    //     cardtype: 'mir'\n    // },\n    {\n      mask: '0000 0000 0000 0000',\n      regex: '^4\\\\d{0,15}',\n      cardtype: 'visa'\n    }, {\n      mask: '0000 0000 0000 0000',\n      regex: '^62\\\\d{0,14}',\n      cardtype: 'unionpay'\n    }, {\n      mask: '0000 0000 0000 0000',\n      cardtype: 'Unknown'\n    }],\n    dispatch: function dispatch(appended, dynamicMasked) {\n      var number = (dynamicMasked.value + appended).replace(/\\D/g, '');\n\n      for (var i = 0; i < dynamicMasked.compiledMasks.length; i++) {\n        var re = new RegExp(dynamicMasked.compiledMasks[i].regex);\n\n        if (number.match(re) != null) {\n          return dynamicMasked.compiledMasks[i];\n        }\n      }\n    }\n  }); //Mask the Expiration Date\n\n  var expirationdate_mask = new (imask__WEBPACK_IMPORTED_MODULE_6___default())(expirationdate, {\n    mask: 'MM{/}YY',\n    groups: {\n      YY: new (imask__WEBPACK_IMPORTED_MODULE_6___default().MaskedPattern.Group.Range)([0, 99]),\n      MM: new (imask__WEBPACK_IMPORTED_MODULE_6___default().MaskedPattern.Group.Range)([1, 12])\n    }\n  }); //Mask the security code\n\n  var securitycode_mask = new (imask__WEBPACK_IMPORTED_MODULE_6___default())(securitycode, {\n    mask: '0000'\n  }); // SVGICONS\n\n  var amex = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"amex\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"Rectangle-1\\\" fill=\\\"#2557D6\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <path d=\\\"M0.002688,221.18508 L36.026849,221.18508 L44.149579,201.67506 L62.334596,201.67506 L70.436042,221.18508 L141.31637,221.18508 L141.31637,206.26909 L147.64322,221.24866 L184.43894,221.24866 L190.76579,206.04654 L190.76579,221.18508 L366.91701,221.18508 L366.83451,189.15941 L370.2427,189.15941 C372.62924,189.24161 373.3263,189.46144 373.3263,193.38516 L373.3263,221.18508 L464.43232,221.18508 L464.43232,213.72973 C471.78082,217.6508 483.21064,221.18508 498.25086,221.18508 L536.57908,221.18508 L544.78163,201.67506 L562.96664,201.67506 L570.98828,221.18508 L644.84844,221.18508 L644.84844,202.65269 L656.0335,221.18508 L715.22061,221.18508 L715.22061,98.67789 L656.64543,98.67789 L656.64543,113.14614 L648.44288,98.67789 L588.33787,98.67789 L588.33787,113.14614 L580.80579,98.67789 L499.61839,98.67789 C486.02818,98.67789 474.08221,100.5669 464.43232,105.83121 L464.43232,98.67789 L408.40596,98.67789 L408.40596,105.83121 C402.26536,100.40529 393.89786,98.67789 384.59383,98.67789 L179.90796,98.67789 L166.17407,130.3194 L152.07037,98.67789 L87.59937,98.67789 L87.59937,113.14614 L80.516924,98.67789 L25.533518,98.67789 L-2.99999999e-06,156.92445 L-2.99999999e-06,221.18508 L0.002597,221.18508 L0.002688,221.18508 Z M227.39957,203.51436 L205.78472,203.51436 L205.70492,134.72064 L175.13228,203.51436 L156.62,203.51436 L125.96754,134.6597 L125.96754,203.51436 L83.084427,203.51436 L74.982981,183.92222 L31.083524,183.92222 L22.8996,203.51436 L4.7e-05,203.51436 L37.756241,115.67692 L69.08183,115.67692 L104.94103,198.84086 L104.94103,115.67692 L139.35289,115.67692 L166.94569,175.26406 L192.29297,115.67692 L227.39657,115.67692 L227.39657,203.51436 L227.39957,203.51436 Z M67.777214,165.69287 L53.346265,130.67606 L38.997794,165.69287 L67.777214,165.69287 Z M313.41947,203.51436 L242.98611,203.51436 L242.98611,115.67692 L313.41947,115.67692 L313.41947,133.96821 L264.07116,133.96821 L264.07116,149.8009 L312.23551,149.8009 L312.23551,167.80606 L264.07116,167.80606 L264.07116,185.34759 L313.41947,185.34759 L313.41947,203.51436 Z M412.67528,139.33321 C412.67528,153.33782 403.28877,160.57326 397.81863,162.74575 C402.43206,164.49434 406.37237,167.58351 408.24808,170.14281 C411.22525,174.51164 411.73875,178.41416 411.73875,186.25897 L411.73875,203.51436 L390.47278,203.51436 L390.39298,192.43732 C390.39298,187.1518 390.90115,179.55074 387.0646,175.32499 C383.98366,172.23581 379.28774,171.56552 371.69714,171.56552 L349.06363,171.56552 L349.06363,203.51436 L327.98125,203.51436 L327.98125,115.67692 L376.47552,115.67692 C387.25084,115.67692 395.18999,115.9604 402.00639,119.88413 C408.67644,123.80786 412.67529,129.53581 412.67529,139.33321 L412.67528,139.33321 Z M386.02277,152.37632 C383.1254,154.12756 379.69859,154.18584 375.59333,154.18584 L349.97998,154.18584 L349.97998,134.67583 L375.94186,134.67583 C379.61611,134.67583 383.44999,134.8401 385.94029,136.26016 C388.67536,137.53981 390.36749,140.26337 390.36749,144.02548 C390.36749,147.86443 388.75784,150.95361 386.02277,152.37632 Z M446.48908,203.51436 L424.97569,203.51436 L424.97569,115.67692 L446.48908,115.67692 L446.48908,203.51436 Z M696.22856,203.51436 L666.35032,203.51436 L626.38585,137.58727 L626.38585,203.51436 L583.44687,203.51436 L575.24166,183.92222 L531.44331,183.92222 L523.48287,203.51436 L498.81137,203.51436 C488.56284,203.51436 475.58722,201.25709 468.23872,193.79909 C460.82903,186.3411 456.97386,176.23903 456.97386,160.26593 C456.97386,147.23895 459.27791,135.33 468.33983,125.91941 C475.15621,118.90916 485.83044,115.67692 500.35982,115.67692 L520.77174,115.67692 L520.77174,134.49809 L500.78818,134.49809 C493.0938,134.49809 488.74909,135.63733 484.564,139.70147 C480.96957,143.4 478.50322,150.39171 478.50322,159.59829 C478.50322,169.00887 480.38158,175.79393 484.30061,180.22633 C487.5465,183.70232 493.445,184.75677 498.99495,184.75677 L508.46393,184.75677 L538.17987,115.67957 L569.77152,115.67957 L605.46843,198.76138 L605.46843,115.67957 L637.5709,115.67957 L674.6327,176.85368 L674.6327,115.67957 L696.22856,115.67957 L696.22856,203.51436 Z M568.07051,165.69287 L553.47993,130.67606 L538.96916,165.69287 L568.07051,165.69287 Z\\\" id=\\\"Path\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M749.95644,343.76716 C744.83485,351.22516 734.85504,355.00582 721.34464,355.00582 L680.62723,355.00582 L680.62723,336.1661 L721.17969,336.1661 C725.20248,336.1661 728.01736,335.63887 729.71215,333.99096 C731.18079,332.63183 732.2051,330.65804 732.2051,328.26036 C732.2051,325.70107 731.18079,323.66899 729.62967,322.45028 C728.09984,321.10969 725.87294,320.50033 722.20135,320.50033 C702.40402,319.83005 677.70592,321.10969 677.70592,293.30714 C677.70592,280.56363 685.83131,267.14983 707.95664,267.14983 L749.95379,267.14983 L749.95644,249.66925 L710.93382,249.66925 C699.15812,249.66925 690.60438,252.47759 684.54626,256.84375 L684.54626,249.66925 L626.83044,249.66925 C617.60091,249.66925 606.76706,251.94771 601.64279,256.84375 L601.64279,249.66925 L498.57751,249.66925 L498.57751,256.84375 C490.37496,250.95154 476.53466,249.66925 470.14663,249.66925 L402.16366,249.66925 L402.16366,256.84375 C395.67452,250.58593 381.24357,249.66925 372.44772,249.66925 L296.3633,249.66925 L278.95252,268.43213 L262.64586,249.66925 L148.99149,249.66925 L148.99149,372.26121 L260.50676,372.26121 L278.447,353.20159 L295.34697,372.26121 L364.08554,372.32211 L364.08554,343.48364 L370.84339,343.48364 C379.96384,343.62405 390.72054,343.25845 400.21079,339.17311 L400.21079,372.25852 L456.90762,372.25852 L456.90762,340.30704 L459.64268,340.30704 C463.13336,340.30704 463.47657,340.45011 463.47657,343.92344 L463.47657,372.25587 L635.71144,372.25587 C646.64639,372.25587 658.07621,369.46873 664.40571,364.41107 L664.40571,372.25587 L719.03792,372.25587 C730.40656,372.25587 741.50913,370.66889 749.95644,366.60475 L749.95644,343.76712 L749.95644,343.76716 Z M408.45301,296.61266 C408.45301,321.01872 390.16689,326.05784 371.7371,326.05784 L345.42935,326.05784 L345.42935,355.52685 L304.44855,355.52685 L278.48667,326.44199 L251.5058,355.52685 L167.9904,355.52685 L167.9904,267.66822 L252.79086,267.66822 L278.73144,296.46694 L305.55002,267.66822 L372.92106,267.66822 C389.6534,267.66822 408.45301,272.28078 408.45301,296.61266 Z M240.82781,337.04655 L188.9892,337.04655 L188.9892,319.56596 L235.27785,319.56596 L235.27785,301.64028 L188.9892,301.64028 L188.9892,285.66718 L241.84947,285.66718 L264.91132,311.27077 L240.82781,337.04655 Z M324.3545,347.10668 L291.9833,311.3189 L324.3545,276.6677 L324.3545,347.10668 Z M372.2272,308.04117 L344.98027,308.04117 L344.98027,285.66718 L372.47197,285.66718 C380.08388,285.66718 385.36777,288.75636 385.36777,296.43956 C385.36777,304.03796 380.32865,308.04117 372.2272,308.04117 Z M514.97053,267.66815 L585.34004,267.66815 L585.34004,285.83764 L535.96778,285.83764 L535.96778,301.81074 L584.1348,301.81074 L584.1348,319.73642 L535.96778,319.73642 L535.96778,337.21701 L585.34004,337.29641 L585.34004,355.52678 L514.97053,355.52678 L514.97053,267.66815 Z M487.91724,314.6973 C492.61049,316.42205 496.44703,319.51387 498.24559,322.07317 C501.22276,326.36251 501.65378,330.36571 501.73891,338.10985 L501.73891,355.52685 L480.5714,355.52685 L480.5714,344.53458 C480.5714,339.24908 481.08223,331.42282 477.1632,327.33748 C474.08226,324.19002 469.38635,323.4376 461.69463,323.4376 L439.16223,323.4376 L439.16223,355.52685 L417.97609,355.52685 L417.97609,267.66822 L466.65393,267.66822 C477.32816,267.66822 485.10236,268.13716 492.02251,271.81449 C498.6766,275.8177 502.86168,281.30191 502.86168,291.3245 C502.85868,305.34765 493.46719,312.50362 487.91724,314.6973 Z M475.99899,303.59022 C473.17879,305.25668 469.69077,305.39975 465.58817,305.39975 L439.97483,305.39975 L439.97483,285.66718 L465.9367,285.66718 C469.69077,285.66718 473.4475,285.74658 475.99899,287.25416 C478.7314,288.67687 480.36499,291.39779 480.36499,295.15725 C480.36499,298.91672 478.7314,301.94496 475.99899,303.59022 Z M666.33539,309.1866 C670.44067,313.41766 672.64095,318.7588 672.64095,327.80112 C672.64095,346.70178 660.78278,355.5242 639.51948,355.5242 L598.45353,355.5242 L598.45353,336.68449 L639.35453,336.68449 C643.35337,336.68449 646.18954,336.15726 647.9668,334.50934 C649.41681,333.15021 650.45709,331.17643 650.45709,328.77875 C650.45709,326.21944 649.33167,324.18738 647.88433,322.96866 C646.27201,321.62807 644.04778,321.01872 640.37619,321.01872 C620.65868,320.34843 595.9659,321.62807 595.9659,293.82551 C595.9659,281.08201 604.00615,267.66822 626.11019,267.66822 L668.37872,267.66822 L668.37872,286.36752 L629.70196,286.36752 C625.86809,286.36752 623.37512,286.51059 621.25464,287.9545 C618.94527,289.37721 618.08856,291.48876 618.08856,294.2759 C618.08856,297.59028 620.04941,299.8449 622.702,300.81987 C624.92624,301.59084 627.31543,301.81603 630.9072,301.81603 L642.25722,302.12071 C653.703,302.39889 661.55967,304.37003 666.33539,309.1866 Z M750,285.66718 L711.57335,285.66718 C707.7368,285.66718 705.18797,285.81025 703.04088,287.25416 C700.81665,288.67687 699.95995,290.78843 699.95995,293.57558 C699.95995,296.88994 701.83831,299.14456 704.57071,300.11953 C706.79495,300.8905 709.18415,301.1157 712.6961,301.1157 L724.12327,301.42038 C735.65419,301.70387 743.35123,303.67765 748.04448,308.49157 C748.89852,309.16186 749.41202,309.91428 750,310.6667 L750,285.66718 Z\\\" id=\\\"path13\\\" fill=\\\"#FFFFFF\\\"></path> </g> </g>\";\n  var visa = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"visa\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"Rectangle-1\\\" fill=\\\"#0E4595\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <polygon id=\\\"Shape\\\" fill=\\\"#FFFFFF\\\" points=\\\"278.1975 334.2275 311.5585 138.4655 364.9175 138.4655 331.5335 334.2275\\\"></polygon> <path d=\\\"M524.3075,142.6875 C513.7355,138.7215 497.1715,134.4655 476.4845,134.4655 C423.7605,134.4655 386.6205,161.0165 386.3045,199.0695 C386.0075,227.1985 412.8185,242.8905 433.0585,252.2545 C453.8275,261.8495 460.8105,267.9695 460.7115,276.5375 C460.5795,289.6595 444.1255,295.6545 428.7885,295.6545 C407.4315,295.6545 396.0855,292.6875 378.5625,285.3785 L371.6865,282.2665 L364.1975,326.0905 C376.6605,331.5545 399.7065,336.2895 423.6355,336.5345 C479.7245,336.5345 516.1365,310.2875 516.5505,269.6525 C516.7515,247.3835 502.5355,230.4355 471.7515,216.4645 C453.1005,207.4085 441.6785,201.3655 441.7995,192.1955 C441.7995,184.0585 451.4675,175.3575 472.3565,175.3575 C489.8055,175.0865 502.4445,178.8915 512.2925,182.8575 L517.0745,185.1165 L524.3075,142.6875\\\" id=\\\"path13\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M661.6145,138.4655 L620.3835,138.4655 C607.6105,138.4655 598.0525,141.9515 592.4425,154.6995 L513.1975,334.1025 L569.2285,334.1025 C569.2285,334.1025 578.3905,309.9805 580.4625,304.6845 C586.5855,304.6845 641.0165,304.7685 648.7985,304.7685 C650.3945,311.6215 655.2905,334.1025 655.2905,334.1025 L704.8025,334.1025 L661.6145,138.4655 Z M596.1975,264.8725 C600.6105,253.5935 617.4565,210.1495 617.4565,210.1495 C617.1415,210.6705 621.8365,198.8155 624.5315,191.4655 L628.1385,208.3435 C628.1385,208.3435 638.3555,255.0725 640.4905,264.8715 L596.1975,264.8715 L596.1975,264.8725 Z\\\" id=\\\"Path\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M232.9025,138.4655 L180.6625,271.9605 L175.0965,244.8315 C165.3715,213.5575 135.0715,179.6755 101.1975,162.7125 L148.9645,333.9155 L205.4195,333.8505 L289.4235,138.4655 L232.9025,138.4655\\\" id=\\\"path16\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M131.9195,138.4655 L45.8785,138.4655 L45.1975,142.5385 C112.1365,158.7425 156.4295,197.9015 174.8155,244.9525 L156.1065,154.9925 C152.8765,142.5965 143.5085,138.8975 131.9195,138.4655\\\" id=\\\"path18\\\" fill=\\\"#F2AE14\\\"></path> </g> </g>\";\n  var diners = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"diners\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"rectangle\\\" fill=\\\"#0079BE\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <path d=\\\"M584.933911,237.947339 C584.933911,138.53154 501.952976,69.8140806 411.038924,69.8471464 L332.79674,69.8471464 C240.793699,69.8140806 165.066089,138.552041 165.066089,237.947339 C165.066089,328.877778 240.793699,403.587432 332.79674,403.150963 L411.038924,403.150963 C501.952976,403.586771 584.933911,328.857939 584.933911,237.947339 Z\\\" id=\\\"Shape-path\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M333.280302,83.9308394 C249.210378,83.9572921 181.085889,152.238282 181.066089,236.510581 C181.085889,320.768331 249.209719,389.042708 333.280302,389.069161 C417.370025,389.042708 485.508375,320.768331 485.520254,236.510581 C485.507715,152.238282 417.370025,83.9572921 333.280302,83.9308394 Z\\\" id=\\\"Shape-path\\\" fill=\\\"#0079BE\\\"></path> <path d=\\\"M237.066089,236.09774 C237.145288,194.917524 262.812421,159.801587 299.006443,145.847134 L299.006443,326.327183 C262.812421,312.380667 237.144628,277.283907 237.066089,236.09774 Z M368.066089,326.372814 L368.066089,145.847134 C404.273312,159.767859 429.980043,194.903637 430.046043,236.103692 C429.980043,277.316312 404.273312,312.425636 368.066089,326.372814 Z\\\" id=\\\"Path\\\" fill=\\\"#FFFFFF\\\"></path> </g> </g>\";\n  var discover = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"discover\\\" fill-rule=\\\"nonzero\\\"> <path d=\\\"M52.8771038,0 C23.6793894,0 -4.55476115e-15,23.1545612 0,51.7102589 L0,419.289737 C0,447.850829 23.671801,471 52.8771038,471 L697.122894,471 C726.320615,471 750,447.845433 750,419.289737 L750,252.475404 L750,51.7102589 C750,23.1491677 726.328202,-4.4533018e-15 697.122894,0 L52.8771038,0 Z\\\" id=\\\"Shape\\\" fill=\\\"#4D4D4D\\\"></path> <path d=\\\"M314.569558,152.198414 C323.06625,152.198414 330.192577,153.9309 338.865308,158.110254 L338.865308,180.197198 C330.650269,172.563549 323.523875,169.368926 314.100058,169.368926 C295.577115,169.368926 281.009615,183.944539 281.009615,202.424438 C281.009615,221.911997 295.126279,235.620254 315.018404,235.620254 C323.972798,235.620254 330.967135,232.591128 338.865308,225.080186 L338.865308,247.178497 C329.883538,251.197965 322.604577,252.785079 314.100058,252.785079 C284.025202,252.785079 260.655798,230.849701 260.655798,202.560947 C260.655798,174.577103 284.647269,152.198414 314.569558,152.198414 Z M221.191404,152.807038 C232.293048,152.807038 242.451462,156.418802 250.944635,163.479831 L240.609981,176.340655 C235.465019,170.859895 230.599394,168.547945 224.682615,168.547945 C216.169885,168.547936 209.970327,173.154235 209.970327,179.215049 C209.970327,184.413218 213.450798,187.164422 225.302356,191.332621 C247.768529,199.141028 254.426462,206.064868 254.426462,221.354473 C254.426462,239.986821 240.026981,252.955721 219.503077,252.955721 C204.47426,252.955721 193.548154,247.330452 184.44824,234.636213 L197.205529,222.956624 C201.754702,231.315341 209.342452,235.792799 218.763144,235.792799 C227.573971,235.792799 234.097058,230.014421 234.097058,222.217168 C234.097058,218.175392 232.121269,214.709536 228.175702,212.259183 C226.189231,211.099073 222.254519,209.369382 214.522615,206.777734 C195.973058,200.43062 189.609,193.646221 189.609,180.386799 C189.609,164.636126 203.275981,152.807038 221.191404,152.807038 Z M446.886269,154.485036 L468.460788,154.485036 L495.464615,219.130417 L522.815885,154.485036 L544.22701,154.485036 L500.482644,253.198414 L489.855019,253.198414 L446.886269,154.485036 Z M64.8212135,154.632923 L93.811974,154.632923 C125.842394,154.632923 148.170827,174.418596 148.170827,202.822609 C148.170827,216.985567 141.340038,230.679389 129.788913,239.766893 C120.068962,247.437722 108.994192,250.877669 93.6598558,250.877669 L64.8212135,250.877669 L64.8212135,154.632923 Z M157.25849,154.632923 L177.009462,154.632923 L177.009462,250.877669 L157.25849,250.877669 L157.25849,154.632923 Z M553.156923,154.632923 L609.168423,154.632923 L609.168423,170.940741 L572.892875,170.940741 L572.892875,192.303392 L607.831279,192.303392 L607.831279,208.603619 L572.892875,208.603619 L572.892875,234.583122 L609.168423,234.583122 L609.168423,250.877669 L553.156923,250.877669 L553.156923,154.632923 Z M622.250596,154.632923 L651.534327,154.632923 C674.313452,154.632923 687.366663,165.030007 687.366663,183.048838 C687.366663,197.784414 679.179923,207.454847 664.302885,210.332805 L696.176385,250.877669 L671.888144,250.877669 L644.551904,212.213673 L641.977163,212.213673 L641.977163,250.877669 L622.250596,250.877669 L622.250596,154.632923 Z M641.977163,169.791736 L641.977163,198.939525 L647.748269,198.939525 C660.360308,198.939525 667.044769,193.734406 667.044769,184.05942 C667.044769,174.693052 660.359106,169.791736 648.060019,169.791736 L641.977163,169.791736 Z M84.5571663,170.940741 L84.5571663,234.583122 L89.8568962,234.583122 C102.619538,234.583122 110.679663,232.259105 116.885144,226.934514 C123.71575,221.152572 127.824519,211.920423 127.824519,202.684197 C127.824519,193.462833 123.71575,184.505917 116.885144,178.723975 C110.361615,173.113074 102.619538,170.940741 89.8568962,170.940741 L84.5571663,170.940741 Z\\\" id=\\\"Shape\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M399.164288,151.559424 C428.914452,151.559424 453.031096,173.727429 453.031096,201.112187 L453.031096,201.143399 C453.031096,228.528147 428.914452,250.727374 399.164288,250.727374 C369.414125,250.727374 345.297481,228.528147 345.297481,201.143399 L345.297481,201.112187 C345.297481,173.727429 369.414125,151.559424 399.164288,151.559424 Z M749.982612,271.093939 C724.934651,288.327133 537.408564,411.490963 212.719237,470.985071 L697.105507,470.985071 C726.303228,470.985071 749.982612,447.830504 749.982612,419.274807 L749.982612,271.093939 Z\\\" id=\\\"Shape\\\" fill=\\\"#F47216\\\"></path> </g> </g>\";\n  var jcb = \"<defs> <linearGradient x1=\\\"0.031607858%\\\" y1=\\\"49.9998574%\\\" x2=\\\"99.9743153%\\\" y2=\\\"49.9998574%\\\" id=\\\"linearGradient-1\\\"> <stop stop-color=\\\"#007B40\\\" offset=\\\"0%\\\"></stop> <stop stop-color=\\\"#55B330\\\" offset=\\\"100%\\\"></stop> </linearGradient> <linearGradient x1=\\\"0.471693172%\\\" y1=\\\"49.999826%\\\" x2=\\\"99.9860086%\\\" y2=\\\"49.999826%\\\" id=\\\"linearGradient-2\\\"> <stop stop-color=\\\"#1D2970\\\" offset=\\\"0%\\\"></stop> <stop stop-color=\\\"#006DBA\\\" offset=\\\"100%\\\"></stop> </linearGradient> <linearGradient x1=\\\"0.113880772%\\\" y1=\\\"50.0008964%\\\" x2=\\\"99.9860003%\\\" y2=\\\"50.0008964%\\\" id=\\\"linearGradient-3\\\"> <stop stop-color=\\\"#6E2B2F\\\" offset=\\\"0%\\\"></stop> <stop stop-color=\\\"#E30138\\\" offset=\\\"100%\\\"></stop> </linearGradient> </defs> <g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"jcb\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"Rectangle-1\\\" fill=\\\"#0E4C96\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <path d=\\\"M617.243183,346.766281 C617.243183,388.380887 583.514892,422.125974 541.88349,422.125974 L132.756823,422.125974 L132.756823,124.244916 C132.756823,82.6186826 166.489851,48.8744567 208.121683,48.8744567 L617.243183,48.874026 L617.242752,346.766281 L617.243183,346.766281 Z\\\" id=\\\"path3494\\\" fill=\\\"#FFFFFF\\\"></path> <path d=\\\"M483.858874,242.044797 C495.542699,242.298285 507.296188,241.528806 518.936004,242.444883 C530.723244,244.645678 533.563915,262.487874 523.09234,268.332511 C515.950746,272.182115 507.459496,269.764696 499.713328,270.446208 L483.858874,270.446208 L483.858874,242.044797 Z M525.691826,209.900487 C528.288491,219.064679 519.453903,227.292118 510.625917,226.030566 L483.858874,226.030566 C484.043758,217.388441 483.491345,208.008973 484.131053,199.821663 C494.854942,200.123386 505.679576,199.205849 516.340394,200.301853 C520.921799,201.451558 524.753935,205.217712 525.691826,209.900487 Z M590.120412,73.9972254 C590.617872,91.498454 590.191471,109.92365 590.33359,127.780192 C590.299137,200.376358 590.405942,272.974174 590.278896,345.569303 C589.81042,372.776592 565.696524,396.413678 538.678749,396.956694 C511.63292,397.068451 484.584297,396.972628 457.537396,397.004497 L457.537396,287.253291 C487.007,287.099803 516.49604,287.561 545.953521,287.021594 C559.62072,286.162769 574.586027,277.145695 575.22328,262.107374 C576.833661,247.005483 562.592128,236.557185 549.071096,234.905684 C543.872773,234.770542 544.027132,233.390846 549.071096,232.788972 C561.96307,230.002483 572.090675,216.655787 568.296786,203.290229 C565.06052,189.232374 549.523839,183.79142 536.600366,183.817768 C510.248548,183.638612 483.891299,183.792359 457.537396,183.74111 C457.708585,163.252408 457.182916,142.740653 457.82271,122.267364 C459.910361,95.5513766 484.628603,73.5195319 511.269759,73.997656 C537.553166,73.9973692 563.837737,73.9982301 590.120412,73.9972254 Z\\\" id=\\\"path3496\\\" fill=\\\"url(#linearGradient-1)\\\"></path> <path d=\\\"M159.740429,125.040498 C160.413689,97.8766592 184.628619,74.4290299 211.614797,74.0325398 C238.559493,73.9499686 265.506204,74.0209119 292.451671,73.9972254 C292.37764,164.882488 292.599905,255.773672 292.340301,346.655222 C291.302298,373.488802 267.350548,396.488661 240.661356,396.962292 C213.665015,397.060957 186.666275,396.976074 159.669012,397.004497 L159.669012,283.550875 C185.891623,289.745491 213.391138,292.382518 240.142406,288.272242 C256.134509,285.697368 273.629935,277.848026 279.044261,261.257567 C283.030122,247.066267 280.785723,232.131602 281.378027,217.566465 L281.378027,183.741541 L235.081246,183.741541 C234.873106,206.112145 235.507258,228.522447 234.746146,250.867107 C233.49785,264.601214 219.900147,273.326996 206.946428,272.861801 C190.879747,273.030535 159.04755,261.221796 159.04755,261.221796 C158.967492,219.3048 159.514314,166.814385 159.740429,125.040498 Z\\\" id=\\\"path3498\\\" fill=\\\"url(#linearGradient-2)\\\"></path> <path d=\\\"M309.719995,197.390136 C307.285788,197.90738 309.229141,189.089459 308.606298,185.743964 C308.772233,164.593637 308.260045,143.420951 308.889718,122.285827 C310.972541,95.4570827 335.881262,73.3701105 362.628748,73.997656 L441.39456,73.997656 C441.320658,164.882346 441.542493,255.77294 441.283406,346.653934 C440.244412,373.488027 416.291344,396.487102 389.602087,396.962292 C362.604605,397.061991 335.604707,396.976504 308.606298,397.004928 L308.606298,272.707624 C327.04641,287.835846 352.105738,290.192248 375.077953,290.233484 C392.39501,290.227455 409.611861,287.557865 426.428143,283.562934 L426.428143,260.790297 C407.474658,270.236609 385.194808,276.235815 364.184745,270.807966 C349.529051,267.157367 338.89089,252.996683 339.128513,237.872204 C337.43001,222.143684 346.652631,205.536885 362.110237,200.860855 C381.300923,194.852545 402.217787,199.448454 420.206344,207.258795 C424.060526,209.27695 427.97066,211.780342 426.428143,205.338044 L426.428143,187.438358 C396.343581,180.280951 364.326644,177.646405 334.099438,185.433619 C325.351193,187.901774 316.82819,191.644647 309.719995,197.390136 Z\\\" id=\\\"path3500\\\" fill=\\\"url(#linearGradient-3)\\\"></path> </g> </g>\";\n  var maestro = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"maestro\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"Rectangle-1\\\" fill=\\\"#000000\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <g id=\\\"Group\\\" transform=\\\"translate(133.000000, 48.000000)\\\"> <path d=\\\"M146.8,373.77 L146.8,349 C146.8,339.65 140.8,333.36 131.25,333.28 C126.25,333.2 120.99,334.77 117.35,340.28 C114.62,335.9 110.35,333.28 104.28,333.28 C99.6528149,333.047729 95.2479974,335.280568 92.7,339.15 L92.7,334.27 L84.09,334.27 L84.09,373.82 L92.78,373.82 L92.78,351.85 C92.78,344.98 96.59,341.34 102.46,341.34 C108.17,341.34 111.07,345.06 111.07,351.76 L111.07,373.76 L119.76,373.76 L119.76,351.85 C119.76,344.98 123.76,341.34 129.44,341.34 C135.31,341.34 138.13,345.06 138.13,351.76 L138.13,373.76 L146.8,373.77 Z M195.28,354 L195.28,334.23 L186.67,334.23 L186.67,339 C183.94,335.44 179.8,333.21 174.18,333.21 C163.09,333.21 154.41,341.9 154.41,353.98 C154.41,366.06 163.1,374.75 174.18,374.75 C179.81,374.75 183.94,372.52 186.67,368.96 L186.67,373.76 L195.28,373.76 L195.28,354 Z M163.28,354 C163.28,347.05 167.83,341.34 175.28,341.34 C182.4,341.34 187.19,346.8 187.19,354 C187.19,361.2 182.39,366.66 175.28,366.66 C167.81,366.66 163.26,360.95 163.26,354 L163.28,354 Z M379.4,333.19 C382.306602,333.161358 385.190743,333.701498 387.89,334.78 C390.404719,335.784654 392.697997,337.272736 394.64,339.16 C396.553063,341.035758 398.069744,343.276773 399.1,345.75 C401.246003,351.047587 401.246003,356.972413 399.1,362.27 C398.069744,364.743227 396.553063,366.984242 394.64,368.86 C392.698322,370.747671 390.404958,372.235809 387.89,373.24 C382.423165,375.368264 376.356835,375.368264 370.89,373.24 C368.379501,372.23863 366.092168,370.749994 364.16,368.86 C362.258485,366.978798 360.749319,364.738843 359.72,362.27 C357.573997,356.972413 357.573997,351.047587 359.72,345.75 C360.749788,343.28141 362.258895,341.041542 364.16,339.16 C366.092334,337.270213 368.379623,335.781606 370.89,334.78 C373.595493,333.69893 376.486681,333.158743 379.4,333.19 Z M379.4,341.33 C377.718221,341.315441 376.049964,341.631425 374.49,342.26 C373.019746,342.850363 371.685751,343.735156 370.57,344.86 C369.447092,346.008077 368.563336,347.367702 367.97,348.86 C366.704271,352.169784 366.704271,355.830216 367.97,359.14 C368.562861,360.632544 369.446675,361.992258 370.57,363.14 C371.685751,364.264844 373.019746,365.149637 374.49,365.74 C377.649488,366.979283 381.160512,366.979283 384.32,365.74 C385.794284,365.146098 387.134154,364.26192 388.26,363.14 C389.392829,361.995929 390.283848,360.635594 390.88,359.14 C392.145729,355.830216 392.145729,352.169784 390.88,348.86 C390.283848,347.364406 389.392829,346.004071 388.26,344.86 C387.134154,343.73808 385.794284,342.853902 384.32,342.26 C382.757613,341.626714 381.085807,341.307304 379.4,341.32 L379.4,341.33 Z M242.1,354 C242.02,341.67 234.41,333.23 223.32,333.23 C211.74,333.23 203.63,341.67 203.63,354 C203.63,366.58 212.07,374.77 223.9,374.77 C229.9,374.77 235.32,373.28 240.12,369.23 L235.9,362.86 C232.633262,365.479648 228.586894,366.936341 224.4,367 C218.86,367 213.81,364.44 212.57,357.32 L241.94,357.32 C242,356.23 242.1,355.16 242.1,354 Z M212.65,350.53 C213.56,344.82 217.03,340.93 223.16,340.93 C228.7,340.93 232.26,344.4 233.16,350.53 L212.65,350.53 Z M278.34,344.33 C274.582803,342.165547 270.335565,340.995319 266,340.93 C261.28,340.93 258.47,342.67 258.47,345.56 C258.47,348.21 261.47,348.95 265.17,349.45 L269.22,350.03 C277.83,351.27 283.04,354.91 283.04,361.86 C283.04,369.39 276.42,374.77 265.04,374.77 C258.59,374.77 252.63,373.11 247.91,369.64 L251.96,362.94 C255.757785,365.757702 260.39304,367.215905 265.12,367.08 C270.99,367.08 274.12,365.34 274.12,362.28 C274.12,360.05 271.89,358.81 267.17,358.14 L263.12,357.56 C254.27,356.32 249.47,352.35 249.47,345.89 C249.47,338.03 255.92,333.23 265.93,333.23 C272.22,333.23 277.93,334.64 282.06,337.37 L278.34,344.33 Z M319.69,342.1 L305.62,342.1 L305.62,360 C305.62,364 307.03,366.62 311.33,366.62 C314.014365,366.531754 316.632562,365.76453 318.94,364.39 L321.42,371.75 C318.192475,373.761602 314.463066,374.822196 310.66,374.81 C300.48,374.81 296.93,369.35 296.93,360.16 L296.93,342.16 L288.93,342.16 L288.93,334.3 L296.93,334.3 L296.93,322.3 L305.62,322.3 L305.62,334.3 L319.68,334.3 L319.69,342.1 Z M349.47,333.25 C351.556514,333.260012 353.62609,333.625232 355.59,334.33 L352.94,342.44 C351.229904,341.756022 349.401653,341.416198 347.56,341.44 C341.93,341.44 339.12,345.08 339.12,351.62 L339.12,373.79 L330.52,373.79 L330.52,334.23 L339,334.23 L339,339 C341.149726,335.306198 345.148028,333.084492 349.42,333.21 L349.47,333.25 Z\\\" id=\\\"Shape\\\" fill=\\\"#FFFFFF\\\"></path> <g id=\\\"_Group_\\\"> <rect id=\\\"Rectangle-path\\\" fill=\\\"#7673C0\\\" x=\\\"176.95\\\" y=\\\"32.39\\\" width=\\\"130.5\\\" height=\\\"234.51\\\"></rect> <path d=\\\"M185.24,149.64 C185.20514,103.86954 206.225386,60.6268374 242.24,32.38 C181.092968,-15.6818249 93.2777189,-8.68578574 40.5116372,48.4512353 C-12.2544445,105.588256 -12.2544445,193.681744 40.5116372,250.818765 C93.2777189,307.955786 181.092968,314.951825 242.24,266.89 C206.228151,238.645328 185.208215,195.406951 185.24,149.64 Z\\\" id=\\\"_Path_\\\" fill=\\\"#EB001B\\\"></path> <path d=\\\"M483.5,149.64 C483.501034,206.73874 450.90156,258.826356 399.545558,283.782862 C348.189556,308.739368 287.092343,302.183759 242.2,266.9 C278.166584,238.620187 299.164715,195.398065 299.164715,149.645 C299.164715,103.891935 278.166584,60.669813 242.2,32.39 C287.090924,-2.89264477 348.185845,-9.44904288 399.541061,15.5049525 C450.896277,40.4589479 483.497206,92.543064 483.5,149.64 Z\\\" id=\\\"Shape\\\" fill=\\\"#00A1DF\\\"></path> </g> </g> </g> </g>\";\n  var mastercard = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"mastercard\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"Rectangle-1\\\" fill=\\\"#000000\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <g id=\\\"Group\\\" transform=\\\"translate(133.000000, 48.000000)\\\"> <path d=\\\"M88.13,373.67 L88.13,348.82 C88.13,339.29 82.33,333.08 72.81,333.08 C67.81,333.08 62.46,334.74 58.73,340.08 C55.83,335.52 51.73,333.08 45.48,333.08 C40.7599149,332.876008 36.2525337,335.054575 33.48,338.88 L33.48,333.88 L25.61,333.88 L25.61,373.64 L33.48,373.64 L33.48,350.89 C33.48,343.89 37.62,340.54 43.42,340.54 C49.22,340.54 52.53,344.27 52.53,350.89 L52.53,373.67 L60.4,373.67 L60.4,350.89 C60.4,343.89 64.54,340.54 70.34,340.54 C76.14,340.54 79.45,344.27 79.45,350.89 L79.45,373.67 L88.13,373.67 Z M217.35,334.32 L202.85,334.32 L202.85,322.32 L195,322.32 L195,334.32 L186.72,334.32 L186.72,341.32 L195,341.32 L195,360 C195,369.11 198.31,374.5 208.25,374.5 C212.015784,374.421483 215.705651,373.426077 219,371.6 L216.51,364.6 C214.275685,365.996557 211.684475,366.715565 209.05,366.67 C204.91,366.67 202.84,364.18 202.84,360.04 L202.84,341 L217.34,341 L217.34,334.37 L217.35,334.32 Z M291.07,333.08 C286.709355,332.982846 282.618836,335.185726 280.3,338.88 L280.3,333.88 L272.43,333.88 L272.43,373.64 L280.3,373.64 L280.3,351.31 C280.3,344.68 283.61,340.54 289,340.54 C290.818809,340.613783 292.62352,340.892205 294.38,341.37 L296.87,333.91 C294.971013,333.43126 293.02704,333.153071 291.07,333.08 Z M179.66,337.22 C175.52,334.32 169.72,333.08 163.51,333.08 C153.57,333.08 147.36,337.64 147.36,345.51 C147.36,352.14 151.92,355.86 160.61,357.11 L164.75,357.52 C169.31,358.35 172.21,360.01 172.21,362.08 C172.21,364.98 168.9,367.08 162.68,367.08 C157.930627,367.177716 153.278889,365.724267 149.43,362.94 L145.29,369.15 C151.09,373.29 158.13,374.15 162.29,374.15 C173.89,374.15 180.1,368.77 180.1,361.31 C180.1,354.31 175.1,350.96 166.43,349.71 L162.29,349.3 C158.56,348.89 155.29,347.64 155.29,345.16 C155.29,342.26 158.6,340.16 163.16,340.16 C168.16,340.16 173.1,342.23 175.59,343.47 L179.66,337.22 Z M299.77,353.79 C299.77,365.79 307.64,374.5 320.48,374.5 C326.28,374.5 330.42,373.26 334.56,369.94 L330.42,363.73 C327.488758,366.10388 323.841703,367.41823 320.07,367.46 C313.07,367.46 307.64,362.08 307.64,354.21 C307.64,346.34 313,341 320.07,341 C323.841703,341.04177 327.488758,342.35612 330.42,344.73 L334.56,338.52 C330.42,335.21 326.28,333.96 320.48,333.96 C308.05,333.13 299.77,341.83 299.77,353.84 L299.77,353.79 Z M244.27,333.08 C232.67,333.08 224.8,341.36 224.8,353.79 C224.8,366.22 233.08,374.5 245.09,374.5 C250.932775,374.623408 256.638486,372.722682 261.24,369.12 L257.1,363.32 C253.772132,365.898743 249.708598,367.349004 245.5,367.46 C240.12,367.46 234.32,364.15 233.5,357.11 L262.91,357.11 L262.91,353.8 C262.91,341.37 255.45,333.09 244.27,333.09 L244.27,333.08 Z M243.86,340.54 C249.66,340.54 253.8,344.27 254.21,350.48 L232.68,350.48 C233.92,344.68 237.68,340.54 243.86,340.54 Z M136.59,353.79 L136.59,333.91 L128.72,333.91 L128.72,338.91 C125.82,335.18 121.72,333.11 115.88,333.11 C104.7,333.11 96.41,341.81 96.41,353.82 C96.41,365.83 104.69,374.53 115.88,374.53 C121.68,374.53 125.82,372.46 128.72,368.73 L128.72,373.73 L136.59,373.73 L136.59,353.79 Z M104.7,353.79 C104.7,346.33 109.26,340.54 117.13,340.54 C124.59,340.54 129.13,346.34 129.13,353.79 C129.13,361.66 124.13,367.04 117.13,367.04 C109.26,367.45 104.7,361.24 104.7,353.79 Z M410.78,333.08 C406.419355,332.982846 402.328836,335.185726 400.01,338.88 L400.01,333.88 L392.14,333.88 L392.14,373.64 L400,373.64 L400,351.31 C400,344.68 403.31,340.54 408.7,340.54 C410.518809,340.613783 412.32352,340.892205 414.08,341.37 L416.57,333.91 C414.671013,333.43126 412.72704,333.153071 410.77,333.08 L410.78,333.08 Z M380.13,353.79 L380.13,333.91 L372.26,333.91 L372.26,338.91 C369.36,335.18 365.26,333.11 359.42,333.11 C348.24,333.11 339.95,341.81 339.95,353.82 C339.95,365.83 348.23,374.53 359.42,374.53 C365.22,374.53 369.36,372.46 372.26,368.73 L372.26,373.73 L380.13,373.73 L380.13,353.79 Z M348.24,353.79 C348.24,346.33 352.8,340.54 360.67,340.54 C368.13,340.54 372.67,346.34 372.67,353.79 C372.67,361.66 367.67,367.04 360.67,367.04 C352.8,367.45 348.24,361.24 348.24,353.79 Z M460.07,353.79 L460.07,318.17 L452.2,318.17 L452.2,338.88 C449.3,335.15 445.2,333.08 439.36,333.08 C428.18,333.08 419.89,341.78 419.89,353.79 C419.89,365.8 428.17,374.5 439.36,374.5 C445.16,374.5 449.3,372.43 452.2,368.7 L452.2,373.7 L460.07,373.7 L460.07,353.79 Z M428.18,353.79 C428.18,346.33 432.74,340.54 440.61,340.54 C448.07,340.54 452.61,346.34 452.61,353.79 C452.61,361.66 447.61,367.04 440.61,367.04 C432.73,367.46 428.17,361.25 428.17,353.79 L428.18,353.79 Z\\\" id=\\\"Shape\\\" fill=\\\"#FFFFFF\\\"></path> <g> <rect id=\\\"Rectangle-path\\\" fill=\\\"#FF5F00\\\" x=\\\"170.55\\\" y=\\\"32.39\\\" width=\\\"143.72\\\" height=\\\"234.42\\\"></rect> <path d=\\\"M185.05,149.6 C185.05997,103.912554 205.96046,60.7376085 241.79,32.39 C180.662018,-15.6713968 92.8620037,-8.68523415 40.103462,48.4380037 C-12.6550796,105.561241 -12.6550796,193.638759 40.103462,250.761996 C92.8620037,307.885234 180.662018,314.871397 241.79,266.81 C205.96046,238.462391 185.05997,195.287446 185.05,149.6 Z\\\" id=\\\"Shape\\\" fill=\\\"#EB001B\\\"></path> <path d=\\\"M483.26,149.6 C483.30134,206.646679 450.756789,258.706022 399.455617,283.656273 C348.154445,308.606523 287.109181,302.064451 242.26,266.81 C278.098424,238.46936 299.001593,195.290092 299.001593,149.6 C299.001593,103.909908 278.098424,60.7306402 242.26,32.39 C287.109181,-2.86445052 348.154445,-9.40652324 399.455617,15.5437274 C450.756789,40.493978 483.30134,92.5533211 483.26,149.6 Z\\\" id=\\\"Shape\\\" fill=\\\"#F79E1B\\\"></path> </g> </g> </g> </g>\";\n  var unionpay = \"<g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g id=\\\"unionpay\\\" fill-rule=\\\"nonzero\\\"> <rect id=\\\"Rectangle-path\\\" fill=\\\"#FFFFFF\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"></rect> <path d=\\\"M201.809581,55 L344.203266,55 C364.072152,55 376.490206,71.4063861 371.833436,91.4702467 L305.500331,378.94775 C300.843561,399.011611 280.871191,415.417997 261.002305,415.417997 L118.60862,415.417997 C98.7397339,415.417997 86.32168,399.011611 90.9784502,378.94775 L157.311555,91.4702467 C161.968325,71.3018868 181.837211,55 201.706097,55 L201.809581,55 Z\\\" id=\\\"Shape\\\" fill=\\\"#D10429\\\"></path> <path d=\\\"M331.750074,55 L495.564902,55 C515.433788,55 506.430699,71.4063861 501.773929,91.4702467 L435.440824,378.94775 C430.784054,399.011611 432.232827,415.417997 412.363941,415.417997 L248.549113,415.417997 C228.576743,415.417997 216.262173,399.011611 221.022427,378.94775 L287.355531,91.4702467 C292.012302,71.3018868 311.881188,55 331.853558,55 L331.750074,55 Z\\\" id=\\\"Shape\\\" fill=\\\"#022E64\\\"></path> <path d=\\\"M489.814981,55 L632.208666,55 C652.077552,55 664.495606,71.4063861 659.838836,91.4702467 L593.505731,378.94775 C588.848961,399.011611 568.876591,415.417997 549.007705,415.417997 L406.61402,415.417997 C386.64165,415.417997 374.32708,399.011611 378.98385,378.94775 L445.316955,91.4702467 C449.973725,71.3018868 469.842611,55 489.711498,55 L489.814981,55 Z\\\" id=\\\"Shape\\\" fill=\\\"#076F74\\\"></path> <path d=\\\"M465.904754,326.014514 L479.357645,326.014514 L483.186545,312.952104 L469.837137,312.952104 L465.904754,326.014514 Z M476.667067,290.066763 L472.010297,305.532656 C472.010297,305.532656 477.081002,302.920174 479.875064,302.08418 C482.669126,301.457184 486.808478,300.934688 486.808478,300.934688 L490.016475,290.171263 L476.563583,290.171263 L476.667067,290.066763 Z M483.393513,267.912917 L478.94371,282.751814 C478.94371,282.751814 483.910932,280.45283 486.704994,279.721335 C489.499056,278.98984 493.638407,278.780842 493.638407,278.780842 L496.846405,268.017417 L483.496997,268.017417 L483.393513,267.912917 Z M513.093359,267.912917 L495.708083,325.910015 L500.364853,325.910015 L496.742921,337.927431 L492.086151,337.927431 L490.947829,341.584906 L474.390424,341.584906 L475.528745,337.927431 L442,337.927431 L445.311481,326.850508 L448.726446,326.850508 L466.318689,267.912917 L469.837137,256 L486.704994,256 L484.94577,261.956459 C484.94577,261.956459 489.395572,258.716981 493.741891,257.567489 C497.984726,256.417997 522.406899,256 522.406899,256 L518.784967,267.808418 L512.989875,267.808418 L513.093359,267.912917 Z\\\" id=\\\"Shape\\\" fill=\\\"#FEFEFE\\\"></path> <path d=\\\"M520,256 L538.006178,256 L538.213146,262.792453 C538.109662,263.941945 539.041016,264.464441 541.214175,264.464441 L544.836108,264.464441 L541.524627,275.645864 L531.797151,275.645864 C523.414965,276.272859 520.206968,272.615385 520.413935,268.539913 L520.103484,256.104499 L520,256 Z M522.216235,309.20029 L505.037927,309.20029 L507.935473,299.272859 L527.597391,299.272859 L530.391454,290.181422 L511.039986,290.181422 L514.351467,279 L568.163034,279 L564.851553,290.181422 L546.741891,290.181422 L543.947829,299.272859 L562.057491,299.272859 L559.056461,309.20029 L539.498026,309.20029 L535.979578,313.380261 L543.947829,313.380261 L545.914021,325.920174 C546.120989,327.174165 546.120989,328.01016 546.534924,328.532656 C546.948859,328.950653 549.328986,329.159652 550.674275,329.159652 L553.054402,329.159652 L549.328986,341.386067 L543.223443,341.386067 C542.292089,341.386067 540.843316,341.281567 538.877124,341.281567 C537.014416,341.072569 535.77261,340.027576 534.530805,339.400581 C533.392483,338.878084 531.736743,337.519594 531.322808,335.11611 L529.4601,322.576197 L520.560494,334.907112 C517.766432,338.773585 513.937532,341.804064 507.418054,341.804064 L495,341.804064 L498.311481,330.936139 L503.071735,330.936139 C504.417024,330.936139 505.65883,330.413643 506.590184,329.891147 C507.521538,329.473149 508.349408,329.055152 509.177278,327.696662 L522.216235,309.20029 Z M334.31354,282 L379.742921,282 L376.43144,292.972424 L358.321778,292.972424 L355.527716,302.272859 L374.154797,302.272859 L370.739832,313.558781 L352.216235,313.558781 L347.662948,328.711176 C347.145529,330.383164 352.112751,330.592163 353.871975,330.592163 L363.185516,329.338171 L359.4601,341.878084 L338.556375,341.878084 C336.900635,341.878084 335.65883,341.669086 333.796122,341.251089 C332.036897,340.833091 331.209027,339.997097 330.48464,338.847605 C329.760254,337.593614 328.518449,336.65312 329.346319,333.936139 L335.348378,313.872279 L325,313.872279 L328.414965,302.377358 L338.763343,302.377358 L341.557405,293.076923 L331.209027,293.076923 L334.520508,282.104499 L334.31354,282 Z M365.700875,262.165457 L384.327956,262.165457 L380.912991,273.555878 L355.455981,273.555878 L352.661919,275.959361 C351.420113,277.108853 351.109662,276.690856 349.557405,277.526851 C348.108632,278.258345 345.107603,279.721335 341.175219,279.721335 L333,279.721335 L336.311481,268.748911 L338.795092,268.748911 C340.864767,268.748911 342.31354,268.539913 343.037927,268.121916 C343.865797,267.599419 344.797151,266.449927 345.728505,264.56894 L350.385275,256 L368.908872,256 L365.700875,262.269956 L365.700875,262.165457 Z M400.808726,280.975327 C400.808726,280.975327 405.879431,276.272859 414.572069,274.809869 C416.538261,274.391872 428.956314,274.600871 428.956314,274.600871 L430.819023,268.330914 L404.637626,268.330914 L400.808726,281.079826 L400.808726,280.975327 Z M425.437866,285.782293 L399.463436,285.782293 L397.91118,291.111756 L420.470644,291.111756 C423.161223,290.798258 423.678642,291.216255 423.885609,291.007257 L425.54135,285.782293 L425.437866,285.782293 Z M391.702153,256.104499 L407.535171,256.104499 L405.258528,264.150943 C405.258528,264.150943 410.22575,260.075472 413.744198,258.612482 C417.262647,257.358491 425.127414,256.104499 425.127414,256.104499 L450.791393,256 L441.995271,285.468795 C440.546498,290.484761 438.787274,293.724238 437.752436,295.291727 C436.821082,296.754717 435.68276,298.113208 433.406117,299.367199 C431.232958,300.516691 429.266766,301.248186 427.404058,301.352685 C425.748317,301.457184 423.057739,301.561684 419.53929,301.561684 L394.806666,301.561684 L387.873253,324.865022 C387.25235,327.164006 386.941899,328.313498 387.355834,328.940493 C387.666285,329.46299 388.597639,330.089985 389.735961,330.089985 L400.601758,329.044993 L396.876342,341.793904 L384.665256,341.793904 C380.732872,341.793904 377.93881,341.689405 375.972618,341.584906 C374.10991,341.375907 372.143718,341.584906 370.798429,340.539913 C369.660107,339.49492 367.900883,338.13643 368.004367,336.777939 C368.10785,335.523948 368.625269,333.433962 369.45314,330.507983 L391.702153,256.104499 Z\\\" id=\\\"Shape\\\" fill=\\\"#FEFEFE\\\"></path> <path d=\\\"M437.840227,303 L436.391454,310.105951 C435.770551,312.300435 435.253132,313.972424 433.597391,315.435414 C431.838167,316.898403 429.871975,318.465893 425.111721,318.465893 L416.3156,318.88389 L416.212116,326.825835 C416.108632,329.020319 416.729535,328.811321 417.039986,329.229318 C417.453921,329.647315 417.764373,329.751814 418.178308,329.960813 L420.97237,329.751814 L429.354556,329.333817 L425.836108,341.037736 L416.212116,341.037736 C409.48567,341.037736 404.414965,340.828737 402.862708,339.574746 C401.206968,338.529753 401,337.275762 401,334.976778 L401.620903,303.835994 L417.039986,303.835994 L416.833019,310.21045 L420.558435,310.21045 C421.80024,310.21045 422.731594,310.105951 423.249013,309.792453 C423.766432,309.478955 424.076883,308.956459 424.283851,308.224964 L425.836108,303.208999 L437.94371,303.208999 L437.840227,303 Z M218.470396,147 C217.952978,149.507983 208.018534,195.592163 208.018534,195.592163 C205.845375,204.892598 204.293118,211.580552 199.118929,215.865022 C196.117899,218.373004 192.599451,219.522496 188.563583,219.522496 C182.044105,219.522496 178.318689,216.283019 177.697786,210.117562 L177.594302,208.027576 C177.594302,208.027576 179.560494,195.592163 179.560494,195.487663 C179.560494,195.487663 189.908872,153.478955 191.771581,147.940493 C191.875064,147.626996 191.875064,147.417997 191.875064,147.313498 C171.695727,147.522496 168.073794,147.313498 167.866827,147 C167.763343,147.417997 167.245924,150.030479 167.245924,150.030479 L156.690578,197.36865 L155.759224,201.339623 L154,214.506531 C154,218.373004 154.724386,221.612482 156.276643,224.224964 C161.140381,232.793904 174.903724,234.047896 182.665008,234.047896 C192.702935,234.047896 202.119959,231.853411 208.43247,227.986938 C219.505234,221.403483 222.40278,211.058055 224.886391,201.966618 L226.128196,197.264151 C226.128196,197.264151 236.787026,153.687954 238.649734,148.044993 C238.753218,147.731495 238.753218,147.522496 238.856702,147.417997 C224.162004,147.522496 219.919169,147.417997 218.470396,147.104499 L218.470396,147 Z M277.499056,233.622642 C270.358675,233.518142 267.771581,233.518142 259.389394,233.936139 L259.078943,233.309144 C259.803329,230.069666 260.6312,226.934688 261.252102,223.69521 L262.28694,219.306241 C263.839197,212.513788 265.28797,204.467344 265.494937,202.063861 C265.701905,200.600871 266.11584,196.943396 261.976489,196.943396 C260.217264,196.943396 258.45804,197.77939 256.595332,198.615385 C255.560494,202.272859 253.594302,212.513788 252.559465,217.111756 C250.489789,226.934688 250.386305,228.08418 249.454951,232.891147 L248.834048,233.518142 C241.4867,233.413643 238.899605,233.413643 230.413935,233.83164 L230,233.100145 C231.448773,227.248186 232.794062,221.396226 234.139351,215.544267 C237.6578,199.764877 238.589154,193.703919 239.520508,185.657475 L240.244894,185.239478 C248.523597,184.089985 250.489789,183.776488 259.492878,182 L260.217264,182.835994 L258.871975,187.851959 C260.424232,186.911466 261.873005,185.970972 263.425262,185.239478 C267.668097,183.149492 272.324867,182.522496 274.911962,182.522496 C278.844345,182.522496 283.190664,183.671988 284.949888,188.269956 C286.605629,192.345428 285.570791,197.361393 283.294148,207.288824 L282.155826,212.30479 C279.879183,223.381713 279.465248,225.367199 278.223443,232.891147 L277.395572,233.518142 L277.499056,233.622642 Z M306.558435,233.650218 C302.212116,233.650218 299.418054,233.545718 296.727476,233.650218 C294.036897,233.650218 291.449803,233.859216 287.413935,233.963716 L287.206968,233.650218 L287,233.232221 C288.138322,229.05225 288.655741,227.58926 289.276643,226.12627 C289.794062,224.66328 290.311481,223.20029 291.346319,218.91582 C292.588124,213.377358 293.415995,209.510885 293.933413,206.062409 C294.554316,202.822932 294.864767,200.001451 295.278703,196.761974 L295.589154,196.552975 L295.899605,196.239478 C300.245924,195.612482 302.936502,195.194485 305.730565,194.776488 C308.524627,194.358491 311.422173,193.835994 315.871975,193 L316.078943,193.417997 L316.182427,193.835994 C315.354556,197.28447 314.526686,200.732946 313.698816,204.181422 C312.870946,207.629898 312.043075,211.078374 311.318689,214.526851 C309.766432,221.8418 309.042046,224.558781 308.731594,226.544267 C308.317659,228.425254 308.214175,229.365747 307.593273,233.127721 L307.179338,233.441219 L306.765402,233.754717 L306.558435,233.650218 Z M352.499319,207.975327 C352.188868,209.856313 350.533127,216.857765 348.359968,219.783745 C346.807711,221.978229 345.048487,223.33672 342.978811,223.33672 C342.357909,223.33672 338.83946,223.33672 338.735976,218.007257 C338.735976,215.394775 339.253395,212.677794 339.874298,209.751814 C341.737006,201.287373 344.013649,194.285922 349.705257,194.285922 C354.15506,194.285922 354.465511,199.510885 352.499319,207.975327 Z M371.229884,208.811321 C373.713495,197.734398 371.747303,192.509434 369.367176,189.374456 C365.64176,184.567489 359.018798,183 352.188868,183 C348.049517,183 338.322041,183.417997 330.664241,190.523948 C325.179601,195.644412 322.592506,202.645864 321.143733,209.333817 C319.591476,216.12627 317.832252,228.352685 329.008501,232.950653 C332.423466,234.413643 337.390687,234.83164 340.598684,234.83164 C348.773903,234.83164 357.156089,232.532656 363.4686,225.844702 C368.332338,220.41074 370.505497,212.259797 371.333368,208.811321 L371.229884,208.811321 Z M545.661919,234.891147 C536.969281,234.786647 534.48567,234.786647 526.517419,235.204644 L526,234.577649 C528.173159,226.322206 530.346319,217.962264 532.312511,209.602322 C534.796122,198.734398 535.417024,194.13643 536.244894,187.761974 L536.865797,187.239478 C545.454951,185.985486 547.835078,185.671988 556.838167,184 L557.045135,184.731495 C555.389394,191.628447 553.837137,198.4209 552.181397,205.213353 C548.869916,219.529753 547.731594,226.844702 546.489789,234.36865 L545.661919,234.995646 L545.661919,234.891147 Z\\\" id=\\\"Shape\\\" fill=\\\"#FEFEFE\\\"></path> <path d=\\\"M533.159909,209.373777 C532.745974,211.150265 531.090233,218.256216 528.917074,221.182195 C527.468301,223.272181 523.949852,224.630672 521.983661,224.630672 C521.362758,224.630672 517.947793,224.630672 517.740826,219.405708 C517.740826,216.793226 518.258244,214.076245 518.879147,211.150265 C520.741855,202.894822 523.018498,195.893371 528.710106,195.893371 C533.159909,195.893371 535.126101,201.013836 533.159909,209.478277 L533.159909,209.373777 Z M550.234733,210.209772 C552.718344,199.132849 542.576933,209.269278 541.024677,205.611804 C538.541066,199.864344 540.093322,188.369423 530.158879,184.50295 C526.329979,182.935461 517.32689,184.920947 509.66909,192.026898 C504.287934,197.042863 501.597355,204.044315 500.148582,210.732268 C498.596326,217.420222 496.837101,229.751136 507.909866,234.035606 C511.428315,235.603095 514.636312,236.021092 517.844309,235.812094 C529.020558,235.185098 537.506228,218.151717 543.818739,211.463763 C548.682476,206.1343 549.510347,213.449249 550.234733,210.209772 Z M420.292089,233.622642 C413.151708,233.518142 410.668097,233.518142 402.28591,233.936139 L401.975459,233.309144 C402.699846,230.069666 403.527716,226.934688 404.252102,223.69521 L405.183456,219.306241 C406.735713,212.513788 408.28797,204.467344 408.391454,202.063861 C408.598421,200.600871 409.012356,196.943396 404.976489,196.943396 C403.217264,196.943396 401.354556,197.77939 399.595332,198.615385 C398.663978,202.272859 396.594302,212.513788 395.559465,217.111756 C393.593273,226.934688 393.386305,228.08418 392.454951,232.891147 L391.834048,233.518142 C384.4867,233.413643 381.899605,233.413643 373.413935,233.83164 L373,233.100145 C374.448773,227.248186 375.794062,221.396226 377.139351,215.544267 C380.6578,199.764877 381.48567,193.703919 382.520508,185.657475 L383.141411,185.239478 C391.420113,184.089985 393.489789,183.776488 402.389394,182 L403.113781,182.835994 L401.871975,187.851959 C403.320748,186.911466 404.873005,185.970972 406.321778,185.239478 C410.564613,183.149492 415.221383,182.522496 417.808478,182.522496 C421.740862,182.522496 425.983697,183.671988 427.846405,188.269956 C429.502145,192.345428 428.363824,197.361393 426.08718,207.288824 L424.948859,212.30479 C422.568732,223.381713 422.25828,225.367199 421.016475,232.891147 L420.188605,233.518142 L420.292089,233.622642 Z M482.293118,147.104499 L476.291059,147.208999 C460.768492,147.417997 454.559465,147.313498 452.075854,147 C451.868886,148.149492 451.454951,150.134978 451.454951,150.134978 C451.454951,150.134978 445.866827,176.050798 445.866827,176.155298 C445.866827,176.155298 432.620903,231.330914 432,233.943396 C445.556375,233.734398 451.041016,233.734398 453.421143,234.047896 C453.938562,231.435414 457.043075,216.07402 457.146559,216.07402 C457.146559,216.07402 459.837137,204.788099 459.940621,204.370102 C459.940621,204.370102 460.768492,203.22061 461.596362,202.698113 L462.838167,202.698113 C474.531835,202.698113 487.674275,202.698113 498.022653,195.069666 C505.05955,189.844702 509.819804,182.007257 511.992964,172.602322 C512.510383,170.303338 512.924318,167.586357 512.924318,164.764877 C512.924318,161.107402 512.199931,157.554427 510.130256,154.732946 C504.852583,147.313498 494.400721,147.208999 482.293118,147.104499 Z M490.054402,174.169811 C488.812597,179.917271 485.08718,184.828737 480.326926,187.127721 C476.394543,189.113208 471.634289,189.322206 466.667067,189.322206 L463.45907,189.322206 L463.666037,188.068215 C463.666037,188.068215 469.564613,162.152395 469.564613,162.256894 L469.771581,160.898403 L469.875064,159.853411 L472.255191,160.062409 C472.255191,160.062409 484.466278,161.107402 484.673245,161.107402 C489.433499,162.988389 491.503175,167.795356 490.054402,174.169811 Z M617.261369,182.835994 L616.536983,182 C607.740862,183.776488 606.085121,184.089985 598.013386,185.239478 L597.392483,185.866473 C597.392483,185.970972 597.288999,186.075472 597.288999,186.28447 L597.288999,186.179971 C591.28694,200.287373 591.390424,197.256894 586.526686,208.333817 C586.526686,207.811321 586.526686,207.497823 586.423202,206.975327 L585.181397,182.940493 L584.45701,182.104499 C575.14347,183.880987 574.936502,184.194485 566.450832,185.343977 L565.82993,185.970972 C565.726446,186.28447 565.726446,186.597968 565.726446,186.911466 L565.82993,187.015965 C566.864767,192.554427 566.6578,191.300435 567.692638,199.973875 C568.210057,204.258345 568.830959,208.542816 569.348378,212.722787 C570.176248,219.828737 570.693667,223.277213 571.728505,234.040639 C565.933413,243.654572 564.588124,247.312046 559,255.776488 L559.310451,256.612482 C567.692638,256.298984 569.555346,256.298984 575.764373,256.298984 L577.109662,254.731495 C581.766432,244.595065 617.364853,182.940493 617.364853,182.940493 L617.261369,182.835994 Z M314.543608,189.75837 C319.303862,186.414394 319.924765,181.816425 315.888897,179.412942 C311.85303,177.009459 304.712649,177.740954 299.952395,181.084931 C295.192141,184.324408 294.674722,188.922376 298.71059,191.430359 C302.642973,193.729343 309.783354,193.102347 314.543608,189.75837 Z\\\" id=\\\"Shape\\\" fill=\\\"#FEFEFE\\\"></path> <path d=\\\"M575.734683,256.104499 L568.80127,268.121916 C566.628111,272.197388 562.488759,275.332366 556.072765,275.332366 L545,275.123367 L548.207997,264.255443 L550.381157,264.255443 C551.519478,264.255443 552.347349,264.150943 552.968251,263.837446 C553.589154,263.628447 553.899605,263.21045 554.417024,262.583454 L558.556375,256 L575.838167,256 L575.734683,256.104499 Z\\\" id=\\\"Shape\\\" fill=\\\"#FEFEFE\\\"></path> </g> </g>\";\n  var amex_single = \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" width=\\\"750\\\" height=\\\"471\\\" viewBox=\\\"0 0 750 471\\\" enable-background=\\\"new 0 0 752 471\\\" xml:space=\\\"preserve\\\"><title>Slice 1</title><desc>Created with Sketch.</desc><g><g><path fill=\\\"#2557D6\\\" d=\\\"M554.594,130.608l-14.521,35.039h29.121L554.594,130.608z M387.03,152.321c2.738-1.422,4.349-4.515,4.349-8.356c0-3.764-1.693-6.49-4.431-7.771c-2.492-1.42-6.328-1.584-10.006-1.584h-25.978v19.523h25.63C380.7,154.134,384.131,154.074,387.03,152.321z M54.142,130.608l-14.357,35.039h28.8L54.142,130.608z M722.565,355.08h-40.742v-18.852h40.578c4.023,0,6.84-0.525,8.537-2.177c1.471-1.358,2.494-3.336,2.494-5.733c0-2.562-1.023-4.596-2.578-5.813c-1.529-1.342-3.76-1.953-7.434-1.953c-19.81-0.67-44.523,0.609-44.523-27.211c0-12.75,8.131-26.172,30.27-26.172h42.025v-17.492h-39.045c-11.783,0-20.344,2.81-26.406,7.181v-7.181h-57.752c-9.233,0-20.074,2.279-25.201,7.181v-7.181H499.655v7.181c-8.207-5.898-22.057-7.181-28.447-7.181H403.18v7.181c-6.492-6.262-20.935-7.181-29.734-7.181h-76.134l-17.42,18.775l-16.318-18.775H149.847v122.675h111.586l17.95-19.076l16.91,19.076l68.78,0.059v-28.859h6.764c9.125,0.145,19.889-0.223,29.387-4.311v33.107h56.731v-31.976h2.736c3.492,0,3.838,0.146,3.838,3.621v28.348h172.344c10.941,0,22.38-2.786,28.712-7.853v7.853h54.668c11.375,0,22.485-1.588,30.938-5.653v-22.853C746.069,351.297,736.079,355.08,722.565,355.08z M372.734,326.113h-26.325v29.488h-41.006L279.425,326.5l-26.997,29.102h-83.569v-87.914h84.855l25.955,28.818l26.835-28.818h67.414c16.743,0,35.555,4.617,35.555,28.963C409.473,321.072,391.176,326.113,372.734,326.113z M499.323,322.127c2.98,4.291,3.41,8.297,3.496,16.047v17.428h-21.182v-10.998c0-5.289,0.512-13.121-3.41-17.209c-3.08-3.149-7.781-3.901-15.48-3.901h-22.545v32.108h-21.198v-87.914h48.706c10.685,0,18.462,0.472,25.386,4.148c6.658,4.006,10.848,9.494,10.848,19.523c-0.002,14.031-9.399,21.19-14.953,23.389C493.684,316.473,497.522,319.566,499.323,322.127z M586.473,285.869h-49.404v15.982h48.197v17.938h-48.197v17.492l49.404,0.078v18.242h-70.414v-87.914h70.414V285.869z M640.686,355.6h-41.09v-18.852h40.926c4.002,0,6.84-0.527,8.619-2.178c1.449-1.359,2.492-3.336,2.492-5.73c0-2.564-1.129-4.598-2.574-5.818c-1.615-1.34-3.842-1.948-7.514-1.948c-19.73-0.673-44.439,0.606-44.439-27.212c0-12.752,8.047-26.174,30.164-26.174h42.297v18.709h-38.703c-3.836,0-6.33,0.146-8.451,1.592c-2.313,1.423-3.17,3.535-3.17,6.322c0,3.316,1.963,5.574,4.615,6.549c2.228,0.771,4.617,0.996,8.211,0.996l11.359,0.308c11.449,0.274,19.313,2.25,24.092,7.069c4.105,4.232,6.311,9.578,6.311,18.625C673.829,346.771,661.963,355.6,640.686,355.6z M751.192,343.838L751.192,343.838L751.192,343.838L751.192,343.838z M477.061,287.287c-2.549-1.508-6.311-1.588-10.066-1.588h-25.979v19.744h25.631c4.104,0,7.594-0.144,10.414-1.812c2.734-1.646,4.371-4.678,4.371-8.438C481.432,291.434,479.795,288.711,477.061,287.287z M712.784,285.697c-3.838,0-6.389,0.145-8.537,1.588c-2.227,1.426-3.081,3.537-3.081,6.326c0,3.315,1.879,5.572,4.612,6.549c2.228,0.771,4.615,0.996,8.129,0.996l11.437,0.303c11.537,0.285,19.242,2.262,23.938,7.08c0.855,0.668,1.369,1.42,1.957,2.174v-25.014h-38.453L712.784,285.697L712.784,285.697z M373.47,285.697h-27.509v22.391h27.265c8.105,0,13.146-4.006,13.149-11.611C386.372,288.789,381.086,285.697,373.47,285.697z M189.872,285.697v15.984h46.315v17.938h-46.315v17.49h51.87l24.1-25.791l-23.076-25.621H189.872L189.872,285.697z M325.321,347.176v-70.482l-32.391,34.673L325.321,347.176z M191.649,206.025v15.148h176.263l-0.082-32.046h3.411c2.39,0.083,3.084,0.302,3.084,4.229v27.818h91.164v-7.461c7.353,3.924,18.789,7.461,33.838,7.461h38.353l8.209-19.522h18.197l8.026,19.522h73.906V202.63l11.189,18.543h59.227V98.59h-58.611v14.477l-8.207-14.477h-60.143v14.477l-7.537-14.477h-81.24c-13.6,0-25.551,1.89-35.207,7.158V98.59h-56.063v7.158c-6.146-5.43-14.519-7.158-23.826-7.158H180.784l-13.742,31.662L152.928,98.59H88.417v14.477L81.329,98.59H26.312L0.763,156.874v46.621l37.779-87.894h31.346l35.88,83.217v-83.217h34.435l27.61,59.625l25.365-59.625h35.126v87.894h-21.625l-0.079-68.837l-30.593,68.837h-18.524l-30.671-68.898v68.898H83.899l-8.106-19.605H31.865l-8.19,19.605H0.762v17.682h36.049l8.128-19.523h18.198l8.106,19.523h70.925V206.25l6.33,14.989h36.819L191.649,206.025z M469.401,125.849c6.818-7.015,17.5-10.25,32.039-10.25h20.424v18.833h-19.996c-7.696,0-12.047,1.14-16.233,5.208c-3.599,3.7-6.066,10.696-6.066,19.908c0,9.417,1.881,16.206,5.801,20.641c3.248,3.478,9.152,4.533,14.705,4.533h9.478l29.733-69.12h31.611l35.719,83.134v-83.133h32.123l37.086,61.213v-61.213h21.611v87.891h-29.898l-39.989-65.968v65.968h-42.968l-8.209-19.605h-43.827l-7.966,19.605h-24.688c-10.254,0-23.238-2.258-30.59-9.722c-7.416-7.462-11.271-17.571-11.271-33.553C458.026,147.182,460.329,135.266,469.401,125.849z M426.006,115.6h21.526v87.894h-21.526V115.6z M328.951,115.6h48.525c10.779,0,18.727,0.285,25.547,4.21c6.674,3.926,10.676,9.658,10.676,19.46c0,14.015-9.393,21.254-14.864,23.429c4.614,1.75,8.559,4.841,10.438,7.401c2.979,4.372,3.492,8.277,3.492,16.126v17.267h-21.279l-0.08-11.084c0-5.29,0.508-12.896-3.33-17.122c-3.082-3.09-7.782-3.763-15.379-3.763H350.05v31.97h-21.098L328.951,115.6L328.951,115.6z M243.902,115.6h70.479v18.303h-49.379v15.843h48.193v18.017h-48.193v17.553h49.379v18.177h-70.479V115.6L243.902,115.6z\\\"/></g></g></svg>\";\n  var visa_single = \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" width=\\\"750px\\\" height=\\\"471px\\\" viewBox=\\\"0 0 750 471\\\" enable-background=\\\"new 0 0 750 471\\\" xml:space=\\\"preserve\\\"><title>Slice 1</title><desc>Created with Sketch.</desc><g id=\\\"visa\\\" sketch:type=\\\"MSLayerGroup\\\"><path id=\\\"Shape\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#0E4595\\\" d=\\\"M278.198,334.228l33.36-195.763h53.358l-33.384,195.763H278.198L278.198,334.228z\\\"/><path id=\\\"path13\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#0E4595\\\" d=\\\"M524.307,142.687c-10.57-3.966-27.135-8.222-47.822-8.222c-52.725,0-89.863,26.551-90.18,64.604c-0.297,28.129,26.514,43.821,46.754,53.185c20.77,9.597,27.752,15.716,27.652,24.283c-0.133,13.123-16.586,19.116-31.924,19.116c-21.355,0-32.701-2.967-50.225-10.274l-6.877-3.112l-7.488,43.823c12.463,5.466,35.508,10.199,59.438,10.445c56.09,0,92.502-26.248,92.916-66.884c0.199-22.27-14.016-39.216-44.801-53.188c-18.65-9.056-30.072-15.099-29.951-24.269c0-8.137,9.668-16.838,30.559-16.838c17.447-0.271,30.088,3.534,39.936,7.5l4.781,2.259L524.307,142.687\\\"/><path id=\\\"Path\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#0E4595\\\" d=\\\"M661.615,138.464h-41.23c-12.773,0-22.332,3.486-27.941,16.234l-79.244,179.402h56.031c0,0,9.16-24.121,11.232-29.418c6.123,0,60.555,0.084,68.336,0.084c1.596,6.854,6.492,29.334,6.492,29.334h49.512L661.615,138.464L661.615,138.464z M596.198,264.872c4.414-11.279,21.26-54.724,21.26-54.724c-0.314,0.521,4.381-11.334,7.074-18.684l3.607,16.878c0,0,10.217,46.729,12.352,56.527h-44.293V264.872L596.198,264.872z\\\"/><path id=\\\"path16\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#0E4595\\\" d=\\\"M232.903,138.464L180.664,271.96l-5.565-27.129c-9.726-31.274-40.025-65.157-73.898-82.12l47.767,171.204l56.455-0.064l84.004-195.386L232.903,138.464\\\"/><path id=\\\"path18\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#F2AE14\\\" d=\\\"M131.92,138.464H45.879l-0.682,4.073c66.939,16.204,111.232,55.363,129.618,102.415l-18.709-89.96C152.877,142.596,143.509,138.896,131.92,138.464\\\"/></g></svg>\";\n  var diners_single = \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" width=\\\"750\\\" height=\\\"471\\\" viewBox=\\\"0 0 750 471\\\" enable-background=\\\"new 0 0 750 471\\\" xml:space=\\\"preserve\\\"><title>diners</title><desc>Created with Sketch.</desc><g id=\\\"diners\\\" sketch:type=\\\"MSLayerGroup\\\"><path id=\\\"Shape-path\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#0079BE\\\" d=\\\"M584.934,236.947c0-99.416-82.98-168.133-173.896-168.1h-78.241c-92.003-0.033-167.73,68.705-167.73,168.1c0,90.931,75.729,165.641,167.73,165.203h78.241C501.951,402.587,584.934,327.857,584.934,236.947L584.934,236.947z\\\"/><path id=\\\"Shape-path_1_\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#FFFFFF\\\" d=\\\"M333.281,82.932c-84.069,0.026-152.193,68.308-152.215,152.58c0.021,84.258,68.145,152.532,152.215,152.559c84.088-0.026,152.229-68.301,152.239-152.559C485.508,151.238,417.369,82.958,333.281,82.932L333.281,82.932z\\\"/><path id=\\\"Path\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#0079BE\\\" d=\\\"M237.066,235.098c0.08-41.18,25.747-76.296,61.94-90.25v180.479C262.813,311.381,237.145,276.283,237.066,235.098z M368.066,325.373V144.848c36.208,13.921,61.915,49.057,61.981,90.256C429.981,276.316,404.274,311.426,368.066,325.373z\\\"/></g></svg>\";\n  var discover_single = \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" width=\\\"780px\\\" height=\\\"501px\\\" viewBox=\\\"0 0 780 501\\\" enable-background=\\\"new 0 0 780 501\\\" xml:space=\\\"preserve\\\"><title>discover</title><desc>Created with Sketch.</desc><g id=\\\"Page-1\\\" sketch:type=\\\"MSPage\\\"><g id=\\\"discover\\\" sketch:type=\\\"MSLayerGroup\\\"><path fill=\\\"#F47216\\\" d=\\\"M409.412,197.758c30.938,0,56.02,23.58,56.02,52.709v0.033c0,29.129-25.082,52.742-56.02,52.742c-30.941,0-56.022-23.613-56.022-52.742v-0.033C353.39,221.338,378.471,197.758,409.412,197.758L409.412,197.758z\\\"/><path d=\\\"M321.433,198.438c8.836,0,16.247,1.785,25.269,6.09v22.752c-8.544-7.863-15.955-11.154-25.757-11.154c-19.265,0-34.413,15.015-34.413,34.051c0,20.074,14.681,34.195,35.368,34.195c9.313,0,16.586-3.12,24.802-10.856v22.764c-9.343,4.141-16.912,5.775-25.757,5.775c-31.277,0-55.581-22.597-55.581-51.737C265.363,221.49,290.314,198.438,321.433,198.438L321.433,198.438z\\\"/><path d=\\\"M224.32,199.064c11.546,0,22.109,3.721,30.942,10.994l-10.748,13.248c-5.351-5.646-10.411-8.027-16.563-8.027c-8.854,0-15.301,4.745-15.301,10.988c0,5.354,3.618,8.188,15.944,12.482c23.364,8.043,30.289,15.176,30.289,30.926c0,19.193-14.976,32.554-36.319,32.554c-15.631,0-26.993-5.795-36.457-18.871l13.268-12.031c4.73,8.609,12.622,13.223,22.42,13.223c9.163,0,15.947-5.951,15.947-13.984c0-4.164-2.056-7.733-6.158-10.258c-2.066-1.195-6.158-2.977-14.199-5.646c-19.292-6.538-25.91-13.527-25.91-27.186C191.474,211.25,205.688,199.064,224.32,199.064L224.32,199.064z\\\"/><polygon points=\\\"459.043,200.793 481.479,200.793 509.563,267.385 538.01,200.793 560.276,200.793 514.783,302.479 503.729,302.479 \\\"/><polygon points=\\\"157.83,200.945 178.371,200.945 178.371,300.088 157.83,300.088 \\\"/><polygon points=\\\"569.563,200.945 627.815,200.945 627.815,217.744 590.09,217.744 590.09,239.75 626.426,239.75 626.426,256.541 590.09,256.541 590.09,283.303 627.815,283.303 627.815,300.088 569.563,300.088 \\\"/><path d=\\\"M685.156,258.322c15.471-2.965,23.984-12.926,23.984-28.105c0-18.562-13.576-29.271-37.266-29.271H641.42v99.143h20.516V260.26h2.68l28.43,39.828h25.26L685.156,258.322z M667.938,246.586h-6.002v-30.025h6.326c12.791,0,19.744,5.049,19.744,14.697C688.008,241.224,681.055,246.586,667.938,246.586z\\\"/><path d=\\\"M91.845,200.945H61.696v99.143h29.992c15.946,0,27.465-3.543,37.573-11.445c12.014-9.36,19.117-23.467,19.117-38.057C148.379,221.327,125.157,200.945,91.845,200.945z M115.842,275.424c-6.454,5.484-14.837,7.879-28.108,7.879H82.22v-65.559h5.513c13.271,0,21.323,2.238,28.108,8.018c7.104,5.956,11.377,15.183,11.377,24.682C127.219,259.957,122.945,269.468,115.842,275.424z\\\"/></g></g></svg>\";\n  var jcb_single = \"<svg version=\\\"1.1\\\" id=\\\"Layer_1\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" width=\\\"750px\\\" height=\\\"471px\\\" viewBox=\\\"0 0 750 471\\\" enable-background=\\\"new 0 0 750 471\\\" xml:space=\\\"preserve\\\"><title>Slice 1</title><desc>Created with Sketch.</desc><g><path id=\\\"path3494\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"#FFFFFF\\\" d=\\\"M617.242,346.766c0,41.615-33.729,75.36-75.357,75.36H132.759V124.245c0-41.626,33.73-75.371,75.364-75.371h409.12V346.766L617.242,346.766L617.242,346.766z\\\"/><linearGradient id=\\\"path3496_1_\\\" gradientUnits=\\\"userSpaceOnUse\\\" x1=\\\"824.7424\\\" y1=\\\"333.7813\\\" x2=\\\"825.7424\\\" y2=\\\"333.7813\\\" gradientTransform=\\\"matrix(132.8743 0 0 -323.0226 -109129.5313 108054.6016)\\\"><stop offset=\\\"0\\\" style=\\\"stop-color:#007B40\\\"/><stop offset=\\\"1\\\" style=\\\"stop-color:#55B330\\\"/></linearGradient><path id=\\\"path3496\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"url(#path3496_1_)\\\" d=\\\"M483.86,242.045c11.686,0.254,23.439-0.516,35.078,0.4c11.787,2.199,14.627,20.043,4.156,25.887c-7.145,3.85-15.633,1.434-23.379,2.113H483.86V242.045L483.86,242.045z M525.694,209.9c2.596,9.164-6.238,17.392-15.064,16.13h-26.77c0.188-8.642-0.367-18.022,0.273-26.209c10.723,0.302,21.547-0.616,32.209,0.48C520.922,201.452,524.756,205.218,525.694,209.9L525.694,209.9z M590.119,73.997c0.498,17.501,0.072,35.927,0.215,53.783c-0.033,72.596,0.07,145.195-0.057,217.789c-0.469,27.207-24.582,50.847-51.6,51.39c-27.045,0.11-54.094,0.017-81.143,0.047v-109.75c29.471-0.153,58.957,0.308,88.416-0.231c13.666-0.858,28.635-9.875,29.271-24.914c1.609-15.103-12.631-25.551-26.152-27.201c-5.197-0.135-5.045-1.515,0-2.117c12.895-2.787,23.021-16.133,19.227-29.499c-3.234-14.058-18.771-19.499-31.695-19.472c-26.352-0.179-52.709-0.025-79.063-0.077c0.17-20.489-0.355-41,0.283-61.474c2.088-26.716,26.807-48.748,53.447-48.27C537.555,73.998,563.838,73.998,590.119,73.997L590.119,73.997z\\\"/><linearGradient id=\\\"path3498_1_\\\" gradientUnits=\\\"userSpaceOnUse\\\" x1=\\\"824.7551\\\" y1=\\\"333.7822\\\" x2=\\\"825.7484\\\" y2=\\\"333.7822\\\" gradientTransform=\\\"matrix(133.4307 0 0 -323.0203 -109887.6875 108053.8203)\\\"><stop offset=\\\"0\\\" style=\\\"stop-color:#1D2970\\\"/><stop offset=\\\"1\\\" style=\\\"stop-color:#006DBA\\\"/></linearGradient><path id=\\\"path3498\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"url(#path3498_1_)\\\" d=\\\"M159.742,125.041c0.673-27.164,24.888-50.611,51.872-51.008c26.945-0.083,53.894-0.012,80.839-0.036c-0.074,90.885,0.146,181.776-0.111,272.657c-1.038,26.834-24.989,49.834-51.679,50.309c-26.996,0.098-53.995,0.014-80.992,0.041V283.551c26.223,6.195,53.722,8.832,80.474,4.723c15.991-2.574,33.487-10.426,38.901-27.016c3.984-14.191,1.741-29.126,2.334-43.691v-33.825h-46.297c-0.208,22.371,0.426,44.781-0.335,67.125c-1.248,13.734-14.849,22.46-27.802,21.994c-16.064,0.17-47.897-11.641-47.897-11.641C158.969,219.305,159.515,166.814,159.742,125.041L159.742,125.041z\\\"/><linearGradient id=\\\"path3500_1_\\\" gradientUnits=\\\"userSpaceOnUse\\\" x1=\\\"824.7424\\\" y1=\\\"333.7813\\\" x2=\\\"825.741\\\" y2=\\\"333.7813\\\" gradientTransform=\\\"matrix(132.9583 0 0 -323.0276 -109347.9219 108056.2656)\\\"><stop offset=\\\"0\\\" style=\\\"stop-color:#6E2B2F\\\"/><stop offset=\\\"1\\\" style=\\\"stop-color:#E30138\\\"/></linearGradient><path id=\\\"path3500\\\" sketch:type=\\\"MSShapeGroup\\\" fill=\\\"url(#path3500_1_)\\\" d=\\\"M309.721,197.39c-2.437,0.517-0.491-8.301-1.114-11.646c0.166-21.15-0.346-42.323,0.284-63.458c2.082-26.829,26.991-48.916,53.738-48.288h78.767c-0.074,90.885,0.145,181.775-0.111,272.657c-1.039,26.834-24.992,49.833-51.682,50.309c-26.998,0.101-53.998,0.015-80.997,0.042V272.707c18.44,15.129,43.5,17.484,66.472,17.525c17.318-0.006,34.535-2.676,51.353-6.67V260.79c-18.953,9.446-41.234,15.446-62.244,10.019c-14.656-3.649-25.294-17.813-25.057-32.937c-1.698-15.729,7.522-32.335,22.979-37.011c19.192-6.008,40.108-1.413,58.096,6.398c3.855,2.018,7.766,4.521,6.225-1.921v-17.899c-30.086-7.158-62.104-9.792-92.33-2.005C325.352,187.902,316.828,191.645,309.721,197.39L309.721,197.39z\\\"/></g></svg>\";\n  var maestro_single = \"<svg id=\\\"Layer_1\\\" data-name=\\\"Layer 1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"482.6\\\" height=\\\"374.31\\\" viewBox=\\\"0 0 482.6 374.31\\\"> <title>maestro</title> <g> <path d=\\\"M278.8,421.77V397c0-9.35-6-15.64-15.55-15.72-5-.08-10.26,1.49-13.9,7-2.73-4.38-7-7-13.07-7a13.08,13.08,0,0,0-11.58,5.87v-4.88h-8.61v39.55h8.69V399.85c0-6.87,3.81-10.51,9.68-10.51,5.71,0,8.61,3.72,8.61,10.42v22h8.69V399.85c0-6.87,4-10.51,9.68-10.51,5.87,0,8.69,3.72,8.69,10.42v22ZM327.28,402V382.23h-8.61V387c-2.73-3.56-6.87-5.79-12.49-5.79-11.09,0-19.77,8.69-19.77,20.77s8.69,20.77,19.77,20.77c5.63,0,9.76-2.23,12.49-5.79v4.8h8.61Zm-32,0c0-6.95,4.55-12.66,12-12.66,7.12,0,11.91,5.46,11.91,12.66s-4.8,12.66-11.91,12.66C299.81,414.66,295.26,408.95,295.26,402ZM511.4,381.19a22.29,22.29,0,0,1,8.49,1.59,20.71,20.71,0,0,1,6.75,4.38,20,20,0,0,1,4.46,6.59,22,22,0,0,1,0,16.52,20,20,0,0,1-4.46,6.59,20.69,20.69,0,0,1-6.75,4.38,23.43,23.43,0,0,1-17,0,20.47,20.47,0,0,1-6.73-4.38,20.21,20.21,0,0,1-4.44-6.59,22,22,0,0,1,0-16.52,20.23,20.23,0,0,1,4.44-6.59,20.48,20.48,0,0,1,6.73-4.38A22.29,22.29,0,0,1,511.4,381.19Zm0,8.14a12.84,12.84,0,0,0-4.91.93,11.62,11.62,0,0,0-3.92,2.6,12.13,12.13,0,0,0-2.6,4,14.39,14.39,0,0,0,0,10.28,12.11,12.11,0,0,0,2.6,4,11.62,11.62,0,0,0,3.92,2.6,13.46,13.46,0,0,0,9.83,0,11.86,11.86,0,0,0,3.94-2.6,12,12,0,0,0,2.62-4,14.39,14.39,0,0,0,0-10.28,12,12,0,0,0-2.62-4,11.86,11.86,0,0,0-3.94-2.6A12.84,12.84,0,0,0,511.4,389.32ZM374.1,402c-.08-12.33-7.69-20.77-18.78-20.77-11.58,0-19.69,8.44-19.69,20.77,0,12.58,8.44,20.77,20.27,20.77,6,0,11.42-1.49,16.22-5.54l-4.22-6.37A18.84,18.84,0,0,1,356.4,415c-5.54,0-10.59-2.56-11.83-9.68h29.37C374,404.23,374.1,403.16,374.1,402Zm-29.45-3.47c.91-5.71,4.38-9.6,10.51-9.6,5.54,0,9.1,3.47,10,9.6Zm65.69-6.2A25.49,25.49,0,0,0,398,388.93c-4.72,0-7.53,1.74-7.53,4.63,0,2.65,3,3.39,6.7,3.89l4.05.58c8.61,1.24,13.82,4.88,13.82,11.83,0,7.53-6.62,12.91-18,12.91-6.45,0-12.41-1.66-17.13-5.13l4.05-6.7a21.07,21.07,0,0,0,13.16,4.14c5.87,0,9-1.74,9-4.8,0-2.23-2.23-3.47-6.95-4.14l-4.05-.58c-8.85-1.24-13.65-5.21-13.65-11.67,0-7.86,6.45-12.66,16.46-12.66,6.29,0,12,1.41,16.13,4.14Zm41.35-2.23H437.62V408c0,4,1.41,6.62,5.71,6.62a15.89,15.89,0,0,0,7.61-2.23l2.48,7.36a20.22,20.22,0,0,1-10.76,3.06c-10.18,0-13.73-5.46-13.73-14.65v-18h-8v-7.86h8v-12h8.69v12h14.06Zm29.78-8.85a18.38,18.38,0,0,1,6.12,1.08l-2.65,8.11a14,14,0,0,0-5.38-1c-5.63,0-8.44,3.64-8.44,10.18v22.17h-8.6V382.23H471V387a11.66,11.66,0,0,1,10.42-5.79Z\\\" transform=\\\"translate(-132.9 -48.5)\\\"/> <g id=\\\"_Group_\\\" data-name=\\\"&lt;Group&gt;\\\"> <rect x=\\\"176.05\\\" y=\\\"31.89\\\" width=\\\"130.5\\\" height=\\\"234.51\\\" fill=\\\"#7673c0\\\"/> <path id=\\\"_Path_\\\" data-name=\\\"&lt;Path&gt;\\\" d=\\\"M317.24,197.64a148.88,148.88,0,0,1,57-117.26,149.14,149.14,0,1,0,0,234.51A148.88,148.88,0,0,1,317.24,197.64Z\\\" transform=\\\"translate(-132.9 -48.5)\\\" fill=\\\"#eb001b\\\"/> <path d=\\\"M615.5,197.64A149.14,149.14,0,0,1,374.2,314.9a149.16,149.16,0,0,0,0-234.51A149.14,149.14,0,0,1,615.5,197.64Z\\\" transform=\\\"translate(-132.9 -48.5)\\\" fill=\\\"#00a1df\\\"/> </g> </g></svg>\";\n  var mastercard_single = \"<svg id=\\\"Layer_1\\\" data-name=\\\"Layer 1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"482.51\\\" height=\\\"374\\\" viewBox=\\\"0 0 482.51 374\\\"> <title>mastercard</title> <g> <path d=\\\"M220.13,421.67V396.82c0-9.53-5.8-15.74-15.32-15.74-5,0-10.35,1.66-14.08,7-2.9-4.56-7-7-13.25-7a14.07,14.07,0,0,0-12,5.8v-5h-7.87v39.76h7.87V398.89c0-7,4.14-10.35,9.94-10.35s9.11,3.73,9.11,10.35v22.78h7.87V398.89c0-7,4.14-10.35,9.94-10.35s9.11,3.73,9.11,10.35v22.78Zm129.22-39.35h-14.5v-12H327v12h-8.28v7H327V408c0,9.11,3.31,14.5,13.25,14.5A23.17,23.17,0,0,0,351,419.6l-2.49-7a13.63,13.63,0,0,1-7.46,2.07c-4.14,0-6.21-2.49-6.21-6.63V389h14.5v-6.63Zm73.72-1.24a12.39,12.39,0,0,0-10.77,5.8v-5h-7.87v39.76h7.87V399.31c0-6.63,3.31-10.77,8.7-10.77a24.24,24.24,0,0,1,5.38.83l2.49-7.46a28,28,0,0,0-5.8-.83Zm-111.41,4.14c-4.14-2.9-9.94-4.14-16.15-4.14-9.94,0-16.15,4.56-16.15,12.43,0,6.63,4.56,10.35,13.25,11.6l4.14.41c4.56.83,7.46,2.49,7.46,4.56,0,2.9-3.31,5-9.53,5a21.84,21.84,0,0,1-13.25-4.14l-4.14,6.21c5.8,4.14,12.84,5,17,5,11.6,0,17.81-5.38,17.81-12.84,0-7-5-10.35-13.67-11.6l-4.14-.41c-3.73-.41-7-1.66-7-4.14,0-2.9,3.31-5,7.87-5,5,0,9.94,2.07,12.43,3.31Zm120.11,16.57c0,12,7.87,20.71,20.71,20.71,5.8,0,9.94-1.24,14.08-4.56l-4.14-6.21a16.74,16.74,0,0,1-10.35,3.73c-7,0-12.43-5.38-12.43-13.25S445,389,452.07,389a16.74,16.74,0,0,1,10.35,3.73l4.14-6.21c-4.14-3.31-8.28-4.56-14.08-4.56-12.43-.83-20.71,7.87-20.71,19.88h0Zm-55.5-20.71c-11.6,0-19.47,8.28-19.47,20.71s8.28,20.71,20.29,20.71a25.33,25.33,0,0,0,16.15-5.38l-4.14-5.8a19.79,19.79,0,0,1-11.6,4.14c-5.38,0-11.18-3.31-12-10.35h29.41v-3.31c0-12.43-7.46-20.71-18.64-20.71h0Zm-.41,7.46c5.8,0,9.94,3.73,10.35,9.94H364.68c1.24-5.8,5-9.94,11.18-9.94ZM268.59,401.79V381.91h-7.87v5c-2.9-3.73-7-5.8-12.84-5.8-11.18,0-19.47,8.7-19.47,20.71s8.28,20.71,19.47,20.71c5.8,0,9.94-2.07,12.84-5.8v5h7.87V401.79Zm-31.89,0c0-7.46,4.56-13.25,12.43-13.25,7.46,0,12,5.8,12,13.25,0,7.87-5,13.25-12,13.25-7.87.41-12.43-5.8-12.43-13.25Zm306.08-20.71a12.39,12.39,0,0,0-10.77,5.8v-5h-7.87v39.76H532V399.31c0-6.63,3.31-10.77,8.7-10.77a24.24,24.24,0,0,1,5.38.83l2.49-7.46a28,28,0,0,0-5.8-.83Zm-30.65,20.71V381.91h-7.87v5c-2.9-3.73-7-5.8-12.84-5.8-11.18,0-19.47,8.7-19.47,20.71s8.28,20.71,19.47,20.71c5.8,0,9.94-2.07,12.84-5.8v5h7.87V401.79Zm-31.89,0c0-7.46,4.56-13.25,12.43-13.25,7.46,0,12,5.8,12,13.25,0,7.87-5,13.25-12,13.25-7.87.41-12.43-5.8-12.43-13.25Zm111.83,0V366.17h-7.87v20.71c-2.9-3.73-7-5.8-12.84-5.8-11.18,0-19.47,8.7-19.47,20.71s8.28,20.71,19.47,20.71c5.8,0,9.94-2.07,12.84-5.8v5h7.87V401.79Zm-31.89,0c0-7.46,4.56-13.25,12.43-13.25,7.46,0,12,5.8,12,13.25,0,7.87-5,13.25-12,13.25C564.73,415.46,560.17,409.25,560.17,401.79Z\\\" transform=\\\"translate(-132.74 -48.5)\\\"/> <g> <rect x=\\\"169.81\\\" y=\\\"31.89\\\" width=\\\"143.72\\\" height=\\\"234.42\\\" fill=\\\"#ff5f00\\\"/> <path d=\\\"M317.05,197.6A149.5,149.5,0,0,1,373.79,80.39a149.1,149.1,0,1,0,0,234.42A149.5,149.5,0,0,1,317.05,197.6Z\\\" transform=\\\"translate(-132.74 -48.5)\\\" fill=\\\"#eb001b\\\"/> <path d=\\\"M615.26,197.6a148.95,148.95,0,0,1-241,117.21,149.43,149.43,0,0,0,0-234.42,148.95,148.95,0,0,1,241,117.21Z\\\" transform=\\\"translate(-132.74 -48.5)\\\" fill=\\\"#f79e1b\\\"/> </g> </g></svg>\";\n  var unionpay_single = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"750\\\" height=\\\"471\\\" viewBox=\\\"0 0 750 471\\\"> <g fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <rect width=\\\"750\\\" height=\\\"471\\\" rx=\\\"40\\\"/> <path fill=\\\"#D10429\\\" d=\\\"M201.809581,55 L344.203266,55 C364.072152,55 376.490206,71.4063861 371.833436,91.4702467 L305.500331,378.94775 C300.843561,399.011611 280.871191,415.417997 261.002305,415.417997 L118.60862,415.417997 C98.7397339,415.417997 86.32168,399.011611 90.9784502,378.94775 L157.311555,91.4702467 C161.968325,71.3018868 181.837211,55 201.706097,55 L201.809581,55 Z\\\"/> <path fill=\\\"#022E64\\\" d=\\\"M331.750074,55 L495.564902,55 C515.433788,55 506.430699,71.4063861 501.773929,91.4702467 L435.440824,378.94775 C430.784054,399.011611 432.232827,415.417997 412.363941,415.417997 L248.549113,415.417997 C228.576743,415.417997 216.262173,399.011611 221.022427,378.94775 L287.355531,91.4702467 C292.012302,71.3018868 311.881188,55 331.853558,55 L331.750074,55 Z\\\"/> <path fill=\\\"#076F74\\\" d=\\\"M489.814981,55 L632.208666,55 C652.077552,55 664.495606,71.4063861 659.838836,91.4702467 L593.505731,378.94775 C588.848961,399.011611 568.876591,415.417997 549.007705,415.417997 L406.61402,415.417997 C386.64165,415.417997 374.32708,399.011611 378.98385,378.94775 L445.316955,91.4702467 C449.973725,71.3018868 469.842611,55 489.711498,55 L489.814981,55 Z\\\"/> <path fill=\\\"#FEFEFE\\\" d=\\\"M465.904754,326.014514 L479.357645,326.014514 L483.186545,312.952104 L469.837137,312.952104 L465.904754,326.014514 L465.904754,326.014514 Z M476.667067,290.066763 L476.667067,290.066763 L472.010297,305.532656 C472.010297,305.532656 477.081002,302.920174 479.875064,302.08418 C482.669126,301.457184 486.808478,300.934688 486.808478,300.934688 L490.016475,290.171263 L476.563583,290.171263 L476.667067,290.066763 Z M483.393513,267.912917 L483.393513,267.912917 L478.94371,282.751814 C478.94371,282.751814 483.910932,280.45283 486.704994,279.721335 C489.499056,278.98984 493.638407,278.780842 493.638407,278.780842 L496.846405,268.017417 L483.496997,268.017417 L483.393513,267.912917 Z M513.093359,267.912917 L513.093359,267.912917 L495.708083,325.910015 L500.364853,325.910015 L496.742921,337.927431 L492.086151,337.927431 L490.947829,341.584906 L474.390424,341.584906 L475.528745,337.927431 L442,337.927431 L445.311481,326.850508 L448.726446,326.850508 L466.318689,267.912917 L469.837137,256 L486.704994,256 L484.94577,261.956459 C484.94577,261.956459 489.395572,258.716981 493.741891,257.567489 C497.984726,256.417997 522.406899,256 522.406899,256 L518.784967,267.808418 L512.989875,267.808418 L513.093359,267.912917 Z\\\"/> <path fill=\\\"#FEFEFE\\\" d=\\\"M520 256L538.006178 256 538.213146 262.792453C538.109662 263.941945 539.041016 264.464441 541.214175 264.464441L544.836108 264.464441 541.524627 275.645864 531.797151 275.645864C523.414965 276.272859 520.206968 272.615385 520.413935 268.539913L520.103484 256.104499 520 256zM522.216235 309.20029L505.037927 309.20029 507.935473 299.272859 527.597391 299.272859 530.391454 290.181422 511.039986 290.181422 514.351467 279 568.163034 279 564.851553 290.181422 546.741891 290.181422 543.947829 299.272859 562.057491 299.272859 559.056461 309.20029 539.498026 309.20029 535.979578 313.380261 543.947829 313.380261 545.914021 325.920174C546.120989 327.174165 546.120989 328.01016 546.534924 328.532656 546.948859 328.950653 549.328986 329.159652 550.674275 329.159652L553.054402 329.159652 549.328986 341.386067 543.223443 341.386067C542.292089 341.386067 540.843316 341.281567 538.877124 341.281567 537.014416 341.072569 535.77261 340.027576 534.530805 339.400581 533.392483 338.878084 531.736743 337.519594 531.322808 335.11611L529.4601 322.576197 520.560494 334.907112C517.766432 338.773585 513.937532 341.804064 507.418054 341.804064L495 341.804064 498.311481 330.936139 503.071735 330.936139C504.417024 330.936139 505.65883 330.413643 506.590184 329.891147 507.521538 329.473149 508.349408 329.055152 509.177278 327.696662L522.216235 309.20029 522.216235 309.20029zM334.31354 282L379.742921 282 376.43144 292.972424 358.321778 292.972424 355.527716 302.272859 374.154797 302.272859 370.739832 313.558781 352.216235 313.558781 347.662948 328.711176C347.145529 330.383164 352.112751 330.592163 353.871975 330.592163L363.185516 329.338171 359.4601 341.878084 338.556375 341.878084C336.900635 341.878084 335.65883 341.669086 333.796122 341.251089 332.036897 340.833091 331.209027 339.997097 330.48464 338.847605 329.760254 337.593614 328.518449 336.65312 329.346319 333.936139L335.348378 313.872279 325 313.872279 328.414965 302.377358 338.763343 302.377358 341.557405 293.076923 331.209027 293.076923 334.520508 282.104499 334.31354 282zM365.700875 262.165457L384.327956 262.165457 380.912991 273.555878 355.455981 273.555878 352.661919 275.959361C351.420113 277.108853 351.109662 276.690856 349.557405 277.526851 348.108632 278.258345 345.107603 279.721335 341.175219 279.721335L333 279.721335 336.311481 268.748911 338.795092 268.748911C340.864767 268.748911 342.31354 268.539913 343.037927 268.121916 343.865797 267.599419 344.797151 266.449927 345.728505 264.56894L350.385275 256 368.908872 256 365.700875 262.269956 365.700875 262.165457zM400.808726 280.975327C400.808726 280.975327 405.879431 276.272859 414.572069 274.809869 416.538261 274.391872 428.956314 274.600871 428.956314 274.600871L430.819023 268.330914 404.637626 268.330914 400.808726 281.079826 400.808726 280.975327zM425.437866 285.782293L425.437866 285.782293 399.463436 285.782293 397.91118 291.111756 420.470644 291.111756C423.161223 290.798258 423.678642 291.216255 423.885609 291.007257L425.54135 285.782293 425.437866 285.782293zM391.702153 256.104499L391.702153 256.104499 407.535171 256.104499 405.258528 264.150943C405.258528 264.150943 410.22575 260.075472 413.744198 258.612482 417.262647 257.358491 425.127414 256.104499 425.127414 256.104499L450.791393 256 441.995271 285.468795C440.546498 290.484761 438.787274 293.724238 437.752436 295.291727 436.821082 296.754717 435.68276 298.113208 433.406117 299.367199 431.232958 300.516691 429.266766 301.248186 427.404058 301.352685 425.748317 301.457184 423.057739 301.561684 419.53929 301.561684L394.806666 301.561684 387.873253 324.865022C387.25235 327.164006 386.941899 328.313498 387.355834 328.940493 387.666285 329.46299 388.597639 330.089985 389.735961 330.089985L400.601758 329.044993 396.876342 341.793904 384.665256 341.793904C380.732872 341.793904 377.93881 341.689405 375.972618 341.584906 374.10991 341.375907 372.143718 341.584906 370.798429 340.539913 369.660107 339.49492 367.900883 338.13643 368.004367 336.777939 368.10785 335.523948 368.625269 333.433962 369.45314 330.507983L391.702153 256.104499 391.702153 256.104499z\\\"/> <path fill=\\\"#FEFEFE\\\" d=\\\"M437.840227 303L436.391454 310.105951C435.770551 312.300435 435.253132 313.972424 433.597391 315.435414 431.838167 316.898403 429.871975 318.465893 425.111721 318.465893L416.3156 318.88389 416.212116 326.825835C416.108632 329.020319 416.729535 328.811321 417.039986 329.229318 417.453921 329.647315 417.764373 329.751814 418.178308 329.960813L420.97237 329.751814 429.354556 329.333817 425.836108 341.037736 416.212116 341.037736C409.48567 341.037736 404.414965 340.828737 402.862708 339.574746 401.206968 338.529753 401 337.275762 401 334.976778L401.620903 303.835994 417.039986 303.835994 416.833019 310.21045 420.558435 310.21045C421.80024 310.21045 422.731594 310.105951 423.249013 309.792453 423.766432 309.478955 424.076883 308.956459 424.283851 308.224964L425.836108 303.208999 437.94371 303.208999 437.840227 303zM218.470396 147C217.952978 149.507983 208.018534 195.592163 208.018534 195.592163 205.845375 204.892598 204.293118 211.580552 199.118929 215.865022 196.117899 218.373004 192.599451 219.522496 188.563583 219.522496 182.044105 219.522496 178.318689 216.283019 177.697786 210.117562L177.594302 208.027576C177.594302 208.027576 179.560494 195.592163 179.560494 195.487663 179.560494 195.487663 189.908872 153.478955 191.771581 147.940493 191.875064 147.626996 191.875064 147.417997 191.875064 147.313498 171.695727 147.522496 168.073794 147.313498 167.866827 147 167.763343 147.417997 167.245924 150.030479 167.245924 150.030479L156.690578 197.36865 155.759224 201.339623 154 214.506531C154 218.373004 154.724386 221.612482 156.276643 224.224964 161.140381 232.793904 174.903724 234.047896 182.665008 234.047896 192.702935 234.047896 202.119959 231.853411 208.43247 227.986938 219.505234 221.403483 222.40278 211.058055 224.886391 201.966618L226.128196 197.264151C226.128196 197.264151 236.787026 153.687954 238.649734 148.044993 238.753218 147.731495 238.753218 147.522496 238.856702 147.417997 224.162004 147.522496 219.919169 147.417997 218.470396 147.104499L218.470396 147zM277.499056 233.622642C270.358675 233.518142 267.771581 233.518142 259.389394 233.936139L259.078943 233.309144C259.803329 230.069666 260.6312 226.934688 261.252102 223.69521L262.28694 219.306241C263.839197 212.513788 265.28797 204.467344 265.494937 202.063861 265.701905 200.600871 266.11584 196.943396 261.976489 196.943396 260.217264 196.943396 258.45804 197.77939 256.595332 198.615385 255.560494 202.272859 253.594302 212.513788 252.559465 217.111756 250.489789 226.934688 250.386305 228.08418 249.454951 232.891147L248.834048 233.518142C241.4867 233.413643 238.899605 233.413643 230.413935 233.83164L230 233.100145C231.448773 227.248186 232.794062 221.396226 234.139351 215.544267 237.6578 199.764877 238.589154 193.703919 239.520508 185.657475L240.244894 185.239478C248.523597 184.089985 250.489789 183.776488 259.492878 182L260.217264 182.835994 258.871975 187.851959C260.424232 186.911466 261.873005 185.970972 263.425262 185.239478 267.668097 183.149492 272.324867 182.522496 274.911962 182.522496 278.844345 182.522496 283.190664 183.671988 284.949888 188.269956 286.605629 192.345428 285.570791 197.361393 283.294148 207.288824L282.155826 212.30479C279.879183 223.381713 279.465248 225.367199 278.223443 232.891147L277.395572 233.518142 277.499056 233.622642zM306.558435 233.650218C302.212116 233.650218 299.418054 233.545718 296.727476 233.650218 294.036897 233.650218 291.449803 233.859216 287.413935 233.963716L287.206968 233.650218 287 233.232221C288.138322 229.05225 288.655741 227.58926 289.276643 226.12627 289.794062 224.66328 290.311481 223.20029 291.346319 218.91582 292.588124 213.377358 293.415995 209.510885 293.933413 206.062409 294.554316 202.822932 294.864767 200.001451 295.278703 196.761974L295.589154 196.552975 295.899605 196.239478C300.245924 195.612482 302.936502 195.194485 305.730565 194.776488 308.524627 194.358491 311.422173 193.835994 315.871975 193L316.078943 193.417997 316.182427 193.835994C315.354556 197.28447 314.526686 200.732946 313.698816 204.181422 312.870946 207.629898 312.043075 211.078374 311.318689 214.526851 309.766432 221.8418 309.042046 224.558781 308.731594 226.544267 308.317659 228.425254 308.214175 229.365747 307.593273 233.127721L307.179338 233.441219 306.765402 233.754717 306.558435 233.650218zM352.499319 207.975327C352.188868 209.856313 350.533127 216.857765 348.359968 219.783745 346.807711 221.978229 345.048487 223.33672 342.978811 223.33672 342.357909 223.33672 338.83946 223.33672 338.735976 218.007257 338.735976 215.394775 339.253395 212.677794 339.874298 209.751814 341.737006 201.287373 344.013649 194.285922 349.705257 194.285922 354.15506 194.285922 354.465511 199.510885 352.499319 207.975327L352.499319 207.975327zM371.229884 208.811321L371.229884 208.811321C373.713495 197.734398 371.747303 192.509434 369.367176 189.374456 365.64176 184.567489 359.018798 183 352.188868 183 348.049517 183 338.322041 183.417997 330.664241 190.523948 325.179601 195.644412 322.592506 202.645864 321.143733 209.333817 319.591476 216.12627 317.832252 228.352685 329.008501 232.950653 332.423466 234.413643 337.390687 234.83164 340.598684 234.83164 348.773903 234.83164 357.156089 232.532656 363.4686 225.844702 368.332338 220.41074 370.505497 212.259797 371.333368 208.811321L371.229884 208.811321zM545.661919 234.891147C536.969281 234.786647 534.48567 234.786647 526.517419 235.204644L526 234.577649C528.173159 226.322206 530.346319 217.962264 532.312511 209.602322 534.796122 198.734398 535.417024 194.13643 536.244894 187.761974L536.865797 187.239478C545.454951 185.985486 547.835078 185.671988 556.838167 184L557.045135 184.731495C555.389394 191.628447 553.837137 198.4209 552.181397 205.213353 548.869916 219.529753 547.731594 226.844702 546.489789 234.36865L545.661919 234.995646 545.661919 234.891147z\\\"/> <path fill=\\\"#FEFEFE\\\" d=\\\"M533.159909 209.373777C532.745974 211.150265 531.090233 218.256216 528.917074 221.182195 527.468301 223.272181 523.949852 224.630672 521.983661 224.630672 521.362758 224.630672 517.947793 224.630672 517.740826 219.405708 517.740826 216.793226 518.258244 214.076245 518.879147 211.150265 520.741855 202.894822 523.018498 195.893371 528.710106 195.893371 533.159909 195.893371 535.126101 201.013836 533.159909 209.478277L533.159909 209.373777zM550.234733 210.209772L550.234733 210.209772C552.718344 199.132849 542.576933 209.269278 541.024677 205.611804 538.541066 199.864344 540.093322 188.369423 530.158879 184.50295 526.329979 182.935461 517.32689 184.920947 509.66909 192.026898 504.287934 197.042863 501.597355 204.044315 500.148582 210.732268 498.596326 217.420222 496.837101 229.751136 507.909866 234.035606 511.428315 235.603095 514.636312 236.021092 517.844309 235.812094 529.020558 235.185098 537.506228 218.151717 543.818739 211.463763 548.682476 206.1343 549.510347 213.449249 550.234733 210.209772L550.234733 210.209772zM420.292089 233.622642C413.151708 233.518142 410.668097 233.518142 402.28591 233.936139L401.975459 233.309144C402.699846 230.069666 403.527716 226.934688 404.252102 223.69521L405.183456 219.306241C406.735713 212.513788 408.28797 204.467344 408.391454 202.063861 408.598421 200.600871 409.012356 196.943396 404.976489 196.943396 403.217264 196.943396 401.354556 197.77939 399.595332 198.615385 398.663978 202.272859 396.594302 212.513788 395.559465 217.111756 393.593273 226.934688 393.386305 228.08418 392.454951 232.891147L391.834048 233.518142C384.4867 233.413643 381.899605 233.413643 373.413935 233.83164L373 233.100145C374.448773 227.248186 375.794062 221.396226 377.139351 215.544267 380.6578 199.764877 381.48567 193.703919 382.520508 185.657475L383.141411 185.239478C391.420113 184.089985 393.489789 183.776488 402.389394 182L403.113781 182.835994 401.871975 187.851959C403.320748 186.911466 404.873005 185.970972 406.321778 185.239478 410.564613 183.149492 415.221383 182.522496 417.808478 182.522496 421.740862 182.522496 425.983697 183.671988 427.846405 188.269956 429.502145 192.345428 428.363824 197.361393 426.08718 207.288824L424.948859 212.30479C422.568732 223.381713 422.25828 225.367199 421.016475 232.891147L420.188605 233.518142 420.292089 233.622642zM482.293118 147.104499L476.291059 147.208999C460.768492 147.417997 454.559465 147.313498 452.075854 147 451.868886 148.149492 451.454951 150.134978 451.454951 150.134978 451.454951 150.134978 445.866827 176.050798 445.866827 176.155298 445.866827 176.155298 432.620903 231.330914 432 233.943396 445.556375 233.734398 451.041016 233.734398 453.421143 234.047896 453.938562 231.435414 457.043075 216.07402 457.146559 216.07402 457.146559 216.07402 459.837137 204.788099 459.940621 204.370102 459.940621 204.370102 460.768492 203.22061 461.596362 202.698113L462.838167 202.698113C474.531835 202.698113 487.674275 202.698113 498.022653 195.069666 505.05955 189.844702 509.819804 182.007257 511.992964 172.602322 512.510383 170.303338 512.924318 167.586357 512.924318 164.764877 512.924318 161.107402 512.199931 157.554427 510.130256 154.732946 504.852583 147.313498 494.400721 147.208999 482.293118 147.104499L482.293118 147.104499zM490.054402 174.169811L490.054402 174.169811C488.812597 179.917271 485.08718 184.828737 480.326926 187.127721 476.394543 189.113208 471.634289 189.322206 466.667067 189.322206L463.45907 189.322206 463.666037 188.068215C463.666037 188.068215 469.564613 162.152395 469.564613 162.256894L469.771581 160.898403 469.875064 159.853411 472.255191 160.062409C472.255191 160.062409 484.466278 161.107402 484.673245 161.107402 489.433499 162.988389 491.503175 167.795356 490.054402 174.169811L490.054402 174.169811zM617.261369 182.835994L616.536983 182C607.740862 183.776488 606.085121 184.089985 598.013386 185.239478L597.392483 185.866473C597.392483 185.970972 597.288999 186.075472 597.288999 186.28447L597.288999 186.179971C591.28694 200.287373 591.390424 197.256894 586.526686 208.333817 586.526686 207.811321 586.526686 207.497823 586.423202 206.975327L585.181397 182.940493 584.45701 182.104499C575.14347 183.880987 574.936502 184.194485 566.450832 185.343977L565.82993 185.970972C565.726446 186.28447 565.726446 186.597968 565.726446 186.911466L565.82993 187.015965C566.864767 192.554427 566.6578 191.300435 567.692638 199.973875 568.210057 204.258345 568.830959 208.542816 569.348378 212.722787 570.176248 219.828737 570.693667 223.277213 571.728505 234.040639 565.933413 243.654572 564.588124 247.312046 559 255.776488L559.310451 256.612482C567.692638 256.298984 569.555346 256.298984 575.764373 256.298984L577.109662 254.731495C581.766432 244.595065 617.364853 182.940493 617.364853 182.940493L617.261369 182.835994zM314.543608 189.75837C319.303862 186.414394 319.924765 181.816425 315.888897 179.412942 311.85303 177.009459 304.712649 177.740954 299.952395 181.084931 295.192141 184.324408 294.674722 188.922376 298.71059 191.430359 302.642973 193.729343 309.783354 193.102347 314.543608 189.75837L314.543608 189.75837z\\\"/> <path fill=\\\"#FEFEFE\\\" d=\\\"M575.734683,256.104499 L568.80127,268.121916 C566.628111,272.197388 562.488759,275.332366 556.072765,275.332366 L545,275.123367 L548.207997,264.255443 L550.381157,264.255443 C551.519478,264.255443 552.347349,264.150943 552.968251,263.837446 C553.589154,263.628447 553.899605,263.21045 554.417024,262.583454 L558.556375,256 L575.838167,256 L575.734683,256.104499 Z\\\"/> </g></svg>\"; //define the color swap function\n\n  var swapColor = function swapColor(basecolor) {\n    document.querySelectorAll('.lightcolor').forEach(function (input) {\n      input.setAttribute('class', '');\n      input.setAttribute('class', 'lightcolor ' + basecolor);\n    });\n    document.querySelectorAll('.darkcolor').forEach(function (input) {\n      input.setAttribute('class', '');\n      input.setAttribute('class', 'darkcolor ' + basecolor + 'dark');\n    });\n  }; //pop in the appropriate card icon when detected\n\n\n  cardnumber_mask.on(\"accept\", function () {\n    switch (cardnumber_mask.masked.currentMask.cardtype) {\n      case 'american express':\n        ccicon.innerHTML = amex;\n        ccsingle.innerHTML = amex_single;\n        swapColor('green');\n        break;\n\n      case 'visa':\n        ccicon.innerHTML = visa;\n        ccsingle.innerHTML = visa_single;\n        swapColor('lime');\n        break;\n\n      case 'diners':\n        ccicon.innerHTML = diners;\n        ccsingle.innerHTML = diners_single;\n        swapColor('orange');\n        break;\n\n      case 'discover':\n        ccicon.innerHTML = discover;\n        ccsingle.innerHTML = discover_single;\n        swapColor('purple');\n        break;\n\n      case 'jcb' || 0:\n        ccicon.innerHTML = jcb;\n        ccsingle.innerHTML = jcb_single;\n        swapColor('red');\n        break;\n\n      case 'maestro':\n        ccicon.innerHTML = maestro;\n        ccsingle.innerHTML = maestro_single;\n        swapColor('yellow');\n        break;\n\n      case 'mastercard':\n        ccicon.innerHTML = mastercard;\n        ccsingle.innerHTML = mastercard_single;\n        swapColor('lightblue');\n        break;\n\n      case 'unionpay':\n        ccicon.innerHTML = unionpay;\n        ccsingle.innerHTML = unionpay_single;\n        swapColor('cyan');\n        break;\n\n      default:\n        ccicon.innerHTML = '';\n        ccsingle.innerHTML = '';\n        swapColor('grey');\n        break;\n    }\n  });\n  document.querySelector('.creditcard').addEventListener('click', function () {\n    if (this.classList.contains('flipped')) {\n      this.classList.remove('flipped');\n    } else {\n      this.classList.add('flipped');\n    }\n  }); //On Input Change Events\n\n  name.addEventListener('input', function () {\n    if (name.value.length == 0) {\n      document.getElementById('svgname').innerHTML = 'John Doe';\n      document.getElementById('svgnameback').innerHTML = 'John Doe';\n    } else {\n      document.getElementById('svgname').innerHTML = this.value;\n      document.getElementById('svgnameback').innerHTML = this.value;\n    }\n  });\n  cardnumber_mask.on('accept', function () {\n    if (cardnumber_mask.value.length == 0) {\n      document.getElementById('svgnumber').innerHTML = '0123 4567 8910 1112';\n    } else {\n      document.getElementById('svgnumber').innerHTML = cardnumber_mask.value;\n    }\n  });\n  expirationdate_mask.on('accept', function () {\n    if (expirationdate_mask.value.length == 0) {\n      document.getElementById('svgexpire').innerHTML = '01/23';\n    } else {\n      document.getElementById('svgexpire').innerHTML = expirationdate_mask.value;\n    }\n  });\n  securitycode_mask.on('accept', function () {\n    if (securitycode_mask.value.length == 0) {\n      document.getElementById('svgsecurity').innerHTML = '985';\n    } else {\n      document.getElementById('svgsecurity').innerHTML = securitycode_mask.value;\n    }\n  }); //On Focus Events\n\n  name.addEventListener('focus', function () {\n    document.querySelector('.creditcard').classList.remove('flipped');\n  });\n  cardnumber.addEventListener('focus', function () {\n    document.querySelector('.creditcard').classList.remove('flipped');\n  });\n  expirationdate.addEventListener('focus', function () {\n    document.querySelector('.creditcard').classList.remove('flipped');\n  });\n  securitycode.addEventListener('focus', function () {\n    document.querySelector('.creditcard').classList.add('flipped');\n  });\n};\n\nwindow.addEventListener('payauth', function (event) {\n  MidtransNew3ds.authenticate(event.detail.redirect_url, {\n    performAuthentication: function performAuthentication(redirect_url) {\n      $.featherlight({\n        iframe: redirect_url,\n        iframeMaxWidth: '80%',\n        iframeWidth: 600,\n        iframeHeight: 500,\n        closeOnClick: true,\n        closeOnEsc: false,\n        closeIcon: 'X'\n      });\n    },\n    onSuccess: function onSuccess(response) {\n      $.featherlight.close();\n      Livewire.emit('doPayment', response);\n    },\n    onFailure: function onFailure(response) {\n      $.featherlight.close();\n      Livewire.emit('errorPayment', response);\n    },\n    onPending: function onPending(response) {\n      $.featherlight.close();\n      Livewire.emit('errorPayment', response);\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQW9CO0FBQzNCN0ksTUFBQUEsQ0FBQyxDQUFDb0ksWUFBRixDQUFlVSxLQUFmO0FBQ0FDLE1BQUFBLFFBQVEsQ0FBQ0MsSUFBVCxDQUFjLFdBQWQsRUFBMkJILFFBQTNCO0FBQ0gsS0Fma0Q7QUFnQm5ESSxJQUFBQSxTQUFTLEVBQUUsbUJBQVVKLFFBQVYsRUFBb0I7QUFDM0I3SSxNQUFBQSxDQUFDLENBQUNvSSxZQUFGLENBQWVVLEtBQWY7QUFDQUMsTUFBQUEsUUFBUSxDQUFDQyxJQUFULENBQWMsY0FBZCxFQUE4QkgsUUFBOUI7QUFDSCxLQW5Ca0Q7QUFvQm5ESyxJQUFBQSxTQUFTLEVBQUUsbUJBQVVMLFFBQVYsRUFBb0I7QUFDM0I3SSxNQUFBQSxDQUFDLENBQUNvSSxZQUFGLENBQWVVLEtBQWY7QUFDQUMsTUFBQUEsUUFBUSxDQUFDQyxJQUFULENBQWMsY0FBZCxFQUE4QkgsUUFBOUI7QUFDSDtBQXZCa0QsR0FBdkQ7QUF5QkgsQ0ExQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzPzZkZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuLi92ZW5kb3Ivc2xpZGVyLXJhbmdlL2pzL3RtcGwuanMnXG5pbXBvcnQgJy4uL3ZlbmRvci9zbGlkZXItcmFuZ2UvanMvanF1ZXJ5LmRlcGVuZENsYXNzLTAuMS5qcydcbmltcG9ydCAnLi4vdmVuZG9yL2RhdGF0YWJsZXMvanF1ZXJ5LmRhdGFUYWJsZXMubWluLmpzJ1xuaW1wb3J0ICcuLi92ZW5kb3IvZGF0YXRhYmxlcy9kYXRhVGFibGVzLmJvb3RzdHJhcDQubWluLmpzJ1xuaW1wb3J0ICcuLi92ZW5kb3Ivc2xpZGVyLXJhbmdlL2pzL2RyYWdnYWJsZS0wLjEuanMnXG5pbXBvcnQgJy4uL3ZlbmRvci9zbGlkZXItcmFuZ2UvanMvanF1ZXJ5LnNsaWRlci5qcydcblxuaW1wb3J0IElNYXNrIGZyb20gJ2ltYXNrJ1xuXG5pbXBvcnQgQWxwaW5lIGZyb20gJ2FscGluZWpzJ1xuXG53aW5kb3cuQWxwaW5lID0gQWxwaW5lXG5cbkFscGluZS5zdGFydCgpXG5cbkNoYXJ0LmRlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udEZhbWlseSA9ICdOdW5pdG8nLCAnLWFwcGxlLXN5c3RlbSxzeXN0ZW0tdWksQmxpbmtNYWNTeXN0ZW1Gb250LFwiU2Vnb2UgVUlcIixSb2JvdG8sXCJIZWx2ZXRpY2EgTmV1ZVwiLEFyaWFsLHNhbnMtc2VyaWYnXG5DaGFydC5kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvciA9ICcjODU4Nzk2J1xuXG53aW5kb3cubGl2ZXdpcmUub24oJ2NoYXJ0VXBkYXRlJywgKGNoYXJ0SWQsIGxhYmVscywgZGF0YXNldHMpID0+IHtcbiAgICBsZXQgY2hhcnQgPSB3aW5kb3dbY2hhcnRJZF0uY2hhcnRcbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGtleSkgPT4ge1xuICAgICAgICBkYXRhc2V0LmRhdGEgPSBkYXRhc2V0c1trZXldXG4gICAgfSlcbiAgICBjaGFydC5kYXRhLmxhYmVscyA9IGxhYmVsc1xuICAgIGNoYXJ0LnVwZGF0ZSgpXG59KVxuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJChcIiNwYWdlLXByZWxvYWRlclwiKS5mYWRlT3V0KClcbn0pXG5cbiQoXCIuc2hvd19oaWRlX3Bhc3N3b3JkIC5pY29uLWV5ZVwiKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJCgnLnNob3dfaGlkZV9wYXNzd29yZCBpbnB1dCcpLmF0dHIoXCJ0eXBlXCIpID09IFwidGV4dFwiKSB7XG4gICAgICAgICQoJy5zaG93X2hpZGVfcGFzc3dvcmQgaW5wdXQnKS5hdHRyKCd0eXBlJywgJ3Bhc3N3b3JkJylcbiAgICAgICAgJCgnLnNob3dfaGlkZV9wYXNzd29yZCBpJykuYWRkQ2xhc3MoXCJmYS1leWUtc2xhc2hcIilcbiAgICAgICAgJCgnLnNob3dfaGlkZV9wYXNzd29yZCBpJykucmVtb3ZlQ2xhc3MoXCJmYS1leWVcIilcbiAgICB9IGVsc2UgaWYgKCQoJy5zaG93X2hpZGVfcGFzc3dvcmQgaW5wdXQnKS5hdHRyKFwidHlwZVwiKSA9PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgICAgJCgnLnNob3dfaGlkZV9wYXNzd29yZCBpbnB1dCcpLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgICQoJy5zaG93X2hpZGVfcGFzc3dvcmQgaScpLnJlbW92ZUNsYXNzKFwiZmEtZXllLXNsYXNoXCIpXG4gICAgICAgICQoJy5zaG93X2hpZGVfcGFzc3dvcmQgaScpLmFkZENsYXNzKFwiZmEtZXllXCIpXG4gICAgfVxufSlcblxuJCgnI2NldGFrJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICQoJ3RhYmxlJykucHJpbnRUaGlzKHtcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBwcmludENvbnRhaW5lcjogdHJ1ZSxcbiAgICAgICAgcGFnZVRpdGxlOiBcIlJla2FwIERhdGEge3sgJHRpdGxlIH19XCIsXG4gICAgICAgIHByaW50RGVsYXk6IDY2NixcbiAgICAgICAgaGVhZGVyOiBgPGgzIGNsYXNzPVwidGV4dC1ncmF5LTgwMCBtYi00XCI+UmVrYXAgRGF0YSB7eyAkdGl0bGUgfX08L2gzPmAsXG4gICAgICAgIGZvb3RlcjogJCgnZm9vdGVyJyksXG4gICAgICAgIGJhc2U6IGZhbHNlLCAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgQkFTRSB0YWcgb3IgYWNjZXB0IGEgc3RyaW5nIGZvciB0aGUgVVJMXG4gICAgICAgIGZvcm1WYWx1ZXM6IHRydWUsICAgICAgICAgICAvLyBwcmVzZXJ2ZSBpbnB1dC9mb3JtIHZhbHVlc1xuICAgICAgICBjYW52YXM6IGZhbHNlLCAgICAgICAgICAgICAgLy8gY29weSBjYW52YXMgY29udGVudFxuICAgICAgICByZW1vdmVTY3JpcHRzOiBmYWxzZSwgICAgICAgLy8gcmVtb3ZlIHNjcmlwdCB0YWdzIGZyb20gcHJpbnQgY29udGVudFxuICAgICAgICBjb3B5VGFnQ2xhc3NlczogZmFsc2UsICAgICAgLy8gY29weSBjbGFzc2VzIGZyb20gdGhlIGh0bWwgJiBib2R5IHRhZ1xuICAgICAgICBiZWZvcmVQcmludEV2ZW50OiBudWxsLCAgICAgLy8gZnVuY3Rpb24gZm9yIHByaW50RXZlbnQgaW4gaWZyYW1lXG4gICAgICAgIGJlZm9yZVByaW50OiBudWxsLCAgICAgICAgICAvLyBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGlmcmFtZSBpcyBmaWxsZWRcbiAgICAgICAgYWZ0ZXJQcmludDogbnVsbCAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGNhbGxlZCBiZWZvcmUgaWZyYW1lIGlzIHJlbW92ZWRcbiAgICB9KVxufSlcblxuJChcIiNzaWRlYmFyVG9nZ2xlLCAjc2lkZWJhclRvZ2dsZVRvcFwiKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICQoXCJib2R5XCIpLnRvZ2dsZUNsYXNzKFwic2lkZWJhci10b2dnbGVkXCIpXG4gICAgJChcIi5zaWRlYmFyXCIpLnRvZ2dsZUNsYXNzKFwidG9nZ2xlZFwiKVxuICAgIGlmICgkKFwiLnNpZGViYXJcIikuaGFzQ2xhc3MoXCJ0b2dnbGVkXCIpKSB7XG4gICAgICAgICQoJy5zaWRlYmFyIC5jb2xsYXBzZScpLmNvbGxhcHNlKCdoaWRlJylcbiAgICB9O1xufSlcblxuJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgNzY4KSB7XG4gICAgICAgICQoJy5zaWRlYmFyIC5jb2xsYXBzZScpLmNvbGxhcHNlKCdoaWRlJylcbiAgICB9O1xuXG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgNDgwICYmICEkKFwiLnNpZGViYXJcIikuaGFzQ2xhc3MoXCJ0b2dnbGVkXCIpKSB7XG4gICAgICAgICQoXCJib2R5XCIpLmFkZENsYXNzKFwic2lkZWJhci10b2dnbGVkXCIpXG4gICAgICAgICQoXCIuc2lkZWJhclwiKS5hZGRDbGFzcyhcInRvZ2dsZWRcIilcbiAgICAgICAgJCgnLnNpZGViYXIgLmNvbGxhcHNlJykuY29sbGFwc2UoJ2hpZGUnKVxuICAgIH07XG59KVxuXG4kKCdib2R5LmZpeGVkLW5hdiAuc2lkZWJhcicpLm9uKCdtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsIHdoZWVsJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoJCh3aW5kb3cpLndpZHRoKCkgPiA3NjgpIHtcbiAgICAgICAgbGV0IGUwID0gZS5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgZGVsdGEgPSBlMC53aGVlbERlbHRhIHx8IC1lMC5kZXRhaWxcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgKz0gKGRlbHRhIDwgMCA/IDEgOiAtMSkgKiAzMFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9XG59KVxuXG4kKGRvY3VtZW50KS5vbignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgIGxldCBzY3JvbGxEaXN0YW5jZSA9ICQodGhpcykuc2Nyb2xsVG9wKClcbiAgICBpZiAoc2Nyb2xsRGlzdGFuY2UgPiAxMDApIHtcbiAgICAgICAgJCgnLnNjcm9sbC10by10b3AnKS5mYWRlSW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJy5zY3JvbGwtdG8tdG9wJykuZmFkZU91dCgpXG4gICAgfVxufSlcblxuJChkb2N1bWVudCkub24oJ2NsaWNrJywgJ2Euc2Nyb2xsLXRvLXRvcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgbGV0ICRhbmNob3IgPSAkKHRoaXMpXG4gICAgJCgnaHRtbCwgYm9keScpLnN0b3AoKS5hbmltYXRlKHtcbiAgICAgICAgc2Nyb2xsVG9wOiAoJCgkYW5jaG9yLmF0dHIoJ2hyZWYnKSkub2Zmc2V0KCkudG9wKVxuICAgIH0sIDEwMDAsICdlYXNlSW5PdXRFeHBvJylcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbn0pXG5cbiQoXCIuYmFjay10by10b3BcIikuaGlkZSgpXG5cbiQod2luZG93KS5vbihcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCQodGhpcykuc2Nyb2xsVG9wKCkgPiA0MDApIHtcbiAgICAgICAgJChcIi5iYWNrLXRvLXRvcFwiKS5mYWRlSW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICAgICQoXCIuYmFjay10by10b3BcIikuZmFkZU91dCgpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufSlcblxuJChcIi5iYWNrLXRvLXRvcCBhXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAkKFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiAwIH0sIDYwMClcbiAgICByZXR1cm4gZmFsc2Vcbn0pXG5cbiQoXCIuZHItc2xpZGVzaG93XCIpLm5pdm9TbGlkZXIoeyBlZmZlY3Q6IFwicmFuZG9tXCIsIGFuaW1TcGVlZDogMWUzLCBwYXVzZVRpbWU6IDVlMywgZGlyZWN0aW9uTmF2OiB0cnVlLCBjb250cm9sTmF2OiB0cnVlLCBwYXVzZU9uSG92ZXI6IHRydWUgfSlcblxuJChcInVsLm1lbnVcIikub24oXCJjbGlja1wiLCBcIi5tb3JlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcyhcImhpZGVcIikpIHtcbiAgICAgICAgJCh0aGlzKS50ZXh0KFwic2hvdyBtb3JlXCIpLnJlbW92ZUNsYXNzKFwiLmhpZGVcIilcbiAgICB9IGVsc2Uge1xuICAgICAgICAkKHRoaXMpLnRleHQoXCJoaWRlXCIpLmFkZENsYXNzKFwiaGlkZVwiKVxuICAgIH1cblxuICAgICQodGhpcykuc2libGluZ3MoXCJsaS50b2dnbGVhYmxlXCIpLnNsaWRlVG9nZ2xlKClcbn0pXG5cbiQoXCIuY2F0ZWdvcnktcHJvZHVjdFwiKS5vd2xDYXJvdXNlbCh7IGxvb3A6IGZhbHNlLCBhdXRvcGxheXRpbWVvdXQ6IDZlMywgbWFyZ2luOiAzMCwgYXV0b3BsYXk6IGZhbHNlLCBkb3RzOiBmYWxzZSwgYXV0b3BsYXlIb3ZlclBhdXNlOiB0cnVlLCByZXNwb25zaXZlQ2xhc3M6IHRydWUsIG5hdjogdHJ1ZSwgcmVzcG9uc2l2ZTogeyAwOiB7IGl0ZW1zOiAxLCBuYXZUZXh0OiBbXCI8aSBjbGFzcz0nZmEgZmEtYW5nbGUtbGVmdCcgYXJpYS1oaWRkZW49J3RydWUnPjwvaT5cIiwgXCI8aSBjbGFzcz0nZmEgZmEtYW5nbGUtcmlnaHQnIGFyaWEtaGlkZGVuPSd0cnVlJz48L2k+XCJdIH0sIDYwMDogeyBpdGVtczogMywgbmF2VGV4dDogW1wiPGkgY2xhc3M9J2ZhIGZhLWFuZ2xlLWxlZnQnIGFyaWEtaGlkZGVuPSd0cnVlJz48L2k+XCIsIFwiPGkgY2xhc3M9J2ZhIGZhLWFuZ2xlLXJpZ2h0JyBhcmlhLWhpZGRlbj0ndHJ1ZSc+PC9pPlwiXSB9LCAxZTM6IHsgaXRlbXM6IDQsIG5hdlRleHQ6IFtcIjxpIGNsYXNzPSdmYSBmYS1hbmdsZS1sZWZ0JyBhcmlhLWhpZGRlbj0ndHJ1ZSc+PC9pPlwiLCBcIjxpIGNsYXNzPSdmYSBmYS1hbmdsZS1yaWdodCcgYXJpYS1oaWRkZW49J3RydWUnPjwvaT5cIl0gfSB9IH0pXG5cbiQoXCIjbWFudWZhY3R1cmVcIikub3dsQ2Fyb3VzZWwoeyBsb29wOiBmYWxzZSwgYXV0b3BsYXl0aW1lb3V0OiA2ZTMsIG1hcmdpbjogMzAsIGF1dG9wbGF5OiB0cnVlLCBkb3RzOiBmYWxzZSwgYXV0b3BsYXlIb3ZlclBhdXNlOiB0cnVlLCByZXNwb25zaXZlQ2xhc3M6IHRydWUsIG5hdjogdHJ1ZSwgcmVzcG9uc2l2ZTogeyAwOiB7IGl0ZW1zOiAzIH0sIDYwMDogeyBpdGVtczogMyB9LCAxZTM6IHsgaXRlbXM6IDYgfSB9IH0pXG5cbiQoXCIudGVzdGltb25pYWxzXCIpLm93bENhcm91c2VsKHsgbG9vcDogZmFsc2UsIG1hcmdpbjogMTAsIHJlc3BvbnNpdmVDbGFzczogdHJ1ZSwgYXV0b3BsYXl0aW1lb3V0OiA2ZTMsIGF1dG9wbGF5OiB0cnVlLCBkb3RzOiB0cnVlLCBhdXRvcGxheUhvdmVyUGF1c2U6IHRydWUsIG5hdjogZmFsc2UsIHJlc3BvbnNpdmU6IHsgMDogeyBpdGVtczogMSB9LCA2MDA6IHsgaXRlbXM6IDEgfSwgMWUzOiB7IGl0ZW1zOiAxIH0gfSB9KVxuXG4kKFwiLmNsb3NlXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkgeyAkKFwiLm1vYmlsZS10b3AtbWVudVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZS1zaG93XCIpIH0pXG5cbiQoXCIubW9iaWxlLW1lbnV0b3BcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7ICQoXCIjbW9iaWxlLXBhZ2VtZW51XCIpLmFkZENsYXNzKFwiYWN0aXZlLXBhZ2VtZW51XCIpIH0pXG5cbiQoXCIuY2xvc2UtYm94XCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkgeyAkKFwiI21vYmlsZS1wYWdlbWVudVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZS1wYWdlbWVudVwiKSB9KVxuXG4kKGRvY3VtZW50KS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLmNvbGxhcHNlJykuY29sbGFwc2UoJ2hpZGUnKVxufSlcblxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IG5hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmFtZScpXG4gICAgY29uc3QgY2FyZG51bWJlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXJkbnVtYmVyJylcbiAgICBjb25zdCBleHBpcmF0aW9uZGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleHBpcmF0aW9uZGF0ZScpXG4gICAgY29uc3Qgc2VjdXJpdHljb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlY3VyaXR5Y29kZScpXG4gICAgY29uc3QgY2NpY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NjaWNvbicpXG4gICAgY29uc3QgY2NzaW5nbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2NzaW5nbGUnKVxuXG4gICAgaWYgKCFjYXJkbnVtYmVyICYmICFleHBpcmF0aW9uZGF0ZSAmJiAhc2VjdXJpdHljb2RlICYmICFjY2ljb24gJiYgIWNjc2luZ2xlKSByZXR1cm5cblxuICAgIC8vTWFzayB0aGUgQ3JlZGl0IENhcmQgTnVtYmVyIElucHV0XG4gICAgdmFyIGNhcmRudW1iZXJfbWFzayA9IG5ldyBJTWFzayhjYXJkbnVtYmVyLCB7XG4gICAgICAgIG1hc2s6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXNrOiAnMDAwMCAwMDAwMDAgMDAwMDAnLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAnXjNbNDddXFxcXGR7MCwxM30nLFxuICAgICAgICAgICAgICAgIGNhcmR0eXBlOiAnYW1lcmljYW4gZXhwcmVzcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFzazogJzAwMDAgMDAwMCAwMDAwIDAwMDAnLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAnXig/OjYwMTF8NjVcXFxcZHswLDJ9fDY0WzQtOV1cXFxcZD8pXFxcXGR7MCwxMn0nLFxuICAgICAgICAgICAgICAgIGNhcmR0eXBlOiAnZGlzY292ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hc2s6ICcwMDAwIDAwMDAwMCAwMDAwJyxcbiAgICAgICAgICAgICAgICByZWdleDogJ14zKD86MChbMC01XXw5KXxbNjg5XVxcXFxkPylcXFxcZHswLDExfScsXG4gICAgICAgICAgICAgICAgY2FyZHR5cGU6ICdkaW5lcnMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hc2s6ICcwMDAwIDAwMDAgMDAwMCAwMDAwJyxcbiAgICAgICAgICAgICAgICByZWdleDogJ14oNVsxLTVdXFxcXGR7MCwyfXwyMlsyLTldXFxcXGR7MCwxfXwyWzMtN11cXFxcZHswLDJ9KVxcXFxkezAsMTJ9JyxcbiAgICAgICAgICAgICAgICBjYXJkdHlwZTogJ21hc3RlcmNhcmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAgIG1hc2s6ICcwMDAwLTAwMDAtMDAwMC0wMDAwJyxcbiAgICAgICAgICAgIC8vICAgICByZWdleDogJ14oNTAxOXw0MTc1fDQ1NzEpXFxcXGR7MCwxMn0nLFxuICAgICAgICAgICAgLy8gICAgIGNhcmR0eXBlOiAnZGFua29ydCdcbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgICAgbWFzazogJzAwMDAtMDAwMC0wMDAwLTAwMDAnLFxuICAgICAgICAgICAgLy8gICAgIHJlZ2V4OiAnXjYzWzctOV1cXFxcZHswLDEzfScsXG4gICAgICAgICAgICAvLyAgICAgY2FyZHR5cGU6ICdpbnN0YXBheW1lbnQnXG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hc2s6ICcwMDAwIDAwMDAwMCAwMDAwMCcsXG4gICAgICAgICAgICAgICAgcmVnZXg6ICdeKD86MjEzMXwxODAwKVxcXFxkezAsMTF9JyxcbiAgICAgICAgICAgICAgICBjYXJkdHlwZTogJ2pjYjE1J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXNrOiAnMDAwMCAwMDAwIDAwMDAgMDAwMCcsXG4gICAgICAgICAgICAgICAgcmVnZXg6ICdeKD86MzVcXFxcZHswLDJ9KVxcXFxkezAsMTJ9JyxcbiAgICAgICAgICAgICAgICBjYXJkdHlwZTogJ2pjYidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFzazogJzAwMDAgMDAwMCAwMDAwIDAwMDAnLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAnXig/OjVbMDY3OF1cXFxcZHswLDJ9fDYzMDR8NjdcXFxcZHswLDJ9KVxcXFxkezAsMTJ9JyxcbiAgICAgICAgICAgICAgICBjYXJkdHlwZTogJ21hZXN0cm8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAgIG1hc2s6ICcwMDAwLTAwMDAtMDAwMC0wMDAwJyxcbiAgICAgICAgICAgIC8vICAgICByZWdleDogJ14yMjBbMC00XVxcXFxkezAsMTJ9JyxcbiAgICAgICAgICAgIC8vICAgICBjYXJkdHlwZTogJ21pcidcbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFzazogJzAwMDAgMDAwMCAwMDAwIDAwMDAnLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAnXjRcXFxcZHswLDE1fScsXG4gICAgICAgICAgICAgICAgY2FyZHR5cGU6ICd2aXNhJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXNrOiAnMDAwMCAwMDAwIDAwMDAgMDAwMCcsXG4gICAgICAgICAgICAgICAgcmVnZXg6ICdeNjJcXFxcZHswLDE0fScsXG4gICAgICAgICAgICAgICAgY2FyZHR5cGU6ICd1bmlvbnBheSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFzazogJzAwMDAgMDAwMCAwMDAwIDAwMDAnLFxuICAgICAgICAgICAgICAgIGNhcmR0eXBlOiAnVW5rbm93bidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcblxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGFwcGVuZGVkLCBkeW5hbWljTWFza2VkKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gKGR5bmFtaWNNYXNrZWQudmFsdWUgKyBhcHBlbmRlZCkucmVwbGFjZSgvXFxEL2csICcnKVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR5bmFtaWNNYXNrZWQuY29tcGlsZWRNYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoZHluYW1pY01hc2tlZC5jb21waWxlZE1hc2tzW2ldLnJlZ2V4KVxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIubWF0Y2gocmUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNNYXNrZWQuY29tcGlsZWRNYXNrc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAvL01hc2sgdGhlIEV4cGlyYXRpb24gRGF0ZVxuICAgIHZhciBleHBpcmF0aW9uZGF0ZV9tYXNrID0gbmV3IElNYXNrKGV4cGlyYXRpb25kYXRlLCB7XG4gICAgICAgIG1hc2s6ICdNTXsvfVlZJyxcbiAgICAgICAgZ3JvdXBzOiB7XG4gICAgICAgICAgICBZWTogbmV3IElNYXNrLk1hc2tlZFBhdHRlcm4uR3JvdXAuUmFuZ2UoWzAsIDk5XSksXG4gICAgICAgICAgICBNTTogbmV3IElNYXNrLk1hc2tlZFBhdHRlcm4uR3JvdXAuUmFuZ2UoWzEsIDEyXSksXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy9NYXNrIHRoZSBzZWN1cml0eSBjb2RlXG4gICAgdmFyIHNlY3VyaXR5Y29kZV9tYXNrID0gbmV3IElNYXNrKHNlY3VyaXR5Y29kZSwge1xuICAgICAgICBtYXNrOiAnMDAwMCcsXG4gICAgfSlcblxuICAgIC8vIFNWR0lDT05TXG4gICAgbGV0IGFtZXggPSBgPGcgaWQ9XCJQYWdlLTFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPiA8ZyBpZD1cImFtZXhcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCI+IDxyZWN0IGlkPVwiUmVjdGFuZ2xlLTFcIiBmaWxsPVwiIzI1NTdENlwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjc1MFwiIGhlaWdodD1cIjQ3MVwiIHJ4PVwiNDBcIj48L3JlY3Q+IDxwYXRoIGQ9XCJNMC4wMDI2ODgsMjIxLjE4NTA4IEwzNi4wMjY4NDksMjIxLjE4NTA4IEw0NC4xNDk1NzksMjAxLjY3NTA2IEw2Mi4zMzQ1OTYsMjAxLjY3NTA2IEw3MC40MzYwNDIsMjIxLjE4NTA4IEwxNDEuMzE2MzcsMjIxLjE4NTA4IEwxNDEuMzE2MzcsMjA2LjI2OTA5IEwxNDcuNjQzMjIsMjIxLjI0ODY2IEwxODQuNDM4OTQsMjIxLjI0ODY2IEwxOTAuNzY1NzksMjA2LjA0NjU0IEwxOTAuNzY1NzksMjIxLjE4NTA4IEwzNjYuOTE3MDEsMjIxLjE4NTA4IEwzNjYuODM0NTEsMTg5LjE1OTQxIEwzNzAuMjQyNywxODkuMTU5NDEgQzM3Mi42MjkyNCwxODkuMjQxNjEgMzczLjMyNjMsMTg5LjQ2MTQ0IDM3My4zMjYzLDE5My4zODUxNiBMMzczLjMyNjMsMjIxLjE4NTA4IEw0NjQuNDMyMzIsMjIxLjE4NTA4IEw0NjQuNDMyMzIsMjEzLjcyOTczIEM0NzEuNzgwODIsMjE3LjY1MDggNDgzLjIxMDY0LDIyMS4xODUwOCA0OTguMjUwODYsMjIxLjE4NTA4IEw1MzYuNTc5MDgsMjIxLjE4NTA4IEw1NDQuNzgxNjMsMjAxLjY3NTA2IEw1NjIuOTY2NjQsMjAxLjY3NTA2IEw1NzAuOTg4MjgsMjIxLjE4NTA4IEw2NDQuODQ4NDQsMjIxLjE4NTA4IEw2NDQuODQ4NDQsMjAyLjY1MjY5IEw2NTYuMDMzNSwyMjEuMTg1MDggTDcxNS4yMjA2MSwyMjEuMTg1MDggTDcxNS4yMjA2MSw5OC42Nzc4OSBMNjU2LjY0NTQzLDk4LjY3Nzg5IEw2NTYuNjQ1NDMsMTEzLjE0NjE0IEw2NDguNDQyODgsOTguNjc3ODkgTDU4OC4zMzc4Nyw5OC42Nzc4OSBMNTg4LjMzNzg3LDExMy4xNDYxNCBMNTgwLjgwNTc5LDk4LjY3Nzg5IEw0OTkuNjE4MzksOTguNjc3ODkgQzQ4Ni4wMjgxOCw5OC42Nzc4OSA0NzQuMDgyMjEsMTAwLjU2NjkgNDY0LjQzMjMyLDEwNS44MzEyMSBMNDY0LjQzMjMyLDk4LjY3Nzg5IEw0MDguNDA1OTYsOTguNjc3ODkgTDQwOC40MDU5NiwxMDUuODMxMjEgQzQwMi4yNjUzNiwxMDAuNDA1MjkgMzkzLjg5Nzg2LDk4LjY3Nzg5IDM4NC41OTM4Myw5OC42Nzc4OSBMMTc5LjkwNzk2LDk4LjY3Nzg5IEwxNjYuMTc0MDcsMTMwLjMxOTQgTDE1Mi4wNzAzNyw5OC42Nzc4OSBMODcuNTk5MzcsOTguNjc3ODkgTDg3LjU5OTM3LDExMy4xNDYxNCBMODAuNTE2OTI0LDk4LjY3Nzg5IEwyNS41MzM1MTgsOTguNjc3ODkgTC0yLjk5OTk5OTk5ZS0wNiwxNTYuOTI0NDUgTC0yLjk5OTk5OTk5ZS0wNiwyMjEuMTg1MDggTDAuMDAyNTk3LDIyMS4xODUwOCBMMC4wMDI2ODgsMjIxLjE4NTA4IFogTTIyNy4zOTk1NywyMDMuNTE0MzYgTDIwNS43ODQ3MiwyMDMuNTE0MzYgTDIwNS43MDQ5MiwxMzQuNzIwNjQgTDE3NS4xMzIyOCwyMDMuNTE0MzYgTDE1Ni42MiwyMDMuNTE0MzYgTDEyNS45Njc1NCwxMzQuNjU5NyBMMTI1Ljk2NzU0LDIwMy41MTQzNiBMODMuMDg0NDI3LDIwMy41MTQzNiBMNzQuOTgyOTgxLDE4My45MjIyMiBMMzEuMDgzNTI0LDE4My45MjIyMiBMMjIuODk5NiwyMDMuNTE0MzYgTDQuN2UtMDUsMjAzLjUxNDM2IEwzNy43NTYyNDEsMTE1LjY3NjkyIEw2OS4wODE4MywxMTUuNjc2OTIgTDEwNC45NDEwMywxOTguODQwODYgTDEwNC45NDEwMywxMTUuNjc2OTIgTDEzOS4zNTI4OSwxMTUuNjc2OTIgTDE2Ni45NDU2OSwxNzUuMjY0MDYgTDE5Mi4yOTI5NywxMTUuNjc2OTIgTDIyNy4zOTY1NywxMTUuNjc2OTIgTDIyNy4zOTY1NywyMDMuNTE0MzYgTDIyNy4zOTk1NywyMDMuNTE0MzYgWiBNNjcuNzc3MjE0LDE2NS42OTI4NyBMNTMuMzQ2MjY1LDEzMC42NzYwNiBMMzguOTk3Nzk0LDE2NS42OTI4NyBMNjcuNzc3MjE0LDE2NS42OTI4NyBaIE0zMTMuNDE5NDcsMjAzLjUxNDM2IEwyNDIuOTg2MTEsMjAzLjUxNDM2IEwyNDIuOTg2MTEsMTE1LjY3NjkyIEwzMTMuNDE5NDcsMTE1LjY3NjkyIEwzMTMuNDE5NDcsMTMzLjk2ODIxIEwyNjQuMDcxMTYsMTMzLjk2ODIxIEwyNjQuMDcxMTYsMTQ5LjgwMDkgTDMxMi4yMzU1MSwxNDkuODAwOSBMMzEyLjIzNTUxLDE2Ny44MDYwNiBMMjY0LjA3MTE2LDE2Ny44MDYwNiBMMjY0LjA3MTE2LDE4NS4zNDc1OSBMMzEzLjQxOTQ3LDE4NS4zNDc1OSBMMzEzLjQxOTQ3LDIwMy41MTQzNiBaIE00MTIuNjc1MjgsMTM5LjMzMzIxIEM0MTIuNjc1MjgsMTUzLjMzNzgyIDQwMy4yODg3NywxNjAuNTczMjYgMzk3LjgxODYzLDE2Mi43NDU3NSBDNDAyLjQzMjA2LDE2NC40OTQzNCA0MDYuMzcyMzcsMTY3LjU4MzUxIDQwOC4yNDgwOCwxNzAuMTQyODEgQzQxMS4yMjUyNSwxNzQuNTExNjQgNDExLjczODc1LDE3OC40MTQxNiA0MTEuNzM4NzUsMTg2LjI1ODk3IEw0MTEuNzM4NzUsMjAzLjUxNDM2IEwzOTAuNDcyNzgsMjAzLjUxNDM2IEwzOTAuMzkyOTgsMTkyLjQzNzMyIEMzOTAuMzkyOTgsMTg3LjE1MTggMzkwLjkwMTE1LDE3OS41NTA3NCAzODcuMDY0NiwxNzUuMzI0OTkgQzM4My45ODM2NiwxNzIuMjM1ODEgMzc5LjI4Nzc0LDE3MS41NjU1MiAzNzEuNjk3MTQsMTcxLjU2NTUyIEwzNDkuMDYzNjMsMTcxLjU2NTUyIEwzNDkuMDYzNjMsMjAzLjUxNDM2IEwzMjcuOTgxMjUsMjAzLjUxNDM2IEwzMjcuOTgxMjUsMTE1LjY3NjkyIEwzNzYuNDc1NTIsMTE1LjY3NjkyIEMzODcuMjUwODQsMTE1LjY3NjkyIDM5NS4xODk5OSwxMTUuOTYwNCA0MDIuMDA2MzksMTE5Ljg4NDEzIEM0MDguNjc2NDQsMTIzLjgwNzg2IDQxMi42NzUyOSwxMjkuNTM1ODEgNDEyLjY3NTI5LDEzOS4zMzMyMSBMNDEyLjY3NTI4LDEzOS4zMzMyMSBaIE0zODYuMDIyNzcsMTUyLjM3NjMyIEMzODMuMTI1NCwxNTQuMTI3NTYgMzc5LjY5ODU5LDE1NC4xODU4NCAzNzUuNTkzMzMsMTU0LjE4NTg0IEwzNDkuOTc5OTgsMTU0LjE4NTg0IEwzNDkuOTc5OTgsMTM0LjY3NTgzIEwzNzUuOTQxODYsMTM0LjY3NTgzIEMzNzkuNjE2MTEsMTM0LjY3NTgzIDM4My40NDk5OSwxMzQuODQwMSAzODUuOTQwMjksMTM2LjI2MDE2IEMzODguNjc1MzYsMTM3LjUzOTgxIDM5MC4zNjc0OSwxNDAuMjYzMzcgMzkwLjM2NzQ5LDE0NC4wMjU0OCBDMzkwLjM2NzQ5LDE0Ny44NjQ0MyAzODguNzU3ODQsMTUwLjk1MzYxIDM4Ni4wMjI3NywxNTIuMzc2MzIgWiBNNDQ2LjQ4OTA4LDIwMy41MTQzNiBMNDI0Ljk3NTY5LDIwMy41MTQzNiBMNDI0Ljk3NTY5LDExNS42NzY5MiBMNDQ2LjQ4OTA4LDExNS42NzY5MiBMNDQ2LjQ4OTA4LDIwMy41MTQzNiBaIE02OTYuMjI4NTYsMjAzLjUxNDM2IEw2NjYuMzUwMzIsMjAzLjUxNDM2IEw2MjYuMzg1ODUsMTM3LjU4NzI3IEw2MjYuMzg1ODUsMjAzLjUxNDM2IEw1ODMuNDQ2ODcsMjAzLjUxNDM2IEw1NzUuMjQxNjYsMTgzLjkyMjIyIEw1MzEuNDQzMzEsMTgzLjkyMjIyIEw1MjMuNDgyODcsMjAzLjUxNDM2IEw0OTguODExMzcsMjAzLjUxNDM2IEM0ODguNTYyODQsMjAzLjUxNDM2IDQ3NS41ODcyMiwyMDEuMjU3MDkgNDY4LjIzODcyLDE5My43OTkwOSBDNDYwLjgyOTAzLDE4Ni4zNDExIDQ1Ni45NzM4NiwxNzYuMjM5MDMgNDU2Ljk3Mzg2LDE2MC4yNjU5MyBDNDU2Ljk3Mzg2LDE0Ny4yMzg5NSA0NTkuMjc3OTEsMTM1LjMzIDQ2OC4zMzk4MywxMjUuOTE5NDEgQzQ3NS4xNTYyMSwxMTguOTA5MTYgNDg1LjgzMDQ0LDExNS42NzY5MiA1MDAuMzU5ODIsMTE1LjY3NjkyIEw1MjAuNzcxNzQsMTE1LjY3NjkyIEw1MjAuNzcxNzQsMTM0LjQ5ODA5IEw1MDAuNzg4MTgsMTM0LjQ5ODA5IEM0OTMuMDkzOCwxMzQuNDk4MDkgNDg4Ljc0OTA5LDEzNS42MzczMyA0ODQuNTY0LDEzOS43MDE0NyBDNDgwLjk2OTU3LDE0My40IDQ3OC41MDMyMiwxNTAuMzkxNzEgNDc4LjUwMzIyLDE1OS41OTgyOSBDNDc4LjUwMzIyLDE2OS4wMDg4NyA0ODAuMzgxNTgsMTc1Ljc5MzkzIDQ4NC4zMDA2MSwxODAuMjI2MzMgQzQ4Ny41NDY1LDE4My43MDIzMiA0OTMuNDQ1LDE4NC43NTY3NyA0OTguOTk0OTUsMTg0Ljc1Njc3IEw1MDguNDYzOTMsMTg0Ljc1Njc3IEw1MzguMTc5ODcsMTE1LjY3OTU3IEw1NjkuNzcxNTIsMTE1LjY3OTU3IEw2MDUuNDY4NDMsMTk4Ljc2MTM4IEw2MDUuNDY4NDMsMTE1LjY3OTU3IEw2MzcuNTcwOSwxMTUuNjc5NTcgTDY3NC42MzI3LDE3Ni44NTM2OCBMNjc0LjYzMjcsMTE1LjY3OTU3IEw2OTYuMjI4NTYsMTE1LjY3OTU3IEw2OTYuMjI4NTYsMjAzLjUxNDM2IFogTTU2OC4wNzA1MSwxNjUuNjkyODcgTDU1My40Nzk5MywxMzAuNjc2MDYgTDUzOC45NjkxNiwxNjUuNjkyODcgTDU2OC4wNzA1MSwxNjUuNjkyODcgWlwiIGlkPVwiUGF0aFwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTc0OS45NTY0NCwzNDMuNzY3MTYgQzc0NC44MzQ4NSwzNTEuMjI1MTYgNzM0Ljg1NTA0LDM1NS4wMDU4MiA3MjEuMzQ0NjQsMzU1LjAwNTgyIEw2ODAuNjI3MjMsMzU1LjAwNTgyIEw2ODAuNjI3MjMsMzM2LjE2NjEgTDcyMS4xNzk2OSwzMzYuMTY2MSBDNzI1LjIwMjQ4LDMzNi4xNjYxIDcyOC4wMTczNiwzMzUuNjM4ODcgNzI5LjcxMjE1LDMzMy45OTA5NiBDNzMxLjE4MDc5LDMzMi42MzE4MyA3MzIuMjA1MSwzMzAuNjU4MDQgNzMyLjIwNTEsMzI4LjI2MDM2IEM3MzIuMjA1MSwzMjUuNzAxMDcgNzMxLjE4MDc5LDMyMy42Njg5OSA3MjkuNjI5NjcsMzIyLjQ1MDI4IEM3MjguMDk5ODQsMzIxLjEwOTY5IDcyNS44NzI5NCwzMjAuNTAwMzMgNzIyLjIwMTM1LDMyMC41MDAzMyBDNzAyLjQwNDAyLDMxOS44MzAwNSA2NzcuNzA1OTIsMzIxLjEwOTY5IDY3Ny43MDU5MiwyOTMuMzA3MTQgQzY3Ny43MDU5MiwyODAuNTYzNjMgNjg1LjgzMTMxLDI2Ny4xNDk4MyA3MDcuOTU2NjQsMjY3LjE0OTgzIEw3NDkuOTUzNzksMjY3LjE0OTgzIEw3NDkuOTU2NDQsMjQ5LjY2OTI1IEw3MTAuOTMzODIsMjQ5LjY2OTI1IEM2OTkuMTU4MTIsMjQ5LjY2OTI1IDY5MC42MDQzOCwyNTIuNDc3NTkgNjg0LjU0NjI2LDI1Ni44NDM3NSBMNjg0LjU0NjI2LDI0OS42NjkyNSBMNjI2LjgzMDQ0LDI0OS42NjkyNSBDNjE3LjYwMDkxLDI0OS42NjkyNSA2MDYuNzY3MDYsMjUxLjk0NzcxIDYwMS42NDI3OSwyNTYuODQzNzUgTDYwMS42NDI3OSwyNDkuNjY5MjUgTDQ5OC41Nzc1MSwyNDkuNjY5MjUgTDQ5OC41Nzc1MSwyNTYuODQzNzUgQzQ5MC4zNzQ5NiwyNTAuOTUxNTQgNDc2LjUzNDY2LDI0OS42NjkyNSA0NzAuMTQ2NjMsMjQ5LjY2OTI1IEw0MDIuMTYzNjYsMjQ5LjY2OTI1IEw0MDIuMTYzNjYsMjU2Ljg0Mzc1IEMzOTUuNjc0NTIsMjUwLjU4NTkzIDM4MS4yNDM1NywyNDkuNjY5MjUgMzcyLjQ0NzcyLDI0OS42NjkyNSBMMjk2LjM2MzMsMjQ5LjY2OTI1IEwyNzguOTUyNTIsMjY4LjQzMjEzIEwyNjIuNjQ1ODYsMjQ5LjY2OTI1IEwxNDguOTkxNDksMjQ5LjY2OTI1IEwxNDguOTkxNDksMzcyLjI2MTIxIEwyNjAuNTA2NzYsMzcyLjI2MTIxIEwyNzguNDQ3LDM1My4yMDE1OSBMMjk1LjM0Njk3LDM3Mi4yNjEyMSBMMzY0LjA4NTU0LDM3Mi4zMjIxMSBMMzY0LjA4NTU0LDM0My40ODM2NCBMMzcwLjg0MzM5LDM0My40ODM2NCBDMzc5Ljk2Mzg0LDM0My42MjQwNSAzOTAuNzIwNTQsMzQzLjI1ODQ1IDQwMC4yMTA3OSwzMzkuMTczMTEgTDQwMC4yMTA3OSwzNzIuMjU4NTIgTDQ1Ni45MDc2MiwzNzIuMjU4NTIgTDQ1Ni45MDc2MiwzNDAuMzA3MDQgTDQ1OS42NDI2OCwzNDAuMzA3MDQgQzQ2My4xMzMzNiwzNDAuMzA3MDQgNDYzLjQ3NjU3LDM0MC40NTAxMSA0NjMuNDc2NTcsMzQzLjkyMzQ0IEw0NjMuNDc2NTcsMzcyLjI1NTg3IEw2MzUuNzExNDQsMzcyLjI1NTg3IEM2NDYuNjQ2MzksMzcyLjI1NTg3IDY1OC4wNzYyMSwzNjkuNDY4NzMgNjY0LjQwNTcxLDM2NC40MTEwNyBMNjY0LjQwNTcxLDM3Mi4yNTU4NyBMNzE5LjAzNzkyLDM3Mi4yNTU4NyBDNzMwLjQwNjU2LDM3Mi4yNTU4NyA3NDEuNTA5MTMsMzcwLjY2ODg5IDc0OS45NTY0NCwzNjYuNjA0NzUgTDc0OS45NTY0NCwzNDMuNzY3MTIgTDc0OS45NTY0NCwzNDMuNzY3MTYgWiBNNDA4LjQ1MzAxLDI5Ni42MTI2NiBDNDA4LjQ1MzAxLDMyMS4wMTg3MiAzOTAuMTY2ODksMzI2LjA1Nzg0IDM3MS43MzcxLDMyNi4wNTc4NCBMMzQ1LjQyOTM1LDMyNi4wNTc4NCBMMzQ1LjQyOTM1LDM1NS41MjY4NSBMMzA0LjQ0ODU1LDM1NS41MjY4NSBMMjc4LjQ4NjY3LDMyNi40NDE5OSBMMjUxLjUwNTgsMzU1LjUyNjg1IEwxNjcuOTkwNCwzNTUuNTI2ODUgTDE2Ny45OTA0LDI2Ny42NjgyMiBMMjUyLjc5MDg2LDI2Ny42NjgyMiBMMjc4LjczMTQ0LDI5Ni40NjY5NCBMMzA1LjU1MDAyLDI2Ny42NjgyMiBMMzcyLjkyMTA2LDI2Ny42NjgyMiBDMzg5LjY1MzQsMjY3LjY2ODIyIDQwOC40NTMwMSwyNzIuMjgwNzggNDA4LjQ1MzAxLDI5Ni42MTI2NiBaIE0yNDAuODI3ODEsMzM3LjA0NjU1IEwxODguOTg5MiwzMzcuMDQ2NTUgTDE4OC45ODkyLDMxOS41NjU5NiBMMjM1LjI3Nzg1LDMxOS41NjU5NiBMMjM1LjI3Nzg1LDMwMS42NDAyOCBMMTg4Ljk4OTIsMzAxLjY0MDI4IEwxODguOTg5MiwyODUuNjY3MTggTDI0MS44NDk0NywyODUuNjY3MTggTDI2NC45MTEzMiwzMTEuMjcwNzcgTDI0MC44Mjc4MSwzMzcuMDQ2NTUgWiBNMzI0LjM1NDUsMzQ3LjEwNjY4IEwyOTEuOTgzMywzMTEuMzE4OSBMMzI0LjM1NDUsMjc2LjY2NzcgTDMyNC4zNTQ1LDM0Ny4xMDY2OCBaIE0zNzIuMjI3MiwzMDguMDQxMTcgTDM0NC45ODAyNywzMDguMDQxMTcgTDM0NC45ODAyNywyODUuNjY3MTggTDM3Mi40NzE5NywyODUuNjY3MTggQzM4MC4wODM4OCwyODUuNjY3MTggMzg1LjM2Nzc3LDI4OC43NTYzNiAzODUuMzY3NzcsMjk2LjQzOTU2IEMzODUuMzY3NzcsMzA0LjAzNzk2IDM4MC4zMjg2NSwzMDguMDQxMTcgMzcyLjIyNzIsMzA4LjA0MTE3IFogTTUxNC45NzA1MywyNjcuNjY4MTUgTDU4NS4zNDAwNCwyNjcuNjY4MTUgTDU4NS4zNDAwNCwyODUuODM3NjQgTDUzNS45Njc3OCwyODUuODM3NjQgTDUzNS45Njc3OCwzMDEuODEwNzQgTDU4NC4xMzQ4LDMwMS44MTA3NCBMNTg0LjEzNDgsMzE5LjczNjQyIEw1MzUuOTY3NzgsMzE5LjczNjQyIEw1MzUuOTY3NzgsMzM3LjIxNzAxIEw1ODUuMzQwMDQsMzM3LjI5NjQxIEw1ODUuMzQwMDQsMzU1LjUyNjc4IEw1MTQuOTcwNTMsMzU1LjUyNjc4IEw1MTQuOTcwNTMsMjY3LjY2ODE1IFogTTQ4Ny45MTcyNCwzMTQuNjk3MyBDNDkyLjYxMDQ5LDMxNi40MjIwNSA0OTYuNDQ3MDMsMzE5LjUxMzg3IDQ5OC4yNDU1OSwzMjIuMDczMTcgQzUwMS4yMjI3NiwzMjYuMzYyNTEgNTAxLjY1Mzc4LDMzMC4zNjU3MSA1MDEuNzM4OTEsMzM4LjEwOTg1IEw1MDEuNzM4OTEsMzU1LjUyNjg1IEw0ODAuNTcxNCwzNTUuNTI2ODUgTDQ4MC41NzE0LDM0NC41MzQ1OCBDNDgwLjU3MTQsMzM5LjI0OTA4IDQ4MS4wODIyMywzMzEuNDIyODIgNDc3LjE2MzIsMzI3LjMzNzQ4IEM0NzQuMDgyMjYsMzI0LjE5MDAyIDQ2OS4zODYzNSwzMjMuNDM3NiA0NjEuNjk0NjMsMzIzLjQzNzYgTDQzOS4xNjIyMywzMjMuNDM3NiBMNDM5LjE2MjIzLDM1NS41MjY4NSBMNDE3Ljk3NjA5LDM1NS41MjY4NSBMNDE3Ljk3NjA5LDI2Ny42NjgyMiBMNDY2LjY1MzkzLDI2Ny42NjgyMiBDNDc3LjMyODE2LDI2Ny42NjgyMiA0ODUuMTAyMzYsMjY4LjEzNzE2IDQ5Mi4wMjI1MSwyNzEuODE0NDkgQzQ5OC42NzY2LDI3NS44MTc3IDUwMi44NjE2OCwyODEuMzAxOTEgNTAyLjg2MTY4LDI5MS4zMjQ1IEM1MDIuODU4NjgsMzA1LjM0NzY1IDQ5My40NjcxOSwzMTIuNTAzNjIgNDg3LjkxNzI0LDMxNC42OTczIFogTTQ3NS45OTg5OSwzMDMuNTkwMjIgQzQ3My4xNzg3OSwzMDUuMjU2NjggNDY5LjY5MDc3LDMwNS4zOTk3NSA0NjUuNTg4MTcsMzA1LjM5OTc1IEw0MzkuOTc0ODMsMzA1LjM5OTc1IEw0MzkuOTc0ODMsMjg1LjY2NzE4IEw0NjUuOTM2NywyODUuNjY3MTggQzQ2OS42OTA3NywyODUuNjY3MTggNDczLjQ0NzUsMjg1Ljc0NjU4IDQ3NS45OTg5OSwyODcuMjU0MTYgQzQ3OC43MzE0LDI4OC42NzY4NyA0ODAuMzY0OTksMjkxLjM5Nzc5IDQ4MC4zNjQ5OSwyOTUuMTU3MjUgQzQ4MC4zNjQ5OSwyOTguOTE2NzIgNDc4LjczMTQsMzAxLjk0NDk2IDQ3NS45OTg5OSwzMDMuNTkwMjIgWiBNNjY2LjMzNTM5LDMwOS4xODY2IEM2NzAuNDQwNjcsMzEzLjQxNzY2IDY3Mi42NDA5NSwzMTguNzU4OCA2NzIuNjQwOTUsMzI3LjgwMTEyIEM2NzIuNjQwOTUsMzQ2LjcwMTc4IDY2MC43ODI3OCwzNTUuNTI0MiA2MzkuNTE5NDgsMzU1LjUyNDIgTDU5OC40NTM1MywzNTUuNTI0MiBMNTk4LjQ1MzUzLDMzNi42ODQ0OSBMNjM5LjM1NDUzLDMzNi42ODQ0OSBDNjQzLjM1MzM3LDMzNi42ODQ0OSA2NDYuMTg5NTQsMzM2LjE1NzI2IDY0Ny45NjY4LDMzNC41MDkzNCBDNjQ5LjQxNjgxLDMzMy4xNTAyMSA2NTAuNDU3MDksMzMxLjE3NjQzIDY1MC40NTcwOSwzMjguNzc4NzUgQzY1MC40NTcwOSwzMjYuMjE5NDQgNjQ5LjMzMTY3LDMyNC4xODczOCA2NDcuODg0MzMsMzIyLjk2ODY2IEM2NDYuMjcyMDEsMzIxLjYyODA3IDY0NC4wNDc3OCwzMjEuMDE4NzIgNjQwLjM3NjE5LDMyMS4wMTg3MiBDNjIwLjY1ODY4LDMyMC4zNDg0MyA1OTUuOTY1OSwzMjEuNjI4MDcgNTk1Ljk2NTksMjkzLjgyNTUxIEM1OTUuOTY1OSwyODEuMDgyMDEgNjA0LjAwNjE1LDI2Ny42NjgyMiA2MjYuMTEwMTksMjY3LjY2ODIyIEw2NjguMzc4NzIsMjY3LjY2ODIyIEw2NjguMzc4NzIsMjg2LjM2NzUyIEw2MjkuNzAxOTYsMjg2LjM2NzUyIEM2MjUuODY4MDksMjg2LjM2NzUyIDYyMy4zNzUxMiwyODYuNTEwNTkgNjIxLjI1NDY0LDI4Ny45NTQ1IEM2MTguOTQ1MjcsMjg5LjM3NzIxIDYxOC4wODg1NiwyOTEuNDg4NzYgNjE4LjA4ODU2LDI5NC4yNzU5IEM2MTguMDg4NTYsMjk3LjU5MDI4IDYyMC4wNDk0MSwyOTkuODQ0OSA2MjIuNzAyLDMwMC44MTk4NyBDNjI0LjkyNjI0LDMwMS41OTA4NCA2MjcuMzE1NDMsMzAxLjgxNjAzIDYzMC45MDcyLDMwMS44MTYwMyBMNjQyLjI1NzIyLDMwMi4xMjA3MSBDNjUzLjcwMywzMDIuMzk4ODkgNjYxLjU1OTY3LDMwNC4zNzAwMyA2NjYuMzM1MzksMzA5LjE4NjYgWiBNNzUwLDI4NS42NjcxOCBMNzExLjU3MzM1LDI4NS42NjcxOCBDNzA3LjczNjgsMjg1LjY2NzE4IDcwNS4xODc5NywyODUuODEwMjUgNzAzLjA0MDg4LDI4Ny4yNTQxNiBDNzAwLjgxNjY1LDI4OC42NzY4NyA2OTkuOTU5OTUsMjkwLjc4ODQzIDY5OS45NTk5NSwyOTMuNTc1NTggQzY5OS45NTk5NSwyOTYuODg5OTQgNzAxLjgzODMxLDI5OS4xNDQ1NiA3MDQuNTcwNzEsMzAwLjExOTUzIEM3MDYuNzk0OTUsMzAwLjg5MDUgNzA5LjE4NDE1LDMwMS4xMTU3IDcxMi42OTYxLDMwMS4xMTU3IEw3MjQuMTIzMjcsMzAxLjQyMDM4IEM3MzUuNjU0MTksMzAxLjcwMzg3IDc0My4zNTEyMywzMDMuNjc3NjUgNzQ4LjA0NDQ4LDMwOC40OTE1NyBDNzQ4Ljg5ODUyLDMwOS4xNjE4NiA3NDkuNDEyMDIsMzA5LjkxNDI4IDc1MCwzMTAuNjY2NyBMNzUwLDI4NS42NjcxOCBaXCIgaWQ9XCJwYXRoMTNcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD4gPC9nPiA8L2c+YFxuICAgIGxldCB2aXNhID0gYDxnIGlkPVwiUGFnZS0xXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj4gPGcgaWQ9XCJ2aXNhXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiPiA8cmVjdCBpZD1cIlJlY3RhbmdsZS0xXCIgZmlsbD1cIiMwRTQ1OTVcIiB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI3NTBcIiBoZWlnaHQ9XCI0NzFcIiByeD1cIjQwXCI+PC9yZWN0PiA8cG9seWdvbiBpZD1cIlNoYXBlXCIgZmlsbD1cIiNGRkZGRkZcIiBwb2ludHM9XCIyNzguMTk3NSAzMzQuMjI3NSAzMTEuNTU4NSAxMzguNDY1NSAzNjQuOTE3NSAxMzguNDY1NSAzMzEuNTMzNSAzMzQuMjI3NVwiPjwvcG9seWdvbj4gPHBhdGggZD1cIk01MjQuMzA3NSwxNDIuNjg3NSBDNTEzLjczNTUsMTM4LjcyMTUgNDk3LjE3MTUsMTM0LjQ2NTUgNDc2LjQ4NDUsMTM0LjQ2NTUgQzQyMy43NjA1LDEzNC40NjU1IDM4Ni42MjA1LDE2MS4wMTY1IDM4Ni4zMDQ1LDE5OS4wNjk1IEMzODYuMDA3NSwyMjcuMTk4NSA0MTIuODE4NSwyNDIuODkwNSA0MzMuMDU4NSwyNTIuMjU0NSBDNDUzLjgyNzUsMjYxLjg0OTUgNDYwLjgxMDUsMjY3Ljk2OTUgNDYwLjcxMTUsMjc2LjUzNzUgQzQ2MC41Nzk1LDI4OS42NTk1IDQ0NC4xMjU1LDI5NS42NTQ1IDQyOC43ODg1LDI5NS42NTQ1IEM0MDcuNDMxNSwyOTUuNjU0NSAzOTYuMDg1NSwyOTIuNjg3NSAzNzguNTYyNSwyODUuMzc4NSBMMzcxLjY4NjUsMjgyLjI2NjUgTDM2NC4xOTc1LDMyNi4wOTA1IEMzNzYuNjYwNSwzMzEuNTU0NSAzOTkuNzA2NSwzMzYuMjg5NSA0MjMuNjM1NSwzMzYuNTM0NSBDNDc5LjcyNDUsMzM2LjUzNDUgNTE2LjEzNjUsMzEwLjI4NzUgNTE2LjU1MDUsMjY5LjY1MjUgQzUxNi43NTE1LDI0Ny4zODM1IDUwMi41MzU1LDIzMC40MzU1IDQ3MS43NTE1LDIxNi40NjQ1IEM0NTMuMTAwNSwyMDcuNDA4NSA0NDEuNjc4NSwyMDEuMzY1NSA0NDEuNzk5NSwxOTIuMTk1NSBDNDQxLjc5OTUsMTg0LjA1ODUgNDUxLjQ2NzUsMTc1LjM1NzUgNDcyLjM1NjUsMTc1LjM1NzUgQzQ4OS44MDU1LDE3NS4wODY1IDUwMi40NDQ1LDE3OC44OTE1IDUxMi4yOTI1LDE4Mi44NTc1IEw1MTcuMDc0NSwxODUuMTE2NSBMNTI0LjMwNzUsMTQyLjY4NzVcIiBpZD1cInBhdGgxM1wiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTY2MS42MTQ1LDEzOC40NjU1IEw2MjAuMzgzNSwxMzguNDY1NSBDNjA3LjYxMDUsMTM4LjQ2NTUgNTk4LjA1MjUsMTQxLjk1MTUgNTkyLjQ0MjUsMTU0LjY5OTUgTDUxMy4xOTc1LDMzNC4xMDI1IEw1NjkuMjI4NSwzMzQuMTAyNSBDNTY5LjIyODUsMzM0LjEwMjUgNTc4LjM5MDUsMzA5Ljk4MDUgNTgwLjQ2MjUsMzA0LjY4NDUgQzU4Ni41ODU1LDMwNC42ODQ1IDY0MS4wMTY1LDMwNC43Njg1IDY0OC43OTg1LDMwNC43Njg1IEM2NTAuMzk0NSwzMTEuNjIxNSA2NTUuMjkwNSwzMzQuMTAyNSA2NTUuMjkwNSwzMzQuMTAyNSBMNzA0LjgwMjUsMzM0LjEwMjUgTDY2MS42MTQ1LDEzOC40NjU1IFogTTU5Ni4xOTc1LDI2NC44NzI1IEM2MDAuNjEwNSwyNTMuNTkzNSA2MTcuNDU2NSwyMTAuMTQ5NSA2MTcuNDU2NSwyMTAuMTQ5NSBDNjE3LjE0MTUsMjEwLjY3MDUgNjIxLjgzNjUsMTk4LjgxNTUgNjI0LjUzMTUsMTkxLjQ2NTUgTDYyOC4xMzg1LDIwOC4zNDM1IEM2MjguMTM4NSwyMDguMzQzNSA2MzguMzU1NSwyNTUuMDcyNSA2NDAuNDkwNSwyNjQuODcxNSBMNTk2LjE5NzUsMjY0Ljg3MTUgTDU5Ni4xOTc1LDI2NC44NzI1IFpcIiBpZD1cIlBhdGhcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD4gPHBhdGggZD1cIk0yMzIuOTAyNSwxMzguNDY1NSBMMTgwLjY2MjUsMjcxLjk2MDUgTDE3NS4wOTY1LDI0NC44MzE1IEMxNjUuMzcxNSwyMTMuNTU3NSAxMzUuMDcxNSwxNzkuNjc1NSAxMDEuMTk3NSwxNjIuNzEyNSBMMTQ4Ljk2NDUsMzMzLjkxNTUgTDIwNS40MTk1LDMzMy44NTA1IEwyODkuNDIzNSwxMzguNDY1NSBMMjMyLjkwMjUsMTM4LjQ2NTVcIiBpZD1cInBhdGgxNlwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTEzMS45MTk1LDEzOC40NjU1IEw0NS44Nzg1LDEzOC40NjU1IEw0NS4xOTc1LDE0Mi41Mzg1IEMxMTIuMTM2NSwxNTguNzQyNSAxNTYuNDI5NSwxOTcuOTAxNSAxNzQuODE1NSwyNDQuOTUyNSBMMTU2LjEwNjUsMTU0Ljk5MjUgQzE1Mi44NzY1LDE0Mi41OTY1IDE0My41MDg1LDEzOC44OTc1IDEzMS45MTk1LDEzOC40NjU1XCIgaWQ9XCJwYXRoMThcIiBmaWxsPVwiI0YyQUUxNFwiPjwvcGF0aD4gPC9nPiA8L2c+YFxuICAgIGxldCBkaW5lcnMgPSBgPGcgaWQ9XCJQYWdlLTFcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPiA8ZyBpZD1cImRpbmVyc1wiIGZpbGwtcnVsZT1cIm5vbnplcm9cIj4gPHJlY3QgaWQ9XCJyZWN0YW5nbGVcIiBmaWxsPVwiIzAwNzlCRVwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjc1MFwiIGhlaWdodD1cIjQ3MVwiIHJ4PVwiNDBcIj48L3JlY3Q+IDxwYXRoIGQ9XCJNNTg0LjkzMzkxMSwyMzcuOTQ3MzM5IEM1ODQuOTMzOTExLDEzOC41MzE1NCA1MDEuOTUyOTc2LDY5LjgxNDA4MDYgNDExLjAzODkyNCw2OS44NDcxNDY0IEwzMzIuNzk2NzQsNjkuODQ3MTQ2NCBDMjQwLjc5MzY5OSw2OS44MTQwODA2IDE2NS4wNjYwODksMTM4LjU1MjA0MSAxNjUuMDY2MDg5LDIzNy45NDczMzkgQzE2NS4wNjYwODksMzI4Ljg3Nzc3OCAyNDAuNzkzNjk5LDQwMy41ODc0MzIgMzMyLjc5Njc0LDQwMy4xNTA5NjMgTDQxMS4wMzg5MjQsNDAzLjE1MDk2MyBDNTAxLjk1Mjk3Niw0MDMuNTg2NzcxIDU4NC45MzM5MTEsMzI4Ljg1NzkzOSA1ODQuOTMzOTExLDIzNy45NDczMzkgWlwiIGlkPVwiU2hhcGUtcGF0aFwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTMzMy4yODAzMDIsODMuOTMwODM5NCBDMjQ5LjIxMDM3OCw4My45NTcyOTIxIDE4MS4wODU4ODksMTUyLjIzODI4MiAxODEuMDY2MDg5LDIzNi41MTA1ODEgQzE4MS4wODU4ODksMzIwLjc2ODMzMSAyNDkuMjA5NzE5LDM4OS4wNDI3MDggMzMzLjI4MDMwMiwzODkuMDY5MTYxIEM0MTcuMzcwMDI1LDM4OS4wNDI3MDggNDg1LjUwODM3NSwzMjAuNzY4MzMxIDQ4NS41MjAyNTQsMjM2LjUxMDU4MSBDNDg1LjUwNzcxNSwxNTIuMjM4MjgyIDQxNy4zNzAwMjUsODMuOTU3MjkyMSAzMzMuMjgwMzAyLDgzLjkzMDgzOTQgWlwiIGlkPVwiU2hhcGUtcGF0aFwiIGZpbGw9XCIjMDA3OUJFXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTIzNy4wNjYwODksMjM2LjA5Nzc0IEMyMzcuMTQ1Mjg4LDE5NC45MTc1MjQgMjYyLjgxMjQyMSwxNTkuODAxNTg3IDI5OS4wMDY0NDMsMTQ1Ljg0NzEzNCBMMjk5LjAwNjQ0MywzMjYuMzI3MTgzIEMyNjIuODEyNDIxLDMxMi4zODA2NjcgMjM3LjE0NDYyOCwyNzcuMjgzOTA3IDIzNy4wNjYwODksMjM2LjA5Nzc0IFogTTM2OC4wNjYwODksMzI2LjM3MjgxNCBMMzY4LjA2NjA4OSwxNDUuODQ3MTM0IEM0MDQuMjczMzEyLDE1OS43Njc4NTkgNDI5Ljk4MDA0MywxOTQuOTAzNjM3IDQzMC4wNDYwNDMsMjM2LjEwMzY5MiBDNDI5Ljk4MDA0MywyNzcuMzE2MzEyIDQwNC4yNzMzMTIsMzEyLjQyNTYzNiAzNjguMDY2MDg5LDMyNi4zNzI4MTQgWlwiIGlkPVwiUGF0aFwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPiA8L2c+IDwvZz5gXG4gICAgbGV0IGRpc2NvdmVyID0gYDxnIGlkPVwiUGFnZS0xXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj4gPGcgaWQ9XCJkaXNjb3ZlclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIj4gPHBhdGggZD1cIk01Mi44NzcxMDM4LDAgQzIzLjY3OTM4OTQsMCAtNC41NTQ3NjExNWUtMTUsMjMuMTU0NTYxMiAwLDUxLjcxMDI1ODkgTDAsNDE5LjI4OTczNyBDMCw0NDcuODUwODI5IDIzLjY3MTgwMSw0NzEgNTIuODc3MTAzOCw0NzEgTDY5Ny4xMjI4OTQsNDcxIEM3MjYuMzIwNjE1LDQ3MSA3NTAsNDQ3Ljg0NTQzMyA3NTAsNDE5LjI4OTczNyBMNzUwLDI1Mi40NzU0MDQgTDc1MCw1MS43MTAyNTg5IEM3NTAsMjMuMTQ5MTY3NyA3MjYuMzI4MjAyLC00LjQ1MzMwMThlLTE1IDY5Ny4xMjI4OTQsMCBMNTIuODc3MTAzOCwwIFpcIiBpZD1cIlNoYXBlXCIgZmlsbD1cIiM0RDRENERcIj48L3BhdGg+IDxwYXRoIGQ9XCJNMzE0LjU2OTU1OCwxNTIuMTk4NDE0IEMzMjMuMDY2MjUsMTUyLjE5ODQxNCAzMzAuMTkyNTc3LDE1My45MzA5IDMzOC44NjUzMDgsMTU4LjExMDI1NCBMMzM4Ljg2NTMwOCwxODAuMTk3MTk4IEMzMzAuNjUwMjY5LDE3Mi41NjM1NDkgMzIzLjUyMzg3NSwxNjkuMzY4OTI2IDMxNC4xMDAwNTgsMTY5LjM2ODkyNiBDMjk1LjU3NzExNSwxNjkuMzY4OTI2IDI4MS4wMDk2MTUsMTgzLjk0NDUzOSAyODEuMDA5NjE1LDIwMi40MjQ0MzggQzI4MS4wMDk2MTUsMjIxLjkxMTk5NyAyOTUuMTI2Mjc5LDIzNS42MjAyNTQgMzE1LjAxODQwNCwyMzUuNjIwMjU0IEMzMjMuOTcyNzk4LDIzNS42MjAyNTQgMzMwLjk2NzEzNSwyMzIuNTkxMTI4IDMzOC44NjUzMDgsMjI1LjA4MDE4NiBMMzM4Ljg2NTMwOCwyNDcuMTc4NDk3IEMzMjkuODgzNTM4LDI1MS4xOTc5NjUgMzIyLjYwNDU3NywyNTIuNzg1MDc5IDMxNC4xMDAwNTgsMjUyLjc4NTA3OSBDMjg0LjAyNTIwMiwyNTIuNzg1MDc5IDI2MC42NTU3OTgsMjMwLjg0OTcwMSAyNjAuNjU1Nzk4LDIwMi41NjA5NDcgQzI2MC42NTU3OTgsMTc0LjU3NzEwMyAyODQuNjQ3MjY5LDE1Mi4xOTg0MTQgMzE0LjU2OTU1OCwxNTIuMTk4NDE0IFogTTIyMS4xOTE0MDQsMTUyLjgwNzAzOCBDMjMyLjI5MzA0OCwxNTIuODA3MDM4IDI0Mi40NTE0NjIsMTU2LjQxODgwMiAyNTAuOTQ0NjM1LDE2My40Nzk4MzEgTDI0MC42MDk5ODEsMTc2LjM0MDY1NSBDMjM1LjQ2NTAxOSwxNzAuODU5ODk1IDIzMC41OTkzOTQsMTY4LjU0Nzk0NSAyMjQuNjgyNjE1LDE2OC41NDc5NDUgQzIxNi4xNjk4ODUsMTY4LjU0NzkzNiAyMDkuOTcwMzI3LDE3My4xNTQyMzUgMjA5Ljk3MDMyNywxNzkuMjE1MDQ5IEMyMDkuOTcwMzI3LDE4NC40MTMyMTggMjEzLjQ1MDc5OCwxODcuMTY0NDIyIDIyNS4zMDIzNTYsMTkxLjMzMjYyMSBDMjQ3Ljc2ODUyOSwxOTkuMTQxMDI4IDI1NC40MjY0NjIsMjA2LjA2NDg2OCAyNTQuNDI2NDYyLDIyMS4zNTQ0NzMgQzI1NC40MjY0NjIsMjM5Ljk4NjgyMSAyNDAuMDI2OTgxLDI1Mi45NTU3MjEgMjE5LjUwMzA3NywyNTIuOTU1NzIxIEMyMDQuNDc0MjYsMjUyLjk1NTcyMSAxOTMuNTQ4MTU0LDI0Ny4zMzA0NTIgMTg0LjQ0ODI0LDIzNC42MzYyMTMgTDE5Ny4yMDU1MjksMjIyLjk1NjYyNCBDMjAxLjc1NDcwMiwyMzEuMzE1MzQxIDIwOS4zNDI0NTIsMjM1Ljc5Mjc5OSAyMTguNzYzMTQ0LDIzNS43OTI3OTkgQzIyNy41NzM5NzEsMjM1Ljc5Mjc5OSAyMzQuMDk3MDU4LDIzMC4wMTQ0MjEgMjM0LjA5NzA1OCwyMjIuMjE3MTY4IEMyMzQuMDk3MDU4LDIxOC4xNzUzOTIgMjMyLjEyMTI2OSwyMTQuNzA5NTM2IDIyOC4xNzU3MDIsMjEyLjI1OTE4MyBDMjI2LjE4OTIzMSwyMTEuMDk5MDczIDIyMi4yNTQ1MTksMjA5LjM2OTM4MiAyMTQuNTIyNjE1LDIwNi43Nzc3MzQgQzE5NS45NzMwNTgsMjAwLjQzMDYyIDE4OS42MDksMTkzLjY0NjIyMSAxODkuNjA5LDE4MC4zODY3OTkgQzE4OS42MDksMTY0LjYzNjEyNiAyMDMuMjc1OTgxLDE1Mi44MDcwMzggMjIxLjE5MTQwNCwxNTIuODA3MDM4IFogTTQ0Ni44ODYyNjksMTU0LjQ4NTAzNiBMNDY4LjQ2MDc4OCwxNTQuNDg1MDM2IEw0OTUuNDY0NjE1LDIxOS4xMzA0MTcgTDUyMi44MTU4ODUsMTU0LjQ4NTAzNiBMNTQ0LjIyNzAxLDE1NC40ODUwMzYgTDUwMC40ODI2NDQsMjUzLjE5ODQxNCBMNDg5Ljg1NTAxOSwyNTMuMTk4NDE0IEw0NDYuODg2MjY5LDE1NC40ODUwMzYgWiBNNjQuODIxMjEzNSwxNTQuNjMyOTIzIEw5My44MTE5NzQsMTU0LjYzMjkyMyBDMTI1Ljg0MjM5NCwxNTQuNjMyOTIzIDE0OC4xNzA4MjcsMTc0LjQxODU5NiAxNDguMTcwODI3LDIwMi44MjI2MDkgQzE0OC4xNzA4MjcsMjE2Ljk4NTU2NyAxNDEuMzQwMDM4LDIzMC42NzkzODkgMTI5Ljc4ODkxMywyMzkuNzY2ODkzIEMxMjAuMDY4OTYyLDI0Ny40Mzc3MjIgMTA4Ljk5NDE5MiwyNTAuODc3NjY5IDkzLjY1OTg1NTgsMjUwLjg3NzY2OSBMNjQuODIxMjEzNSwyNTAuODc3NjY5IEw2NC44MjEyMTM1LDE1NC42MzI5MjMgWiBNMTU3LjI1ODQ5LDE1NC42MzI5MjMgTDE3Ny4wMDk0NjIsMTU0LjYzMjkyMyBMMTc3LjAwOTQ2MiwyNTAuODc3NjY5IEwxNTcuMjU4NDksMjUwLjg3NzY2OSBMMTU3LjI1ODQ5LDE1NC42MzI5MjMgWiBNNTUzLjE1NjkyMywxNTQuNjMyOTIzIEw2MDkuMTY4NDIzLDE1NC42MzI5MjMgTDYwOS4xNjg0MjMsMTcwLjk0MDc0MSBMNTcyLjg5Mjg3NSwxNzAuOTQwNzQxIEw1NzIuODkyODc1LDE5Mi4zMDMzOTIgTDYwNy44MzEyNzksMTkyLjMwMzM5MiBMNjA3LjgzMTI3OSwyMDguNjAzNjE5IEw1NzIuODkyODc1LDIwOC42MDM2MTkgTDU3Mi44OTI4NzUsMjM0LjU4MzEyMiBMNjA5LjE2ODQyMywyMzQuNTgzMTIyIEw2MDkuMTY4NDIzLDI1MC44Nzc2NjkgTDU1My4xNTY5MjMsMjUwLjg3NzY2OSBMNTUzLjE1NjkyMywxNTQuNjMyOTIzIFogTTYyMi4yNTA1OTYsMTU0LjYzMjkyMyBMNjUxLjUzNDMyNywxNTQuNjMyOTIzIEM2NzQuMzEzNDUyLDE1NC42MzI5MjMgNjg3LjM2NjY2MywxNjUuMDMwMDA3IDY4Ny4zNjY2NjMsMTgzLjA0ODgzOCBDNjg3LjM2NjY2MywxOTcuNzg0NDE0IDY3OS4xNzk5MjMsMjA3LjQ1NDg0NyA2NjQuMzAyODg1LDIxMC4zMzI4MDUgTDY5Ni4xNzYzODUsMjUwLjg3NzY2OSBMNjcxLjg4ODE0NCwyNTAuODc3NjY5IEw2NDQuNTUxOTA0LDIxMi4yMTM2NzMgTDY0MS45NzcxNjMsMjEyLjIxMzY3MyBMNjQxLjk3NzE2MywyNTAuODc3NjY5IEw2MjIuMjUwNTk2LDI1MC44Nzc2NjkgTDYyMi4yNTA1OTYsMTU0LjYzMjkyMyBaIE02NDEuOTc3MTYzLDE2OS43OTE3MzYgTDY0MS45NzcxNjMsMTk4LjkzOTUyNSBMNjQ3Ljc0ODI2OSwxOTguOTM5NTI1IEM2NjAuMzYwMzA4LDE5OC45Mzk1MjUgNjY3LjA0NDc2OSwxOTMuNzM0NDA2IDY2Ny4wNDQ3NjksMTg0LjA1OTQyIEM2NjcuMDQ0NzY5LDE3NC42OTMwNTIgNjYwLjM1OTEwNiwxNjkuNzkxNzM2IDY0OC4wNjAwMTksMTY5Ljc5MTczNiBMNjQxLjk3NzE2MywxNjkuNzkxNzM2IFogTTg0LjU1NzE2NjMsMTcwLjk0MDc0MSBMODQuNTU3MTY2MywyMzQuNTgzMTIyIEw4OS44NTY4OTYyLDIzNC41ODMxMjIgQzEwMi42MTk1MzgsMjM0LjU4MzEyMiAxMTAuNjc5NjYzLDIzMi4yNTkxMDUgMTE2Ljg4NTE0NCwyMjYuOTM0NTE0IEMxMjMuNzE1NzUsMjIxLjE1MjU3MiAxMjcuODI0NTE5LDIxMS45MjA0MjMgMTI3LjgyNDUxOSwyMDIuNjg0MTk3IEMxMjcuODI0NTE5LDE5My40NjI4MzMgMTIzLjcxNTc1LDE4NC41MDU5MTcgMTE2Ljg4NTE0NCwxNzguNzIzOTc1IEMxMTAuMzYxNjE1LDE3My4xMTMwNzQgMTAyLjYxOTUzOCwxNzAuOTQwNzQxIDg5Ljg1Njg5NjIsMTcwLjk0MDc0MSBMODQuNTU3MTY2MywxNzAuOTQwNzQxIFpcIiBpZD1cIlNoYXBlXCIgZmlsbD1cIiNGRkZGRkZcIj48L3BhdGg+IDxwYXRoIGQ9XCJNMzk5LjE2NDI4OCwxNTEuNTU5NDI0IEM0MjguOTE0NDUyLDE1MS41NTk0MjQgNDUzLjAzMTA5NiwxNzMuNzI3NDI5IDQ1My4wMzEwOTYsMjAxLjExMjE4NyBMNDUzLjAzMTA5NiwyMDEuMTQzMzk5IEM0NTMuMDMxMDk2LDIyOC41MjgxNDcgNDI4LjkxNDQ1MiwyNTAuNzI3Mzc0IDM5OS4xNjQyODgsMjUwLjcyNzM3NCBDMzY5LjQxNDEyNSwyNTAuNzI3Mzc0IDM0NS4yOTc0ODEsMjI4LjUyODE0NyAzNDUuMjk3NDgxLDIwMS4xNDMzOTkgTDM0NS4yOTc0ODEsMjAxLjExMjE4NyBDMzQ1LjI5NzQ4MSwxNzMuNzI3NDI5IDM2OS40MTQxMjUsMTUxLjU1OTQyNCAzOTkuMTY0Mjg4LDE1MS41NTk0MjQgWiBNNzQ5Ljk4MjYxMiwyNzEuMDkzOTM5IEM3MjQuOTM0NjUxLDI4OC4zMjcxMzMgNTM3LjQwODU2NCw0MTEuNDkwOTYzIDIxMi43MTkyMzcsNDcwLjk4NTA3MSBMNjk3LjEwNTUwNyw0NzAuOTg1MDcxIEM3MjYuMzAzMjI4LDQ3MC45ODUwNzEgNzQ5Ljk4MjYxMiw0NDcuODMwNTA0IDc0OS45ODI2MTIsNDE5LjI3NDgwNyBMNzQ5Ljk4MjYxMiwyNzEuMDkzOTM5IFpcIiBpZD1cIlNoYXBlXCIgZmlsbD1cIiNGNDcyMTZcIj48L3BhdGg+IDwvZz4gPC9nPmBcbiAgICBsZXQgamNiID0gYDxkZWZzPiA8bGluZWFyR3JhZGllbnQgeDE9XCIwLjAzMTYwNzg1OCVcIiB5MT1cIjQ5Ljk5OTg1NzQlXCIgeDI9XCI5OS45NzQzMTUzJVwiIHkyPVwiNDkuOTk5ODU3NCVcIiBpZD1cImxpbmVhckdyYWRpZW50LTFcIj4gPHN0b3Agc3RvcC1jb2xvcj1cIiMwMDdCNDBcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD4gPHN0b3Agc3RvcC1jb2xvcj1cIiM1NUIzMzBcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPiA8L2xpbmVhckdyYWRpZW50PiA8bGluZWFyR3JhZGllbnQgeDE9XCIwLjQ3MTY5MzE3MiVcIiB5MT1cIjQ5Ljk5OTgyNiVcIiB4Mj1cIjk5Ljk4NjAwODYlXCIgeTI9XCI0OS45OTk4MjYlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC0yXCI+IDxzdG9wIHN0b3AtY29sb3I9XCIjMUQyOTcwXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+IDxzdG9wIHN0b3AtY29sb3I9XCIjMDA2REJBXCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD4gPC9saW5lYXJHcmFkaWVudD4gPGxpbmVhckdyYWRpZW50IHgxPVwiMC4xMTM4ODA3NzIlXCIgeTE9XCI1MC4wMDA4OTY0JVwiIHgyPVwiOTkuOTg2MDAwMyVcIiB5Mj1cIjUwLjAwMDg5NjQlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC0zXCI+IDxzdG9wIHN0b3AtY29sb3I9XCIjNkUyQjJGXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+IDxzdG9wIHN0b3AtY29sb3I9XCIjRTMwMTM4XCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD4gPC9saW5lYXJHcmFkaWVudD4gPC9kZWZzPiA8ZyBpZD1cIlBhZ2UtMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+IDxnIGlkPVwiamNiXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiPiA8cmVjdCBpZD1cIlJlY3RhbmdsZS0xXCIgZmlsbD1cIiMwRTRDOTZcIiB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI3NTBcIiBoZWlnaHQ9XCI0NzFcIiByeD1cIjQwXCI+PC9yZWN0PiA8cGF0aCBkPVwiTTYxNy4yNDMxODMsMzQ2Ljc2NjI4MSBDNjE3LjI0MzE4MywzODguMzgwODg3IDU4My41MTQ4OTIsNDIyLjEyNTk3NCA1NDEuODgzNDksNDIyLjEyNTk3NCBMMTMyLjc1NjgyMyw0MjIuMTI1OTc0IEwxMzIuNzU2ODIzLDEyNC4yNDQ5MTYgQzEzMi43NTY4MjMsODIuNjE4NjgyNiAxNjYuNDg5ODUxLDQ4Ljg3NDQ1NjcgMjA4LjEyMTY4Myw0OC44NzQ0NTY3IEw2MTcuMjQzMTgzLDQ4Ljg3NDAyNiBMNjE3LjI0Mjc1MiwzNDYuNzY2MjgxIEw2MTcuMjQzMTgzLDM0Ni43NjYyODEgWlwiIGlkPVwicGF0aDM0OTRcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD4gPHBhdGggZD1cIk00ODMuODU4ODc0LDI0Mi4wNDQ3OTcgQzQ5NS41NDI2OTksMjQyLjI5ODI4NSA1MDcuMjk2MTg4LDI0MS41Mjg4MDYgNTE4LjkzNjAwNCwyNDIuNDQ0ODgzIEM1MzAuNzIzMjQ0LDI0NC42NDU2NzggNTMzLjU2MzkxNSwyNjIuNDg3ODc0IDUyMy4wOTIzNCwyNjguMzMyNTExIEM1MTUuOTUwNzQ2LDI3Mi4xODIxMTUgNTA3LjQ1OTQ5NiwyNjkuNzY0Njk2IDQ5OS43MTMzMjgsMjcwLjQ0NjIwOCBMNDgzLjg1ODg3NCwyNzAuNDQ2MjA4IEw0ODMuODU4ODc0LDI0Mi4wNDQ3OTcgWiBNNTI1LjY5MTgyNiwyMDkuOTAwNDg3IEM1MjguMjg4NDkxLDIxOS4wNjQ2NzkgNTE5LjQ1MzkwMywyMjcuMjkyMTE4IDUxMC42MjU5MTcsMjI2LjAzMDU2NiBMNDgzLjg1ODg3NCwyMjYuMDMwNTY2IEM0ODQuMDQzNzU4LDIxNy4zODg0NDEgNDgzLjQ5MTM0NSwyMDguMDA4OTczIDQ4NC4xMzEwNTMsMTk5LjgyMTY2MyBDNDk0Ljg1NDk0MiwyMDAuMTIzMzg2IDUwNS42Nzk1NzYsMTk5LjIwNTg0OSA1MTYuMzQwMzk0LDIwMC4zMDE4NTMgQzUyMC45MjE3OTksMjAxLjQ1MTU1OCA1MjQuNzUzOTM1LDIwNS4yMTc3MTIgNTI1LjY5MTgyNiwyMDkuOTAwNDg3IFogTTU5MC4xMjA0MTIsNzMuOTk3MjI1NCBDNTkwLjYxNzg3Miw5MS40OTg0NTQgNTkwLjE5MTQ3MSwxMDkuOTIzNjUgNTkwLjMzMzU5LDEyNy43ODAxOTIgQzU5MC4yOTkxMzcsMjAwLjM3NjM1OCA1OTAuNDA1OTQyLDI3Mi45NzQxNzQgNTkwLjI3ODg5NiwzNDUuNTY5MzAzIEM1ODkuODEwNDIsMzcyLjc3NjU5MiA1NjUuNjk2NTI0LDM5Ni40MTM2NzggNTM4LjY3ODc0OSwzOTYuOTU2Njk0IEM1MTEuNjMyOTIsMzk3LjA2ODQ1MSA0ODQuNTg0Mjk3LDM5Ni45NzI2MjggNDU3LjUzNzM5NiwzOTcuMDA0NDk3IEw0NTcuNTM3Mzk2LDI4Ny4yNTMyOTEgQzQ4Ny4wMDcsMjg3LjA5OTgwMyA1MTYuNDk2MDQsMjg3LjU2MSA1NDUuOTUzNTIxLDI4Ny4wMjE1OTQgQzU1OS42MjA3MiwyODYuMTYyNzY5IDU3NC41ODYwMjcsMjc3LjE0NTY5NSA1NzUuMjIzMjgsMjYyLjEwNzM3NCBDNTc2LjgzMzY2MSwyNDcuMDA1NDgzIDU2Mi41OTIxMjgsMjM2LjU1NzE4NSA1NDkuMDcxMDk2LDIzNC45MDU2ODQgQzU0My44NzI3NzMsMjM0Ljc3MDU0MiA1NDQuMDI3MTMyLDIzMy4zOTA4NDYgNTQ5LjA3MTA5NiwyMzIuNzg4OTcyIEM1NjEuOTYzMDcsMjMwLjAwMjQ4MyA1NzIuMDkwNjc1LDIxNi42NTU3ODcgNTY4LjI5Njc4NiwyMDMuMjkwMjI5IEM1NjUuMDYwNTIsMTg5LjIzMjM3NCA1NDkuNTIzODM5LDE4My43OTE0MiA1MzYuNjAwMzY2LDE4My44MTc3NjggQzUxMC4yNDg1NDgsMTgzLjYzODYxMiA0ODMuODkxMjk5LDE4My43OTIzNTkgNDU3LjUzNzM5NiwxODMuNzQxMTEgQzQ1Ny43MDg1ODUsMTYzLjI1MjQwOCA0NTcuMTgyOTE2LDE0Mi43NDA2NTMgNDU3LjgyMjcxLDEyMi4yNjczNjQgQzQ1OS45MTAzNjEsOTUuNTUxMzc2NiA0ODQuNjI4NjAzLDczLjUxOTUzMTkgNTExLjI2OTc1OSw3My45OTc2NTYgQzUzNy41NTMxNjYsNzMuOTk3MzY5MiA1NjMuODM3NzM3LDczLjk5ODIzMDEgNTkwLjEyMDQxMiw3My45OTcyMjU0IFpcIiBpZD1cInBhdGgzNDk2XCIgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtMSlcIj48L3BhdGg+IDxwYXRoIGQ9XCJNMTU5Ljc0MDQyOSwxMjUuMDQwNDk4IEMxNjAuNDEzNjg5LDk3Ljg3NjY1OTIgMTg0LjYyODYxOSw3NC40MjkwMjk5IDIxMS42MTQ3OTcsNzQuMDMyNTM5OCBDMjM4LjU1OTQ5Myw3My45NDk5Njg2IDI2NS41MDYyMDQsNzQuMDIwOTExOSAyOTIuNDUxNjcxLDczLjk5NzIyNTQgQzI5Mi4zNzc2NCwxNjQuODgyNDg4IDI5Mi41OTk5MDUsMjU1Ljc3MzY3MiAyOTIuMzQwMzAxLDM0Ni42NTUyMjIgQzI5MS4zMDIyOTgsMzczLjQ4ODgwMiAyNjcuMzUwNTQ4LDM5Ni40ODg2NjEgMjQwLjY2MTM1NiwzOTYuOTYyMjkyIEMyMTMuNjY1MDE1LDM5Ny4wNjA5NTcgMTg2LjY2NjI3NSwzOTYuOTc2MDc0IDE1OS42NjkwMTIsMzk3LjAwNDQ5NyBMMTU5LjY2OTAxMiwyODMuNTUwODc1IEMxODUuODkxNjIzLDI4OS43NDU0OTEgMjEzLjM5MTEzOCwyOTIuMzgyNTE4IDI0MC4xNDI0MDYsMjg4LjI3MjI0MiBDMjU2LjEzNDUwOSwyODUuNjk3MzY4IDI3My42Mjk5MzUsMjc3Ljg0ODAyNiAyNzkuMDQ0MjYxLDI2MS4yNTc1NjcgQzI4My4wMzAxMjIsMjQ3LjA2NjI2NyAyODAuNzg1NzIzLDIzMi4xMzE2MDIgMjgxLjM3ODAyNywyMTcuNTY2NDY1IEwyODEuMzc4MDI3LDE4My43NDE1NDEgTDIzNS4wODEyNDYsMTgzLjc0MTU0MSBDMjM0Ljg3MzEwNiwyMDYuMTEyMTQ1IDIzNS41MDcyNTgsMjI4LjUyMjQ0NyAyMzQuNzQ2MTQ2LDI1MC44NjcxMDcgQzIzMy40OTc4NSwyNjQuNjAxMjE0IDIxOS45MDAxNDcsMjczLjMyNjk5NiAyMDYuOTQ2NDI4LDI3Mi44NjE4MDEgQzE5MC44Nzk3NDcsMjczLjAzMDUzNSAxNTkuMDQ3NTUsMjYxLjIyMTc5NiAxNTkuMDQ3NTUsMjYxLjIyMTc5NiBDMTU4Ljk2NzQ5MiwyMTkuMzA0OCAxNTkuNTE0MzE0LDE2Ni44MTQzODUgMTU5Ljc0MDQyOSwxMjUuMDQwNDk4IFpcIiBpZD1cInBhdGgzNDk4XCIgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtMilcIj48L3BhdGg+IDxwYXRoIGQ9XCJNMzA5LjcxOTk5NSwxOTcuMzkwMTM2IEMzMDcuMjg1Nzg4LDE5Ny45MDczOCAzMDkuMjI5MTQxLDE4OS4wODk0NTkgMzA4LjYwNjI5OCwxODUuNzQzOTY0IEMzMDguNzcyMjMzLDE2NC41OTM2MzcgMzA4LjI2MDA0NSwxNDMuNDIwOTUxIDMwOC44ODk3MTgsMTIyLjI4NTgyNyBDMzEwLjk3MjU0MSw5NS40NTcwODI3IDMzNS44ODEyNjIsNzMuMzcwMTEwNSAzNjIuNjI4NzQ4LDczLjk5NzY1NiBMNDQxLjM5NDU2LDczLjk5NzY1NiBDNDQxLjMyMDY1OCwxNjQuODgyMzQ2IDQ0MS41NDI0OTMsMjU1Ljc3Mjk0IDQ0MS4yODM0MDYsMzQ2LjY1MzkzNCBDNDQwLjI0NDQxMiwzNzMuNDg4MDI3IDQxNi4yOTEzNDQsMzk2LjQ4NzEwMiAzODkuNjAyMDg3LDM5Ni45NjIyOTIgQzM2Mi42MDQ2MDUsMzk3LjA2MTk5MSAzMzUuNjA0NzA3LDM5Ni45NzY1MDQgMzA4LjYwNjI5OCwzOTcuMDA0OTI4IEwzMDguNjA2Mjk4LDI3Mi43MDc2MjQgQzMyNy4wNDY0MSwyODcuODM1ODQ2IDM1Mi4xMDU3MzgsMjkwLjE5MjI0OCAzNzUuMDc3OTUzLDI5MC4yMzM0ODQgQzM5Mi4zOTUwMSwyOTAuMjI3NDU1IDQwOS42MTE4NjEsMjg3LjU1Nzg2NSA0MjYuNDI4MTQzLDI4My41NjI5MzQgTDQyNi40MjgxNDMsMjYwLjc5MDI5NyBDNDA3LjQ3NDY1OCwyNzAuMjM2NjA5IDM4NS4xOTQ4MDgsMjc2LjIzNTgxNSAzNjQuMTg0NzQ1LDI3MC44MDc5NjYgQzM0OS41MjkwNTEsMjY3LjE1NzM2NyAzMzguODkwODksMjUyLjk5NjY4MyAzMzkuMTI4NTEzLDIzNy44NzIyMDQgQzMzNy40MzAwMSwyMjIuMTQzNjg0IDM0Ni42NTI2MzEsMjA1LjUzNjg4NSAzNjIuMTEwMjM3LDIwMC44NjA4NTUgQzM4MS4zMDA5MjMsMTk0Ljg1MjU0NSA0MDIuMjE3Nzg3LDE5OS40NDg0NTQgNDIwLjIwNjM0NCwyMDcuMjU4Nzk1IEM0MjQuMDYwNTI2LDIwOS4yNzY5NSA0MjcuOTcwNjYsMjExLjc4MDM0MiA0MjYuNDI4MTQzLDIwNS4zMzgwNDQgTDQyNi40MjgxNDMsMTg3LjQzODM1OCBDMzk2LjM0MzU4MSwxODAuMjgwOTUxIDM2NC4zMjY2NDQsMTc3LjY0NjQwNSAzMzQuMDk5NDM4LDE4NS40MzM2MTkgQzMyNS4zNTExOTMsMTg3LjkwMTc3NCAzMTYuODI4MTksMTkxLjY0NDY0NyAzMDkuNzE5OTk1LDE5Ny4zOTAxMzYgWlwiIGlkPVwicGF0aDM1MDBcIiBmaWxsPVwidXJsKCNsaW5lYXJHcmFkaWVudC0zKVwiPjwvcGF0aD4gPC9nPiA8L2c+YFxuICAgIGxldCBtYWVzdHJvID0gYDxnIGlkPVwiUGFnZS0xXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj4gPGcgaWQ9XCJtYWVzdHJvXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiPiA8cmVjdCBpZD1cIlJlY3RhbmdsZS0xXCIgZmlsbD1cIiMwMDAwMDBcIiB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI3NTBcIiBoZWlnaHQ9XCI0NzFcIiByeD1cIjQwXCI+PC9yZWN0PiA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEzMy4wMDAwMDAsIDQ4LjAwMDAwMClcIj4gPHBhdGggZD1cIk0xNDYuOCwzNzMuNzcgTDE0Ni44LDM0OSBDMTQ2LjgsMzM5LjY1IDE0MC44LDMzMy4zNiAxMzEuMjUsMzMzLjI4IEMxMjYuMjUsMzMzLjIgMTIwLjk5LDMzNC43NyAxMTcuMzUsMzQwLjI4IEMxMTQuNjIsMzM1LjkgMTEwLjM1LDMzMy4yOCAxMDQuMjgsMzMzLjI4IEM5OS42NTI4MTQ5LDMzMy4wNDc3MjkgOTUuMjQ3OTk3NCwzMzUuMjgwNTY4IDkyLjcsMzM5LjE1IEw5Mi43LDMzNC4yNyBMODQuMDksMzM0LjI3IEw4NC4wOSwzNzMuODIgTDkyLjc4LDM3My44MiBMOTIuNzgsMzUxLjg1IEM5Mi43OCwzNDQuOTggOTYuNTksMzQxLjM0IDEwMi40NiwzNDEuMzQgQzEwOC4xNywzNDEuMzQgMTExLjA3LDM0NS4wNiAxMTEuMDcsMzUxLjc2IEwxMTEuMDcsMzczLjc2IEwxMTkuNzYsMzczLjc2IEwxMTkuNzYsMzUxLjg1IEMxMTkuNzYsMzQ0Ljk4IDEyMy43NiwzNDEuMzQgMTI5LjQ0LDM0MS4zNCBDMTM1LjMxLDM0MS4zNCAxMzguMTMsMzQ1LjA2IDEzOC4xMywzNTEuNzYgTDEzOC4xMywzNzMuNzYgTDE0Ni44LDM3My43NyBaIE0xOTUuMjgsMzU0IEwxOTUuMjgsMzM0LjIzIEwxODYuNjcsMzM0LjIzIEwxODYuNjcsMzM5IEMxODMuOTQsMzM1LjQ0IDE3OS44LDMzMy4yMSAxNzQuMTgsMzMzLjIxIEMxNjMuMDksMzMzLjIxIDE1NC40MSwzNDEuOSAxNTQuNDEsMzUzLjk4IEMxNTQuNDEsMzY2LjA2IDE2My4xLDM3NC43NSAxNzQuMTgsMzc0Ljc1IEMxNzkuODEsMzc0Ljc1IDE4My45NCwzNzIuNTIgMTg2LjY3LDM2OC45NiBMMTg2LjY3LDM3My43NiBMMTk1LjI4LDM3My43NiBMMTk1LjI4LDM1NCBaIE0xNjMuMjgsMzU0IEMxNjMuMjgsMzQ3LjA1IDE2Ny44MywzNDEuMzQgMTc1LjI4LDM0MS4zNCBDMTgyLjQsMzQxLjM0IDE4Ny4xOSwzNDYuOCAxODcuMTksMzU0IEMxODcuMTksMzYxLjIgMTgyLjM5LDM2Ni42NiAxNzUuMjgsMzY2LjY2IEMxNjcuODEsMzY2LjY2IDE2My4yNiwzNjAuOTUgMTYzLjI2LDM1NCBMMTYzLjI4LDM1NCBaIE0zNzkuNCwzMzMuMTkgQzM4Mi4zMDY2MDIsMzMzLjE2MTM1OCAzODUuMTkwNzQzLDMzMy43MDE0OTggMzg3Ljg5LDMzNC43OCBDMzkwLjQwNDcxOSwzMzUuNzg0NjU0IDM5Mi42OTc5OTcsMzM3LjI3MjczNiAzOTQuNjQsMzM5LjE2IEMzOTYuNTUzMDYzLDM0MS4wMzU3NTggMzk4LjA2OTc0NCwzNDMuMjc2NzczIDM5OS4xLDM0NS43NSBDNDAxLjI0NjAwMywzNTEuMDQ3NTg3IDQwMS4yNDYwMDMsMzU2Ljk3MjQxMyAzOTkuMSwzNjIuMjcgQzM5OC4wNjk3NDQsMzY0Ljc0MzIyNyAzOTYuNTUzMDYzLDM2Ni45ODQyNDIgMzk0LjY0LDM2OC44NiBDMzkyLjY5ODMyMiwzNzAuNzQ3NjcxIDM5MC40MDQ5NTgsMzcyLjIzNTgwOSAzODcuODksMzczLjI0IEMzODIuNDIzMTY1LDM3NS4zNjgyNjQgMzc2LjM1NjgzNSwzNzUuMzY4MjY0IDM3MC44OSwzNzMuMjQgQzM2OC4zNzk1MDEsMzcyLjIzODYzIDM2Ni4wOTIxNjgsMzcwLjc0OTk5NCAzNjQuMTYsMzY4Ljg2IEMzNjIuMjU4NDg1LDM2Ni45Nzg3OTggMzYwLjc0OTMxOSwzNjQuNzM4ODQzIDM1OS43MiwzNjIuMjcgQzM1Ny41NzM5OTcsMzU2Ljk3MjQxMyAzNTcuNTczOTk3LDM1MS4wNDc1ODcgMzU5LjcyLDM0NS43NSBDMzYwLjc0OTc4OCwzNDMuMjgxNDEgMzYyLjI1ODg5NSwzNDEuMDQxNTQyIDM2NC4xNiwzMzkuMTYgQzM2Ni4wOTIzMzQsMzM3LjI3MDIxMyAzNjguMzc5NjIzLDMzNS43ODE2MDYgMzcwLjg5LDMzNC43OCBDMzczLjU5NTQ5MywzMzMuNjk4OTMgMzc2LjQ4NjY4MSwzMzMuMTU4NzQzIDM3OS40LDMzMy4xOSBaIE0zNzkuNCwzNDEuMzMgQzM3Ny43MTgyMjEsMzQxLjMxNTQ0MSAzNzYuMDQ5OTY0LDM0MS42MzE0MjUgMzc0LjQ5LDM0Mi4yNiBDMzczLjAxOTc0NiwzNDIuODUwMzYzIDM3MS42ODU3NTEsMzQzLjczNTE1NiAzNzAuNTcsMzQ0Ljg2IEMzNjkuNDQ3MDkyLDM0Ni4wMDgwNzcgMzY4LjU2MzMzNiwzNDcuMzY3NzAyIDM2Ny45NywzNDguODYgQzM2Ni43MDQyNzEsMzUyLjE2OTc4NCAzNjYuNzA0MjcxLDM1NS44MzAyMTYgMzY3Ljk3LDM1OS4xNCBDMzY4LjU2Mjg2MSwzNjAuNjMyNTQ0IDM2OS40NDY2NzUsMzYxLjk5MjI1OCAzNzAuNTcsMzYzLjE0IEMzNzEuNjg1NzUxLDM2NC4yNjQ4NDQgMzczLjAxOTc0NiwzNjUuMTQ5NjM3IDM3NC40OSwzNjUuNzQgQzM3Ny42NDk0ODgsMzY2Ljk3OTI4MyAzODEuMTYwNTEyLDM2Ni45NzkyODMgMzg0LjMyLDM2NS43NCBDMzg1Ljc5NDI4NCwzNjUuMTQ2MDk4IDM4Ny4xMzQxNTQsMzY0LjI2MTkyIDM4OC4yNiwzNjMuMTQgQzM4OS4zOTI4MjksMzYxLjk5NTkyOSAzOTAuMjgzODQ4LDM2MC42MzU1OTQgMzkwLjg4LDM1OS4xNCBDMzkyLjE0NTcyOSwzNTUuODMwMjE2IDM5Mi4xNDU3MjksMzUyLjE2OTc4NCAzOTAuODgsMzQ4Ljg2IEMzOTAuMjgzODQ4LDM0Ny4zNjQ0MDYgMzg5LjM5MjgyOSwzNDYuMDA0MDcxIDM4OC4yNiwzNDQuODYgQzM4Ny4xMzQxNTQsMzQzLjczODA4IDM4NS43OTQyODQsMzQyLjg1MzkwMiAzODQuMzIsMzQyLjI2IEMzODIuNzU3NjEzLDM0MS42MjY3MTQgMzgxLjA4NTgwNywzNDEuMzA3MzA0IDM3OS40LDM0MS4zMiBMMzc5LjQsMzQxLjMzIFogTTI0Mi4xLDM1NCBDMjQyLjAyLDM0MS42NyAyMzQuNDEsMzMzLjIzIDIyMy4zMiwzMzMuMjMgQzIxMS43NCwzMzMuMjMgMjAzLjYzLDM0MS42NyAyMDMuNjMsMzU0IEMyMDMuNjMsMzY2LjU4IDIxMi4wNywzNzQuNzcgMjIzLjksMzc0Ljc3IEMyMjkuOSwzNzQuNzcgMjM1LjMyLDM3My4yOCAyNDAuMTIsMzY5LjIzIEwyMzUuOSwzNjIuODYgQzIzMi42MzMyNjIsMzY1LjQ3OTY0OCAyMjguNTg2ODk0LDM2Ni45MzYzNDEgMjI0LjQsMzY3IEMyMTguODYsMzY3IDIxMy44MSwzNjQuNDQgMjEyLjU3LDM1Ny4zMiBMMjQxLjk0LDM1Ny4zMiBDMjQyLDM1Ni4yMyAyNDIuMSwzNTUuMTYgMjQyLjEsMzU0IFogTTIxMi42NSwzNTAuNTMgQzIxMy41NiwzNDQuODIgMjE3LjAzLDM0MC45MyAyMjMuMTYsMzQwLjkzIEMyMjguNywzNDAuOTMgMjMyLjI2LDM0NC40IDIzMy4xNiwzNTAuNTMgTDIxMi42NSwzNTAuNTMgWiBNMjc4LjM0LDM0NC4zMyBDMjc0LjU4MjgwMywzNDIuMTY1NTQ3IDI3MC4zMzU1NjUsMzQwLjk5NTMxOSAyNjYsMzQwLjkzIEMyNjEuMjgsMzQwLjkzIDI1OC40NywzNDIuNjcgMjU4LjQ3LDM0NS41NiBDMjU4LjQ3LDM0OC4yMSAyNjEuNDcsMzQ4Ljk1IDI2NS4xNywzNDkuNDUgTDI2OS4yMiwzNTAuMDMgQzI3Ny44MywzNTEuMjcgMjgzLjA0LDM1NC45MSAyODMuMDQsMzYxLjg2IEMyODMuMDQsMzY5LjM5IDI3Ni40MiwzNzQuNzcgMjY1LjA0LDM3NC43NyBDMjU4LjU5LDM3NC43NyAyNTIuNjMsMzczLjExIDI0Ny45MSwzNjkuNjQgTDI1MS45NiwzNjIuOTQgQzI1NS43NTc3ODUsMzY1Ljc1NzcwMiAyNjAuMzkzMDQsMzY3LjIxNTkwNSAyNjUuMTIsMzY3LjA4IEMyNzAuOTksMzY3LjA4IDI3NC4xMiwzNjUuMzQgMjc0LjEyLDM2Mi4yOCBDMjc0LjEyLDM2MC4wNSAyNzEuODksMzU4LjgxIDI2Ny4xNywzNTguMTQgTDI2My4xMiwzNTcuNTYgQzI1NC4yNywzNTYuMzIgMjQ5LjQ3LDM1Mi4zNSAyNDkuNDcsMzQ1Ljg5IEMyNDkuNDcsMzM4LjAzIDI1NS45MiwzMzMuMjMgMjY1LjkzLDMzMy4yMyBDMjcyLjIyLDMzMy4yMyAyNzcuOTMsMzM0LjY0IDI4Mi4wNiwzMzcuMzcgTDI3OC4zNCwzNDQuMzMgWiBNMzE5LjY5LDM0Mi4xIEwzMDUuNjIsMzQyLjEgTDMwNS42MiwzNjAgQzMwNS42MiwzNjQgMzA3LjAzLDM2Ni42MiAzMTEuMzMsMzY2LjYyIEMzMTQuMDE0MzY1LDM2Ni41MzE3NTQgMzE2LjYzMjU2MiwzNjUuNzY0NTMgMzE4Ljk0LDM2NC4zOSBMMzIxLjQyLDM3MS43NSBDMzE4LjE5MjQ3NSwzNzMuNzYxNjAyIDMxNC40NjMwNjYsMzc0LjgyMjE5NiAzMTAuNjYsMzc0LjgxIEMzMDAuNDgsMzc0LjgxIDI5Ni45MywzNjkuMzUgMjk2LjkzLDM2MC4xNiBMMjk2LjkzLDM0Mi4xNiBMMjg4LjkzLDM0Mi4xNiBMMjg4LjkzLDMzNC4zIEwyOTYuOTMsMzM0LjMgTDI5Ni45MywzMjIuMyBMMzA1LjYyLDMyMi4zIEwzMDUuNjIsMzM0LjMgTDMxOS42OCwzMzQuMyBMMzE5LjY5LDM0Mi4xIFogTTM0OS40NywzMzMuMjUgQzM1MS41NTY1MTQsMzMzLjI2MDAxMiAzNTMuNjI2MDksMzMzLjYyNTIzMiAzNTUuNTksMzM0LjMzIEwzNTIuOTQsMzQyLjQ0IEMzNTEuMjI5OTA0LDM0MS43NTYwMjIgMzQ5LjQwMTY1MywzNDEuNDE2MTk4IDM0Ny41NiwzNDEuNDQgQzM0MS45MywzNDEuNDQgMzM5LjEyLDM0NS4wOCAzMzkuMTIsMzUxLjYyIEwzMzkuMTIsMzczLjc5IEwzMzAuNTIsMzczLjc5IEwzMzAuNTIsMzM0LjIzIEwzMzksMzM0LjIzIEwzMzksMzM5IEMzNDEuMTQ5NzI2LDMzNS4zMDYxOTggMzQ1LjE0ODAyOCwzMzMuMDg0NDkyIDM0OS40MiwzMzMuMjEgTDM0OS40NywzMzMuMjUgWlwiIGlkPVwiU2hhcGVcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD4gPGcgaWQ9XCJfR3JvdXBfXCI+IDxyZWN0IGlkPVwiUmVjdGFuZ2xlLXBhdGhcIiBmaWxsPVwiIzc2NzNDMFwiIHg9XCIxNzYuOTVcIiB5PVwiMzIuMzlcIiB3aWR0aD1cIjEzMC41XCIgaGVpZ2h0PVwiMjM0LjUxXCI+PC9yZWN0PiA8cGF0aCBkPVwiTTE4NS4yNCwxNDkuNjQgQzE4NS4yMDUxNCwxMDMuODY5NTQgMjA2LjIyNTM4Niw2MC42MjY4Mzc0IDI0Mi4yNCwzMi4zOCBDMTgxLjA5Mjk2OCwtMTUuNjgxODI0OSA5My4yNzc3MTg5LC04LjY4NTc4NTc0IDQwLjUxMTYzNzIsNDguNDUxMjM1MyBDLTEyLjI1NDQ0NDUsMTA1LjU4ODI1NiAtMTIuMjU0NDQ0NSwxOTMuNjgxNzQ0IDQwLjUxMTYzNzIsMjUwLjgxODc2NSBDOTMuMjc3NzE4OSwzMDcuOTU1Nzg2IDE4MS4wOTI5NjgsMzE0Ljk1MTgyNSAyNDIuMjQsMjY2Ljg5IEMyMDYuMjI4MTUxLDIzOC42NDUzMjggMTg1LjIwODIxNSwxOTUuNDA2OTUxIDE4NS4yNCwxNDkuNjQgWlwiIGlkPVwiX1BhdGhfXCIgZmlsbD1cIiNFQjAwMUJcIj48L3BhdGg+IDxwYXRoIGQ9XCJNNDgzLjUsMTQ5LjY0IEM0ODMuNTAxMDM0LDIwNi43Mzg3NCA0NTAuOTAxNTYsMjU4LjgyNjM1NiAzOTkuNTQ1NTU4LDI4My43ODI4NjIgQzM0OC4xODk1NTYsMzA4LjczOTM2OCAyODcuMDkyMzQzLDMwMi4xODM3NTkgMjQyLjIsMjY2LjkgQzI3OC4xNjY1ODQsMjM4LjYyMDE4NyAyOTkuMTY0NzE1LDE5NS4zOTgwNjUgMjk5LjE2NDcxNSwxNDkuNjQ1IEMyOTkuMTY0NzE1LDEwMy44OTE5MzUgMjc4LjE2NjU4NCw2MC42Njk4MTMgMjQyLjIsMzIuMzkgQzI4Ny4wOTA5MjQsLTIuODkyNjQ0NzcgMzQ4LjE4NTg0NSwtOS40NDkwNDI4OCAzOTkuNTQxMDYxLDE1LjUwNDk1MjUgQzQ1MC44OTYyNzcsNDAuNDU4OTQ3OSA0ODMuNDk3MjA2LDkyLjU0MzA2NCA0ODMuNSwxNDkuNjQgWlwiIGlkPVwiU2hhcGVcIiBmaWxsPVwiIzAwQTFERlwiPjwvcGF0aD4gPC9nPiA8L2c+IDwvZz4gPC9nPmBcbiAgICBsZXQgbWFzdGVyY2FyZCA9IGA8ZyBpZD1cIlBhZ2UtMVwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+IDxnIGlkPVwibWFzdGVyY2FyZFwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIj4gPHJlY3QgaWQ9XCJSZWN0YW5nbGUtMVwiIGZpbGw9XCIjMDAwMDAwXCIgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiNzUwXCIgaGVpZ2h0PVwiNDcxXCIgcng9XCI0MFwiPjwvcmVjdD4gPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMzMuMDAwMDAwLCA0OC4wMDAwMDApXCI+IDxwYXRoIGQ9XCJNODguMTMsMzczLjY3IEw4OC4xMywzNDguODIgQzg4LjEzLDMzOS4yOSA4Mi4zMywzMzMuMDggNzIuODEsMzMzLjA4IEM2Ny44MSwzMzMuMDggNjIuNDYsMzM0Ljc0IDU4LjczLDM0MC4wOCBDNTUuODMsMzM1LjUyIDUxLjczLDMzMy4wOCA0NS40OCwzMzMuMDggQzQwLjc1OTkxNDksMzMyLjg3NjAwOCAzNi4yNTI1MzM3LDMzNS4wNTQ1NzUgMzMuNDgsMzM4Ljg4IEwzMy40OCwzMzMuODggTDI1LjYxLDMzMy44OCBMMjUuNjEsMzczLjY0IEwzMy40OCwzNzMuNjQgTDMzLjQ4LDM1MC44OSBDMzMuNDgsMzQzLjg5IDM3LjYyLDM0MC41NCA0My40MiwzNDAuNTQgQzQ5LjIyLDM0MC41NCA1Mi41MywzNDQuMjcgNTIuNTMsMzUwLjg5IEw1Mi41MywzNzMuNjcgTDYwLjQsMzczLjY3IEw2MC40LDM1MC44OSBDNjAuNCwzNDMuODkgNjQuNTQsMzQwLjU0IDcwLjM0LDM0MC41NCBDNzYuMTQsMzQwLjU0IDc5LjQ1LDM0NC4yNyA3OS40NSwzNTAuODkgTDc5LjQ1LDM3My42NyBMODguMTMsMzczLjY3IFogTTIxNy4zNSwzMzQuMzIgTDIwMi44NSwzMzQuMzIgTDIwMi44NSwzMjIuMzIgTDE5NSwzMjIuMzIgTDE5NSwzMzQuMzIgTDE4Ni43MiwzMzQuMzIgTDE4Ni43MiwzNDEuMzIgTDE5NSwzNDEuMzIgTDE5NSwzNjAgQzE5NSwzNjkuMTEgMTk4LjMxLDM3NC41IDIwOC4yNSwzNzQuNSBDMjEyLjAxNTc4NCwzNzQuNDIxNDgzIDIxNS43MDU2NTEsMzczLjQyNjA3NyAyMTksMzcxLjYgTDIxNi41MSwzNjQuNiBDMjE0LjI3NTY4NSwzNjUuOTk2NTU3IDIxMS42ODQ0NzUsMzY2LjcxNTU2NSAyMDkuMDUsMzY2LjY3IEMyMDQuOTEsMzY2LjY3IDIwMi44NCwzNjQuMTggMjAyLjg0LDM2MC4wNCBMMjAyLjg0LDM0MSBMMjE3LjM0LDM0MSBMMjE3LjM0LDMzNC4zNyBMMjE3LjM1LDMzNC4zMiBaIE0yOTEuMDcsMzMzLjA4IEMyODYuNzA5MzU1LDMzMi45ODI4NDYgMjgyLjYxODgzNiwzMzUuMTg1NzI2IDI4MC4zLDMzOC44OCBMMjgwLjMsMzMzLjg4IEwyNzIuNDMsMzMzLjg4IEwyNzIuNDMsMzczLjY0IEwyODAuMywzNzMuNjQgTDI4MC4zLDM1MS4zMSBDMjgwLjMsMzQ0LjY4IDI4My42MSwzNDAuNTQgMjg5LDM0MC41NCBDMjkwLjgxODgwOSwzNDAuNjEzNzgzIDI5Mi42MjM1MiwzNDAuODkyMjA1IDI5NC4zOCwzNDEuMzcgTDI5Ni44NywzMzMuOTEgQzI5NC45NzEwMTMsMzMzLjQzMTI2IDI5My4wMjcwNCwzMzMuMTUzMDcxIDI5MS4wNywzMzMuMDggWiBNMTc5LjY2LDMzNy4yMiBDMTc1LjUyLDMzNC4zMiAxNjkuNzIsMzMzLjA4IDE2My41MSwzMzMuMDggQzE1My41NywzMzMuMDggMTQ3LjM2LDMzNy42NCAxNDcuMzYsMzQ1LjUxIEMxNDcuMzYsMzUyLjE0IDE1MS45MiwzNTUuODYgMTYwLjYxLDM1Ny4xMSBMMTY0Ljc1LDM1Ny41MiBDMTY5LjMxLDM1OC4zNSAxNzIuMjEsMzYwLjAxIDE3Mi4yMSwzNjIuMDggQzE3Mi4yMSwzNjQuOTggMTY4LjksMzY3LjA4IDE2Mi42OCwzNjcuMDggQzE1Ny45MzA2MjcsMzY3LjE3NzcxNiAxNTMuMjc4ODg5LDM2NS43MjQyNjcgMTQ5LjQzLDM2Mi45NCBMMTQ1LjI5LDM2OS4xNSBDMTUxLjA5LDM3My4yOSAxNTguMTMsMzc0LjE1IDE2Mi4yOSwzNzQuMTUgQzE3My44OSwzNzQuMTUgMTgwLjEsMzY4Ljc3IDE4MC4xLDM2MS4zMSBDMTgwLjEsMzU0LjMxIDE3NS4xLDM1MC45NiAxNjYuNDMsMzQ5LjcxIEwxNjIuMjksMzQ5LjMgQzE1OC41NiwzNDguODkgMTU1LjI5LDM0Ny42NCAxNTUuMjksMzQ1LjE2IEMxNTUuMjksMzQyLjI2IDE1OC42LDM0MC4xNiAxNjMuMTYsMzQwLjE2IEMxNjguMTYsMzQwLjE2IDE3My4xLDM0Mi4yMyAxNzUuNTksMzQzLjQ3IEwxNzkuNjYsMzM3LjIyIFogTTI5OS43NywzNTMuNzkgQzI5OS43NywzNjUuNzkgMzA3LjY0LDM3NC41IDMyMC40OCwzNzQuNSBDMzI2LjI4LDM3NC41IDMzMC40MiwzNzMuMjYgMzM0LjU2LDM2OS45NCBMMzMwLjQyLDM2My43MyBDMzI3LjQ4ODc1OCwzNjYuMTAzODggMzIzLjg0MTcwMywzNjcuNDE4MjMgMzIwLjA3LDM2Ny40NiBDMzEzLjA3LDM2Ny40NiAzMDcuNjQsMzYyLjA4IDMwNy42NCwzNTQuMjEgQzMwNy42NCwzNDYuMzQgMzEzLDM0MSAzMjAuMDcsMzQxIEMzMjMuODQxNzAzLDM0MS4wNDE3NyAzMjcuNDg4NzU4LDM0Mi4zNTYxMiAzMzAuNDIsMzQ0LjczIEwzMzQuNTYsMzM4LjUyIEMzMzAuNDIsMzM1LjIxIDMyNi4yOCwzMzMuOTYgMzIwLjQ4LDMzMy45NiBDMzA4LjA1LDMzMy4xMyAyOTkuNzcsMzQxLjgzIDI5OS43NywzNTMuODQgTDI5OS43NywzNTMuNzkgWiBNMjQ0LjI3LDMzMy4wOCBDMjMyLjY3LDMzMy4wOCAyMjQuOCwzNDEuMzYgMjI0LjgsMzUzLjc5IEMyMjQuOCwzNjYuMjIgMjMzLjA4LDM3NC41IDI0NS4wOSwzNzQuNSBDMjUwLjkzMjc3NSwzNzQuNjIzNDA4IDI1Ni42Mzg0ODYsMzcyLjcyMjY4MiAyNjEuMjQsMzY5LjEyIEwyNTcuMSwzNjMuMzIgQzI1My43NzIxMzIsMzY1Ljg5ODc0MyAyNDkuNzA4NTk4LDM2Ny4zNDkwMDQgMjQ1LjUsMzY3LjQ2IEMyNDAuMTIsMzY3LjQ2IDIzNC4zMiwzNjQuMTUgMjMzLjUsMzU3LjExIEwyNjIuOTEsMzU3LjExIEwyNjIuOTEsMzUzLjggQzI2Mi45MSwzNDEuMzcgMjU1LjQ1LDMzMy4wOSAyNDQuMjcsMzMzLjA5IEwyNDQuMjcsMzMzLjA4IFogTTI0My44NiwzNDAuNTQgQzI0OS42NiwzNDAuNTQgMjUzLjgsMzQ0LjI3IDI1NC4yMSwzNTAuNDggTDIzMi42OCwzNTAuNDggQzIzMy45MiwzNDQuNjggMjM3LjY4LDM0MC41NCAyNDMuODYsMzQwLjU0IFogTTEzNi41OSwzNTMuNzkgTDEzNi41OSwzMzMuOTEgTDEyOC43MiwzMzMuOTEgTDEyOC43MiwzMzguOTEgQzEyNS44MiwzMzUuMTggMTIxLjcyLDMzMy4xMSAxMTUuODgsMzMzLjExIEMxMDQuNywzMzMuMTEgOTYuNDEsMzQxLjgxIDk2LjQxLDM1My44MiBDOTYuNDEsMzY1LjgzIDEwNC42OSwzNzQuNTMgMTE1Ljg4LDM3NC41MyBDMTIxLjY4LDM3NC41MyAxMjUuODIsMzcyLjQ2IDEyOC43MiwzNjguNzMgTDEyOC43MiwzNzMuNzMgTDEzNi41OSwzNzMuNzMgTDEzNi41OSwzNTMuNzkgWiBNMTA0LjcsMzUzLjc5IEMxMDQuNywzNDYuMzMgMTA5LjI2LDM0MC41NCAxMTcuMTMsMzQwLjU0IEMxMjQuNTksMzQwLjU0IDEyOS4xMywzNDYuMzQgMTI5LjEzLDM1My43OSBDMTI5LjEzLDM2MS42NiAxMjQuMTMsMzY3LjA0IDExNy4xMywzNjcuMDQgQzEwOS4yNiwzNjcuNDUgMTA0LjcsMzYxLjI0IDEwNC43LDM1My43OSBaIE00MTAuNzgsMzMzLjA4IEM0MDYuNDE5MzU1LDMzMi45ODI4NDYgNDAyLjMyODgzNiwzMzUuMTg1NzI2IDQwMC4wMSwzMzguODggTDQwMC4wMSwzMzMuODggTDM5Mi4xNCwzMzMuODggTDM5Mi4xNCwzNzMuNjQgTDQwMCwzNzMuNjQgTDQwMCwzNTEuMzEgQzQwMCwzNDQuNjggNDAzLjMxLDM0MC41NCA0MDguNywzNDAuNTQgQzQxMC41MTg4MDksMzQwLjYxMzc4MyA0MTIuMzIzNTIsMzQwLjg5MjIwNSA0MTQuMDgsMzQxLjM3IEw0MTYuNTcsMzMzLjkxIEM0MTQuNjcxMDEzLDMzMy40MzEyNiA0MTIuNzI3MDQsMzMzLjE1MzA3MSA0MTAuNzcsMzMzLjA4IEw0MTAuNzgsMzMzLjA4IFogTTM4MC4xMywzNTMuNzkgTDM4MC4xMywzMzMuOTEgTDM3Mi4yNiwzMzMuOTEgTDM3Mi4yNiwzMzguOTEgQzM2OS4zNiwzMzUuMTggMzY1LjI2LDMzMy4xMSAzNTkuNDIsMzMzLjExIEMzNDguMjQsMzMzLjExIDMzOS45NSwzNDEuODEgMzM5Ljk1LDM1My44MiBDMzM5Ljk1LDM2NS44MyAzNDguMjMsMzc0LjUzIDM1OS40MiwzNzQuNTMgQzM2NS4yMiwzNzQuNTMgMzY5LjM2LDM3Mi40NiAzNzIuMjYsMzY4LjczIEwzNzIuMjYsMzczLjczIEwzODAuMTMsMzczLjczIEwzODAuMTMsMzUzLjc5IFogTTM0OC4yNCwzNTMuNzkgQzM0OC4yNCwzNDYuMzMgMzUyLjgsMzQwLjU0IDM2MC42NywzNDAuNTQgQzM2OC4xMywzNDAuNTQgMzcyLjY3LDM0Ni4zNCAzNzIuNjcsMzUzLjc5IEMzNzIuNjcsMzYxLjY2IDM2Ny42NywzNjcuMDQgMzYwLjY3LDM2Ny4wNCBDMzUyLjgsMzY3LjQ1IDM0OC4yNCwzNjEuMjQgMzQ4LjI0LDM1My43OSBaIE00NjAuMDcsMzUzLjc5IEw0NjAuMDcsMzE4LjE3IEw0NTIuMiwzMTguMTcgTDQ1Mi4yLDMzOC44OCBDNDQ5LjMsMzM1LjE1IDQ0NS4yLDMzMy4wOCA0MzkuMzYsMzMzLjA4IEM0MjguMTgsMzMzLjA4IDQxOS44OSwzNDEuNzggNDE5Ljg5LDM1My43OSBDNDE5Ljg5LDM2NS44IDQyOC4xNywzNzQuNSA0MzkuMzYsMzc0LjUgQzQ0NS4xNiwzNzQuNSA0NDkuMywzNzIuNDMgNDUyLjIsMzY4LjcgTDQ1Mi4yLDM3My43IEw0NjAuMDcsMzczLjcgTDQ2MC4wNywzNTMuNzkgWiBNNDI4LjE4LDM1My43OSBDNDI4LjE4LDM0Ni4zMyA0MzIuNzQsMzQwLjU0IDQ0MC42MSwzNDAuNTQgQzQ0OC4wNywzNDAuNTQgNDUyLjYxLDM0Ni4zNCA0NTIuNjEsMzUzLjc5IEM0NTIuNjEsMzYxLjY2IDQ0Ny42MSwzNjcuMDQgNDQwLjYxLDM2Ny4wNCBDNDMyLjczLDM2Ny40NiA0MjguMTcsMzYxLjI1IDQyOC4xNywzNTMuNzkgTDQyOC4xOCwzNTMuNzkgWlwiIGlkPVwiU2hhcGVcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD4gPGc+IDxyZWN0IGlkPVwiUmVjdGFuZ2xlLXBhdGhcIiBmaWxsPVwiI0ZGNUYwMFwiIHg9XCIxNzAuNTVcIiB5PVwiMzIuMzlcIiB3aWR0aD1cIjE0My43MlwiIGhlaWdodD1cIjIzNC40MlwiPjwvcmVjdD4gPHBhdGggZD1cIk0xODUuMDUsMTQ5LjYgQzE4NS4wNTk5NywxMDMuOTEyNTU0IDIwNS45NjA0Niw2MC43Mzc2MDg1IDI0MS43OSwzMi4zOSBDMTgwLjY2MjAxOCwtMTUuNjcxMzk2OCA5Mi44NjIwMDM3LC04LjY4NTIzNDE1IDQwLjEwMzQ2Miw0OC40MzgwMDM3IEMtMTIuNjU1MDc5NiwxMDUuNTYxMjQxIC0xMi42NTUwNzk2LDE5My42Mzg3NTkgNDAuMTAzNDYyLDI1MC43NjE5OTYgQzkyLjg2MjAwMzcsMzA3Ljg4NTIzNCAxODAuNjYyMDE4LDMxNC44NzEzOTcgMjQxLjc5LDI2Ni44MSBDMjA1Ljk2MDQ2LDIzOC40NjIzOTEgMTg1LjA1OTk3LDE5NS4yODc0NDYgMTg1LjA1LDE0OS42IFpcIiBpZD1cIlNoYXBlXCIgZmlsbD1cIiNFQjAwMUJcIj48L3BhdGg+IDxwYXRoIGQ9XCJNNDgzLjI2LDE0OS42IEM0ODMuMzAxMzQsMjA2LjY0NjY3OSA0NTAuNzU2Nzg5LDI1OC43MDYwMjIgMzk5LjQ1NTYxNywyODMuNjU2MjczIEMzNDguMTU0NDQ1LDMwOC42MDY1MjMgMjg3LjEwOTE4MSwzMDIuMDY0NDUxIDI0Mi4yNiwyNjYuODEgQzI3OC4wOTg0MjQsMjM4LjQ2OTM2IDI5OS4wMDE1OTMsMTk1LjI5MDA5MiAyOTkuMDAxNTkzLDE0OS42IEMyOTkuMDAxNTkzLDEwMy45MDk5MDggMjc4LjA5ODQyNCw2MC43MzA2NDAyIDI0Mi4yNiwzMi4zOSBDMjg3LjEwOTE4MSwtMi44NjQ0NTA1MiAzNDguMTU0NDQ1LC05LjQwNjUyMzI0IDM5OS40NTU2MTcsMTUuNTQzNzI3NCBDNDUwLjc1Njc4OSw0MC40OTM5NzggNDgzLjMwMTM0LDkyLjU1MzMyMTEgNDgzLjI2LDE0OS42IFpcIiBpZD1cIlNoYXBlXCIgZmlsbD1cIiNGNzlFMUJcIj48L3BhdGg+IDwvZz4gPC9nPiA8L2c+IDwvZz5gXG4gICAgbGV0IHVuaW9ucGF5ID0gYDxnIGlkPVwiUGFnZS0xXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj4gPGcgaWQ9XCJ1bmlvbnBheVwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIj4gPHJlY3QgaWQ9XCJSZWN0YW5nbGUtcGF0aFwiIGZpbGw9XCIjRkZGRkZGXCIgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiNzUwXCIgaGVpZ2h0PVwiNDcxXCIgcng9XCI0MFwiPjwvcmVjdD4gPHBhdGggZD1cIk0yMDEuODA5NTgxLDU1IEwzNDQuMjAzMjY2LDU1IEMzNjQuMDcyMTUyLDU1IDM3Ni40OTAyMDYsNzEuNDA2Mzg2MSAzNzEuODMzNDM2LDkxLjQ3MDI0NjcgTDMwNS41MDAzMzEsMzc4Ljk0Nzc1IEMzMDAuODQzNTYxLDM5OS4wMTE2MTEgMjgwLjg3MTE5MSw0MTUuNDE3OTk3IDI2MS4wMDIzMDUsNDE1LjQxNzk5NyBMMTE4LjYwODYyLDQxNS40MTc5OTcgQzk4LjczOTczMzksNDE1LjQxNzk5NyA4Ni4zMjE2OCwzOTkuMDExNjExIDkwLjk3ODQ1MDIsMzc4Ljk0Nzc1IEwxNTcuMzExNTU1LDkxLjQ3MDI0NjcgQzE2MS45NjgzMjUsNzEuMzAxODg2OCAxODEuODM3MjExLDU1IDIwMS43MDYwOTcsNTUgTDIwMS44MDk1ODEsNTUgWlwiIGlkPVwiU2hhcGVcIiBmaWxsPVwiI0QxMDQyOVwiPjwvcGF0aD4gPHBhdGggZD1cIk0zMzEuNzUwMDc0LDU1IEw0OTUuNTY0OTAyLDU1IEM1MTUuNDMzNzg4LDU1IDUwNi40MzA2OTksNzEuNDA2Mzg2MSA1MDEuNzczOTI5LDkxLjQ3MDI0NjcgTDQzNS40NDA4MjQsMzc4Ljk0Nzc1IEM0MzAuNzg0MDU0LDM5OS4wMTE2MTEgNDMyLjIzMjgyNyw0MTUuNDE3OTk3IDQxMi4zNjM5NDEsNDE1LjQxNzk5NyBMMjQ4LjU0OTExMyw0MTUuNDE3OTk3IEMyMjguNTc2NzQzLDQxNS40MTc5OTcgMjE2LjI2MjE3MywzOTkuMDExNjExIDIyMS4wMjI0MjcsMzc4Ljk0Nzc1IEwyODcuMzU1NTMxLDkxLjQ3MDI0NjcgQzI5Mi4wMTIzMDIsNzEuMzAxODg2OCAzMTEuODgxMTg4LDU1IDMzMS44NTM1NTgsNTUgTDMzMS43NTAwNzQsNTUgWlwiIGlkPVwiU2hhcGVcIiBmaWxsPVwiIzAyMkU2NFwiPjwvcGF0aD4gPHBhdGggZD1cIk00ODkuODE0OTgxLDU1IEw2MzIuMjA4NjY2LDU1IEM2NTIuMDc3NTUyLDU1IDY2NC40OTU2MDYsNzEuNDA2Mzg2MSA2NTkuODM4ODM2LDkxLjQ3MDI0NjcgTDU5My41MDU3MzEsMzc4Ljk0Nzc1IEM1ODguODQ4OTYxLDM5OS4wMTE2MTEgNTY4Ljg3NjU5MSw0MTUuNDE3OTk3IDU0OS4wMDc3MDUsNDE1LjQxNzk5NyBMNDA2LjYxNDAyLDQxNS40MTc5OTcgQzM4Ni42NDE2NSw0MTUuNDE3OTk3IDM3NC4zMjcwOCwzOTkuMDExNjExIDM3OC45ODM4NSwzNzguOTQ3NzUgTDQ0NS4zMTY5NTUsOTEuNDcwMjQ2NyBDNDQ5Ljk3MzcyNSw3MS4zMDE4ODY4IDQ2OS44NDI2MTEsNTUgNDg5LjcxMTQ5OCw1NSBMNDg5LjgxNDk4MSw1NSBaXCIgaWQ9XCJTaGFwZVwiIGZpbGw9XCIjMDc2Rjc0XCI+PC9wYXRoPiA8cGF0aCBkPVwiTTQ2NS45MDQ3NTQsMzI2LjAxNDUxNCBMNDc5LjM1NzY0NSwzMjYuMDE0NTE0IEw0ODMuMTg2NTQ1LDMxMi45NTIxMDQgTDQ2OS44MzcxMzcsMzEyLjk1MjEwNCBMNDY1LjkwNDc1NCwzMjYuMDE0NTE0IFogTTQ3Ni42NjcwNjcsMjkwLjA2Njc2MyBMNDcyLjAxMDI5NywzMDUuNTMyNjU2IEM0NzIuMDEwMjk3LDMwNS41MzI2NTYgNDc3LjA4MTAwMiwzMDIuOTIwMTc0IDQ3OS44NzUwNjQsMzAyLjA4NDE4IEM0ODIuNjY5MTI2LDMwMS40NTcxODQgNDg2LjgwODQ3OCwzMDAuOTM0Njg4IDQ4Ni44MDg0NzgsMzAwLjkzNDY4OCBMNDkwLjAxNjQ3NSwyOTAuMTcxMjYzIEw0NzYuNTYzNTgzLDI5MC4xNzEyNjMgTDQ3Ni42NjcwNjcsMjkwLjA2Njc2MyBaIE00ODMuMzkzNTEzLDI2Ny45MTI5MTcgTDQ3OC45NDM3MSwyODIuNzUxODE0IEM0NzguOTQzNzEsMjgyLjc1MTgxNCA0ODMuOTEwOTMyLDI4MC40NTI4MyA0ODYuNzA0OTk0LDI3OS43MjEzMzUgQzQ4OS40OTkwNTYsMjc4Ljk4OTg0IDQ5My42Mzg0MDcsMjc4Ljc4MDg0MiA0OTMuNjM4NDA3LDI3OC43ODA4NDIgTDQ5Ni44NDY0MDUsMjY4LjAxNzQxNyBMNDgzLjQ5Njk5NywyNjguMDE3NDE3IEw0ODMuMzkzNTEzLDI2Ny45MTI5MTcgWiBNNTEzLjA5MzM1OSwyNjcuOTEyOTE3IEw0OTUuNzA4MDgzLDMyNS45MTAwMTUgTDUwMC4zNjQ4NTMsMzI1LjkxMDAxNSBMNDk2Ljc0MjkyMSwzMzcuOTI3NDMxIEw0OTIuMDg2MTUxLDMzNy45Mjc0MzEgTDQ5MC45NDc4MjksMzQxLjU4NDkwNiBMNDc0LjM5MDQyNCwzNDEuNTg0OTA2IEw0NzUuNTI4NzQ1LDMzNy45Mjc0MzEgTDQ0MiwzMzcuOTI3NDMxIEw0NDUuMzExNDgxLDMyNi44NTA1MDggTDQ0OC43MjY0NDYsMzI2Ljg1MDUwOCBMNDY2LjMxODY4OSwyNjcuOTEyOTE3IEw0NjkuODM3MTM3LDI1NiBMNDg2LjcwNDk5NCwyNTYgTDQ4NC45NDU3NywyNjEuOTU2NDU5IEM0ODQuOTQ1NzcsMjYxLjk1NjQ1OSA0ODkuMzk1NTcyLDI1OC43MTY5ODEgNDkzLjc0MTg5MSwyNTcuNTY3NDg5IEM0OTcuOTg0NzI2LDI1Ni40MTc5OTcgNTIyLjQwNjg5OSwyNTYgNTIyLjQwNjg5OSwyNTYgTDUxOC43ODQ5NjcsMjY3LjgwODQxOCBMNTEyLjk4OTg3NSwyNjcuODA4NDE4IEw1MTMuMDkzMzU5LDI2Ny45MTI5MTcgWlwiIGlkPVwiU2hhcGVcIiBmaWxsPVwiI0ZFRkVGRVwiPjwvcGF0aD4gPHBhdGggZD1cIk01MjAsMjU2IEw1MzguMDA2MTc4LDI1NiBMNTM4LjIxMzE0NiwyNjIuNzkyNDUzIEM1MzguMTA5NjYyLDI2My45NDE5NDUgNTM5LjA0MTAxNiwyNjQuNDY0NDQxIDU0MS4yMTQxNzUsMjY0LjQ2NDQ0MSBMNTQ0LjgzNjEwOCwyNjQuNDY0NDQxIEw1NDEuNTI0NjI3LDI3NS42NDU4NjQgTDUzMS43OTcxNTEsMjc1LjY0NTg2NCBDNTIzLjQxNDk2NSwyNzYuMjcyODU5IDUyMC4yMDY5NjgsMjcyLjYxNTM4NSA1MjAuNDEzOTM1LDI2OC41Mzk5MTMgTDUyMC4xMDM0ODQsMjU2LjEwNDQ5OSBMNTIwLDI1NiBaIE01MjIuMjE2MjM1LDMwOS4yMDAyOSBMNTA1LjAzNzkyNywzMDkuMjAwMjkgTDUwNy45MzU0NzMsMjk5LjI3Mjg1OSBMNTI3LjU5NzM5MSwyOTkuMjcyODU5IEw1MzAuMzkxNDU0LDI5MC4xODE0MjIgTDUxMS4wMzk5ODYsMjkwLjE4MTQyMiBMNTE0LjM1MTQ2NywyNzkgTDU2OC4xNjMwMzQsMjc5IEw1NjQuODUxNTUzLDI5MC4xODE0MjIgTDU0Ni43NDE4OTEsMjkwLjE4MTQyMiBMNTQzLjk0NzgyOSwyOTkuMjcyODU5IEw1NjIuMDU3NDkxLDI5OS4yNzI4NTkgTDU1OS4wNTY0NjEsMzA5LjIwMDI5IEw1MzkuNDk4MDI2LDMwOS4yMDAyOSBMNTM1Ljk3OTU3OCwzMTMuMzgwMjYxIEw1NDMuOTQ3ODI5LDMxMy4zODAyNjEgTDU0NS45MTQwMjEsMzI1LjkyMDE3NCBDNTQ2LjEyMDk4OSwzMjcuMTc0MTY1IDU0Ni4xMjA5ODksMzI4LjAxMDE2IDU0Ni41MzQ5MjQsMzI4LjUzMjY1NiBDNTQ2Ljk0ODg1OSwzMjguOTUwNjUzIDU0OS4zMjg5ODYsMzI5LjE1OTY1MiA1NTAuNjc0Mjc1LDMyOS4xNTk2NTIgTDU1My4wNTQ0MDIsMzI5LjE1OTY1MiBMNTQ5LjMyODk4NiwzNDEuMzg2MDY3IEw1NDMuMjIzNDQzLDM0MS4zODYwNjcgQzU0Mi4yOTIwODksMzQxLjM4NjA2NyA1NDAuODQzMzE2LDM0MS4yODE1NjcgNTM4Ljg3NzEyNCwzNDEuMjgxNTY3IEM1MzcuMDE0NDE2LDM0MS4wNzI1NjkgNTM1Ljc3MjYxLDM0MC4wMjc1NzYgNTM0LjUzMDgwNSwzMzkuNDAwNTgxIEM1MzMuMzkyNDgzLDMzOC44NzgwODQgNTMxLjczNjc0MywzMzcuNTE5NTk0IDUzMS4zMjI4MDgsMzM1LjExNjExIEw1MjkuNDYwMSwzMjIuNTc2MTk3IEw1MjAuNTYwNDk0LDMzNC45MDcxMTIgQzUxNy43NjY0MzIsMzM4Ljc3MzU4NSA1MTMuOTM3NTMyLDM0MS44MDQwNjQgNTA3LjQxODA1NCwzNDEuODA0MDY0IEw0OTUsMzQxLjgwNDA2NCBMNDk4LjMxMTQ4MSwzMzAuOTM2MTM5IEw1MDMuMDcxNzM1LDMzMC45MzYxMzkgQzUwNC40MTcwMjQsMzMwLjkzNjEzOSA1MDUuNjU4ODMsMzMwLjQxMzY0MyA1MDYuNTkwMTg0LDMyOS44OTExNDcgQzUwNy41MjE1MzgsMzI5LjQ3MzE0OSA1MDguMzQ5NDA4LDMyOS4wNTUxNTIgNTA5LjE3NzI3OCwzMjcuNjk2NjYyIEw1MjIuMjE2MjM1LDMwOS4yMDAyOSBaIE0zMzQuMzEzNTQsMjgyIEwzNzkuNzQyOTIxLDI4MiBMMzc2LjQzMTQ0LDI5Mi45NzI0MjQgTDM1OC4zMjE3NzgsMjkyLjk3MjQyNCBMMzU1LjUyNzcxNiwzMDIuMjcyODU5IEwzNzQuMTU0Nzk3LDMwMi4yNzI4NTkgTDM3MC43Mzk4MzIsMzEzLjU1ODc4MSBMMzUyLjIxNjIzNSwzMTMuNTU4NzgxIEwzNDcuNjYyOTQ4LDMyOC43MTExNzYgQzM0Ny4xNDU1MjksMzMwLjM4MzE2NCAzNTIuMTEyNzUxLDMzMC41OTIxNjMgMzUzLjg3MTk3NSwzMzAuNTkyMTYzIEwzNjMuMTg1NTE2LDMyOS4zMzgxNzEgTDM1OS40NjAxLDM0MS44NzgwODQgTDMzOC41NTYzNzUsMzQxLjg3ODA4NCBDMzM2LjkwMDYzNSwzNDEuODc4MDg0IDMzNS42NTg4MywzNDEuNjY5MDg2IDMzMy43OTYxMjIsMzQxLjI1MTA4OSBDMzMyLjAzNjg5NywzNDAuODMzMDkxIDMzMS4yMDkwMjcsMzM5Ljk5NzA5NyAzMzAuNDg0NjQsMzM4Ljg0NzYwNSBDMzI5Ljc2MDI1NCwzMzcuNTkzNjE0IDMyOC41MTg0NDksMzM2LjY1MzEyIDMyOS4zNDYzMTksMzMzLjkzNjEzOSBMMzM1LjM0ODM3OCwzMTMuODcyMjc5IEwzMjUsMzEzLjg3MjI3OSBMMzI4LjQxNDk2NSwzMDIuMzc3MzU4IEwzMzguNzYzMzQzLDMwMi4zNzczNTggTDM0MS41NTc0MDUsMjkzLjA3NjkyMyBMMzMxLjIwOTAyNywyOTMuMDc2OTIzIEwzMzQuNTIwNTA4LDI4Mi4xMDQ0OTkgTDMzNC4zMTM1NCwyODIgWiBNMzY1LjcwMDg3NSwyNjIuMTY1NDU3IEwzODQuMzI3OTU2LDI2Mi4xNjU0NTcgTDM4MC45MTI5OTEsMjczLjU1NTg3OCBMMzU1LjQ1NTk4MSwyNzMuNTU1ODc4IEwzNTIuNjYxOTE5LDI3NS45NTkzNjEgQzM1MS40MjAxMTMsMjc3LjEwODg1MyAzNTEuMTA5NjYyLDI3Ni42OTA4NTYgMzQ5LjU1NzQwNSwyNzcuNTI2ODUxIEMzNDguMTA4NjMyLDI3OC4yNTgzNDUgMzQ1LjEwNzYwMywyNzkuNzIxMzM1IDM0MS4xNzUyMTksMjc5LjcyMTMzNSBMMzMzLDI3OS43MjEzMzUgTDMzNi4zMTE0ODEsMjY4Ljc0ODkxMSBMMzM4Ljc5NTA5MiwyNjguNzQ4OTExIEMzNDAuODY0NzY3LDI2OC43NDg5MTEgMzQyLjMxMzU0LDI2OC41Mzk5MTMgMzQzLjAzNzkyNywyNjguMTIxOTE2IEMzNDMuODY1Nzk3LDI2Ny41OTk0MTkgMzQ0Ljc5NzE1MSwyNjYuNDQ5OTI3IDM0NS43Mjg1MDUsMjY0LjU2ODk0IEwzNTAuMzg1Mjc1LDI1NiBMMzY4LjkwODg3MiwyNTYgTDM2NS43MDA4NzUsMjYyLjI2OTk1NiBMMzY1LjcwMDg3NSwyNjIuMTY1NDU3IFogTTQwMC44MDg3MjYsMjgwLjk3NTMyNyBDNDAwLjgwODcyNiwyODAuOTc1MzI3IDQwNS44Nzk0MzEsMjc2LjI3Mjg1OSA0MTQuNTcyMDY5LDI3NC44MDk4NjkgQzQxNi41MzgyNjEsMjc0LjM5MTg3MiA0MjguOTU2MzE0LDI3NC42MDA4NzEgNDI4Ljk1NjMxNCwyNzQuNjAwODcxIEw0MzAuODE5MDIzLDI2OC4zMzA5MTQgTDQwNC42Mzc2MjYsMjY4LjMzMDkxNCBMNDAwLjgwODcyNiwyODEuMDc5ODI2IEw0MDAuODA4NzI2LDI4MC45NzUzMjcgWiBNNDI1LjQzNzg2NiwyODUuNzgyMjkzIEwzOTkuNDYzNDM2LDI4NS43ODIyOTMgTDM5Ny45MTExOCwyOTEuMTExNzU2IEw0MjAuNDcwNjQ0LDI5MS4xMTE3NTYgQzQyMy4xNjEyMjMsMjkwLjc5ODI1OCA0MjMuNjc4NjQyLDI5MS4yMTYyNTUgNDIzLjg4NTYwOSwyOTEuMDA3MjU3IEw0MjUuNTQxMzUsMjg1Ljc4MjI5MyBMNDI1LjQzNzg2NiwyODUuNzgyMjkzIFogTTM5MS43MDIxNTMsMjU2LjEwNDQ5OSBMNDA3LjUzNTE3MSwyNTYuMTA0NDk5IEw0MDUuMjU4NTI4LDI2NC4xNTA5NDMgQzQwNS4yNTg1MjgsMjY0LjE1MDk0MyA0MTAuMjI1NzUsMjYwLjA3NTQ3MiA0MTMuNzQ0MTk4LDI1OC42MTI0ODIgQzQxNy4yNjI2NDcsMjU3LjM1ODQ5MSA0MjUuMTI3NDE0LDI1Ni4xMDQ0OTkgNDI1LjEyNzQxNCwyNTYuMTA0NDk5IEw0NTAuNzkxMzkzLDI1NiBMNDQxLjk5NTI3MSwyODUuNDY4Nzk1IEM0NDAuNTQ2NDk4LDI5MC40ODQ3NjEgNDM4Ljc4NzI3NCwyOTMuNzI0MjM4IDQzNy43NTI0MzYsMjk1LjI5MTcyNyBDNDM2LjgyMTA4MiwyOTYuNzU0NzE3IDQzNS42ODI3NiwyOTguMTEzMjA4IDQzMy40MDYxMTcsMjk5LjM2NzE5OSBDNDMxLjIzMjk1OCwzMDAuNTE2NjkxIDQyOS4yNjY3NjYsMzAxLjI0ODE4NiA0MjcuNDA0MDU4LDMwMS4zNTI2ODUgQzQyNS43NDgzMTcsMzAxLjQ1NzE4NCA0MjMuMDU3NzM5LDMwMS41NjE2ODQgNDE5LjUzOTI5LDMwMS41NjE2ODQgTDM5NC44MDY2NjYsMzAxLjU2MTY4NCBMMzg3Ljg3MzI1MywzMjQuODY1MDIyIEMzODcuMjUyMzUsMzI3LjE2NDAwNiAzODYuOTQxODk5LDMyOC4zMTM0OTggMzg3LjM1NTgzNCwzMjguOTQwNDkzIEMzODcuNjY2Mjg1LDMyOS40NjI5OSAzODguNTk3NjM5LDMzMC4wODk5ODUgMzg5LjczNTk2MSwzMzAuMDg5OTg1IEw0MDAuNjAxNzU4LDMyOS4wNDQ5OTMgTDM5Ni44NzYzNDIsMzQxLjc5MzkwNCBMMzg0LjY2NTI1NiwzNDEuNzkzOTA0IEMzODAuNzMyODcyLDM0MS43OTM5MDQgMzc3LjkzODgxLDM0MS42ODk0MDUgMzc1Ljk3MjYxOCwzNDEuNTg0OTA2IEMzNzQuMTA5OTEsMzQxLjM3NTkwNyAzNzIuMTQzNzE4LDM0MS41ODQ5MDYgMzcwLjc5ODQyOSwzNDAuNTM5OTEzIEMzNjkuNjYwMTA3LDMzOS40OTQ5MiAzNjcuOTAwODgzLDMzOC4xMzY0MyAzNjguMDA0MzY3LDMzNi43Nzc5MzkgQzM2OC4xMDc4NSwzMzUuNTIzOTQ4IDM2OC42MjUyNjksMzMzLjQzMzk2MiAzNjkuNDUzMTQsMzMwLjUwNzk4MyBMMzkxLjcwMjE1MywyNTYuMTA0NDk5IFpcIiBpZD1cIlNoYXBlXCIgZmlsbD1cIiNGRUZFRkVcIj48L3BhdGg+IDxwYXRoIGQ9XCJNNDM3Ljg0MDIyNywzMDMgTDQzNi4zOTE0NTQsMzEwLjEwNTk1MSBDNDM1Ljc3MDU1MSwzMTIuMzAwNDM1IDQzNS4yNTMxMzIsMzEzLjk3MjQyNCA0MzMuNTk3MzkxLDMxNS40MzU0MTQgQzQzMS44MzgxNjcsMzE2Ljg5ODQwMyA0MjkuODcxOTc1LDMxOC40NjU4OTMgNDI1LjExMTcyMSwzMTguNDY1ODkzIEw0MTYuMzE1NiwzMTguODgzODkgTDQxNi4yMTIxMTYsMzI2LjgyNTgzNSBDNDE2LjEwODYzMiwzMjkuMDIwMzE5IDQxNi43Mjk1MzUsMzI4LjgxMTMyMSA0MTcuMDM5OTg2LDMyOS4yMjkzMTggQzQxNy40NTM5MjEsMzI5LjY0NzMxNSA0MTcuNzY0MzczLDMyOS43NTE4MTQgNDE4LjE3ODMwOCwzMjkuOTYwODEzIEw0MjAuOTcyMzcsMzI5Ljc1MTgxNCBMNDI5LjM1NDU1NiwzMjkuMzMzODE3IEw0MjUuODM2MTA4LDM0MS4wMzc3MzYgTDQxNi4yMTIxMTYsMzQxLjAzNzczNiBDNDA5LjQ4NTY3LDM0MS4wMzc3MzYgNDA0LjQxNDk2NSwzNDAuODI4NzM3IDQwMi44NjI3MDgsMzM5LjU3NDc0NiBDNDAxLjIwNjk2OCwzMzguNTI5NzUzIDQwMSwzMzcuMjc1NzYyIDQwMSwzMzQuOTc2Nzc4IEw0MDEuNjIwOTAzLDMwMy44MzU5OTQgTDQxNy4wMzk5ODYsMzAzLjgzNTk5NCBMNDE2LjgzMzAxOSwzMTAuMjEwNDUgTDQyMC41NTg0MzUsMzEwLjIxMDQ1IEM0MjEuODAwMjQsMzEwLjIxMDQ1IDQyMi43MzE1OTQsMzEwLjEwNTk1MSA0MjMuMjQ5MDEzLDMwOS43OTI0NTMgQzQyMy43NjY0MzIsMzA5LjQ3ODk1NSA0MjQuMDc2ODgzLDMwOC45NTY0NTkgNDI0LjI4Mzg1MSwzMDguMjI0OTY0IEw0MjUuODM2MTA4LDMwMy4yMDg5OTkgTDQzNy45NDM3MSwzMDMuMjA4OTk5IEw0MzcuODQwMjI3LDMwMyBaIE0yMTguNDcwMzk2LDE0NyBDMjE3Ljk1Mjk3OCwxNDkuNTA3OTgzIDIwOC4wMTg1MzQsMTk1LjU5MjE2MyAyMDguMDE4NTM0LDE5NS41OTIxNjMgQzIwNS44NDUzNzUsMjA0Ljg5MjU5OCAyMDQuMjkzMTE4LDIxMS41ODA1NTIgMTk5LjExODkyOSwyMTUuODY1MDIyIEMxOTYuMTE3ODk5LDIxOC4zNzMwMDQgMTkyLjU5OTQ1MSwyMTkuNTIyNDk2IDE4OC41NjM1ODMsMjE5LjUyMjQ5NiBDMTgyLjA0NDEwNSwyMTkuNTIyNDk2IDE3OC4zMTg2ODksMjE2LjI4MzAxOSAxNzcuNjk3Nzg2LDIxMC4xMTc1NjIgTDE3Ny41OTQzMDIsMjA4LjAyNzU3NiBDMTc3LjU5NDMwMiwyMDguMDI3NTc2IDE3OS41NjA0OTQsMTk1LjU5MjE2MyAxNzkuNTYwNDk0LDE5NS40ODc2NjMgQzE3OS41NjA0OTQsMTk1LjQ4NzY2MyAxODkuOTA4ODcyLDE1My40Nzg5NTUgMTkxLjc3MTU4MSwxNDcuOTQwNDkzIEMxOTEuODc1MDY0LDE0Ny42MjY5OTYgMTkxLjg3NTA2NCwxNDcuNDE3OTk3IDE5MS44NzUwNjQsMTQ3LjMxMzQ5OCBDMTcxLjY5NTcyNywxNDcuNTIyNDk2IDE2OC4wNzM3OTQsMTQ3LjMxMzQ5OCAxNjcuODY2ODI3LDE0NyBDMTY3Ljc2MzM0MywxNDcuNDE3OTk3IDE2Ny4yNDU5MjQsMTUwLjAzMDQ3OSAxNjcuMjQ1OTI0LDE1MC4wMzA0NzkgTDE1Ni42OTA1NzgsMTk3LjM2ODY1IEwxNTUuNzU5MjI0LDIwMS4zMzk2MjMgTDE1NCwyMTQuNTA2NTMxIEMxNTQsMjE4LjM3MzAwNCAxNTQuNzI0Mzg2LDIyMS42MTI0ODIgMTU2LjI3NjY0MywyMjQuMjI0OTY0IEMxNjEuMTQwMzgxLDIzMi43OTM5MDQgMTc0LjkwMzcyNCwyMzQuMDQ3ODk2IDE4Mi42NjUwMDgsMjM0LjA0Nzg5NiBDMTkyLjcwMjkzNSwyMzQuMDQ3ODk2IDIwMi4xMTk5NTksMjMxLjg1MzQxMSAyMDguNDMyNDcsMjI3Ljk4NjkzOCBDMjE5LjUwNTIzNCwyMjEuNDAzNDgzIDIyMi40MDI3OCwyMTEuMDU4MDU1IDIyNC44ODYzOTEsMjAxLjk2NjYxOCBMMjI2LjEyODE5NiwxOTcuMjY0MTUxIEMyMjYuMTI4MTk2LDE5Ny4yNjQxNTEgMjM2Ljc4NzAyNiwxNTMuNjg3OTU0IDIzOC42NDk3MzQsMTQ4LjA0NDk5MyBDMjM4Ljc1MzIxOCwxNDcuNzMxNDk1IDIzOC43NTMyMTgsMTQ3LjUyMjQ5NiAyMzguODU2NzAyLDE0Ny40MTc5OTcgQzIyNC4xNjIwMDQsMTQ3LjUyMjQ5NiAyMTkuOTE5MTY5LDE0Ny40MTc5OTcgMjE4LjQ3MDM5NiwxNDcuMTA0NDk5IEwyMTguNDcwMzk2LDE0NyBaIE0yNzcuNDk5MDU2LDIzMy42MjI2NDIgQzI3MC4zNTg2NzUsMjMzLjUxODE0MiAyNjcuNzcxNTgxLDIzMy41MTgxNDIgMjU5LjM4OTM5NCwyMzMuOTM2MTM5IEwyNTkuMDc4OTQzLDIzMy4zMDkxNDQgQzI1OS44MDMzMjksMjMwLjA2OTY2NiAyNjAuNjMxMiwyMjYuOTM0Njg4IDI2MS4yNTIxMDIsMjIzLjY5NTIxIEwyNjIuMjg2OTQsMjE5LjMwNjI0MSBDMjYzLjgzOTE5NywyMTIuNTEzNzg4IDI2NS4yODc5NywyMDQuNDY3MzQ0IDI2NS40OTQ5MzcsMjAyLjA2Mzg2MSBDMjY1LjcwMTkwNSwyMDAuNjAwODcxIDI2Ni4xMTU4NCwxOTYuOTQzMzk2IDI2MS45NzY0ODksMTk2Ljk0MzM5NiBDMjYwLjIxNzI2NCwxOTYuOTQzMzk2IDI1OC40NTgwNCwxOTcuNzc5MzkgMjU2LjU5NTMzMiwxOTguNjE1Mzg1IEMyNTUuNTYwNDk0LDIwMi4yNzI4NTkgMjUzLjU5NDMwMiwyMTIuNTEzNzg4IDI1Mi41NTk0NjUsMjE3LjExMTc1NiBDMjUwLjQ4OTc4OSwyMjYuOTM0Njg4IDI1MC4zODYzMDUsMjI4LjA4NDE4IDI0OS40NTQ5NTEsMjMyLjg5MTE0NyBMMjQ4LjgzNDA0OCwyMzMuNTE4MTQyIEMyNDEuNDg2NywyMzMuNDEzNjQzIDIzOC44OTk2MDUsMjMzLjQxMzY0MyAyMzAuNDEzOTM1LDIzMy44MzE2NCBMMjMwLDIzMy4xMDAxNDUgQzIzMS40NDg3NzMsMjI3LjI0ODE4NiAyMzIuNzk0MDYyLDIyMS4zOTYyMjYgMjM0LjEzOTM1MSwyMTUuNTQ0MjY3IEMyMzcuNjU3OCwxOTkuNzY0ODc3IDIzOC41ODkxNTQsMTkzLjcwMzkxOSAyMzkuNTIwNTA4LDE4NS42NTc0NzUgTDI0MC4yNDQ4OTQsMTg1LjIzOTQ3OCBDMjQ4LjUyMzU5NywxODQuMDg5OTg1IDI1MC40ODk3ODksMTgzLjc3NjQ4OCAyNTkuNDkyODc4LDE4MiBMMjYwLjIxNzI2NCwxODIuODM1OTk0IEwyNTguODcxOTc1LDE4Ny44NTE5NTkgQzI2MC40MjQyMzIsMTg2LjkxMTQ2NiAyNjEuODczMDA1LDE4NS45NzA5NzIgMjYzLjQyNTI2MiwxODUuMjM5NDc4IEMyNjcuNjY4MDk3LDE4My4xNDk0OTIgMjcyLjMyNDg2NywxODIuNTIyNDk2IDI3NC45MTE5NjIsMTgyLjUyMjQ5NiBDMjc4Ljg0NDM0NSwxODIuNTIyNDk2IDI4My4xOTA2NjQsMTgzLjY3MTk4OCAyODQuOTQ5ODg4LDE4OC4yNjk5NTYgQzI4Ni42MDU2MjksMTkyLjM0NTQyOCAyODUuNTcwNzkxLDE5Ny4zNjEzOTMgMjgzLjI5NDE0OCwyMDcuMjg4ODI0IEwyODIuMTU1ODI2LDIxMi4zMDQ3OSBDMjc5Ljg3OTE4MywyMjMuMzgxNzEzIDI3OS40NjUyNDgsMjI1LjM2NzE5OSAyNzguMjIzNDQzLDIzMi44OTExNDcgTDI3Ny4zOTU1NzIsMjMzLjUxODE0MiBMMjc3LjQ5OTA1NiwyMzMuNjIyNjQyIFogTTMwNi41NTg0MzUsMjMzLjY1MDIxOCBDMzAyLjIxMjExNiwyMzMuNjUwMjE4IDI5OS40MTgwNTQsMjMzLjU0NTcxOCAyOTYuNzI3NDc2LDIzMy42NTAyMTggQzI5NC4wMzY4OTcsMjMzLjY1MDIxOCAyOTEuNDQ5ODAzLDIzMy44NTkyMTYgMjg3LjQxMzkzNSwyMzMuOTYzNzE2IEwyODcuMjA2OTY4LDIzMy42NTAyMTggTDI4NywyMzMuMjMyMjIxIEMyODguMTM4MzIyLDIyOS4wNTIyNSAyODguNjU1NzQxLDIyNy41ODkyNiAyODkuMjc2NjQzLDIyNi4xMjYyNyBDMjg5Ljc5NDA2MiwyMjQuNjYzMjggMjkwLjMxMTQ4MSwyMjMuMjAwMjkgMjkxLjM0NjMxOSwyMTguOTE1ODIgQzI5Mi41ODgxMjQsMjEzLjM3NzM1OCAyOTMuNDE1OTk1LDIwOS41MTA4ODUgMjkzLjkzMzQxMywyMDYuMDYyNDA5IEMyOTQuNTU0MzE2LDIwMi44MjI5MzIgMjk0Ljg2NDc2NywyMDAuMDAxNDUxIDI5NS4yNzg3MDMsMTk2Ljc2MTk3NCBMMjk1LjU4OTE1NCwxOTYuNTUyOTc1IEwyOTUuODk5NjA1LDE5Ni4yMzk0NzggQzMwMC4yNDU5MjQsMTk1LjYxMjQ4MiAzMDIuOTM2NTAyLDE5NS4xOTQ0ODUgMzA1LjczMDU2NSwxOTQuNzc2NDg4IEMzMDguNTI0NjI3LDE5NC4zNTg0OTEgMzExLjQyMjE3MywxOTMuODM1OTk0IDMxNS44NzE5NzUsMTkzIEwzMTYuMDc4OTQzLDE5My40MTc5OTcgTDMxNi4xODI0MjcsMTkzLjgzNTk5NCBDMzE1LjM1NDU1NiwxOTcuMjg0NDcgMzE0LjUyNjY4NiwyMDAuNzMyOTQ2IDMxMy42OTg4MTYsMjA0LjE4MTQyMiBDMzEyLjg3MDk0NiwyMDcuNjI5ODk4IDMxMi4wNDMwNzUsMjExLjA3ODM3NCAzMTEuMzE4Njg5LDIxNC41MjY4NTEgQzMwOS43NjY0MzIsMjIxLjg0MTggMzA5LjA0MjA0NiwyMjQuNTU4NzgxIDMwOC43MzE1OTQsMjI2LjU0NDI2NyBDMzA4LjMxNzY1OSwyMjguNDI1MjU0IDMwOC4yMTQxNzUsMjI5LjM2NTc0NyAzMDcuNTkzMjczLDIzMy4xMjc3MjEgTDMwNy4xNzkzMzgsMjMzLjQ0MTIxOSBMMzA2Ljc2NTQwMiwyMzMuNzU0NzE3IEwzMDYuNTU4NDM1LDIzMy42NTAyMTggWiBNMzUyLjQ5OTMxOSwyMDcuOTc1MzI3IEMzNTIuMTg4ODY4LDIwOS44NTYzMTMgMzUwLjUzMzEyNywyMTYuODU3NzY1IDM0OC4zNTk5NjgsMjE5Ljc4Mzc0NSBDMzQ2LjgwNzcxMSwyMjEuOTc4MjI5IDM0NS4wNDg0ODcsMjIzLjMzNjcyIDM0Mi45Nzg4MTEsMjIzLjMzNjcyIEMzNDIuMzU3OTA5LDIyMy4zMzY3MiAzMzguODM5NDYsMjIzLjMzNjcyIDMzOC43MzU5NzYsMjE4LjAwNzI1NyBDMzM4LjczNTk3NiwyMTUuMzk0Nzc1IDMzOS4yNTMzOTUsMjEyLjY3Nzc5NCAzMzkuODc0Mjk4LDIwOS43NTE4MTQgQzM0MS43MzcwMDYsMjAxLjI4NzM3MyAzNDQuMDEzNjQ5LDE5NC4yODU5MjIgMzQ5LjcwNTI1NywxOTQuMjg1OTIyIEMzNTQuMTU1MDYsMTk0LjI4NTkyMiAzNTQuNDY1NTExLDE5OS41MTA4ODUgMzUyLjQ5OTMxOSwyMDcuOTc1MzI3IFogTTM3MS4yMjk4ODQsMjA4LjgxMTMyMSBDMzczLjcxMzQ5NSwxOTcuNzM0Mzk4IDM3MS43NDczMDMsMTkyLjUwOTQzNCAzNjkuMzY3MTc2LDE4OS4zNzQ0NTYgQzM2NS42NDE3NiwxODQuNTY3NDg5IDM1OS4wMTg3OTgsMTgzIDM1Mi4xODg4NjgsMTgzIEMzNDguMDQ5NTE3LDE4MyAzMzguMzIyMDQxLDE4My40MTc5OTcgMzMwLjY2NDI0MSwxOTAuNTIzOTQ4IEMzMjUuMTc5NjAxLDE5NS42NDQ0MTIgMzIyLjU5MjUwNiwyMDIuNjQ1ODY0IDMyMS4xNDM3MzMsMjA5LjMzMzgxNyBDMzE5LjU5MTQ3NiwyMTYuMTI2MjcgMzE3LjgzMjI1MiwyMjguMzUyNjg1IDMyOS4wMDg1MDEsMjMyLjk1MDY1MyBDMzMyLjQyMzQ2NiwyMzQuNDEzNjQzIDMzNy4zOTA2ODcsMjM0LjgzMTY0IDM0MC41OTg2ODQsMjM0LjgzMTY0IEMzNDguNzczOTAzLDIzNC44MzE2NCAzNTcuMTU2MDg5LDIzMi41MzI2NTYgMzYzLjQ2ODYsMjI1Ljg0NDcwMiBDMzY4LjMzMjMzOCwyMjAuNDEwNzQgMzcwLjUwNTQ5NywyMTIuMjU5Nzk3IDM3MS4zMzMzNjgsMjA4LjgxMTMyMSBMMzcxLjIyOTg4NCwyMDguODExMzIxIFogTTU0NS42NjE5MTksMjM0Ljg5MTE0NyBDNTM2Ljk2OTI4MSwyMzQuNzg2NjQ3IDUzNC40ODU2NywyMzQuNzg2NjQ3IDUyNi41MTc0MTksMjM1LjIwNDY0NCBMNTI2LDIzNC41Nzc2NDkgQzUyOC4xNzMxNTksMjI2LjMyMjIwNiA1MzAuMzQ2MzE5LDIxNy45NjIyNjQgNTMyLjMxMjUxMSwyMDkuNjAyMzIyIEM1MzQuNzk2MTIyLDE5OC43MzQzOTggNTM1LjQxNzAyNCwxOTQuMTM2NDMgNTM2LjI0NDg5NCwxODcuNzYxOTc0IEw1MzYuODY1Nzk3LDE4Ny4yMzk0NzggQzU0NS40NTQ5NTEsMTg1Ljk4NTQ4NiA1NDcuODM1MDc4LDE4NS42NzE5ODggNTU2LjgzODE2NywxODQgTDU1Ny4wNDUxMzUsMTg0LjczMTQ5NSBDNTU1LjM4OTM5NCwxOTEuNjI4NDQ3IDU1My44MzcxMzcsMTk4LjQyMDkgNTUyLjE4MTM5NywyMDUuMjEzMzUzIEM1NDguODY5OTE2LDIxOS41Mjk3NTMgNTQ3LjczMTU5NCwyMjYuODQ0NzAyIDU0Ni40ODk3ODksMjM0LjM2ODY1IEw1NDUuNjYxOTE5LDIzNC45OTU2NDYgTDU0NS42NjE5MTksMjM0Ljg5MTE0NyBaXCIgaWQ9XCJTaGFwZVwiIGZpbGw9XCIjRkVGRUZFXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTUzMy4xNTk5MDksMjA5LjM3Mzc3NyBDNTMyLjc0NTk3NCwyMTEuMTUwMjY1IDUzMS4wOTAyMzMsMjE4LjI1NjIxNiA1MjguOTE3MDc0LDIyMS4xODIxOTUgQzUyNy40NjgzMDEsMjIzLjI3MjE4MSA1MjMuOTQ5ODUyLDIyNC42MzA2NzIgNTIxLjk4MzY2MSwyMjQuNjMwNjcyIEM1MjEuMzYyNzU4LDIyNC42MzA2NzIgNTE3Ljk0Nzc5MywyMjQuNjMwNjcyIDUxNy43NDA4MjYsMjE5LjQwNTcwOCBDNTE3Ljc0MDgyNiwyMTYuNzkzMjI2IDUxOC4yNTgyNDQsMjE0LjA3NjI0NSA1MTguODc5MTQ3LDIxMS4xNTAyNjUgQzUyMC43NDE4NTUsMjAyLjg5NDgyMiA1MjMuMDE4NDk4LDE5NS44OTMzNzEgNTI4LjcxMDEwNiwxOTUuODkzMzcxIEM1MzMuMTU5OTA5LDE5NS44OTMzNzEgNTM1LjEyNjEwMSwyMDEuMDEzODM2IDUzMy4xNTk5MDksMjA5LjQ3ODI3NyBMNTMzLjE1OTkwOSwyMDkuMzczNzc3IFogTTU1MC4yMzQ3MzMsMjEwLjIwOTc3MiBDNTUyLjcxODM0NCwxOTkuMTMyODQ5IDU0Mi41NzY5MzMsMjA5LjI2OTI3OCA1NDEuMDI0Njc3LDIwNS42MTE4MDQgQzUzOC41NDEwNjYsMTk5Ljg2NDM0NCA1NDAuMDkzMzIyLDE4OC4zNjk0MjMgNTMwLjE1ODg3OSwxODQuNTAyOTUgQzUyNi4zMjk5NzksMTgyLjkzNTQ2MSA1MTcuMzI2ODksMTg0LjkyMDk0NyA1MDkuNjY5MDksMTkyLjAyNjg5OCBDNTA0LjI4NzkzNCwxOTcuMDQyODYzIDUwMS41OTczNTUsMjA0LjA0NDMxNSA1MDAuMTQ4NTgyLDIxMC43MzIyNjggQzQ5OC41OTYzMjYsMjE3LjQyMDIyMiA0OTYuODM3MTAxLDIyOS43NTExMzYgNTA3LjkwOTg2NiwyMzQuMDM1NjA2IEM1MTEuNDI4MzE1LDIzNS42MDMwOTUgNTE0LjYzNjMxMiwyMzYuMDIxMDkyIDUxNy44NDQzMDksMjM1LjgxMjA5NCBDNTI5LjAyMDU1OCwyMzUuMTg1MDk4IDUzNy41MDYyMjgsMjE4LjE1MTcxNyA1NDMuODE4NzM5LDIxMS40NjM3NjMgQzU0OC42ODI0NzYsMjA2LjEzNDMgNTQ5LjUxMDM0NywyMTMuNDQ5MjQ5IDU1MC4yMzQ3MzMsMjEwLjIwOTc3MiBaIE00MjAuMjkyMDg5LDIzMy42MjI2NDIgQzQxMy4xNTE3MDgsMjMzLjUxODE0MiA0MTAuNjY4MDk3LDIzMy41MTgxNDIgNDAyLjI4NTkxLDIzMy45MzYxMzkgTDQwMS45NzU0NTksMjMzLjMwOTE0NCBDNDAyLjY5OTg0NiwyMzAuMDY5NjY2IDQwMy41Mjc3MTYsMjI2LjkzNDY4OCA0MDQuMjUyMTAyLDIyMy42OTUyMSBMNDA1LjE4MzQ1NiwyMTkuMzA2MjQxIEM0MDYuNzM1NzEzLDIxMi41MTM3ODggNDA4LjI4Nzk3LDIwNC40NjczNDQgNDA4LjM5MTQ1NCwyMDIuMDYzODYxIEM0MDguNTk4NDIxLDIwMC42MDA4NzEgNDA5LjAxMjM1NiwxOTYuOTQzMzk2IDQwNC45NzY0ODksMTk2Ljk0MzM5NiBDNDAzLjIxNzI2NCwxOTYuOTQzMzk2IDQwMS4zNTQ1NTYsMTk3Ljc3OTM5IDM5OS41OTUzMzIsMTk4LjYxNTM4NSBDMzk4LjY2Mzk3OCwyMDIuMjcyODU5IDM5Ni41OTQzMDIsMjEyLjUxMzc4OCAzOTUuNTU5NDY1LDIxNy4xMTE3NTYgQzM5My41OTMyNzMsMjI2LjkzNDY4OCAzOTMuMzg2MzA1LDIyOC4wODQxOCAzOTIuNDU0OTUxLDIzMi44OTExNDcgTDM5MS44MzQwNDgsMjMzLjUxODE0MiBDMzg0LjQ4NjcsMjMzLjQxMzY0MyAzODEuODk5NjA1LDIzMy40MTM2NDMgMzczLjQxMzkzNSwyMzMuODMxNjQgTDM3MywyMzMuMTAwMTQ1IEMzNzQuNDQ4NzczLDIyNy4yNDgxODYgMzc1Ljc5NDA2MiwyMjEuMzk2MjI2IDM3Ny4xMzkzNTEsMjE1LjU0NDI2NyBDMzgwLjY1NzgsMTk5Ljc2NDg3NyAzODEuNDg1NjcsMTkzLjcwMzkxOSAzODIuNTIwNTA4LDE4NS42NTc0NzUgTDM4My4xNDE0MTEsMTg1LjIzOTQ3OCBDMzkxLjQyMDExMywxODQuMDg5OTg1IDM5My40ODk3ODksMTgzLjc3NjQ4OCA0MDIuMzg5Mzk0LDE4MiBMNDAzLjExMzc4MSwxODIuODM1OTk0IEw0MDEuODcxOTc1LDE4Ny44NTE5NTkgQzQwMy4zMjA3NDgsMTg2LjkxMTQ2NiA0MDQuODczMDA1LDE4NS45NzA5NzIgNDA2LjMyMTc3OCwxODUuMjM5NDc4IEM0MTAuNTY0NjEzLDE4My4xNDk0OTIgNDE1LjIyMTM4MywxODIuNTIyNDk2IDQxNy44MDg0NzgsMTgyLjUyMjQ5NiBDNDIxLjc0MDg2MiwxODIuNTIyNDk2IDQyNS45ODM2OTcsMTgzLjY3MTk4OCA0MjcuODQ2NDA1LDE4OC4yNjk5NTYgQzQyOS41MDIxNDUsMTkyLjM0NTQyOCA0MjguMzYzODI0LDE5Ny4zNjEzOTMgNDI2LjA4NzE4LDIwNy4yODg4MjQgTDQyNC45NDg4NTksMjEyLjMwNDc5IEM0MjIuNTY4NzMyLDIyMy4zODE3MTMgNDIyLjI1ODI4LDIyNS4zNjcxOTkgNDIxLjAxNjQ3NSwyMzIuODkxMTQ3IEw0MjAuMTg4NjA1LDIzMy41MTgxNDIgTDQyMC4yOTIwODksMjMzLjYyMjY0MiBaIE00ODIuMjkzMTE4LDE0Ny4xMDQ0OTkgTDQ3Ni4yOTEwNTksMTQ3LjIwODk5OSBDNDYwLjc2ODQ5MiwxNDcuNDE3OTk3IDQ1NC41NTk0NjUsMTQ3LjMxMzQ5OCA0NTIuMDc1ODU0LDE0NyBDNDUxLjg2ODg4NiwxNDguMTQ5NDkyIDQ1MS40NTQ5NTEsMTUwLjEzNDk3OCA0NTEuNDU0OTUxLDE1MC4xMzQ5NzggQzQ1MS40NTQ5NTEsMTUwLjEzNDk3OCA0NDUuODY2ODI3LDE3Ni4wNTA3OTggNDQ1Ljg2NjgyNywxNzYuMTU1Mjk4IEM0NDUuODY2ODI3LDE3Ni4xNTUyOTggNDMyLjYyMDkwMywyMzEuMzMwOTE0IDQzMiwyMzMuOTQzMzk2IEM0NDUuNTU2Mzc1LDIzMy43MzQzOTggNDUxLjA0MTAxNiwyMzMuNzM0Mzk4IDQ1My40MjExNDMsMjM0LjA0Nzg5NiBDNDUzLjkzODU2MiwyMzEuNDM1NDE0IDQ1Ny4wNDMwNzUsMjE2LjA3NDAyIDQ1Ny4xNDY1NTksMjE2LjA3NDAyIEM0NTcuMTQ2NTU5LDIxNi4wNzQwMiA0NTkuODM3MTM3LDIwNC43ODgwOTkgNDU5Ljk0MDYyMSwyMDQuMzcwMTAyIEM0NTkuOTQwNjIxLDIwNC4zNzAxMDIgNDYwLjc2ODQ5MiwyMDMuMjIwNjEgNDYxLjU5NjM2MiwyMDIuNjk4MTEzIEw0NjIuODM4MTY3LDIwMi42OTgxMTMgQzQ3NC41MzE4MzUsMjAyLjY5ODExMyA0ODcuNjc0Mjc1LDIwMi42OTgxMTMgNDk4LjAyMjY1MywxOTUuMDY5NjY2IEM1MDUuMDU5NTUsMTg5Ljg0NDcwMiA1MDkuODE5ODA0LDE4Mi4wMDcyNTcgNTExLjk5Mjk2NCwxNzIuNjAyMzIyIEM1MTIuNTEwMzgzLDE3MC4zMDMzMzggNTEyLjkyNDMxOCwxNjcuNTg2MzU3IDUxMi45MjQzMTgsMTY0Ljc2NDg3NyBDNTEyLjkyNDMxOCwxNjEuMTA3NDAyIDUxMi4xOTk5MzEsMTU3LjU1NDQyNyA1MTAuMTMwMjU2LDE1NC43MzI5NDYgQzUwNC44NTI1ODMsMTQ3LjMxMzQ5OCA0OTQuNDAwNzIxLDE0Ny4yMDg5OTkgNDgyLjI5MzExOCwxNDcuMTA0NDk5IFogTTQ5MC4wNTQ0MDIsMTc0LjE2OTgxMSBDNDg4LjgxMjU5NywxNzkuOTE3MjcxIDQ4NS4wODcxOCwxODQuODI4NzM3IDQ4MC4zMjY5MjYsMTg3LjEyNzcyMSBDNDc2LjM5NDU0MywxODkuMTEzMjA4IDQ3MS42MzQyODksMTg5LjMyMjIwNiA0NjYuNjY3MDY3LDE4OS4zMjIyMDYgTDQ2My40NTkwNywxODkuMzIyMjA2IEw0NjMuNjY2MDM3LDE4OC4wNjgyMTUgQzQ2My42NjYwMzcsMTg4LjA2ODIxNSA0NjkuNTY0NjEzLDE2Mi4xNTIzOTUgNDY5LjU2NDYxMywxNjIuMjU2ODk0IEw0NjkuNzcxNTgxLDE2MC44OTg0MDMgTDQ2OS44NzUwNjQsMTU5Ljg1MzQxMSBMNDcyLjI1NTE5MSwxNjAuMDYyNDA5IEM0NzIuMjU1MTkxLDE2MC4wNjI0MDkgNDg0LjQ2NjI3OCwxNjEuMTA3NDAyIDQ4NC42NzMyNDUsMTYxLjEwNzQwMiBDNDg5LjQzMzQ5OSwxNjIuOTg4Mzg5IDQ5MS41MDMxNzUsMTY3Ljc5NTM1NiA0OTAuMDU0NDAyLDE3NC4xNjk4MTEgWiBNNjE3LjI2MTM2OSwxODIuODM1OTk0IEw2MTYuNTM2OTgzLDE4MiBDNjA3Ljc0MDg2MiwxODMuNzc2NDg4IDYwNi4wODUxMjEsMTg0LjA4OTk4NSA1OTguMDEzMzg2LDE4NS4yMzk0NzggTDU5Ny4zOTI0ODMsMTg1Ljg2NjQ3MyBDNTk3LjM5MjQ4MywxODUuOTcwOTcyIDU5Ny4yODg5OTksMTg2LjA3NTQ3MiA1OTcuMjg4OTk5LDE4Ni4yODQ0NyBMNTk3LjI4ODk5OSwxODYuMTc5OTcxIEM1OTEuMjg2OTQsMjAwLjI4NzM3MyA1OTEuMzkwNDI0LDE5Ny4yNTY4OTQgNTg2LjUyNjY4NiwyMDguMzMzODE3IEM1ODYuNTI2Njg2LDIwNy44MTEzMjEgNTg2LjUyNjY4NiwyMDcuNDk3ODIzIDU4Ni40MjMyMDIsMjA2Ljk3NTMyNyBMNTg1LjE4MTM5NywxODIuOTQwNDkzIEw1ODQuNDU3MDEsMTgyLjEwNDQ5OSBDNTc1LjE0MzQ3LDE4My44ODA5ODcgNTc0LjkzNjUwMiwxODQuMTk0NDg1IDU2Ni40NTA4MzIsMTg1LjM0Mzk3NyBMNTY1LjgyOTkzLDE4NS45NzA5NzIgQzU2NS43MjY0NDYsMTg2LjI4NDQ3IDU2NS43MjY0NDYsMTg2LjU5Nzk2OCA1NjUuNzI2NDQ2LDE4Ni45MTE0NjYgTDU2NS44Mjk5MywxODcuMDE1OTY1IEM1NjYuODY0NzY3LDE5Mi41NTQ0MjcgNTY2LjY1NzgsMTkxLjMwMDQzNSA1NjcuNjkyNjM4LDE5OS45NzM4NzUgQzU2OC4yMTAwNTcsMjA0LjI1ODM0NSA1NjguODMwOTU5LDIwOC41NDI4MTYgNTY5LjM0ODM3OCwyMTIuNzIyNzg3IEM1NzAuMTc2MjQ4LDIxOS44Mjg3MzcgNTcwLjY5MzY2NywyMjMuMjc3MjEzIDU3MS43Mjg1MDUsMjM0LjA0MDYzOSBDNTY1LjkzMzQxMywyNDMuNjU0NTcyIDU2NC41ODgxMjQsMjQ3LjMxMjA0NiA1NTksMjU1Ljc3NjQ4OCBMNTU5LjMxMDQ1MSwyNTYuNjEyNDgyIEM1NjcuNjkyNjM4LDI1Ni4yOTg5ODQgNTY5LjU1NTM0NiwyNTYuMjk4OTg0IDU3NS43NjQzNzMsMjU2LjI5ODk4NCBMNTc3LjEwOTY2MiwyNTQuNzMxNDk1IEM1ODEuNzY2NDMyLDI0NC41OTUwNjUgNjE3LjM2NDg1MywxODIuOTQwNDkzIDYxNy4zNjQ4NTMsMTgyLjk0MDQ5MyBMNjE3LjI2MTM2OSwxODIuODM1OTk0IFogTTMxNC41NDM2MDgsMTg5Ljc1ODM3IEMzMTkuMzAzODYyLDE4Ni40MTQzOTQgMzE5LjkyNDc2NSwxODEuODE2NDI1IDMxNS44ODg4OTcsMTc5LjQxMjk0MiBDMzExLjg1MzAzLDE3Ny4wMDk0NTkgMzA0LjcxMjY0OSwxNzcuNzQwOTU0IDI5OS45NTIzOTUsMTgxLjA4NDkzMSBDMjk1LjE5MjE0MSwxODQuMzI0NDA4IDI5NC42NzQ3MjIsMTg4LjkyMjM3NiAyOTguNzEwNTksMTkxLjQzMDM1OSBDMzAyLjY0Mjk3MywxOTMuNzI5MzQzIDMwOS43ODMzNTQsMTkzLjEwMjM0NyAzMTQuNTQzNjA4LDE4OS43NTgzNyBaXCIgaWQ9XCJTaGFwZVwiIGZpbGw9XCIjRkVGRUZFXCI+PC9wYXRoPiA8cGF0aCBkPVwiTTU3NS43MzQ2ODMsMjU2LjEwNDQ5OSBMNTY4LjgwMTI3LDI2OC4xMjE5MTYgQzU2Ni42MjgxMTEsMjcyLjE5NzM4OCA1NjIuNDg4NzU5LDI3NS4zMzIzNjYgNTU2LjA3Mjc2NSwyNzUuMzMyMzY2IEw1NDUsMjc1LjEyMzM2NyBMNTQ4LjIwNzk5NywyNjQuMjU1NDQzIEw1NTAuMzgxMTU3LDI2NC4yNTU0NDMgQzU1MS41MTk0NzgsMjY0LjI1NTQ0MyA1NTIuMzQ3MzQ5LDI2NC4xNTA5NDMgNTUyLjk2ODI1MSwyNjMuODM3NDQ2IEM1NTMuNTg5MTU0LDI2My42Mjg0NDcgNTUzLjg5OTYwNSwyNjMuMjEwNDUgNTU0LjQxNzAyNCwyNjIuNTgzNDU0IEw1NTguNTU2Mzc1LDI1NiBMNTc1LjgzODE2NywyNTYgTDU3NS43MzQ2ODMsMjU2LjEwNDQ5OSBaXCIgaWQ9XCJTaGFwZVwiIGZpbGw9XCIjRkVGRUZFXCI+PC9wYXRoPiA8L2c+IDwvZz5gXG5cbiAgICBsZXQgYW1leF9zaW5nbGUgPSBgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJMYXllcl8xXCIgeG1sbnM6c2tldGNoPVwiaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI3NTBcIiBoZWlnaHQ9XCI0NzFcIiB2aWV3Qm94PVwiMCAwIDc1MCA0NzFcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgNzUyIDQ3MVwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+PHRpdGxlPlNsaWNlIDE8L3RpdGxlPjxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPjxnPjxnPjxwYXRoIGZpbGw9XCIjMjU1N0Q2XCIgZD1cIk01NTQuNTk0LDEzMC42MDhsLTE0LjUyMSwzNS4wMzloMjkuMTIxTDU1NC41OTQsMTMwLjYwOHogTTM4Ny4wMywxNTIuMzIxYzIuNzM4LTEuNDIyLDQuMzQ5LTQuNTE1LDQuMzQ5LTguMzU2YzAtMy43NjQtMS42OTMtNi40OS00LjQzMS03Ljc3MWMtMi40OTItMS40Mi02LjMyOC0xLjU4NC0xMC4wMDYtMS41ODRoLTI1Ljk3OHYxOS41MjNoMjUuNjNDMzgwLjcsMTU0LjEzNCwzODQuMTMxLDE1NC4wNzQsMzg3LjAzLDE1Mi4zMjF6IE01NC4xNDIsMTMwLjYwOGwtMTQuMzU3LDM1LjAzOWgyOC44TDU0LjE0MiwxMzAuNjA4eiBNNzIyLjU2NSwzNTUuMDhoLTQwLjc0MnYtMTguODUyaDQwLjU3OGM0LjAyMywwLDYuODQtMC41MjUsOC41MzctMi4xNzdjMS40NzEtMS4zNTgsMi40OTQtMy4zMzYsMi40OTQtNS43MzNjMC0yLjU2Mi0xLjAyMy00LjU5Ni0yLjU3OC01LjgxM2MtMS41MjktMS4zNDItMy43Ni0xLjk1My03LjQzNC0xLjk1M2MtMTkuODEtMC42Ny00NC41MjMsMC42MDktNDQuNTIzLTI3LjIxMWMwLTEyLjc1LDguMTMxLTI2LjE3MiwzMC4yNy0yNi4xNzJoNDIuMDI1di0xNy40OTJoLTM5LjA0NWMtMTEuNzgzLDAtMjAuMzQ0LDIuODEtMjYuNDA2LDcuMTgxdi03LjE4MWgtNTcuNzUyYy05LjIzMywwLTIwLjA3NCwyLjI3OS0yNS4yMDEsNy4xODF2LTcuMTgxSDQ5OS42NTV2Ny4xODFjLTguMjA3LTUuODk4LTIyLjA1Ny03LjE4MS0yOC40NDctNy4xODFINDAzLjE4djcuMTgxYy02LjQ5Mi02LjI2Mi0yMC45MzUtNy4xODEtMjkuNzM0LTcuMTgxaC03Ni4xMzRsLTE3LjQyLDE4Ljc3NWwtMTYuMzE4LTE4Ljc3NUgxNDkuODQ3djEyMi42NzVoMTExLjU4NmwxNy45NS0xOS4wNzZsMTYuOTEsMTkuMDc2bDY4Ljc4LDAuMDU5di0yOC44NTloNi43NjRjOS4xMjUsMC4xNDUsMTkuODg5LTAuMjIzLDI5LjM4Ny00LjMxMXYzMy4xMDdoNTYuNzMxdi0zMS45NzZoMi43MzZjMy40OTIsMCwzLjgzOCwwLjE0NiwzLjgzOCwzLjYyMXYyOC4zNDhoMTcyLjM0NGMxMC45NDEsMCwyMi4zOC0yLjc4NiwyOC43MTItNy44NTN2Ny44NTNoNTQuNjY4YzExLjM3NSwwLDIyLjQ4NS0xLjU4OCwzMC45MzgtNS42NTN2LTIyLjg1M0M3NDYuMDY5LDM1MS4yOTcsNzM2LjA3OSwzNTUuMDgsNzIyLjU2NSwzNTUuMDh6IE0zNzIuNzM0LDMyNi4xMTNoLTI2LjMyNXYyOS40ODhoLTQxLjAwNkwyNzkuNDI1LDMyNi41bC0yNi45OTcsMjkuMTAyaC04My41Njl2LTg3LjkxNGg4NC44NTVsMjUuOTU1LDI4LjgxOGwyNi44MzUtMjguODE4aDY3LjQxNGMxNi43NDMsMCwzNS41NTUsNC42MTcsMzUuNTU1LDI4Ljk2M0M0MDkuNDczLDMyMS4wNzIsMzkxLjE3NiwzMjYuMTEzLDM3Mi43MzQsMzI2LjExM3ogTTQ5OS4zMjMsMzIyLjEyN2MyLjk4LDQuMjkxLDMuNDEsOC4yOTcsMy40OTYsMTYuMDQ3djE3LjQyOGgtMjEuMTgydi0xMC45OThjMC01LjI4OSwwLjUxMi0xMy4xMjEtMy40MS0xNy4yMDljLTMuMDgtMy4xNDktNy43ODEtMy45MDEtMTUuNDgtMy45MDFoLTIyLjU0NXYzMi4xMDhoLTIxLjE5OHYtODcuOTE0aDQ4LjcwNmMxMC42ODUsMCwxOC40NjIsMC40NzIsMjUuMzg2LDQuMTQ4YzYuNjU4LDQuMDA2LDEwLjg0OCw5LjQ5NCwxMC44NDgsMTkuNTIzYy0wLjAwMiwxNC4wMzEtOS4zOTksMjEuMTktMTQuOTUzLDIzLjM4OUM0OTMuNjg0LDMxNi40NzMsNDk3LjUyMiwzMTkuNTY2LDQ5OS4zMjMsMzIyLjEyN3ogTTU4Ni40NzMsMjg1Ljg2OWgtNDkuNDA0djE1Ljk4Mmg0OC4xOTd2MTcuOTM4aC00OC4xOTd2MTcuNDkybDQ5LjQwNCwwLjA3OHYxOC4yNDJoLTcwLjQxNHYtODcuOTE0aDcwLjQxNFYyODUuODY5eiBNNjQwLjY4NiwzNTUuNmgtNDEuMDl2LTE4Ljg1Mmg0MC45MjZjNC4wMDIsMCw2Ljg0LTAuNTI3LDguNjE5LTIuMTc4YzEuNDQ5LTEuMzU5LDIuNDkyLTMuMzM2LDIuNDkyLTUuNzNjMC0yLjU2NC0xLjEyOS00LjU5OC0yLjU3NC01LjgxOGMtMS42MTUtMS4zNC0zLjg0Mi0xLjk0OC03LjUxNC0xLjk0OGMtMTkuNzMtMC42NzMtNDQuNDM5LDAuNjA2LTQ0LjQzOS0yNy4yMTJjMC0xMi43NTIsOC4wNDctMjYuMTc0LDMwLjE2NC0yNi4xNzRoNDIuMjk3djE4LjcwOWgtMzguNzAzYy0zLjgzNiwwLTYuMzMsMC4xNDYtOC40NTEsMS41OTJjLTIuMzEzLDEuNDIzLTMuMTcsMy41MzUtMy4xNyw2LjMyMmMwLDMuMzE2LDEuOTYzLDUuNTc0LDQuNjE1LDYuNTQ5YzIuMjI4LDAuNzcxLDQuNjE3LDAuOTk2LDguMjExLDAuOTk2bDExLjM1OSwwLjMwOGMxMS40NDksMC4yNzQsMTkuMzEzLDIuMjUsMjQuMDkyLDcuMDY5YzQuMTA1LDQuMjMyLDYuMzExLDkuNTc4LDYuMzExLDE4LjYyNUM2NzMuODI5LDM0Ni43NzEsNjYxLjk2MywzNTUuNiw2NDAuNjg2LDM1NS42eiBNNzUxLjE5MiwzNDMuODM4TDc1MS4xOTIsMzQzLjgzOEw3NTEuMTkyLDM0My44MzhMNzUxLjE5MiwzNDMuODM4eiBNNDc3LjA2MSwyODcuMjg3Yy0yLjU0OS0xLjUwOC02LjMxMS0xLjU4OC0xMC4wNjYtMS41ODhoLTI1Ljk3OXYxOS43NDRoMjUuNjMxYzQuMTA0LDAsNy41OTQtMC4xNDQsMTAuNDE0LTEuODEyYzIuNzM0LTEuNjQ2LDQuMzcxLTQuNjc4LDQuMzcxLTguNDM4QzQ4MS40MzIsMjkxLjQzNCw0NzkuNzk1LDI4OC43MTEsNDc3LjA2MSwyODcuMjg3eiBNNzEyLjc4NCwyODUuNjk3Yy0zLjgzOCwwLTYuMzg5LDAuMTQ1LTguNTM3LDEuNTg4Yy0yLjIyNywxLjQyNi0zLjA4MSwzLjUzNy0zLjA4MSw2LjMyNmMwLDMuMzE1LDEuODc5LDUuNTcyLDQuNjEyLDYuNTQ5YzIuMjI4LDAuNzcxLDQuNjE1LDAuOTk2LDguMTI5LDAuOTk2bDExLjQzNywwLjMwM2MxMS41MzcsMC4yODUsMTkuMjQyLDIuMjYyLDIzLjkzOCw3LjA4YzAuODU1LDAuNjY4LDEuMzY5LDEuNDIsMS45NTcsMi4xNzR2LTI1LjAxNGgtMzguNDUzTDcxMi43ODQsMjg1LjY5N0w3MTIuNzg0LDI4NS42OTd6IE0zNzMuNDcsMjg1LjY5N2gtMjcuNTA5djIyLjM5MWgyNy4yNjVjOC4xMDUsMCwxMy4xNDYtNC4wMDYsMTMuMTQ5LTExLjYxMUMzODYuMzcyLDI4OC43ODksMzgxLjA4NiwyODUuNjk3LDM3My40NywyODUuNjk3eiBNMTg5Ljg3MiwyODUuNjk3djE1Ljk4NGg0Ni4zMTV2MTcuOTM4aC00Ni4zMTV2MTcuNDloNTEuODdsMjQuMS0yNS43OTFsLTIzLjA3Ni0yNS42MjFIMTg5Ljg3MkwxODkuODcyLDI4NS42OTd6IE0zMjUuMzIxLDM0Ny4xNzZ2LTcwLjQ4MmwtMzIuMzkxLDM0LjY3M0wzMjUuMzIxLDM0Ny4xNzZ6IE0xOTEuNjQ5LDIwNi4wMjV2MTUuMTQ4aDE3Ni4yNjNsLTAuMDgyLTMyLjA0NmgzLjQxMWMyLjM5LDAuMDgzLDMuMDg0LDAuMzAyLDMuMDg0LDQuMjI5djI3LjgxOGg5MS4xNjR2LTcuNDYxYzcuMzUzLDMuOTI0LDE4Ljc4OSw3LjQ2MSwzMy44MzgsNy40NjFoMzguMzUzbDguMjA5LTE5LjUyMmgxOC4xOTdsOC4wMjYsMTkuNTIyaDczLjkwNlYyMDIuNjNsMTEuMTg5LDE4LjU0M2g1OS4yMjdWOTguNTloLTU4LjYxMXYxNC40NzdsLTguMjA3LTE0LjQ3N2gtNjAuMTQzdjE0LjQ3N2wtNy41MzctMTQuNDc3aC04MS4yNGMtMTMuNiwwLTI1LjU1MSwxLjg5LTM1LjIwNyw3LjE1OFY5OC41OWgtNTYuMDYzdjcuMTU4Yy02LjE0Ni01LjQzLTE0LjUxOS03LjE1OC0yMy44MjYtNy4xNThIMTgwLjc4NGwtMTMuNzQyLDMxLjY2MkwxNTIuOTI4LDk4LjU5SDg4LjQxN3YxNC40NzdMODEuMzI5LDk4LjU5SDI2LjMxMkwwLjc2MywxNTYuODc0djQ2LjYyMWwzNy43NzktODcuODk0aDMxLjM0NmwzNS44OCw4My4yMTd2LTgzLjIxN2gzNC40MzVsMjcuNjEsNTkuNjI1bDI1LjM2NS01OS42MjVoMzUuMTI2djg3Ljg5NGgtMjEuNjI1bC0wLjA3OS02OC44MzdsLTMwLjU5Myw2OC44MzdoLTE4LjUyNGwtMzAuNjcxLTY4Ljg5OHY2OC44OThIODMuODk5bC04LjEwNi0xOS42MDVIMzEuODY1bC04LjE5LDE5LjYwNUgwLjc2MnYxNy42ODJoMzYuMDQ5bDguMTI4LTE5LjUyM2gxOC4xOThsOC4xMDYsMTkuNTIzaDcwLjkyNVYyMDYuMjVsNi4zMywxNC45ODloMzYuODE5TDE5MS42NDksMjA2LjAyNXogTTQ2OS40MDEsMTI1Ljg0OWM2LjgxOC03LjAxNSwxNy41LTEwLjI1LDMyLjAzOS0xMC4yNWgyMC40MjR2MTguODMzaC0xOS45OTZjLTcuNjk2LDAtMTIuMDQ3LDEuMTQtMTYuMjMzLDUuMjA4Yy0zLjU5OSwzLjctNi4wNjYsMTAuNjk2LTYuMDY2LDE5LjkwOGMwLDkuNDE3LDEuODgxLDE2LjIwNiw1LjgwMSwyMC42NDFjMy4yNDgsMy40NzgsOS4xNTIsNC41MzMsMTQuNzA1LDQuNTMzaDkuNDc4bDI5LjczMy02OS4xMmgzMS42MTFsMzUuNzE5LDgzLjEzNHYtODMuMTMzaDMyLjEyM2wzNy4wODYsNjEuMjEzdi02MS4yMTNoMjEuNjExdjg3Ljg5MWgtMjkuODk4bC0zOS45ODktNjUuOTY4djY1Ljk2OGgtNDIuOTY4bC04LjIwOS0xOS42MDVoLTQzLjgyN2wtNy45NjYsMTkuNjA1aC0yNC42ODhjLTEwLjI1NCwwLTIzLjIzOC0yLjI1OC0zMC41OS05LjcyMmMtNy40MTYtNy40NjItMTEuMjcxLTE3LjU3MS0xMS4yNzEtMzMuNTUzQzQ1OC4wMjYsMTQ3LjE4Miw0NjAuMzI5LDEzNS4yNjYsNDY5LjQwMSwxMjUuODQ5eiBNNDI2LjAwNiwxMTUuNmgyMS41MjZ2ODcuODk0aC0yMS41MjZWMTE1LjZ6IE0zMjguOTUxLDExNS42aDQ4LjUyNWMxMC43NzksMCwxOC43MjcsMC4yODUsMjUuNTQ3LDQuMjFjNi42NzQsMy45MjYsMTAuNjc2LDkuNjU4LDEwLjY3NiwxOS40NmMwLDE0LjAxNS05LjM5MywyMS4yNTQtMTQuODY0LDIzLjQyOWM0LjYxNCwxLjc1LDguNTU5LDQuODQxLDEwLjQzOCw3LjQwMWMyLjk3OSw0LjM3MiwzLjQ5Miw4LjI3NywzLjQ5MiwxNi4xMjZ2MTcuMjY3aC0yMS4yNzlsLTAuMDgtMTEuMDg0YzAtNS4yOSwwLjUwOC0xMi44OTYtMy4zMy0xNy4xMjJjLTMuMDgyLTMuMDktNy43ODItMy43NjMtMTUuMzc5LTMuNzYzSDM1MC4wNXYzMS45N2gtMjEuMDk4TDMyOC45NTEsMTE1LjZMMzI4Ljk1MSwxMTUuNnogTTI0My45MDIsMTE1LjZoNzAuNDc5djE4LjMwM2gtNDkuMzc5djE1Ljg0M2g0OC4xOTN2MTguMDE3aC00OC4xOTN2MTcuNTUzaDQ5LjM3OXYxOC4xNzdoLTcwLjQ3OVYxMTUuNkwyNDMuOTAyLDExNS42elwiLz48L2c+PC9nPjwvc3ZnPmBcbiAgICBsZXQgdmlzYV9zaW5nbGUgPSBgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJMYXllcl8xXCIgeG1sbnM6c2tldGNoPVwiaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI3NTBweFwiIGhlaWdodD1cIjQ3MXB4XCIgdmlld0JveD1cIjAgMCA3NTAgNDcxXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDc1MCA0NzFcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPjx0aXRsZT5TbGljZSAxPC90aXRsZT48ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz48ZyBpZD1cInZpc2FcIiBza2V0Y2g6dHlwZT1cIk1TTGF5ZXJHcm91cFwiPjxwYXRoIGlkPVwiU2hhcGVcIiBza2V0Y2g6dHlwZT1cIk1TU2hhcGVHcm91cFwiIGZpbGw9XCIjMEU0NTk1XCIgZD1cIk0yNzguMTk4LDMzNC4yMjhsMzMuMzYtMTk1Ljc2M2g1My4zNThsLTMzLjM4NCwxOTUuNzYzSDI3OC4xOThMMjc4LjE5OCwzMzQuMjI4elwiLz48cGF0aCBpZD1cInBhdGgxM1wiIHNrZXRjaDp0eXBlPVwiTVNTaGFwZUdyb3VwXCIgZmlsbD1cIiMwRTQ1OTVcIiBkPVwiTTUyNC4zMDcsMTQyLjY4N2MtMTAuNTctMy45NjYtMjcuMTM1LTguMjIyLTQ3LjgyMi04LjIyMmMtNTIuNzI1LDAtODkuODYzLDI2LjU1MS05MC4xOCw2NC42MDRjLTAuMjk3LDI4LjEyOSwyNi41MTQsNDMuODIxLDQ2Ljc1NCw1My4xODVjMjAuNzcsOS41OTcsMjcuNzUyLDE1LjcxNiwyNy42NTIsMjQuMjgzYy0wLjEzMywxMy4xMjMtMTYuNTg2LDE5LjExNi0zMS45MjQsMTkuMTE2Yy0yMS4zNTUsMC0zMi43MDEtMi45NjctNTAuMjI1LTEwLjI3NGwtNi44NzctMy4xMTJsLTcuNDg4LDQzLjgyM2MxMi40NjMsNS40NjYsMzUuNTA4LDEwLjE5OSw1OS40MzgsMTAuNDQ1YzU2LjA5LDAsOTIuNTAyLTI2LjI0OCw5Mi45MTYtNjYuODg0YzAuMTk5LTIyLjI3LTE0LjAxNi0zOS4yMTYtNDQuODAxLTUzLjE4OGMtMTguNjUtOS4wNTYtMzAuMDcyLTE1LjA5OS0yOS45NTEtMjQuMjY5YzAtOC4xMzcsOS42NjgtMTYuODM4LDMwLjU1OS0xNi44MzhjMTcuNDQ3LTAuMjcxLDMwLjA4OCwzLjUzNCwzOS45MzYsNy41bDQuNzgxLDIuMjU5TDUyNC4zMDcsMTQyLjY4N1wiLz48cGF0aCBpZD1cIlBhdGhcIiBza2V0Y2g6dHlwZT1cIk1TU2hhcGVHcm91cFwiIGZpbGw9XCIjMEU0NTk1XCIgZD1cIk02NjEuNjE1LDEzOC40NjRoLTQxLjIzYy0xMi43NzMsMC0yMi4zMzIsMy40ODYtMjcuOTQxLDE2LjIzNGwtNzkuMjQ0LDE3OS40MDJoNTYuMDMxYzAsMCw5LjE2LTI0LjEyMSwxMS4yMzItMjkuNDE4YzYuMTIzLDAsNjAuNTU1LDAuMDg0LDY4LjMzNiwwLjA4NGMxLjU5Niw2Ljg1NCw2LjQ5MiwyOS4zMzQsNi40OTIsMjkuMzM0aDQ5LjUxMkw2NjEuNjE1LDEzOC40NjRMNjYxLjYxNSwxMzguNDY0eiBNNTk2LjE5OCwyNjQuODcyYzQuNDE0LTExLjI3OSwyMS4yNi01NC43MjQsMjEuMjYtNTQuNzI0Yy0wLjMxNCwwLjUyMSw0LjM4MS0xMS4zMzQsNy4wNzQtMTguNjg0bDMuNjA3LDE2Ljg3OGMwLDAsMTAuMjE3LDQ2LjcyOSwxMi4zNTIsNTYuNTI3aC00NC4yOTNWMjY0Ljg3Mkw1OTYuMTk4LDI2NC44NzJ6XCIvPjxwYXRoIGlkPVwicGF0aDE2XCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwiIzBFNDU5NVwiIGQ9XCJNMjMyLjkwMywxMzguNDY0TDE4MC42NjQsMjcxLjk2bC01LjU2NS0yNy4xMjljLTkuNzI2LTMxLjI3NC00MC4wMjUtNjUuMTU3LTczLjg5OC04Mi4xMmw0Ny43NjcsMTcxLjIwNGw1Ni40NTUtMC4wNjRsODQuMDA0LTE5NS4zODZMMjMyLjkwMywxMzguNDY0XCIvPjxwYXRoIGlkPVwicGF0aDE4XCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwiI0YyQUUxNFwiIGQ9XCJNMTMxLjkyLDEzOC40NjRINDUuODc5bC0wLjY4Miw0LjA3M2M2Ni45MzksMTYuMjA0LDExMS4yMzIsNTUuMzYzLDEyOS42MTgsMTAyLjQxNWwtMTguNzA5LTg5Ljk2QzE1Mi44NzcsMTQyLjU5NiwxNDMuNTA5LDEzOC44OTYsMTMxLjkyLDEzOC40NjRcIi8+PC9nPjwvc3ZnPmBcbiAgICBsZXQgZGluZXJzX3NpbmdsZSA9IGA8c3ZnIHZlcnNpb249XCIxLjFcIiBpZD1cIkxheWVyXzFcIiB4bWxuczpza2V0Y2g9XCJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnNcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjc1MFwiIGhlaWdodD1cIjQ3MVwiIHZpZXdCb3g9XCIwIDAgNzUwIDQ3MVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA3NTAgNDcxXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj48dGl0bGU+ZGluZXJzPC90aXRsZT48ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz48ZyBpZD1cImRpbmVyc1wiIHNrZXRjaDp0eXBlPVwiTVNMYXllckdyb3VwXCI+PHBhdGggaWQ9XCJTaGFwZS1wYXRoXCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwiIzAwNzlCRVwiIGQ9XCJNNTg0LjkzNCwyMzYuOTQ3YzAtOTkuNDE2LTgyLjk4LTE2OC4xMzMtMTczLjg5Ni0xNjguMWgtNzguMjQxYy05Mi4wMDMtMC4wMzMtMTY3LjczLDY4LjcwNS0xNjcuNzMsMTY4LjFjMCw5MC45MzEsNzUuNzI5LDE2NS42NDEsMTY3LjczLDE2NS4yMDNoNzguMjQxQzUwMS45NTEsNDAyLjU4Nyw1ODQuOTM0LDMyNy44NTcsNTg0LjkzNCwyMzYuOTQ3TDU4NC45MzQsMjM2Ljk0N3pcIi8+PHBhdGggaWQ9XCJTaGFwZS1wYXRoXzFfXCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwiI0ZGRkZGRlwiIGQ9XCJNMzMzLjI4MSw4Mi45MzJjLTg0LjA2OSwwLjAyNi0xNTIuMTkzLDY4LjMwOC0xNTIuMjE1LDE1Mi41OGMwLjAyMSw4NC4yNTgsNjguMTQ1LDE1Mi41MzIsMTUyLjIxNSwxNTIuNTU5Yzg0LjA4OC0wLjAyNiwxNTIuMjI5LTY4LjMwMSwxNTIuMjM5LTE1Mi41NTlDNDg1LjUwOCwxNTEuMjM4LDQxNy4zNjksODIuOTU4LDMzMy4yODEsODIuOTMyTDMzMy4yODEsODIuOTMyelwiLz48cGF0aCBpZD1cIlBhdGhcIiBza2V0Y2g6dHlwZT1cIk1TU2hhcGVHcm91cFwiIGZpbGw9XCIjMDA3OUJFXCIgZD1cIk0yMzcuMDY2LDIzNS4wOThjMC4wOC00MS4xOCwyNS43NDctNzYuMjk2LDYxLjk0LTkwLjI1djE4MC40NzlDMjYyLjgxMywzMTEuMzgxLDIzNy4xNDUsMjc2LjI4MywyMzcuMDY2LDIzNS4wOTh6IE0zNjguMDY2LDMyNS4zNzNWMTQ0Ljg0OGMzNi4yMDgsMTMuOTIxLDYxLjkxNSw0OS4wNTcsNjEuOTgxLDkwLjI1NkM0MjkuOTgxLDI3Ni4zMTYsNDA0LjI3NCwzMTEuNDI2LDM2OC4wNjYsMzI1LjM3M3pcIi8+PC9nPjwvc3ZnPmBcbiAgICBsZXQgZGlzY292ZXJfc2luZ2xlID0gYDxzdmcgdmVyc2lvbj1cIjEuMVwiIGlkPVwiTGF5ZXJfMVwiIHhtbG5zOnNrZXRjaD1cImh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9uc1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHdpZHRoPVwiNzgwcHhcIiBoZWlnaHQ9XCI1MDFweFwiIHZpZXdCb3g9XCIwIDAgNzgwIDUwMVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA3ODAgNTAxXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj48dGl0bGU+ZGlzY292ZXI8L3RpdGxlPjxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPjxnIGlkPVwiUGFnZS0xXCIgc2tldGNoOnR5cGU9XCJNU1BhZ2VcIj48ZyBpZD1cImRpc2NvdmVyXCIgc2tldGNoOnR5cGU9XCJNU0xheWVyR3JvdXBcIj48cGF0aCBmaWxsPVwiI0Y0NzIxNlwiIGQ9XCJNNDA5LjQxMiwxOTcuNzU4YzMwLjkzOCwwLDU2LjAyLDIzLjU4LDU2LjAyLDUyLjcwOXYwLjAzM2MwLDI5LjEyOS0yNS4wODIsNTIuNzQyLTU2LjAyLDUyLjc0MmMtMzAuOTQxLDAtNTYuMDIyLTIzLjYxMy01Ni4wMjItNTIuNzQydi0wLjAzM0MzNTMuMzksMjIxLjMzOCwzNzguNDcxLDE5Ny43NTgsNDA5LjQxMiwxOTcuNzU4TDQwOS40MTIsMTk3Ljc1OHpcIi8+PHBhdGggZD1cIk0zMjEuNDMzLDE5OC40MzhjOC44MzYsMCwxNi4yNDcsMS43ODUsMjUuMjY5LDYuMDl2MjIuNzUyYy04LjU0NC03Ljg2My0xNS45NTUtMTEuMTU0LTI1Ljc1Ny0xMS4xNTRjLTE5LjI2NSwwLTM0LjQxMywxNS4wMTUtMzQuNDEzLDM0LjA1MWMwLDIwLjA3NCwxNC42ODEsMzQuMTk1LDM1LjM2OCwzNC4xOTVjOS4zMTMsMCwxNi41ODYtMy4xMiwyNC44MDItMTAuODU2djIyLjc2NGMtOS4zNDMsNC4xNDEtMTYuOTEyLDUuNzc1LTI1Ljc1Nyw1Ljc3NWMtMzEuMjc3LDAtNTUuNTgxLTIyLjU5Ny01NS41ODEtNTEuNzM3QzI2NS4zNjMsMjIxLjQ5LDI5MC4zMTQsMTk4LjQzOCwzMjEuNDMzLDE5OC40MzhMMzIxLjQzMywxOTguNDM4elwiLz48cGF0aCBkPVwiTTIyNC4zMiwxOTkuMDY0YzExLjU0NiwwLDIyLjEwOSwzLjcyMSwzMC45NDIsMTAuOTk0bC0xMC43NDgsMTMuMjQ4Yy01LjM1MS01LjY0Ni0xMC40MTEtOC4wMjctMTYuNTYzLTguMDI3Yy04Ljg1NCwwLTE1LjMwMSw0Ljc0NS0xNS4zMDEsMTAuOTg4YzAsNS4zNTQsMy42MTgsOC4xODgsMTUuOTQ0LDEyLjQ4MmMyMy4zNjQsOC4wNDMsMzAuMjg5LDE1LjE3NiwzMC4yODksMzAuOTI2YzAsMTkuMTkzLTE0Ljk3NiwzMi41NTQtMzYuMzE5LDMyLjU1NGMtMTUuNjMxLDAtMjYuOTkzLTUuNzk1LTM2LjQ1Ny0xOC44NzFsMTMuMjY4LTEyLjAzMWM0LjczLDguNjA5LDEyLjYyMiwxMy4yMjMsMjIuNDIsMTMuMjIzYzkuMTYzLDAsMTUuOTQ3LTUuOTUxLDE1Ljk0Ny0xMy45ODRjMC00LjE2NC0yLjA1Ni03LjczMy02LjE1OC0xMC4yNThjLTIuMDY2LTEuMTk1LTYuMTU4LTIuOTc3LTE0LjE5OS01LjY0NmMtMTkuMjkyLTYuNTM4LTI1LjkxLTEzLjUyNy0yNS45MS0yNy4xODZDMTkxLjQ3NCwyMTEuMjUsMjA1LjY4OCwxOTkuMDY0LDIyNC4zMiwxOTkuMDY0TDIyNC4zMiwxOTkuMDY0elwiLz48cG9seWdvbiBwb2ludHM9XCI0NTkuMDQzLDIwMC43OTMgNDgxLjQ3OSwyMDAuNzkzIDUwOS41NjMsMjY3LjM4NSA1MzguMDEsMjAwLjc5MyA1NjAuMjc2LDIwMC43OTMgNTE0Ljc4MywzMDIuNDc5IDUwMy43MjksMzAyLjQ3OSBcIi8+PHBvbHlnb24gcG9pbnRzPVwiMTU3LjgzLDIwMC45NDUgMTc4LjM3MSwyMDAuOTQ1IDE3OC4zNzEsMzAwLjA4OCAxNTcuODMsMzAwLjA4OCBcIi8+PHBvbHlnb24gcG9pbnRzPVwiNTY5LjU2MywyMDAuOTQ1IDYyNy44MTUsMjAwLjk0NSA2MjcuODE1LDIxNy43NDQgNTkwLjA5LDIxNy43NDQgNTkwLjA5LDIzOS43NSA2MjYuNDI2LDIzOS43NSA2MjYuNDI2LDI1Ni41NDEgNTkwLjA5LDI1Ni41NDEgNTkwLjA5LDI4My4zMDMgNjI3LjgxNSwyODMuMzAzIDYyNy44MTUsMzAwLjA4OCA1NjkuNTYzLDMwMC4wODggXCIvPjxwYXRoIGQ9XCJNNjg1LjE1NiwyNTguMzIyYzE1LjQ3MS0yLjk2NSwyMy45ODQtMTIuOTI2LDIzLjk4NC0yOC4xMDVjMC0xOC41NjItMTMuNTc2LTI5LjI3MS0zNy4yNjYtMjkuMjcxSDY0MS40MnY5OS4xNDNoMjAuNTE2VjI2MC4yNmgyLjY4bDI4LjQzLDM5LjgyOGgyNS4yNkw2ODUuMTU2LDI1OC4zMjJ6IE02NjcuOTM4LDI0Ni41ODZoLTYuMDAydi0zMC4wMjVoNi4zMjZjMTIuNzkxLDAsMTkuNzQ0LDUuMDQ5LDE5Ljc0NCwxNC42OTdDNjg4LjAwOCwyNDEuMjI0LDY4MS4wNTUsMjQ2LjU4Niw2NjcuOTM4LDI0Ni41ODZ6XCIvPjxwYXRoIGQ9XCJNOTEuODQ1LDIwMC45NDVINjEuNjk2djk5LjE0M2gyOS45OTJjMTUuOTQ2LDAsMjcuNDY1LTMuNTQzLDM3LjU3My0xMS40NDVjMTIuMDE0LTkuMzYsMTkuMTE3LTIzLjQ2NywxOS4xMTctMzguMDU3QzE0OC4zNzksMjIxLjMyNywxMjUuMTU3LDIwMC45NDUsOTEuODQ1LDIwMC45NDV6IE0xMTUuODQyLDI3NS40MjRjLTYuNDU0LDUuNDg0LTE0LjgzNyw3Ljg3OS0yOC4xMDgsNy44NzlIODIuMjJ2LTY1LjU1OWg1LjUxM2MxMy4yNzEsMCwyMS4zMjMsMi4yMzgsMjguMTA4LDguMDE4YzcuMTA0LDUuOTU2LDExLjM3NywxNS4xODMsMTEuMzc3LDI0LjY4MkMxMjcuMjE5LDI1OS45NTcsMTIyLjk0NSwyNjkuNDY4LDExNS44NDIsMjc1LjQyNHpcIi8+PC9nPjwvZz48L3N2Zz5gXG4gICAgbGV0IGpjYl9zaW5nbGUgPSBgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJMYXllcl8xXCIgeG1sbnM6c2tldGNoPVwiaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI3NTBweFwiIGhlaWdodD1cIjQ3MXB4XCIgdmlld0JveD1cIjAgMCA3NTAgNDcxXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDc1MCA0NzFcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPjx0aXRsZT5TbGljZSAxPC90aXRsZT48ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz48Zz48cGF0aCBpZD1cInBhdGgzNDk0XCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwiI0ZGRkZGRlwiIGQ9XCJNNjE3LjI0MiwzNDYuNzY2YzAsNDEuNjE1LTMzLjcyOSw3NS4zNi03NS4zNTcsNzUuMzZIMTMyLjc1OVYxMjQuMjQ1YzAtNDEuNjI2LDMzLjczLTc1LjM3MSw3NS4zNjQtNzUuMzcxaDQwOS4xMlYzNDYuNzY2TDYxNy4yNDIsMzQ2Ljc2Nkw2MTcuMjQyLDM0Ni43NjZ6XCIvPjxsaW5lYXJHcmFkaWVudCBpZD1cInBhdGgzNDk2XzFfXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgeDE9XCI4MjQuNzQyNFwiIHkxPVwiMzMzLjc4MTNcIiB4Mj1cIjgyNS43NDI0XCIgeTI9XCIzMzMuNzgxM1wiIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KDEzMi44NzQzIDAgMCAtMzIzLjAyMjYgLTEwOTEyOS41MzEzIDEwODA1NC42MDE2KVwiPjxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6IzAwN0I0MFwiLz48c3RvcCBvZmZzZXQ9XCIxXCIgc3R5bGU9XCJzdG9wLWNvbG9yOiM1NUIzMzBcIi8+PC9saW5lYXJHcmFkaWVudD48cGF0aCBpZD1cInBhdGgzNDk2XCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwidXJsKCNwYXRoMzQ5Nl8xXylcIiBkPVwiTTQ4My44NiwyNDIuMDQ1YzExLjY4NiwwLjI1NCwyMy40MzktMC41MTYsMzUuMDc4LDAuNGMxMS43ODcsMi4xOTksMTQuNjI3LDIwLjA0Myw0LjE1NiwyNS44ODdjLTcuMTQ1LDMuODUtMTUuNjMzLDEuNDM0LTIzLjM3OSwyLjExM0g0ODMuODZWMjQyLjA0NUw0ODMuODYsMjQyLjA0NXogTTUyNS42OTQsMjA5LjljMi41OTYsOS4xNjQtNi4yMzgsMTcuMzkyLTE1LjA2NCwxNi4xM2gtMjYuNzdjMC4xODgtOC42NDItMC4zNjctMTguMDIyLDAuMjczLTI2LjIwOWMxMC43MjMsMC4zMDIsMjEuNTQ3LTAuNjE2LDMyLjIwOSwwLjQ4QzUyMC45MjIsMjAxLjQ1Miw1MjQuNzU2LDIwNS4yMTgsNTI1LjY5NCwyMDkuOUw1MjUuNjk0LDIwOS45eiBNNTkwLjExOSw3My45OTdjMC40OTgsMTcuNTAxLDAuMDcyLDM1LjkyNywwLjIxNSw1My43ODNjLTAuMDMzLDcyLjU5NiwwLjA3LDE0NS4xOTUtMC4wNTcsMjE3Ljc4OWMtMC40NjksMjcuMjA3LTI0LjU4Miw1MC44NDctNTEuNiw1MS4zOWMtMjcuMDQ1LDAuMTEtNTQuMDk0LDAuMDE3LTgxLjE0MywwLjA0N3YtMTA5Ljc1YzI5LjQ3MS0wLjE1Myw1OC45NTcsMC4zMDgsODguNDE2LTAuMjMxYzEzLjY2Ni0wLjg1OCwyOC42MzUtOS44NzUsMjkuMjcxLTI0LjkxNGMxLjYwOS0xNS4xMDMtMTIuNjMxLTI1LjU1MS0yNi4xNTItMjcuMjAxYy01LjE5Ny0wLjEzNS01LjA0NS0xLjUxNSwwLTIuMTE3YzEyLjg5NS0yLjc4NywyMy4wMjEtMTYuMTMzLDE5LjIyNy0yOS40OTljLTMuMjM0LTE0LjA1OC0xOC43NzEtMTkuNDk5LTMxLjY5NS0xOS40NzJjLTI2LjM1Mi0wLjE3OS01Mi43MDktMC4wMjUtNzkuMDYzLTAuMDc3YzAuMTctMjAuNDg5LTAuMzU1LTQxLDAuMjgzLTYxLjQ3NGMyLjA4OC0yNi43MTYsMjYuODA3LTQ4Ljc0OCw1My40NDctNDguMjdDNTM3LjU1NSw3My45OTgsNTYzLjgzOCw3My45OTgsNTkwLjExOSw3My45OTdMNTkwLjExOSw3My45OTd6XCIvPjxsaW5lYXJHcmFkaWVudCBpZD1cInBhdGgzNDk4XzFfXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgeDE9XCI4MjQuNzU1MVwiIHkxPVwiMzMzLjc4MjJcIiB4Mj1cIjgyNS43NDg0XCIgeTI9XCIzMzMuNzgyMlwiIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KDEzMy40MzA3IDAgMCAtMzIzLjAyMDMgLTEwOTg4Ny42ODc1IDEwODA1My44MjAzKVwiPjxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6IzFEMjk3MFwiLz48c3RvcCBvZmZzZXQ9XCIxXCIgc3R5bGU9XCJzdG9wLWNvbG9yOiMwMDZEQkFcIi8+PC9saW5lYXJHcmFkaWVudD48cGF0aCBpZD1cInBhdGgzNDk4XCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwidXJsKCNwYXRoMzQ5OF8xXylcIiBkPVwiTTE1OS43NDIsMTI1LjA0MWMwLjY3My0yNy4xNjQsMjQuODg4LTUwLjYxMSw1MS44NzItNTEuMDA4YzI2Ljk0NS0wLjA4Myw1My44OTQtMC4wMTIsODAuODM5LTAuMDM2Yy0wLjA3NCw5MC44ODUsMC4xNDYsMTgxLjc3Ni0wLjExMSwyNzIuNjU3Yy0xLjAzOCwyNi44MzQtMjQuOTg5LDQ5LjgzNC01MS42NzksNTAuMzA5Yy0yNi45OTYsMC4wOTgtNTMuOTk1LDAuMDE0LTgwLjk5MiwwLjA0MVYyODMuNTUxYzI2LjIyMyw2LjE5NSw1My43MjIsOC44MzIsODAuNDc0LDQuNzIzYzE1Ljk5MS0yLjU3NCwzMy40ODctMTAuNDI2LDM4LjkwMS0yNy4wMTZjMy45ODQtMTQuMTkxLDEuNzQxLTI5LjEyNiwyLjMzNC00My42OTF2LTMzLjgyNWgtNDYuMjk3Yy0wLjIwOCwyMi4zNzEsMC40MjYsNDQuNzgxLTAuMzM1LDY3LjEyNWMtMS4yNDgsMTMuNzM0LTE0Ljg0OSwyMi40Ni0yNy44MDIsMjEuOTk0Yy0xNi4wNjQsMC4xNy00Ny44OTctMTEuNjQxLTQ3Ljg5Ny0xMS42NDFDMTU4Ljk2OSwyMTkuMzA1LDE1OS41MTUsMTY2LjgxNCwxNTkuNzQyLDEyNS4wNDFMMTU5Ljc0MiwxMjUuMDQxelwiLz48bGluZWFyR3JhZGllbnQgaWQ9XCJwYXRoMzUwMF8xX1wiIGdyYWRpZW50VW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiIHgxPVwiODI0Ljc0MjRcIiB5MT1cIjMzMy43ODEzXCIgeDI9XCI4MjUuNzQxXCIgeTI9XCIzMzMuNzgxM1wiIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KDEzMi45NTgzIDAgMCAtMzIzLjAyNzYgLTEwOTM0Ny45MjE5IDEwODA1Ni4yNjU2KVwiPjxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6IzZFMkIyRlwiLz48c3RvcCBvZmZzZXQ9XCIxXCIgc3R5bGU9XCJzdG9wLWNvbG9yOiNFMzAxMzhcIi8+PC9saW5lYXJHcmFkaWVudD48cGF0aCBpZD1cInBhdGgzNTAwXCIgc2tldGNoOnR5cGU9XCJNU1NoYXBlR3JvdXBcIiBmaWxsPVwidXJsKCNwYXRoMzUwMF8xXylcIiBkPVwiTTMwOS43MjEsMTk3LjM5Yy0yLjQzNywwLjUxNy0wLjQ5MS04LjMwMS0xLjExNC0xMS42NDZjMC4xNjYtMjEuMTUtMC4zNDYtNDIuMzIzLDAuMjg0LTYzLjQ1OGMyLjA4Mi0yNi44MjksMjYuOTkxLTQ4LjkxNiw1My43MzgtNDguMjg4aDc4Ljc2N2MtMC4wNzQsOTAuODg1LDAuMTQ1LDE4MS43NzUtMC4xMTEsMjcyLjY1N2MtMS4wMzksMjYuODM0LTI0Ljk5Miw0OS44MzMtNTEuNjgyLDUwLjMwOWMtMjYuOTk4LDAuMTAxLTUzLjk5OCwwLjAxNS04MC45OTcsMC4wNDJWMjcyLjcwN2MxOC40NCwxNS4xMjksNDMuNSwxNy40ODQsNjYuNDcyLDE3LjUyNWMxNy4zMTgtMC4wMDYsMzQuNTM1LTIuNjc2LDUxLjM1My02LjY3VjI2MC43OWMtMTguOTUzLDkuNDQ2LTQxLjIzNCwxNS40NDYtNjIuMjQ0LDEwLjAxOWMtMTQuNjU2LTMuNjQ5LTI1LjI5NC0xNy44MTMtMjUuMDU3LTMyLjkzN2MtMS42OTgtMTUuNzI5LDcuNTIyLTMyLjMzNSwyMi45NzktMzcuMDExYzE5LjE5Mi02LjAwOCw0MC4xMDgtMS40MTMsNTguMDk2LDYuMzk4YzMuODU1LDIuMDE4LDcuNzY2LDQuNTIxLDYuMjI1LTEuOTIxdi0xNy44OTljLTMwLjA4Ni03LjE1OC02Mi4xMDQtOS43OTItOTIuMzMtMi4wMDVDMzI1LjM1MiwxODcuOTAyLDMxNi44MjgsMTkxLjY0NSwzMDkuNzIxLDE5Ny4zOUwzMDkuNzIxLDE5Ny4zOXpcIi8+PC9nPjwvc3ZnPmBcbiAgICBsZXQgbWFlc3Ryb19zaW5nbGUgPSBgPHN2ZyBpZD1cIkxheWVyXzFcIiBkYXRhLW5hbWU9XCJMYXllciAxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNDgyLjZcIiBoZWlnaHQ9XCIzNzQuMzFcIiB2aWV3Qm94PVwiMCAwIDQ4Mi42IDM3NC4zMVwiPiA8dGl0bGU+bWFlc3RybzwvdGl0bGU+IDxnPiA8cGF0aCBkPVwiTTI3OC44LDQyMS43N1YzOTdjMC05LjM1LTYtMTUuNjQtMTUuNTUtMTUuNzItNS0uMDgtMTAuMjYsMS40OS0xMy45LDctMi43My00LjM4LTctNy0xMy4wNy03YTEzLjA4LDEzLjA4LDAsMCwwLTExLjU4LDUuODd2LTQuODhoLTguNjF2MzkuNTVoOC42OVYzOTkuODVjMC02Ljg3LDMuODEtMTAuNTEsOS42OC0xMC41MSw1LjcxLDAsOC42MSwzLjcyLDguNjEsMTAuNDJ2MjJoOC42OVYzOTkuODVjMC02Ljg3LDQtMTAuNTEsOS42OC0xMC41MSw1Ljg3LDAsOC42OSwzLjcyLDguNjksMTAuNDJ2MjJaTTMyNy4yOCw0MDJWMzgyLjIzaC04LjYxVjM4N2MtMi43My0zLjU2LTYuODctNS43OS0xMi40OS01Ljc5LTExLjA5LDAtMTkuNzcsOC42OS0xOS43NywyMC43N3M4LjY5LDIwLjc3LDE5Ljc3LDIwLjc3YzUuNjMsMCw5Ljc2LTIuMjMsMTIuNDktNS43OXY0LjhoOC42MVptLTMyLDBjMC02Ljk1LDQuNTUtMTIuNjYsMTItMTIuNjYsNy4xMiwwLDExLjkxLDUuNDYsMTEuOTEsMTIuNjZzLTQuOCwxMi42Ni0xMS45MSwxMi42NkMyOTkuODEsNDE0LjY2LDI5NS4yNiw0MDguOTUsMjk1LjI2LDQwMlpNNTExLjQsMzgxLjE5YTIyLjI5LDIyLjI5LDAsMCwxLDguNDksMS41OSwyMC43MSwyMC43MSwwLDAsMSw2Ljc1LDQuMzgsMjAsMjAsMCwwLDEsNC40Niw2LjU5LDIyLDIyLDAsMCwxLDAsMTYuNTIsMjAsMjAsMCwwLDEtNC40Niw2LjU5LDIwLjY5LDIwLjY5LDAsMCwxLTYuNzUsNC4zOCwyMy40MywyMy40MywwLDAsMS0xNywwLDIwLjQ3LDIwLjQ3LDAsMCwxLTYuNzMtNC4zOCwyMC4yMSwyMC4yMSwwLDAsMS00LjQ0LTYuNTksMjIsMjIsMCwwLDEsMC0xNi41MiwyMC4yMywyMC4yMywwLDAsMSw0LjQ0LTYuNTksMjAuNDgsMjAuNDgsMCwwLDEsNi43My00LjM4QTIyLjI5LDIyLjI5LDAsMCwxLDUxMS40LDM4MS4xOVptMCw4LjE0YTEyLjg0LDEyLjg0LDAsMCwwLTQuOTEuOTMsMTEuNjIsMTEuNjIsMCwwLDAtMy45MiwyLjYsMTIuMTMsMTIuMTMsMCwwLDAtMi42LDQsMTQuMzksMTQuMzksMCwwLDAsMCwxMC4yOCwxMi4xMSwxMi4xMSwwLDAsMCwyLjYsNCwxMS42MiwxMS42MiwwLDAsMCwzLjkyLDIuNiwxMy40NiwxMy40NiwwLDAsMCw5LjgzLDAsMTEuODYsMTEuODYsMCwwLDAsMy45NC0yLjYsMTIsMTIsMCwwLDAsMi42Mi00LDE0LjM5LDE0LjM5LDAsMCwwLDAtMTAuMjgsMTIsMTIsMCwwLDAtMi42Mi00LDExLjg2LDExLjg2LDAsMCwwLTMuOTQtMi42QTEyLjg0LDEyLjg0LDAsMCwwLDUxMS40LDM4OS4zMlpNMzc0LjEsNDAyYy0uMDgtMTIuMzMtNy42OS0yMC43Ny0xOC43OC0yMC43Ny0xMS41OCwwLTE5LjY5LDguNDQtMTkuNjksMjAuNzcsMCwxMi41OCw4LjQ0LDIwLjc3LDIwLjI3LDIwLjc3LDYsMCwxMS40Mi0xLjQ5LDE2LjIyLTUuNTRsLTQuMjItNi4zN0ExOC44NCwxOC44NCwwLDAsMSwzNTYuNCw0MTVjLTUuNTQsMC0xMC41OS0yLjU2LTExLjgzLTkuNjhoMjkuMzdDMzc0LDQwNC4yMywzNzQuMSw0MDMuMTYsMzc0LjEsNDAyWm0tMjkuNDUtMy40N2MuOTEtNS43MSw0LjM4LTkuNiwxMC41MS05LjYsNS41NCwwLDkuMSwzLjQ3LDEwLDkuNlptNjUuNjktNi4yQTI1LjQ5LDI1LjQ5LDAsMCwwLDM5OCwzODguOTNjLTQuNzIsMC03LjUzLDEuNzQtNy41Myw0LjYzLDAsMi42NSwzLDMuMzksNi43LDMuODlsNC4wNS41OGM4LjYxLDEuMjQsMTMuODIsNC44OCwxMy44MiwxMS44MywwLDcuNTMtNi42MiwxMi45MS0xOCwxMi45MS02LjQ1LDAtMTIuNDEtMS42Ni0xNy4xMy01LjEzbDQuMDUtNi43YTIxLjA3LDIxLjA3LDAsMCwwLDEzLjE2LDQuMTRjNS44NywwLDktMS43NCw5LTQuOCwwLTIuMjMtMi4yMy0zLjQ3LTYuOTUtNC4xNGwtNC4wNS0uNThjLTguODUtMS4yNC0xMy42NS01LjIxLTEzLjY1LTExLjY3LDAtNy44Niw2LjQ1LTEyLjY2LDE2LjQ2LTEyLjY2LDYuMjksMCwxMiwxLjQxLDE2LjEzLDQuMTRabTQxLjM1LTIuMjNINDM3LjYyVjQwOGMwLDQsMS40MSw2LjYyLDUuNzEsNi42MmExNS44OSwxNS44OSwwLDAsMCw3LjYxLTIuMjNsMi40OCw3LjM2YTIwLjIyLDIwLjIyLDAsMCwxLTEwLjc2LDMuMDZjLTEwLjE4LDAtMTMuNzMtNS40Ni0xMy43My0xNC42NXYtMThoLTh2LTcuODZoOHYtMTJoOC42OXYxMmgxNC4wNlptMjkuNzgtOC44NWExOC4zOCwxOC4zOCwwLDAsMSw2LjEyLDEuMDhsLTIuNjUsOC4xMWExNCwxNCwwLDAsMC01LjM4LTFjLTUuNjMsMC04LjQ0LDMuNjQtOC40NCwxMC4xOHYyMi4xN2gtOC42VjM4Mi4yM0g0NzFWMzg3YTExLjY2LDExLjY2LDAsMCwxLDEwLjQyLTUuNzlaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0xMzIuOSAtNDguNSlcIi8+IDxnIGlkPVwiX0dyb3VwX1wiIGRhdGEtbmFtZT1cIiZsdDtHcm91cCZndDtcIj4gPHJlY3QgeD1cIjE3Ni4wNVwiIHk9XCIzMS44OVwiIHdpZHRoPVwiMTMwLjVcIiBoZWlnaHQ9XCIyMzQuNTFcIiBmaWxsPVwiIzc2NzNjMFwiLz4gPHBhdGggaWQ9XCJfUGF0aF9cIiBkYXRhLW5hbWU9XCImbHQ7UGF0aCZndDtcIiBkPVwiTTMxNy4yNCwxOTcuNjRhMTQ4Ljg4LDE0OC44OCwwLDAsMSw1Ny0xMTcuMjYsMTQ5LjE0LDE0OS4xNCwwLDEsMCwwLDIzNC41MUExNDguODgsMTQ4Ljg4LDAsMCwxLDMxNy4yNCwxOTcuNjRaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0xMzIuOSAtNDguNSlcIiBmaWxsPVwiI2ViMDAxYlwiLz4gPHBhdGggZD1cIk02MTUuNSwxOTcuNjRBMTQ5LjE0LDE0OS4xNCwwLDAsMSwzNzQuMiwzMTQuOWExNDkuMTYsMTQ5LjE2LDAsMCwwLDAtMjM0LjUxQTE0OS4xNCwxNDkuMTQsMCwwLDEsNjE1LjUsMTk3LjY0WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTMyLjkgLTQ4LjUpXCIgZmlsbD1cIiMwMGExZGZcIi8+IDwvZz4gPC9nPjwvc3ZnPmBcbiAgICBsZXQgbWFzdGVyY2FyZF9zaW5nbGUgPSBgPHN2ZyBpZD1cIkxheWVyXzFcIiBkYXRhLW5hbWU9XCJMYXllciAxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNDgyLjUxXCIgaGVpZ2h0PVwiMzc0XCIgdmlld0JveD1cIjAgMCA0ODIuNTEgMzc0XCI+IDx0aXRsZT5tYXN0ZXJjYXJkPC90aXRsZT4gPGc+IDxwYXRoIGQ9XCJNMjIwLjEzLDQyMS42N1YzOTYuODJjMC05LjUzLTUuOC0xNS43NC0xNS4zMi0xNS43NC01LDAtMTAuMzUsMS42Ni0xNC4wOCw3LTIuOS00LjU2LTctNy0xMy4yNS03YTE0LjA3LDE0LjA3LDAsMCwwLTEyLDUuOHYtNWgtNy44N3YzOS43Nmg3Ljg3VjM5OC44OWMwLTcsNC4xNC0xMC4zNSw5Ljk0LTEwLjM1czkuMTEsMy43Myw5LjExLDEwLjM1djIyLjc4aDcuODdWMzk4Ljg5YzAtNyw0LjE0LTEwLjM1LDkuOTQtMTAuMzVzOS4xMSwzLjczLDkuMTEsMTAuMzV2MjIuNzhabTEyOS4yMi0zOS4zNWgtMTQuNXYtMTJIMzI3djEyaC04LjI4djdIMzI3VjQwOGMwLDkuMTEsMy4zMSwxNC41LDEzLjI1LDE0LjVBMjMuMTcsMjMuMTcsMCwwLDAsMzUxLDQxOS42bC0yLjQ5LTdhMTMuNjMsMTMuNjMsMCwwLDEtNy40NiwyLjA3Yy00LjE0LDAtNi4yMS0yLjQ5LTYuMjEtNi42M1YzODloMTQuNXYtNi42M1ptNzMuNzItMS4yNGExMi4zOSwxMi4zOSwwLDAsMC0xMC43Nyw1Ljh2LTVoLTcuODd2MzkuNzZoNy44N1YzOTkuMzFjMC02LjYzLDMuMzEtMTAuNzcsOC43LTEwLjc3YTI0LjI0LDI0LjI0LDAsMCwxLDUuMzguODNsMi40OS03LjQ2YTI4LDI4LDAsMCwwLTUuOC0uODNabS0xMTEuNDEsNC4xNGMtNC4xNC0yLjktOS45NC00LjE0LTE2LjE1LTQuMTQtOS45NCwwLTE2LjE1LDQuNTYtMTYuMTUsMTIuNDMsMCw2LjYzLDQuNTYsMTAuMzUsMTMuMjUsMTEuNmw0LjE0LjQxYzQuNTYuODMsNy40NiwyLjQ5LDcuNDYsNC41NiwwLDIuOS0zLjMxLDUtOS41Myw1YTIxLjg0LDIxLjg0LDAsMCwxLTEzLjI1LTQuMTRsLTQuMTQsNi4yMWM1LjgsNC4xNCwxMi44NCw1LDE3LDUsMTEuNiwwLDE3LjgxLTUuMzgsMTcuODEtMTIuODQsMC03LTUtMTAuMzUtMTMuNjctMTEuNmwtNC4xNC0uNDFjLTMuNzMtLjQxLTctMS42Ni03LTQuMTQsMC0yLjksMy4zMS01LDcuODctNSw1LDAsOS45NCwyLjA3LDEyLjQzLDMuMzFabTEyMC4xMSwxNi41N2MwLDEyLDcuODcsMjAuNzEsMjAuNzEsMjAuNzEsNS44LDAsOS45NC0xLjI0LDE0LjA4LTQuNTZsLTQuMTQtNi4yMWExNi43NCwxNi43NCwwLDAsMS0xMC4zNSwzLjczYy03LDAtMTIuNDMtNS4zOC0xMi40My0xMy4yNVM0NDUsMzg5LDQ1Mi4wNywzODlhMTYuNzQsMTYuNzQsMCwwLDEsMTAuMzUsMy43M2w0LjE0LTYuMjFjLTQuMTQtMy4zMS04LjI4LTQuNTYtMTQuMDgtNC41Ni0xMi40My0uODMtMjAuNzEsNy44Ny0yMC43MSwxOS44OGgwWm0tNTUuNS0yMC43MWMtMTEuNiwwLTE5LjQ3LDguMjgtMTkuNDcsMjAuNzFzOC4yOCwyMC43MSwyMC4yOSwyMC43MWEyNS4zMywyNS4zMywwLDAsMCwxNi4xNS01LjM4bC00LjE0LTUuOGExOS43OSwxOS43OSwwLDAsMS0xMS42LDQuMTRjLTUuMzgsMC0xMS4xOC0zLjMxLTEyLTEwLjM1aDI5LjQxdi0zLjMxYzAtMTIuNDMtNy40Ni0yMC43MS0xOC42NC0yMC43MWgwWm0tLjQxLDcuNDZjNS44LDAsOS45NCwzLjczLDEwLjM1LDkuOTRIMzY0LjY4YzEuMjQtNS44LDUtOS45NCwxMS4xOC05Ljk0Wk0yNjguNTksNDAxLjc5VjM4MS45MWgtNy44N3Y1Yy0yLjktMy43My03LTUuOC0xMi44NC01LjgtMTEuMTgsMC0xOS40Nyw4LjctMTkuNDcsMjAuNzFzOC4yOCwyMC43MSwxOS40NywyMC43MWM1LjgsMCw5Ljk0LTIuMDcsMTIuODQtNS44djVoNy44N1Y0MDEuNzlabS0zMS44OSwwYzAtNy40Niw0LjU2LTEzLjI1LDEyLjQzLTEzLjI1LDcuNDYsMCwxMiw1LjgsMTIsMTMuMjUsMCw3Ljg3LTUsMTMuMjUtMTIsMTMuMjUtNy44Ny40MS0xMi40My01LjgtMTIuNDMtMTMuMjVabTMwNi4wOC0yMC43MWExMi4zOSwxMi4zOSwwLDAsMC0xMC43Nyw1Ljh2LTVoLTcuODd2MzkuNzZINTMyVjM5OS4zMWMwLTYuNjMsMy4zMS0xMC43Nyw4LjctMTAuNzdhMjQuMjQsMjQuMjQsMCwwLDEsNS4zOC44M2wyLjQ5LTcuNDZhMjgsMjgsMCwwLDAtNS44LS44M1ptLTMwLjY1LDIwLjcxVjM4MS45MWgtNy44N3Y1Yy0yLjktMy43My03LTUuOC0xMi44NC01LjgtMTEuMTgsMC0xOS40Nyw4LjctMTkuNDcsMjAuNzFzOC4yOCwyMC43MSwxOS40NywyMC43MWM1LjgsMCw5Ljk0LTIuMDcsMTIuODQtNS44djVoNy44N1Y0MDEuNzlabS0zMS44OSwwYzAtNy40Niw0LjU2LTEzLjI1LDEyLjQzLTEzLjI1LDcuNDYsMCwxMiw1LjgsMTIsMTMuMjUsMCw3Ljg3LTUsMTMuMjUtMTIsMTMuMjUtNy44Ny40MS0xMi40My01LjgtMTIuNDMtMTMuMjVabTExMS44MywwVjM2Ni4xN2gtNy44N3YyMC43MWMtMi45LTMuNzMtNy01LjgtMTIuODQtNS44LTExLjE4LDAtMTkuNDcsOC43LTE5LjQ3LDIwLjcxczguMjgsMjAuNzEsMTkuNDcsMjAuNzFjNS44LDAsOS45NC0yLjA3LDEyLjg0LTUuOHY1aDcuODdWNDAxLjc5Wm0tMzEuODksMGMwLTcuNDYsNC41Ni0xMy4yNSwxMi40My0xMy4yNSw3LjQ2LDAsMTIsNS44LDEyLDEzLjI1LDAsNy44Ny01LDEzLjI1LTEyLDEzLjI1QzU2NC43Myw0MTUuNDYsNTYwLjE3LDQwOS4yNSw1NjAuMTcsNDAxLjc5WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTMyLjc0IC00OC41KVwiLz4gPGc+IDxyZWN0IHg9XCIxNjkuODFcIiB5PVwiMzEuODlcIiB3aWR0aD1cIjE0My43MlwiIGhlaWdodD1cIjIzNC40MlwiIGZpbGw9XCIjZmY1ZjAwXCIvPiA8cGF0aCBkPVwiTTMxNy4wNSwxOTcuNkExNDkuNSwxNDkuNSwwLDAsMSwzNzMuNzksODAuMzlhMTQ5LjEsMTQ5LjEsMCwxLDAsMCwyMzQuNDJBMTQ5LjUsMTQ5LjUsMCwwLDEsMzE3LjA1LDE5Ny42WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTMyLjc0IC00OC41KVwiIGZpbGw9XCIjZWIwMDFiXCIvPiA8cGF0aCBkPVwiTTYxNS4yNiwxOTcuNmExNDguOTUsMTQ4Ljk1LDAsMCwxLTI0MSwxMTcuMjEsMTQ5LjQzLDE0OS40MywwLDAsMCwwLTIzNC40MiwxNDguOTUsMTQ4Ljk1LDAsMCwxLDI0MSwxMTcuMjFaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0xMzIuNzQgLTQ4LjUpXCIgZmlsbD1cIiNmNzllMWJcIi8+IDwvZz4gPC9nPjwvc3ZnPmBcbiAgICBsZXQgdW5pb25wYXlfc2luZ2xlID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNzUwXCIgaGVpZ2h0PVwiNDcxXCIgdmlld0JveD1cIjAgMCA3NTAgNDcxXCI+IDxnIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPiA8cmVjdCB3aWR0aD1cIjc1MFwiIGhlaWdodD1cIjQ3MVwiIHJ4PVwiNDBcIi8+IDxwYXRoIGZpbGw9XCIjRDEwNDI5XCIgZD1cIk0yMDEuODA5NTgxLDU1IEwzNDQuMjAzMjY2LDU1IEMzNjQuMDcyMTUyLDU1IDM3Ni40OTAyMDYsNzEuNDA2Mzg2MSAzNzEuODMzNDM2LDkxLjQ3MDI0NjcgTDMwNS41MDAzMzEsMzc4Ljk0Nzc1IEMzMDAuODQzNTYxLDM5OS4wMTE2MTEgMjgwLjg3MTE5MSw0MTUuNDE3OTk3IDI2MS4wMDIzMDUsNDE1LjQxNzk5NyBMMTE4LjYwODYyLDQxNS40MTc5OTcgQzk4LjczOTczMzksNDE1LjQxNzk5NyA4Ni4zMjE2OCwzOTkuMDExNjExIDkwLjk3ODQ1MDIsMzc4Ljk0Nzc1IEwxNTcuMzExNTU1LDkxLjQ3MDI0NjcgQzE2MS45NjgzMjUsNzEuMzAxODg2OCAxODEuODM3MjExLDU1IDIwMS43MDYwOTcsNTUgTDIwMS44MDk1ODEsNTUgWlwiLz4gPHBhdGggZmlsbD1cIiMwMjJFNjRcIiBkPVwiTTMzMS43NTAwNzQsNTUgTDQ5NS41NjQ5MDIsNTUgQzUxNS40MzM3ODgsNTUgNTA2LjQzMDY5OSw3MS40MDYzODYxIDUwMS43NzM5MjksOTEuNDcwMjQ2NyBMNDM1LjQ0MDgyNCwzNzguOTQ3NzUgQzQzMC43ODQwNTQsMzk5LjAxMTYxMSA0MzIuMjMyODI3LDQxNS40MTc5OTcgNDEyLjM2Mzk0MSw0MTUuNDE3OTk3IEwyNDguNTQ5MTEzLDQxNS40MTc5OTcgQzIyOC41NzY3NDMsNDE1LjQxNzk5NyAyMTYuMjYyMTczLDM5OS4wMTE2MTEgMjIxLjAyMjQyNywzNzguOTQ3NzUgTDI4Ny4zNTU1MzEsOTEuNDcwMjQ2NyBDMjkyLjAxMjMwMiw3MS4zMDE4ODY4IDMxMS44ODExODgsNTUgMzMxLjg1MzU1OCw1NSBMMzMxLjc1MDA3NCw1NSBaXCIvPiA8cGF0aCBmaWxsPVwiIzA3NkY3NFwiIGQ9XCJNNDg5LjgxNDk4MSw1NSBMNjMyLjIwODY2Niw1NSBDNjUyLjA3NzU1Miw1NSA2NjQuNDk1NjA2LDcxLjQwNjM4NjEgNjU5LjgzODgzNiw5MS40NzAyNDY3IEw1OTMuNTA1NzMxLDM3OC45NDc3NSBDNTg4Ljg0ODk2MSwzOTkuMDExNjExIDU2OC44NzY1OTEsNDE1LjQxNzk5NyA1NDkuMDA3NzA1LDQxNS40MTc5OTcgTDQwNi42MTQwMiw0MTUuNDE3OTk3IEMzODYuNjQxNjUsNDE1LjQxNzk5NyAzNzQuMzI3MDgsMzk5LjAxMTYxMSAzNzguOTgzODUsMzc4Ljk0Nzc1IEw0NDUuMzE2OTU1LDkxLjQ3MDI0NjcgQzQ0OS45NzM3MjUsNzEuMzAxODg2OCA0NjkuODQyNjExLDU1IDQ4OS43MTE0OTgsNTUgTDQ4OS44MTQ5ODEsNTUgWlwiLz4gPHBhdGggZmlsbD1cIiNGRUZFRkVcIiBkPVwiTTQ2NS45MDQ3NTQsMzI2LjAxNDUxNCBMNDc5LjM1NzY0NSwzMjYuMDE0NTE0IEw0ODMuMTg2NTQ1LDMxMi45NTIxMDQgTDQ2OS44MzcxMzcsMzEyLjk1MjEwNCBMNDY1LjkwNDc1NCwzMjYuMDE0NTE0IEw0NjUuOTA0NzU0LDMyNi4wMTQ1MTQgWiBNNDc2LjY2NzA2NywyOTAuMDY2NzYzIEw0NzYuNjY3MDY3LDI5MC4wNjY3NjMgTDQ3Mi4wMTAyOTcsMzA1LjUzMjY1NiBDNDcyLjAxMDI5NywzMDUuNTMyNjU2IDQ3Ny4wODEwMDIsMzAyLjkyMDE3NCA0NzkuODc1MDY0LDMwMi4wODQxOCBDNDgyLjY2OTEyNiwzMDEuNDU3MTg0IDQ4Ni44MDg0NzgsMzAwLjkzNDY4OCA0ODYuODA4NDc4LDMwMC45MzQ2ODggTDQ5MC4wMTY0NzUsMjkwLjE3MTI2MyBMNDc2LjU2MzU4MywyOTAuMTcxMjYzIEw0NzYuNjY3MDY3LDI5MC4wNjY3NjMgWiBNNDgzLjM5MzUxMywyNjcuOTEyOTE3IEw0ODMuMzkzNTEzLDI2Ny45MTI5MTcgTDQ3OC45NDM3MSwyODIuNzUxODE0IEM0NzguOTQzNzEsMjgyLjc1MTgxNCA0ODMuOTEwOTMyLDI4MC40NTI4MyA0ODYuNzA0OTk0LDI3OS43MjEzMzUgQzQ4OS40OTkwNTYsMjc4Ljk4OTg0IDQ5My42Mzg0MDcsMjc4Ljc4MDg0MiA0OTMuNjM4NDA3LDI3OC43ODA4NDIgTDQ5Ni44NDY0MDUsMjY4LjAxNzQxNyBMNDgzLjQ5Njk5NywyNjguMDE3NDE3IEw0ODMuMzkzNTEzLDI2Ny45MTI5MTcgWiBNNTEzLjA5MzM1OSwyNjcuOTEyOTE3IEw1MTMuMDkzMzU5LDI2Ny45MTI5MTcgTDQ5NS43MDgwODMsMzI1LjkxMDAxNSBMNTAwLjM2NDg1MywzMjUuOTEwMDE1IEw0OTYuNzQyOTIxLDMzNy45Mjc0MzEgTDQ5Mi4wODYxNTEsMzM3LjkyNzQzMSBMNDkwLjk0NzgyOSwzNDEuNTg0OTA2IEw0NzQuMzkwNDI0LDM0MS41ODQ5MDYgTDQ3NS41Mjg3NDUsMzM3LjkyNzQzMSBMNDQyLDMzNy45Mjc0MzEgTDQ0NS4zMTE0ODEsMzI2Ljg1MDUwOCBMNDQ4LjcyNjQ0NiwzMjYuODUwNTA4IEw0NjYuMzE4Njg5LDI2Ny45MTI5MTcgTDQ2OS44MzcxMzcsMjU2IEw0ODYuNzA0OTk0LDI1NiBMNDg0Ljk0NTc3LDI2MS45NTY0NTkgQzQ4NC45NDU3NywyNjEuOTU2NDU5IDQ4OS4zOTU1NzIsMjU4LjcxNjk4MSA0OTMuNzQxODkxLDI1Ny41Njc0ODkgQzQ5Ny45ODQ3MjYsMjU2LjQxNzk5NyA1MjIuNDA2ODk5LDI1NiA1MjIuNDA2ODk5LDI1NiBMNTE4Ljc4NDk2NywyNjcuODA4NDE4IEw1MTIuOTg5ODc1LDI2Ny44MDg0MTggTDUxMy4wOTMzNTksMjY3LjkxMjkxNyBaXCIvPiA8cGF0aCBmaWxsPVwiI0ZFRkVGRVwiIGQ9XCJNNTIwIDI1Nkw1MzguMDA2MTc4IDI1NiA1MzguMjEzMTQ2IDI2Mi43OTI0NTNDNTM4LjEwOTY2MiAyNjMuOTQxOTQ1IDUzOS4wNDEwMTYgMjY0LjQ2NDQ0MSA1NDEuMjE0MTc1IDI2NC40NjQ0NDFMNTQ0LjgzNjEwOCAyNjQuNDY0NDQxIDU0MS41MjQ2MjcgMjc1LjY0NTg2NCA1MzEuNzk3MTUxIDI3NS42NDU4NjRDNTIzLjQxNDk2NSAyNzYuMjcyODU5IDUyMC4yMDY5NjggMjcyLjYxNTM4NSA1MjAuNDEzOTM1IDI2OC41Mzk5MTNMNTIwLjEwMzQ4NCAyNTYuMTA0NDk5IDUyMCAyNTZ6TTUyMi4yMTYyMzUgMzA5LjIwMDI5TDUwNS4wMzc5MjcgMzA5LjIwMDI5IDUwNy45MzU0NzMgMjk5LjI3Mjg1OSA1MjcuNTk3MzkxIDI5OS4yNzI4NTkgNTMwLjM5MTQ1NCAyOTAuMTgxNDIyIDUxMS4wMzk5ODYgMjkwLjE4MTQyMiA1MTQuMzUxNDY3IDI3OSA1NjguMTYzMDM0IDI3OSA1NjQuODUxNTUzIDI5MC4xODE0MjIgNTQ2Ljc0MTg5MSAyOTAuMTgxNDIyIDU0My45NDc4MjkgMjk5LjI3Mjg1OSA1NjIuMDU3NDkxIDI5OS4yNzI4NTkgNTU5LjA1NjQ2MSAzMDkuMjAwMjkgNTM5LjQ5ODAyNiAzMDkuMjAwMjkgNTM1Ljk3OTU3OCAzMTMuMzgwMjYxIDU0My45NDc4MjkgMzEzLjM4MDI2MSA1NDUuOTE0MDIxIDMyNS45MjAxNzRDNTQ2LjEyMDk4OSAzMjcuMTc0MTY1IDU0Ni4xMjA5ODkgMzI4LjAxMDE2IDU0Ni41MzQ5MjQgMzI4LjUzMjY1NiA1NDYuOTQ4ODU5IDMyOC45NTA2NTMgNTQ5LjMyODk4NiAzMjkuMTU5NjUyIDU1MC42NzQyNzUgMzI5LjE1OTY1Mkw1NTMuMDU0NDAyIDMyOS4xNTk2NTIgNTQ5LjMyODk4NiAzNDEuMzg2MDY3IDU0My4yMjM0NDMgMzQxLjM4NjA2N0M1NDIuMjkyMDg5IDM0MS4zODYwNjcgNTQwLjg0MzMxNiAzNDEuMjgxNTY3IDUzOC44NzcxMjQgMzQxLjI4MTU2NyA1MzcuMDE0NDE2IDM0MS4wNzI1NjkgNTM1Ljc3MjYxIDM0MC4wMjc1NzYgNTM0LjUzMDgwNSAzMzkuNDAwNTgxIDUzMy4zOTI0ODMgMzM4Ljg3ODA4NCA1MzEuNzM2NzQzIDMzNy41MTk1OTQgNTMxLjMyMjgwOCAzMzUuMTE2MTFMNTI5LjQ2MDEgMzIyLjU3NjE5NyA1MjAuNTYwNDk0IDMzNC45MDcxMTJDNTE3Ljc2NjQzMiAzMzguNzczNTg1IDUxMy45Mzc1MzIgMzQxLjgwNDA2NCA1MDcuNDE4MDU0IDM0MS44MDQwNjRMNDk1IDM0MS44MDQwNjQgNDk4LjMxMTQ4MSAzMzAuOTM2MTM5IDUwMy4wNzE3MzUgMzMwLjkzNjEzOUM1MDQuNDE3MDI0IDMzMC45MzYxMzkgNTA1LjY1ODgzIDMzMC40MTM2NDMgNTA2LjU5MDE4NCAzMjkuODkxMTQ3IDUwNy41MjE1MzggMzI5LjQ3MzE0OSA1MDguMzQ5NDA4IDMyOS4wNTUxNTIgNTA5LjE3NzI3OCAzMjcuNjk2NjYyTDUyMi4yMTYyMzUgMzA5LjIwMDI5IDUyMi4yMTYyMzUgMzA5LjIwMDI5ek0zMzQuMzEzNTQgMjgyTDM3OS43NDI5MjEgMjgyIDM3Ni40MzE0NCAyOTIuOTcyNDI0IDM1OC4zMjE3NzggMjkyLjk3MjQyNCAzNTUuNTI3NzE2IDMwMi4yNzI4NTkgMzc0LjE1NDc5NyAzMDIuMjcyODU5IDM3MC43Mzk4MzIgMzEzLjU1ODc4MSAzNTIuMjE2MjM1IDMxMy41NTg3ODEgMzQ3LjY2Mjk0OCAzMjguNzExMTc2QzM0Ny4xNDU1MjkgMzMwLjM4MzE2NCAzNTIuMTEyNzUxIDMzMC41OTIxNjMgMzUzLjg3MTk3NSAzMzAuNTkyMTYzTDM2My4xODU1MTYgMzI5LjMzODE3MSAzNTkuNDYwMSAzNDEuODc4MDg0IDMzOC41NTYzNzUgMzQxLjg3ODA4NEMzMzYuOTAwNjM1IDM0MS44NzgwODQgMzM1LjY1ODgzIDM0MS42NjkwODYgMzMzLjc5NjEyMiAzNDEuMjUxMDg5IDMzMi4wMzY4OTcgMzQwLjgzMzA5MSAzMzEuMjA5MDI3IDMzOS45OTcwOTcgMzMwLjQ4NDY0IDMzOC44NDc2MDUgMzI5Ljc2MDI1NCAzMzcuNTkzNjE0IDMyOC41MTg0NDkgMzM2LjY1MzEyIDMyOS4zNDYzMTkgMzMzLjkzNjEzOUwzMzUuMzQ4Mzc4IDMxMy44NzIyNzkgMzI1IDMxMy44NzIyNzkgMzI4LjQxNDk2NSAzMDIuMzc3MzU4IDMzOC43NjMzNDMgMzAyLjM3NzM1OCAzNDEuNTU3NDA1IDI5My4wNzY5MjMgMzMxLjIwOTAyNyAyOTMuMDc2OTIzIDMzNC41MjA1MDggMjgyLjEwNDQ5OSAzMzQuMzEzNTQgMjgyek0zNjUuNzAwODc1IDI2Mi4xNjU0NTdMMzg0LjMyNzk1NiAyNjIuMTY1NDU3IDM4MC45MTI5OTEgMjczLjU1NTg3OCAzNTUuNDU1OTgxIDI3My41NTU4NzggMzUyLjY2MTkxOSAyNzUuOTU5MzYxQzM1MS40MjAxMTMgMjc3LjEwODg1MyAzNTEuMTA5NjYyIDI3Ni42OTA4NTYgMzQ5LjU1NzQwNSAyNzcuNTI2ODUxIDM0OC4xMDg2MzIgMjc4LjI1ODM0NSAzNDUuMTA3NjAzIDI3OS43MjEzMzUgMzQxLjE3NTIxOSAyNzkuNzIxMzM1TDMzMyAyNzkuNzIxMzM1IDMzNi4zMTE0ODEgMjY4Ljc0ODkxMSAzMzguNzk1MDkyIDI2OC43NDg5MTFDMzQwLjg2NDc2NyAyNjguNzQ4OTExIDM0Mi4zMTM1NCAyNjguNTM5OTEzIDM0My4wMzc5MjcgMjY4LjEyMTkxNiAzNDMuODY1Nzk3IDI2Ny41OTk0MTkgMzQ0Ljc5NzE1MSAyNjYuNDQ5OTI3IDM0NS43Mjg1MDUgMjY0LjU2ODk0TDM1MC4zODUyNzUgMjU2IDM2OC45MDg4NzIgMjU2IDM2NS43MDA4NzUgMjYyLjI2OTk1NiAzNjUuNzAwODc1IDI2Mi4xNjU0NTd6TTQwMC44MDg3MjYgMjgwLjk3NTMyN0M0MDAuODA4NzI2IDI4MC45NzUzMjcgNDA1Ljg3OTQzMSAyNzYuMjcyODU5IDQxNC41NzIwNjkgMjc0LjgwOTg2OSA0MTYuNTM4MjYxIDI3NC4zOTE4NzIgNDI4Ljk1NjMxNCAyNzQuNjAwODcxIDQyOC45NTYzMTQgMjc0LjYwMDg3MUw0MzAuODE5MDIzIDI2OC4zMzA5MTQgNDA0LjYzNzYyNiAyNjguMzMwOTE0IDQwMC44MDg3MjYgMjgxLjA3OTgyNiA0MDAuODA4NzI2IDI4MC45NzUzMjd6TTQyNS40Mzc4NjYgMjg1Ljc4MjI5M0w0MjUuNDM3ODY2IDI4NS43ODIyOTMgMzk5LjQ2MzQzNiAyODUuNzgyMjkzIDM5Ny45MTExOCAyOTEuMTExNzU2IDQyMC40NzA2NDQgMjkxLjExMTc1NkM0MjMuMTYxMjIzIDI5MC43OTgyNTggNDIzLjY3ODY0MiAyOTEuMjE2MjU1IDQyMy44ODU2MDkgMjkxLjAwNzI1N0w0MjUuNTQxMzUgMjg1Ljc4MjI5MyA0MjUuNDM3ODY2IDI4NS43ODIyOTN6TTM5MS43MDIxNTMgMjU2LjEwNDQ5OUwzOTEuNzAyMTUzIDI1Ni4xMDQ0OTkgNDA3LjUzNTE3MSAyNTYuMTA0NDk5IDQwNS4yNTg1MjggMjY0LjE1MDk0M0M0MDUuMjU4NTI4IDI2NC4xNTA5NDMgNDEwLjIyNTc1IDI2MC4wNzU0NzIgNDEzLjc0NDE5OCAyNTguNjEyNDgyIDQxNy4yNjI2NDcgMjU3LjM1ODQ5MSA0MjUuMTI3NDE0IDI1Ni4xMDQ0OTkgNDI1LjEyNzQxNCAyNTYuMTA0NDk5TDQ1MC43OTEzOTMgMjU2IDQ0MS45OTUyNzEgMjg1LjQ2ODc5NUM0NDAuNTQ2NDk4IDI5MC40ODQ3NjEgNDM4Ljc4NzI3NCAyOTMuNzI0MjM4IDQzNy43NTI0MzYgMjk1LjI5MTcyNyA0MzYuODIxMDgyIDI5Ni43NTQ3MTcgNDM1LjY4Mjc2IDI5OC4xMTMyMDggNDMzLjQwNjExNyAyOTkuMzY3MTk5IDQzMS4yMzI5NTggMzAwLjUxNjY5MSA0MjkuMjY2NzY2IDMwMS4yNDgxODYgNDI3LjQwNDA1OCAzMDEuMzUyNjg1IDQyNS43NDgzMTcgMzAxLjQ1NzE4NCA0MjMuMDU3NzM5IDMwMS41NjE2ODQgNDE5LjUzOTI5IDMwMS41NjE2ODRMMzk0LjgwNjY2NiAzMDEuNTYxNjg0IDM4Ny44NzMyNTMgMzI0Ljg2NTAyMkMzODcuMjUyMzUgMzI3LjE2NDAwNiAzODYuOTQxODk5IDMyOC4zMTM0OTggMzg3LjM1NTgzNCAzMjguOTQwNDkzIDM4Ny42NjYyODUgMzI5LjQ2Mjk5IDM4OC41OTc2MzkgMzMwLjA4OTk4NSAzODkuNzM1OTYxIDMzMC4wODk5ODVMNDAwLjYwMTc1OCAzMjkuMDQ0OTkzIDM5Ni44NzYzNDIgMzQxLjc5MzkwNCAzODQuNjY1MjU2IDM0MS43OTM5MDRDMzgwLjczMjg3MiAzNDEuNzkzOTA0IDM3Ny45Mzg4MSAzNDEuNjg5NDA1IDM3NS45NzI2MTggMzQxLjU4NDkwNiAzNzQuMTA5OTEgMzQxLjM3NTkwNyAzNzIuMTQzNzE4IDM0MS41ODQ5MDYgMzcwLjc5ODQyOSAzNDAuNTM5OTEzIDM2OS42NjAxMDcgMzM5LjQ5NDkyIDM2Ny45MDA4ODMgMzM4LjEzNjQzIDM2OC4wMDQzNjcgMzM2Ljc3NzkzOSAzNjguMTA3ODUgMzM1LjUyMzk0OCAzNjguNjI1MjY5IDMzMy40MzM5NjIgMzY5LjQ1MzE0IDMzMC41MDc5ODNMMzkxLjcwMjE1MyAyNTYuMTA0NDk5IDM5MS43MDIxNTMgMjU2LjEwNDQ5OXpcIi8+IDxwYXRoIGZpbGw9XCIjRkVGRUZFXCIgZD1cIk00MzcuODQwMjI3IDMwM0w0MzYuMzkxNDU0IDMxMC4xMDU5NTFDNDM1Ljc3MDU1MSAzMTIuMzAwNDM1IDQzNS4yNTMxMzIgMzEzLjk3MjQyNCA0MzMuNTk3MzkxIDMxNS40MzU0MTQgNDMxLjgzODE2NyAzMTYuODk4NDAzIDQyOS44NzE5NzUgMzE4LjQ2NTg5MyA0MjUuMTExNzIxIDMxOC40NjU4OTNMNDE2LjMxNTYgMzE4Ljg4Mzg5IDQxNi4yMTIxMTYgMzI2LjgyNTgzNUM0MTYuMTA4NjMyIDMyOS4wMjAzMTkgNDE2LjcyOTUzNSAzMjguODExMzIxIDQxNy4wMzk5ODYgMzI5LjIyOTMxOCA0MTcuNDUzOTIxIDMyOS42NDczMTUgNDE3Ljc2NDM3MyAzMjkuNzUxODE0IDQxOC4xNzgzMDggMzI5Ljk2MDgxM0w0MjAuOTcyMzcgMzI5Ljc1MTgxNCA0MjkuMzU0NTU2IDMyOS4zMzM4MTcgNDI1LjgzNjEwOCAzNDEuMDM3NzM2IDQxNi4yMTIxMTYgMzQxLjAzNzczNkM0MDkuNDg1NjcgMzQxLjAzNzczNiA0MDQuNDE0OTY1IDM0MC44Mjg3MzcgNDAyLjg2MjcwOCAzMzkuNTc0NzQ2IDQwMS4yMDY5NjggMzM4LjUyOTc1MyA0MDEgMzM3LjI3NTc2MiA0MDEgMzM0Ljk3Njc3OEw0MDEuNjIwOTAzIDMwMy44MzU5OTQgNDE3LjAzOTk4NiAzMDMuODM1OTk0IDQxNi44MzMwMTkgMzEwLjIxMDQ1IDQyMC41NTg0MzUgMzEwLjIxMDQ1QzQyMS44MDAyNCAzMTAuMjEwNDUgNDIyLjczMTU5NCAzMTAuMTA1OTUxIDQyMy4yNDkwMTMgMzA5Ljc5MjQ1MyA0MjMuNzY2NDMyIDMwOS40Nzg5NTUgNDI0LjA3Njg4MyAzMDguOTU2NDU5IDQyNC4yODM4NTEgMzA4LjIyNDk2NEw0MjUuODM2MTA4IDMwMy4yMDg5OTkgNDM3Ljk0MzcxIDMwMy4yMDg5OTkgNDM3Ljg0MDIyNyAzMDN6TTIxOC40NzAzOTYgMTQ3QzIxNy45NTI5NzggMTQ5LjUwNzk4MyAyMDguMDE4NTM0IDE5NS41OTIxNjMgMjA4LjAxODUzNCAxOTUuNTkyMTYzIDIwNS44NDUzNzUgMjA0Ljg5MjU5OCAyMDQuMjkzMTE4IDIxMS41ODA1NTIgMTk5LjExODkyOSAyMTUuODY1MDIyIDE5Ni4xMTc4OTkgMjE4LjM3MzAwNCAxOTIuNTk5NDUxIDIxOS41MjI0OTYgMTg4LjU2MzU4MyAyMTkuNTIyNDk2IDE4Mi4wNDQxMDUgMjE5LjUyMjQ5NiAxNzguMzE4Njg5IDIxNi4yODMwMTkgMTc3LjY5Nzc4NiAyMTAuMTE3NTYyTDE3Ny41OTQzMDIgMjA4LjAyNzU3NkMxNzcuNTk0MzAyIDIwOC4wMjc1NzYgMTc5LjU2MDQ5NCAxOTUuNTkyMTYzIDE3OS41NjA0OTQgMTk1LjQ4NzY2MyAxNzkuNTYwNDk0IDE5NS40ODc2NjMgMTg5LjkwODg3MiAxNTMuNDc4OTU1IDE5MS43NzE1ODEgMTQ3Ljk0MDQ5MyAxOTEuODc1MDY0IDE0Ny42MjY5OTYgMTkxLjg3NTA2NCAxNDcuNDE3OTk3IDE5MS44NzUwNjQgMTQ3LjMxMzQ5OCAxNzEuNjk1NzI3IDE0Ny41MjI0OTYgMTY4LjA3Mzc5NCAxNDcuMzEzNDk4IDE2Ny44NjY4MjcgMTQ3IDE2Ny43NjMzNDMgMTQ3LjQxNzk5NyAxNjcuMjQ1OTI0IDE1MC4wMzA0NzkgMTY3LjI0NTkyNCAxNTAuMDMwNDc5TDE1Ni42OTA1NzggMTk3LjM2ODY1IDE1NS43NTkyMjQgMjAxLjMzOTYyMyAxNTQgMjE0LjUwNjUzMUMxNTQgMjE4LjM3MzAwNCAxNTQuNzI0Mzg2IDIyMS42MTI0ODIgMTU2LjI3NjY0MyAyMjQuMjI0OTY0IDE2MS4xNDAzODEgMjMyLjc5MzkwNCAxNzQuOTAzNzI0IDIzNC4wNDc4OTYgMTgyLjY2NTAwOCAyMzQuMDQ3ODk2IDE5Mi43MDI5MzUgMjM0LjA0Nzg5NiAyMDIuMTE5OTU5IDIzMS44NTM0MTEgMjA4LjQzMjQ3IDIyNy45ODY5MzggMjE5LjUwNTIzNCAyMjEuNDAzNDgzIDIyMi40MDI3OCAyMTEuMDU4MDU1IDIyNC44ODYzOTEgMjAxLjk2NjYxOEwyMjYuMTI4MTk2IDE5Ny4yNjQxNTFDMjI2LjEyODE5NiAxOTcuMjY0MTUxIDIzNi43ODcwMjYgMTUzLjY4Nzk1NCAyMzguNjQ5NzM0IDE0OC4wNDQ5OTMgMjM4Ljc1MzIxOCAxNDcuNzMxNDk1IDIzOC43NTMyMTggMTQ3LjUyMjQ5NiAyMzguODU2NzAyIDE0Ny40MTc5OTcgMjI0LjE2MjAwNCAxNDcuNTIyNDk2IDIxOS45MTkxNjkgMTQ3LjQxNzk5NyAyMTguNDcwMzk2IDE0Ny4xMDQ0OTlMMjE4LjQ3MDM5NiAxNDd6TTI3Ny40OTkwNTYgMjMzLjYyMjY0MkMyNzAuMzU4Njc1IDIzMy41MTgxNDIgMjY3Ljc3MTU4MSAyMzMuNTE4MTQyIDI1OS4zODkzOTQgMjMzLjkzNjEzOUwyNTkuMDc4OTQzIDIzMy4zMDkxNDRDMjU5LjgwMzMyOSAyMzAuMDY5NjY2IDI2MC42MzEyIDIyNi45MzQ2ODggMjYxLjI1MjEwMiAyMjMuNjk1MjFMMjYyLjI4Njk0IDIxOS4zMDYyNDFDMjYzLjgzOTE5NyAyMTIuNTEzNzg4IDI2NS4yODc5NyAyMDQuNDY3MzQ0IDI2NS40OTQ5MzcgMjAyLjA2Mzg2MSAyNjUuNzAxOTA1IDIwMC42MDA4NzEgMjY2LjExNTg0IDE5Ni45NDMzOTYgMjYxLjk3NjQ4OSAxOTYuOTQzMzk2IDI2MC4yMTcyNjQgMTk2Ljk0MzM5NiAyNTguNDU4MDQgMTk3Ljc3OTM5IDI1Ni41OTUzMzIgMTk4LjYxNTM4NSAyNTUuNTYwNDk0IDIwMi4yNzI4NTkgMjUzLjU5NDMwMiAyMTIuNTEzNzg4IDI1Mi41NTk0NjUgMjE3LjExMTc1NiAyNTAuNDg5Nzg5IDIyNi45MzQ2ODggMjUwLjM4NjMwNSAyMjguMDg0MTggMjQ5LjQ1NDk1MSAyMzIuODkxMTQ3TDI0OC44MzQwNDggMjMzLjUxODE0MkMyNDEuNDg2NyAyMzMuNDEzNjQzIDIzOC44OTk2MDUgMjMzLjQxMzY0MyAyMzAuNDEzOTM1IDIzMy44MzE2NEwyMzAgMjMzLjEwMDE0NUMyMzEuNDQ4NzczIDIyNy4yNDgxODYgMjMyLjc5NDA2MiAyMjEuMzk2MjI2IDIzNC4xMzkzNTEgMjE1LjU0NDI2NyAyMzcuNjU3OCAxOTkuNzY0ODc3IDIzOC41ODkxNTQgMTkzLjcwMzkxOSAyMzkuNTIwNTA4IDE4NS42NTc0NzVMMjQwLjI0NDg5NCAxODUuMjM5NDc4QzI0OC41MjM1OTcgMTg0LjA4OTk4NSAyNTAuNDg5Nzg5IDE4My43NzY0ODggMjU5LjQ5Mjg3OCAxODJMMjYwLjIxNzI2NCAxODIuODM1OTk0IDI1OC44NzE5NzUgMTg3Ljg1MTk1OUMyNjAuNDI0MjMyIDE4Ni45MTE0NjYgMjYxLjg3MzAwNSAxODUuOTcwOTcyIDI2My40MjUyNjIgMTg1LjIzOTQ3OCAyNjcuNjY4MDk3IDE4My4xNDk0OTIgMjcyLjMyNDg2NyAxODIuNTIyNDk2IDI3NC45MTE5NjIgMTgyLjUyMjQ5NiAyNzguODQ0MzQ1IDE4Mi41MjI0OTYgMjgzLjE5MDY2NCAxODMuNjcxOTg4IDI4NC45NDk4ODggMTg4LjI2OTk1NiAyODYuNjA1NjI5IDE5Mi4zNDU0MjggMjg1LjU3MDc5MSAxOTcuMzYxMzkzIDI4My4yOTQxNDggMjA3LjI4ODgyNEwyODIuMTU1ODI2IDIxMi4zMDQ3OUMyNzkuODc5MTgzIDIyMy4zODE3MTMgMjc5LjQ2NTI0OCAyMjUuMzY3MTk5IDI3OC4yMjM0NDMgMjMyLjg5MTE0N0wyNzcuMzk1NTcyIDIzMy41MTgxNDIgMjc3LjQ5OTA1NiAyMzMuNjIyNjQyek0zMDYuNTU4NDM1IDIzMy42NTAyMThDMzAyLjIxMjExNiAyMzMuNjUwMjE4IDI5OS40MTgwNTQgMjMzLjU0NTcxOCAyOTYuNzI3NDc2IDIzMy42NTAyMTggMjk0LjAzNjg5NyAyMzMuNjUwMjE4IDI5MS40NDk4MDMgMjMzLjg1OTIxNiAyODcuNDEzOTM1IDIzMy45NjM3MTZMMjg3LjIwNjk2OCAyMzMuNjUwMjE4IDI4NyAyMzMuMjMyMjIxQzI4OC4xMzgzMjIgMjI5LjA1MjI1IDI4OC42NTU3NDEgMjI3LjU4OTI2IDI4OS4yNzY2NDMgMjI2LjEyNjI3IDI4OS43OTQwNjIgMjI0LjY2MzI4IDI5MC4zMTE0ODEgMjIzLjIwMDI5IDI5MS4zNDYzMTkgMjE4LjkxNTgyIDI5Mi41ODgxMjQgMjEzLjM3NzM1OCAyOTMuNDE1OTk1IDIwOS41MTA4ODUgMjkzLjkzMzQxMyAyMDYuMDYyNDA5IDI5NC41NTQzMTYgMjAyLjgyMjkzMiAyOTQuODY0NzY3IDIwMC4wMDE0NTEgMjk1LjI3ODcwMyAxOTYuNzYxOTc0TDI5NS41ODkxNTQgMTk2LjU1Mjk3NSAyOTUuODk5NjA1IDE5Ni4yMzk0NzhDMzAwLjI0NTkyNCAxOTUuNjEyNDgyIDMwMi45MzY1MDIgMTk1LjE5NDQ4NSAzMDUuNzMwNTY1IDE5NC43NzY0ODggMzA4LjUyNDYyNyAxOTQuMzU4NDkxIDMxMS40MjIxNzMgMTkzLjgzNTk5NCAzMTUuODcxOTc1IDE5M0wzMTYuMDc4OTQzIDE5My40MTc5OTcgMzE2LjE4MjQyNyAxOTMuODM1OTk0QzMxNS4zNTQ1NTYgMTk3LjI4NDQ3IDMxNC41MjY2ODYgMjAwLjczMjk0NiAzMTMuNjk4ODE2IDIwNC4xODE0MjIgMzEyLjg3MDk0NiAyMDcuNjI5ODk4IDMxMi4wNDMwNzUgMjExLjA3ODM3NCAzMTEuMzE4Njg5IDIxNC41MjY4NTEgMzA5Ljc2NjQzMiAyMjEuODQxOCAzMDkuMDQyMDQ2IDIyNC41NTg3ODEgMzA4LjczMTU5NCAyMjYuNTQ0MjY3IDMwOC4zMTc2NTkgMjI4LjQyNTI1NCAzMDguMjE0MTc1IDIyOS4zNjU3NDcgMzA3LjU5MzI3MyAyMzMuMTI3NzIxTDMwNy4xNzkzMzggMjMzLjQ0MTIxOSAzMDYuNzY1NDAyIDIzMy43NTQ3MTcgMzA2LjU1ODQzNSAyMzMuNjUwMjE4ek0zNTIuNDk5MzE5IDIwNy45NzUzMjdDMzUyLjE4ODg2OCAyMDkuODU2MzEzIDM1MC41MzMxMjcgMjE2Ljg1Nzc2NSAzNDguMzU5OTY4IDIxOS43ODM3NDUgMzQ2LjgwNzcxMSAyMjEuOTc4MjI5IDM0NS4wNDg0ODcgMjIzLjMzNjcyIDM0Mi45Nzg4MTEgMjIzLjMzNjcyIDM0Mi4zNTc5MDkgMjIzLjMzNjcyIDMzOC44Mzk0NiAyMjMuMzM2NzIgMzM4LjczNTk3NiAyMTguMDA3MjU3IDMzOC43MzU5NzYgMjE1LjM5NDc3NSAzMzkuMjUzMzk1IDIxMi42Nzc3OTQgMzM5Ljg3NDI5OCAyMDkuNzUxODE0IDM0MS43MzcwMDYgMjAxLjI4NzM3MyAzNDQuMDEzNjQ5IDE5NC4yODU5MjIgMzQ5LjcwNTI1NyAxOTQuMjg1OTIyIDM1NC4xNTUwNiAxOTQuMjg1OTIyIDM1NC40NjU1MTEgMTk5LjUxMDg4NSAzNTIuNDk5MzE5IDIwNy45NzUzMjdMMzUyLjQ5OTMxOSAyMDcuOTc1MzI3ek0zNzEuMjI5ODg0IDIwOC44MTEzMjFMMzcxLjIyOTg4NCAyMDguODExMzIxQzM3My43MTM0OTUgMTk3LjczNDM5OCAzNzEuNzQ3MzAzIDE5Mi41MDk0MzQgMzY5LjM2NzE3NiAxODkuMzc0NDU2IDM2NS42NDE3NiAxODQuNTY3NDg5IDM1OS4wMTg3OTggMTgzIDM1Mi4xODg4NjggMTgzIDM0OC4wNDk1MTcgMTgzIDMzOC4zMjIwNDEgMTgzLjQxNzk5NyAzMzAuNjY0MjQxIDE5MC41MjM5NDggMzI1LjE3OTYwMSAxOTUuNjQ0NDEyIDMyMi41OTI1MDYgMjAyLjY0NTg2NCAzMjEuMTQzNzMzIDIwOS4zMzM4MTcgMzE5LjU5MTQ3NiAyMTYuMTI2MjcgMzE3LjgzMjI1MiAyMjguMzUyNjg1IDMyOS4wMDg1MDEgMjMyLjk1MDY1MyAzMzIuNDIzNDY2IDIzNC40MTM2NDMgMzM3LjM5MDY4NyAyMzQuODMxNjQgMzQwLjU5ODY4NCAyMzQuODMxNjQgMzQ4Ljc3MzkwMyAyMzQuODMxNjQgMzU3LjE1NjA4OSAyMzIuNTMyNjU2IDM2My40Njg2IDIyNS44NDQ3MDIgMzY4LjMzMjMzOCAyMjAuNDEwNzQgMzcwLjUwNTQ5NyAyMTIuMjU5Nzk3IDM3MS4zMzMzNjggMjA4LjgxMTMyMUwzNzEuMjI5ODg0IDIwOC44MTEzMjF6TTU0NS42NjE5MTkgMjM0Ljg5MTE0N0M1MzYuOTY5MjgxIDIzNC43ODY2NDcgNTM0LjQ4NTY3IDIzNC43ODY2NDcgNTI2LjUxNzQxOSAyMzUuMjA0NjQ0TDUyNiAyMzQuNTc3NjQ5QzUyOC4xNzMxNTkgMjI2LjMyMjIwNiA1MzAuMzQ2MzE5IDIxNy45NjIyNjQgNTMyLjMxMjUxMSAyMDkuNjAyMzIyIDUzNC43OTYxMjIgMTk4LjczNDM5OCA1MzUuNDE3MDI0IDE5NC4xMzY0MyA1MzYuMjQ0ODk0IDE4Ny43NjE5NzRMNTM2Ljg2NTc5NyAxODcuMjM5NDc4QzU0NS40NTQ5NTEgMTg1Ljk4NTQ4NiA1NDcuODM1MDc4IDE4NS42NzE5ODggNTU2LjgzODE2NyAxODRMNTU3LjA0NTEzNSAxODQuNzMxNDk1QzU1NS4zODkzOTQgMTkxLjYyODQ0NyA1NTMuODM3MTM3IDE5OC40MjA5IDU1Mi4xODEzOTcgMjA1LjIxMzM1MyA1NDguODY5OTE2IDIxOS41Mjk3NTMgNTQ3LjczMTU5NCAyMjYuODQ0NzAyIDU0Ni40ODk3ODkgMjM0LjM2ODY1TDU0NS42NjE5MTkgMjM0Ljk5NTY0NiA1NDUuNjYxOTE5IDIzNC44OTExNDd6XCIvPiA8cGF0aCBmaWxsPVwiI0ZFRkVGRVwiIGQ9XCJNNTMzLjE1OTkwOSAyMDkuMzczNzc3QzUzMi43NDU5NzQgMjExLjE1MDI2NSA1MzEuMDkwMjMzIDIxOC4yNTYyMTYgNTI4LjkxNzA3NCAyMjEuMTgyMTk1IDUyNy40NjgzMDEgMjIzLjI3MjE4MSA1MjMuOTQ5ODUyIDIyNC42MzA2NzIgNTIxLjk4MzY2MSAyMjQuNjMwNjcyIDUyMS4zNjI3NTggMjI0LjYzMDY3MiA1MTcuOTQ3NzkzIDIyNC42MzA2NzIgNTE3Ljc0MDgyNiAyMTkuNDA1NzA4IDUxNy43NDA4MjYgMjE2Ljc5MzIyNiA1MTguMjU4MjQ0IDIxNC4wNzYyNDUgNTE4Ljg3OTE0NyAyMTEuMTUwMjY1IDUyMC43NDE4NTUgMjAyLjg5NDgyMiA1MjMuMDE4NDk4IDE5NS44OTMzNzEgNTI4LjcxMDEwNiAxOTUuODkzMzcxIDUzMy4xNTk5MDkgMTk1Ljg5MzM3MSA1MzUuMTI2MTAxIDIwMS4wMTM4MzYgNTMzLjE1OTkwOSAyMDkuNDc4Mjc3TDUzMy4xNTk5MDkgMjA5LjM3Mzc3N3pNNTUwLjIzNDczMyAyMTAuMjA5NzcyTDU1MC4yMzQ3MzMgMjEwLjIwOTc3MkM1NTIuNzE4MzQ0IDE5OS4xMzI4NDkgNTQyLjU3NjkzMyAyMDkuMjY5Mjc4IDU0MS4wMjQ2NzcgMjA1LjYxMTgwNCA1MzguNTQxMDY2IDE5OS44NjQzNDQgNTQwLjA5MzMyMiAxODguMzY5NDIzIDUzMC4xNTg4NzkgMTg0LjUwMjk1IDUyNi4zMjk5NzkgMTgyLjkzNTQ2MSA1MTcuMzI2ODkgMTg0LjkyMDk0NyA1MDkuNjY5MDkgMTkyLjAyNjg5OCA1MDQuMjg3OTM0IDE5Ny4wNDI4NjMgNTAxLjU5NzM1NSAyMDQuMDQ0MzE1IDUwMC4xNDg1ODIgMjEwLjczMjI2OCA0OTguNTk2MzI2IDIxNy40MjAyMjIgNDk2LjgzNzEwMSAyMjkuNzUxMTM2IDUwNy45MDk4NjYgMjM0LjAzNTYwNiA1MTEuNDI4MzE1IDIzNS42MDMwOTUgNTE0LjYzNjMxMiAyMzYuMDIxMDkyIDUxNy44NDQzMDkgMjM1LjgxMjA5NCA1MjkuMDIwNTU4IDIzNS4xODUwOTggNTM3LjUwNjIyOCAyMTguMTUxNzE3IDU0My44MTg3MzkgMjExLjQ2Mzc2MyA1NDguNjgyNDc2IDIwNi4xMzQzIDU0OS41MTAzNDcgMjEzLjQ0OTI0OSA1NTAuMjM0NzMzIDIxMC4yMDk3NzJMNTUwLjIzNDczMyAyMTAuMjA5Nzcyek00MjAuMjkyMDg5IDIzMy42MjI2NDJDNDEzLjE1MTcwOCAyMzMuNTE4MTQyIDQxMC42NjgwOTcgMjMzLjUxODE0MiA0MDIuMjg1OTEgMjMzLjkzNjEzOUw0MDEuOTc1NDU5IDIzMy4zMDkxNDRDNDAyLjY5OTg0NiAyMzAuMDY5NjY2IDQwMy41Mjc3MTYgMjI2LjkzNDY4OCA0MDQuMjUyMTAyIDIyMy42OTUyMUw0MDUuMTgzNDU2IDIxOS4zMDYyNDFDNDA2LjczNTcxMyAyMTIuNTEzNzg4IDQwOC4yODc5NyAyMDQuNDY3MzQ0IDQwOC4zOTE0NTQgMjAyLjA2Mzg2MSA0MDguNTk4NDIxIDIwMC42MDA4NzEgNDA5LjAxMjM1NiAxOTYuOTQzMzk2IDQwNC45NzY0ODkgMTk2Ljk0MzM5NiA0MDMuMjE3MjY0IDE5Ni45NDMzOTYgNDAxLjM1NDU1NiAxOTcuNzc5MzkgMzk5LjU5NTMzMiAxOTguNjE1Mzg1IDM5OC42NjM5NzggMjAyLjI3Mjg1OSAzOTYuNTk0MzAyIDIxMi41MTM3ODggMzk1LjU1OTQ2NSAyMTcuMTExNzU2IDM5My41OTMyNzMgMjI2LjkzNDY4OCAzOTMuMzg2MzA1IDIyOC4wODQxOCAzOTIuNDU0OTUxIDIzMi44OTExNDdMMzkxLjgzNDA0OCAyMzMuNTE4MTQyQzM4NC40ODY3IDIzMy40MTM2NDMgMzgxLjg5OTYwNSAyMzMuNDEzNjQzIDM3My40MTM5MzUgMjMzLjgzMTY0TDM3MyAyMzMuMTAwMTQ1QzM3NC40NDg3NzMgMjI3LjI0ODE4NiAzNzUuNzk0MDYyIDIyMS4zOTYyMjYgMzc3LjEzOTM1MSAyMTUuNTQ0MjY3IDM4MC42NTc4IDE5OS43NjQ4NzcgMzgxLjQ4NTY3IDE5My43MDM5MTkgMzgyLjUyMDUwOCAxODUuNjU3NDc1TDM4My4xNDE0MTEgMTg1LjIzOTQ3OEMzOTEuNDIwMTEzIDE4NC4wODk5ODUgMzkzLjQ4OTc4OSAxODMuNzc2NDg4IDQwMi4zODkzOTQgMTgyTDQwMy4xMTM3ODEgMTgyLjgzNTk5NCA0MDEuODcxOTc1IDE4Ny44NTE5NTlDNDAzLjMyMDc0OCAxODYuOTExNDY2IDQwNC44NzMwMDUgMTg1Ljk3MDk3MiA0MDYuMzIxNzc4IDE4NS4yMzk0NzggNDEwLjU2NDYxMyAxODMuMTQ5NDkyIDQxNS4yMjEzODMgMTgyLjUyMjQ5NiA0MTcuODA4NDc4IDE4Mi41MjI0OTYgNDIxLjc0MDg2MiAxODIuNTIyNDk2IDQyNS45ODM2OTcgMTgzLjY3MTk4OCA0MjcuODQ2NDA1IDE4OC4yNjk5NTYgNDI5LjUwMjE0NSAxOTIuMzQ1NDI4IDQyOC4zNjM4MjQgMTk3LjM2MTM5MyA0MjYuMDg3MTggMjA3LjI4ODgyNEw0MjQuOTQ4ODU5IDIxMi4zMDQ3OUM0MjIuNTY4NzMyIDIyMy4zODE3MTMgNDIyLjI1ODI4IDIyNS4zNjcxOTkgNDIxLjAxNjQ3NSAyMzIuODkxMTQ3TDQyMC4xODg2MDUgMjMzLjUxODE0MiA0MjAuMjkyMDg5IDIzMy42MjI2NDJ6TTQ4Mi4yOTMxMTggMTQ3LjEwNDQ5OUw0NzYuMjkxMDU5IDE0Ny4yMDg5OTlDNDYwLjc2ODQ5MiAxNDcuNDE3OTk3IDQ1NC41NTk0NjUgMTQ3LjMxMzQ5OCA0NTIuMDc1ODU0IDE0NyA0NTEuODY4ODg2IDE0OC4xNDk0OTIgNDUxLjQ1NDk1MSAxNTAuMTM0OTc4IDQ1MS40NTQ5NTEgMTUwLjEzNDk3OCA0NTEuNDU0OTUxIDE1MC4xMzQ5NzggNDQ1Ljg2NjgyNyAxNzYuMDUwNzk4IDQ0NS44NjY4MjcgMTc2LjE1NTI5OCA0NDUuODY2ODI3IDE3Ni4xNTUyOTggNDMyLjYyMDkwMyAyMzEuMzMwOTE0IDQzMiAyMzMuOTQzMzk2IDQ0NS41NTYzNzUgMjMzLjczNDM5OCA0NTEuMDQxMDE2IDIzMy43MzQzOTggNDUzLjQyMTE0MyAyMzQuMDQ3ODk2IDQ1My45Mzg1NjIgMjMxLjQzNTQxNCA0NTcuMDQzMDc1IDIxNi4wNzQwMiA0NTcuMTQ2NTU5IDIxNi4wNzQwMiA0NTcuMTQ2NTU5IDIxNi4wNzQwMiA0NTkuODM3MTM3IDIwNC43ODgwOTkgNDU5Ljk0MDYyMSAyMDQuMzcwMTAyIDQ1OS45NDA2MjEgMjA0LjM3MDEwMiA0NjAuNzY4NDkyIDIwMy4yMjA2MSA0NjEuNTk2MzYyIDIwMi42OTgxMTNMNDYyLjgzODE2NyAyMDIuNjk4MTEzQzQ3NC41MzE4MzUgMjAyLjY5ODExMyA0ODcuNjc0Mjc1IDIwMi42OTgxMTMgNDk4LjAyMjY1MyAxOTUuMDY5NjY2IDUwNS4wNTk1NSAxODkuODQ0NzAyIDUwOS44MTk4MDQgMTgyLjAwNzI1NyA1MTEuOTkyOTY0IDE3Mi42MDIzMjIgNTEyLjUxMDM4MyAxNzAuMzAzMzM4IDUxMi45MjQzMTggMTY3LjU4NjM1NyA1MTIuOTI0MzE4IDE2NC43NjQ4NzcgNTEyLjkyNDMxOCAxNjEuMTA3NDAyIDUxMi4xOTk5MzEgMTU3LjU1NDQyNyA1MTAuMTMwMjU2IDE1NC43MzI5NDYgNTA0Ljg1MjU4MyAxNDcuMzEzNDk4IDQ5NC40MDA3MjEgMTQ3LjIwODk5OSA0ODIuMjkzMTE4IDE0Ny4xMDQ0OTlMNDgyLjI5MzExOCAxNDcuMTA0NDk5ek00OTAuMDU0NDAyIDE3NC4xNjk4MTFMNDkwLjA1NDQwMiAxNzQuMTY5ODExQzQ4OC44MTI1OTcgMTc5LjkxNzI3MSA0ODUuMDg3MTggMTg0LjgyODczNyA0ODAuMzI2OTI2IDE4Ny4xMjc3MjEgNDc2LjM5NDU0MyAxODkuMTEzMjA4IDQ3MS42MzQyODkgMTg5LjMyMjIwNiA0NjYuNjY3MDY3IDE4OS4zMjIyMDZMNDYzLjQ1OTA3IDE4OS4zMjIyMDYgNDYzLjY2NjAzNyAxODguMDY4MjE1QzQ2My42NjYwMzcgMTg4LjA2ODIxNSA0NjkuNTY0NjEzIDE2Mi4xNTIzOTUgNDY5LjU2NDYxMyAxNjIuMjU2ODk0TDQ2OS43NzE1ODEgMTYwLjg5ODQwMyA0NjkuODc1MDY0IDE1OS44NTM0MTEgNDcyLjI1NTE5MSAxNjAuMDYyNDA5QzQ3Mi4yNTUxOTEgMTYwLjA2MjQwOSA0ODQuNDY2Mjc4IDE2MS4xMDc0MDIgNDg0LjY3MzI0NSAxNjEuMTA3NDAyIDQ4OS40MzM0OTkgMTYyLjk4ODM4OSA0OTEuNTAzMTc1IDE2Ny43OTUzNTYgNDkwLjA1NDQwMiAxNzQuMTY5ODExTDQ5MC4wNTQ0MDIgMTc0LjE2OTgxMXpNNjE3LjI2MTM2OSAxODIuODM1OTk0TDYxNi41MzY5ODMgMTgyQzYwNy43NDA4NjIgMTgzLjc3NjQ4OCA2MDYuMDg1MTIxIDE4NC4wODk5ODUgNTk4LjAxMzM4NiAxODUuMjM5NDc4TDU5Ny4zOTI0ODMgMTg1Ljg2NjQ3M0M1OTcuMzkyNDgzIDE4NS45NzA5NzIgNTk3LjI4ODk5OSAxODYuMDc1NDcyIDU5Ny4yODg5OTkgMTg2LjI4NDQ3TDU5Ny4yODg5OTkgMTg2LjE3OTk3MUM1OTEuMjg2OTQgMjAwLjI4NzM3MyA1OTEuMzkwNDI0IDE5Ny4yNTY4OTQgNTg2LjUyNjY4NiAyMDguMzMzODE3IDU4Ni41MjY2ODYgMjA3LjgxMTMyMSA1ODYuNTI2Njg2IDIwNy40OTc4MjMgNTg2LjQyMzIwMiAyMDYuOTc1MzI3TDU4NS4xODEzOTcgMTgyLjk0MDQ5MyA1ODQuNDU3MDEgMTgyLjEwNDQ5OUM1NzUuMTQzNDcgMTgzLjg4MDk4NyA1NzQuOTM2NTAyIDE4NC4xOTQ0ODUgNTY2LjQ1MDgzMiAxODUuMzQzOTc3TDU2NS44Mjk5MyAxODUuOTcwOTcyQzU2NS43MjY0NDYgMTg2LjI4NDQ3IDU2NS43MjY0NDYgMTg2LjU5Nzk2OCA1NjUuNzI2NDQ2IDE4Ni45MTE0NjZMNTY1LjgyOTkzIDE4Ny4wMTU5NjVDNTY2Ljg2NDc2NyAxOTIuNTU0NDI3IDU2Ni42NTc4IDE5MS4zMDA0MzUgNTY3LjY5MjYzOCAxOTkuOTczODc1IDU2OC4yMTAwNTcgMjA0LjI1ODM0NSA1NjguODMwOTU5IDIwOC41NDI4MTYgNTY5LjM0ODM3OCAyMTIuNzIyNzg3IDU3MC4xNzYyNDggMjE5LjgyODczNyA1NzAuNjkzNjY3IDIyMy4yNzcyMTMgNTcxLjcyODUwNSAyMzQuMDQwNjM5IDU2NS45MzM0MTMgMjQzLjY1NDU3MiA1NjQuNTg4MTI0IDI0Ny4zMTIwNDYgNTU5IDI1NS43NzY0ODhMNTU5LjMxMDQ1MSAyNTYuNjEyNDgyQzU2Ny42OTI2MzggMjU2LjI5ODk4NCA1NjkuNTU1MzQ2IDI1Ni4yOTg5ODQgNTc1Ljc2NDM3MyAyNTYuMjk4OTg0TDU3Ny4xMDk2NjIgMjU0LjczMTQ5NUM1ODEuNzY2NDMyIDI0NC41OTUwNjUgNjE3LjM2NDg1MyAxODIuOTQwNDkzIDYxNy4zNjQ4NTMgMTgyLjk0MDQ5M0w2MTcuMjYxMzY5IDE4Mi44MzU5OTR6TTMxNC41NDM2MDggMTg5Ljc1ODM3QzMxOS4zMDM4NjIgMTg2LjQxNDM5NCAzMTkuOTI0NzY1IDE4MS44MTY0MjUgMzE1Ljg4ODg5NyAxNzkuNDEyOTQyIDMxMS44NTMwMyAxNzcuMDA5NDU5IDMwNC43MTI2NDkgMTc3Ljc0MDk1NCAyOTkuOTUyMzk1IDE4MS4wODQ5MzEgMjk1LjE5MjE0MSAxODQuMzI0NDA4IDI5NC42NzQ3MjIgMTg4LjkyMjM3NiAyOTguNzEwNTkgMTkxLjQzMDM1OSAzMDIuNjQyOTczIDE5My43MjkzNDMgMzA5Ljc4MzM1NCAxOTMuMTAyMzQ3IDMxNC41NDM2MDggMTg5Ljc1ODM3TDMxNC41NDM2MDggMTg5Ljc1ODM3elwiLz4gPHBhdGggZmlsbD1cIiNGRUZFRkVcIiBkPVwiTTU3NS43MzQ2ODMsMjU2LjEwNDQ5OSBMNTY4LjgwMTI3LDI2OC4xMjE5MTYgQzU2Ni42MjgxMTEsMjcyLjE5NzM4OCA1NjIuNDg4NzU5LDI3NS4zMzIzNjYgNTU2LjA3Mjc2NSwyNzUuMzMyMzY2IEw1NDUsMjc1LjEyMzM2NyBMNTQ4LjIwNzk5NywyNjQuMjU1NDQzIEw1NTAuMzgxMTU3LDI2NC4yNTU0NDMgQzU1MS41MTk0NzgsMjY0LjI1NTQ0MyA1NTIuMzQ3MzQ5LDI2NC4xNTA5NDMgNTUyLjk2ODI1MSwyNjMuODM3NDQ2IEM1NTMuNTg5MTU0LDI2My42Mjg0NDcgNTUzLjg5OTYwNSwyNjMuMjEwNDUgNTU0LjQxNzAyNCwyNjIuNTgzNDU0IEw1NTguNTU2Mzc1LDI1NiBMNTc1LjgzODE2NywyNTYgTDU3NS43MzQ2ODMsMjU2LjEwNDQ5OSBaXCIvPiA8L2c+PC9zdmc+YFxuXG4gICAgLy9kZWZpbmUgdGhlIGNvbG9yIHN3YXAgZnVuY3Rpb25cbiAgICBjb25zdCBzd2FwQ29sb3IgPSBmdW5jdGlvbiAoYmFzZWNvbG9yKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5saWdodGNvbG9yJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnJylcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2xpZ2h0Y29sb3IgJyArIGJhc2Vjb2xvcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kYXJrY29sb3InKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdjbGFzcycsICcnKVxuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGFya2NvbG9yICcgKyBiYXNlY29sb3IgKyAnZGFyaycpXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vcG9wIGluIHRoZSBhcHByb3ByaWF0ZSBjYXJkIGljb24gd2hlbiBkZXRlY3RlZFxuICAgIGNhcmRudW1iZXJfbWFzay5vbihcImFjY2VwdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZG51bWJlcl9tYXNrLm1hc2tlZC5jdXJyZW50TWFzay5jYXJkdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYW1lcmljYW4gZXhwcmVzcyc6XG4gICAgICAgICAgICAgICAgY2NpY29uLmlubmVySFRNTCA9IGFtZXhcbiAgICAgICAgICAgICAgICBjY3NpbmdsZS5pbm5lckhUTUwgPSBhbWV4X3NpbmdsZVxuICAgICAgICAgICAgICAgIHN3YXBDb2xvcignZ3JlZW4nKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICd2aXNhJzpcbiAgICAgICAgICAgICAgICBjY2ljb24uaW5uZXJIVE1MID0gdmlzYVxuICAgICAgICAgICAgICAgIGNjc2luZ2xlLmlubmVySFRNTCA9IHZpc2Ffc2luZ2xlXG4gICAgICAgICAgICAgICAgc3dhcENvbG9yKCdsaW1lJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnZGluZXJzJzpcbiAgICAgICAgICAgICAgICBjY2ljb24uaW5uZXJIVE1MID0gZGluZXJzXG4gICAgICAgICAgICAgICAgY2NzaW5nbGUuaW5uZXJIVE1MID0gZGluZXJzX3NpbmdsZVxuICAgICAgICAgICAgICAgIHN3YXBDb2xvcignb3JhbmdlJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnZGlzY292ZXInOlxuICAgICAgICAgICAgICAgIGNjaWNvbi5pbm5lckhUTUwgPSBkaXNjb3ZlclxuICAgICAgICAgICAgICAgIGNjc2luZ2xlLmlubmVySFRNTCA9IGRpc2NvdmVyX3NpbmdsZVxuICAgICAgICAgICAgICAgIHN3YXBDb2xvcigncHVycGxlJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAoJ2pjYicgfHwgJ2pjYjE1Jyk6XG4gICAgICAgICAgICAgICAgY2NpY29uLmlubmVySFRNTCA9IGpjYlxuICAgICAgICAgICAgICAgIGNjc2luZ2xlLmlubmVySFRNTCA9IGpjYl9zaW5nbGVcbiAgICAgICAgICAgICAgICBzd2FwQ29sb3IoJ3JlZCcpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ21hZXN0cm8nOlxuICAgICAgICAgICAgICAgIGNjaWNvbi5pbm5lckhUTUwgPSBtYWVzdHJvXG4gICAgICAgICAgICAgICAgY2NzaW5nbGUuaW5uZXJIVE1MID0gbWFlc3Ryb19zaW5nbGVcbiAgICAgICAgICAgICAgICBzd2FwQ29sb3IoJ3llbGxvdycpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ21hc3RlcmNhcmQnOlxuICAgICAgICAgICAgICAgIGNjaWNvbi5pbm5lckhUTUwgPSBtYXN0ZXJjYXJkXG4gICAgICAgICAgICAgICAgY2NzaW5nbGUuaW5uZXJIVE1MID0gbWFzdGVyY2FyZF9zaW5nbGVcbiAgICAgICAgICAgICAgICBzd2FwQ29sb3IoJ2xpZ2h0Ymx1ZScpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ3VuaW9ucGF5JzpcbiAgICAgICAgICAgICAgICBjY2ljb24uaW5uZXJIVE1MID0gdW5pb25wYXlcbiAgICAgICAgICAgICAgICBjY3NpbmdsZS5pbm5lckhUTUwgPSB1bmlvbnBheV9zaW5nbGVcbiAgICAgICAgICAgICAgICBzd2FwQ29sb3IoJ2N5YW4nKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNjaWNvbi5pbm5lckhUTUwgPSAnJ1xuICAgICAgICAgICAgICAgIGNjc2luZ2xlLmlubmVySFRNTCA9ICcnXG4gICAgICAgICAgICAgICAgc3dhcENvbG9yKCdncmV5JylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICB9KVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNyZWRpdGNhcmQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdmbGlwcGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnZmxpcHBlZCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZsaXBwZWQnKVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC8vT24gSW5wdXQgQ2hhbmdlIEV2ZW50c1xuICAgIG5hbWUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYW1lLnZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ZnbmFtZScpLmlubmVySFRNTCA9ICdKb2huIERvZSdcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdmduYW1lYmFjaycpLmlubmVySFRNTCA9ICdKb2huIERvZSdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdmduYW1lJykuaW5uZXJIVE1MID0gdGhpcy52YWx1ZVxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N2Z25hbWViYWNrJykuaW5uZXJIVE1MID0gdGhpcy52YWx1ZVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIGNhcmRudW1iZXJfbWFzay5vbignYWNjZXB0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2FyZG51bWJlcl9tYXNrLnZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ZnbnVtYmVyJykuaW5uZXJIVE1MID0gJzAxMjMgNDU2NyA4OTEwIDExMTInXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ZnbnVtYmVyJykuaW5uZXJIVE1MID0gY2FyZG51bWJlcl9tYXNrLnZhbHVlXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgZXhwaXJhdGlvbmRhdGVfbWFzay5vbignYWNjZXB0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZXhwaXJhdGlvbmRhdGVfbWFzay52YWx1ZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N2Z2V4cGlyZScpLmlubmVySFRNTCA9ICcwMS8yMydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdmdleHBpcmUnKS5pbm5lckhUTUwgPSBleHBpcmF0aW9uZGF0ZV9tYXNrLnZhbHVlXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgc2VjdXJpdHljb2RlX21hc2sub24oJ2FjY2VwdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlY3VyaXR5Y29kZV9tYXNrLnZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3Znc2VjdXJpdHknKS5pbm5lckhUTUwgPSAnOTg1J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N2Z3NlY3VyaXR5JykuaW5uZXJIVE1MID0gc2VjdXJpdHljb2RlX21hc2sudmFsdWVcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAvL09uIEZvY3VzIEV2ZW50c1xuICAgIG5hbWUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVkaXRjYXJkJykuY2xhc3NMaXN0LnJlbW92ZSgnZmxpcHBlZCcpXG4gICAgfSlcblxuICAgIGNhcmRudW1iZXIuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVkaXRjYXJkJykuY2xhc3NMaXN0LnJlbW92ZSgnZmxpcHBlZCcpXG4gICAgfSlcblxuICAgIGV4cGlyYXRpb25kYXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY3JlZGl0Y2FyZCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2ZsaXBwZWQnKVxuICAgIH0pXG5cbiAgICBzZWN1cml0eWNvZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jcmVkaXRjYXJkJykuY2xhc3NMaXN0LmFkZCgnZmxpcHBlZCcpXG4gICAgfSlcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BheWF1dGgnLCBldmVudCA9PiB7XG4gICAgTWlkdHJhbnNOZXczZHMuYXV0aGVudGljYXRlKGV2ZW50LmRldGFpbC5yZWRpcmVjdF91cmwsIHtcbiAgICAgICAgcGVyZm9ybUF1dGhlbnRpY2F0aW9uOiBmdW5jdGlvbiAocmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgICAkLmZlYXRoZXJsaWdodCh7XG4gICAgICAgICAgICAgICAgaWZyYW1lOiByZWRpcmVjdF91cmwsXG4gICAgICAgICAgICAgICAgaWZyYW1lTWF4V2lkdGg6ICc4MCUnLFxuICAgICAgICAgICAgICAgIGlmcmFtZVdpZHRoOiA2MDAsXG4gICAgICAgICAgICAgICAgaWZyYW1lSGVpZ2h0OiA1MDAsXG4gICAgICAgICAgICAgICAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNsb3NlT25Fc2M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsb3NlSWNvbjogJ1gnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgJC5mZWF0aGVybGlnaHQuY2xvc2UoKVxuICAgICAgICAgICAgTGl2ZXdpcmUuZW1pdCgnZG9QYXltZW50JywgcmVzcG9uc2UpXG4gICAgICAgIH0sXG4gICAgICAgIG9uRmFpbHVyZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAkLmZlYXRoZXJsaWdodC5jbG9zZSgpXG4gICAgICAgICAgICBMaXZld2lyZS5lbWl0KCdlcnJvclBheW1lbnQnLCByZXNwb25zZSlcbiAgICAgICAgfSxcbiAgICAgICAgb25QZW5kaW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICQuZmVhdGhlcmxpZ2h0LmNsb3NlKClcbiAgICAgICAgICAgIExpdmV3aXJlLmVtaXQoJ2Vycm9yUGF5bWVudCcsIHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgfSlcbn0pXG4iXSwibmFtZXMiOlsiSU1hc2siLCJBbHBpbmUiLCJ3aW5kb3ciLCJzdGFydCIsIkNoYXJ0IiwiZGVmYXVsdHMiLCJnbG9iYWwiLCJkZWZhdWx0Rm9udEZhbWlseSIsImRlZmF1bHRGb250Q29sb3IiLCJsaXZld2lyZSIsIm9uIiwiY2hhcnRJZCIsImxhYmVscyIsImRhdGFzZXRzIiwiY2hhcnQiLCJkYXRhIiwiZm9yRWFjaCIsImRhdGFzZXQiLCJrZXkiLCJ1cGRhdGUiLCIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsImZhZGVPdXQiLCJldmVudCIsImF0dHIiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwicHJpbnRUaGlzIiwiZGVidWciLCJwcmludENvbnRhaW5lciIsInBhZ2VUaXRsZSIsInByaW50RGVsYXkiLCJoZWFkZXIiLCJmb290ZXIiLCJiYXNlIiwiZm9ybVZhbHVlcyIsImNhbnZhcyIsInJlbW92ZVNjcmlwdHMiLCJjb3B5VGFnQ2xhc3NlcyIsImJlZm9yZVByaW50RXZlbnQiLCJiZWZvcmVQcmludCIsImFmdGVyUHJpbnQiLCJlIiwidG9nZ2xlQ2xhc3MiLCJoYXNDbGFzcyIsImNvbGxhcHNlIiwicmVzaXplIiwid2lkdGgiLCJlMCIsIm9yaWdpbmFsRXZlbnQiLCJkZWx0YSIsIndoZWVsRGVsdGEiLCJkZXRhaWwiLCJzY3JvbGxUb3AiLCJwcmV2ZW50RGVmYXVsdCIsInNjcm9sbERpc3RhbmNlIiwiZmFkZUluIiwiJGFuY2hvciIsInN0b3AiLCJhbmltYXRlIiwib2Zmc2V0IiwidG9wIiwiaGlkZSIsIm5pdm9TbGlkZXIiLCJlZmZlY3QiLCJhbmltU3BlZWQiLCJwYXVzZVRpbWUiLCJkaXJlY3Rpb25OYXYiLCJjb250cm9sTmF2IiwicGF1c2VPbkhvdmVyIiwidGV4dCIsInNpYmxpbmdzIiwic2xpZGVUb2dnbGUiLCJvd2xDYXJvdXNlbCIsImxvb3AiLCJhdXRvcGxheXRpbWVvdXQiLCJtYXJnaW4iLCJhdXRvcGxheSIsImRvdHMiLCJhdXRvcGxheUhvdmVyUGF1c2UiLCJyZXNwb25zaXZlQ2xhc3MiLCJuYXYiLCJyZXNwb25zaXZlIiwiaXRlbXMiLCJuYXZUZXh0Iiwib25sb2FkIiwibmFtZSIsImdldEVsZW1lbnRCeUlkIiwiY2FyZG51bWJlciIsImV4cGlyYXRpb25kYXRlIiwic2VjdXJpdHljb2RlIiwiY2NpY29uIiwiY2NzaW5nbGUiLCJjYXJkbnVtYmVyX21hc2siLCJtYXNrIiwicmVnZXgiLCJjYXJkdHlwZSIsImRpc3BhdGNoIiwiYXBwZW5kZWQiLCJkeW5hbWljTWFza2VkIiwibnVtYmVyIiwidmFsdWUiLCJyZXBsYWNlIiwiaSIsImNvbXBpbGVkTWFza3MiLCJsZW5ndGgiLCJyZSIsIlJlZ0V4cCIsIm1hdGNoIiwiZXhwaXJhdGlvbmRhdGVfbWFzayIsImdyb3VwcyIsIllZIiwiTWFza2VkUGF0dGVybiIsIkdyb3VwIiwiUmFuZ2UiLCJNTSIsInNlY3VyaXR5Y29kZV9tYXNrIiwiYW1leCIsInZpc2EiLCJkaW5lcnMiLCJkaXNjb3ZlciIsImpjYiIsIm1hZXN0cm8iLCJtYXN0ZXJjYXJkIiwidW5pb25wYXkiLCJhbWV4X3NpbmdsZSIsInZpc2Ffc2luZ2xlIiwiZGluZXJzX3NpbmdsZSIsImRpc2NvdmVyX3NpbmdsZSIsImpjYl9zaW5nbGUiLCJtYWVzdHJvX3NpbmdsZSIsIm1hc3RlcmNhcmRfc2luZ2xlIiwidW5pb25wYXlfc2luZ2xlIiwic3dhcENvbG9yIiwiYmFzZWNvbG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImlucHV0Iiwic2V0QXR0cmlidXRlIiwibWFza2VkIiwiY3VycmVudE1hc2siLCJpbm5lckhUTUwiLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwicmVtb3ZlIiwiYWRkIiwiTWlkdHJhbnNOZXczZHMiLCJhdXRoZW50aWNhdGUiLCJyZWRpcmVjdF91cmwiLCJwZXJmb3JtQXV0aGVudGljYXRpb24iLCJmZWF0aGVybGlnaHQiLCJpZnJhbWUiLCJpZnJhbWVNYXhXaWR0aCIsImlmcmFtZVdpZHRoIiwiaWZyYW1lSGVpZ2h0IiwiY2xvc2VPbkNsaWNrIiwiY2xvc2VPbkVzYyIsImNsb3NlSWNvbiIsIm9uU3VjY2VzcyIsInJlc3BvbnNlIiwiY2xvc2UiLCJMaXZld2lyZSIsImVtaXQiLCJvbkZhaWx1cmUiLCJvblBlbmRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/vendor/datatables/dataTables.bootstrap4.min.js":
/*!******************************************************************!*\
  !*** ./resources/vendor/datatables/dataTables.bootstrap4.min.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\r\n DataTables Bootstrap 4 integration\r\n ©2011-2017 SpryMedia Ltd - datatables.net/license\r\n*/\n(function (c) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"./node_modules/datatables.net/js/jquery.dataTables.mjs\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (a) {\n    return c(a, window, document);\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n})(function (c, a, d, m) {\n  var f = c.fn.dataTable;\n  c.extend(!0, f.defaults, {\n    dom: \"<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>><'row'<'col-sm-12'tr>><'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>\",\n    renderer: \"bootstrap\"\n  });\n  c.extend(f.ext.classes, {\n    sWrapper: \"dataTables_wrapper dt-bootstrap4\",\n    sFilterInput: \"form-control form-control-sm\",\n    sLengthSelect: \"custom-select custom-select-sm form-control form-control-sm\",\n    sProcessing: \"dataTables_processing card\",\n    sPageButton: \"paginate_button page-item\"\n  });\n\n  f.ext.renderer.pageButton.bootstrap = function (a, h, r, s, j, n) {\n    var o = new f.Api(a),\n        t = a.oClasses,\n        k = a.oLanguage.oPaginate,\n        u = a.oLanguage.oAria.paginate || {},\n        e,\n        g,\n        p = 0,\n        q = function q(d, f) {\n      var l,\n          h,\n          i,\n          b,\n          m = function m(a) {\n        a.preventDefault();\n        !c(a.currentTarget).hasClass(\"disabled\") && o.page() != a.data.action && o.page(a.data.action).draw(\"page\");\n      };\n\n      l = 0;\n\n      for (h = f.length; l < h; l++) {\n        if (b = f[l], Array.isArray(b)) q(d, b);else {\n          g = e = \"\";\n\n          switch (b) {\n            case \"ellipsis\":\n              e = \"&#x2026;\";\n              g = \"disabled\";\n              break;\n\n            case \"first\":\n              e = k.sFirst;\n              g = b + (0 < j ? \"\" : \" disabled\");\n              break;\n\n            case \"previous\":\n              e = k.sPrevious;\n              g = b + (0 < j ? \"\" : \" disabled\");\n              break;\n\n            case \"next\":\n              e = k.sNext;\n              g = b + (j < n - 1 ? \"\" : \" disabled\");\n              break;\n\n            case \"last\":\n              e = k.sLast;\n              g = b + (j < n - 1 ? \"\" : \" disabled\");\n              break;\n\n            default:\n              e = b + 1, g = j === b ? \"active\" : \"\";\n          }\n\n          e && (i = c(\"<li>\", {\n            \"class\": t.sPageButton + \" \" + g,\n            id: 0 === r && \"string\" === typeof b ? a.sTableId + \"_\" + b : null\n          }).append(c(\"<a>\", {\n            href: \"#\",\n            \"aria-controls\": a.sTableId,\n            \"aria-label\": u[b],\n            \"data-dt-idx\": p,\n            tabindex: a.iTabIndex,\n            \"class\": \"page-link\"\n          }).html(e)).appendTo(d), a.oApi._fnBindAction(i, {\n            action: b\n          }, m), p++);\n        }\n      }\n    },\n        i;\n\n    try {\n      i = c(h).find(d.activeElement).data(\"dt-idx\");\n    } catch (v) {}\n\n    q(c(h).empty().html('<ul class=\"pagination\"/>').children(\"ul\"), s);\n    i !== m && c(h).find(\"[data-dt-idx=\" + i + \"]\").trigger(\"focus\");\n  };\n\n  return f;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL2RhdGF0YWJsZXMvZGF0YVRhYmxlcy5ib290c3RyYXA0Lm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFBQyxVQUF1Q0MsaUNBQU8sQ0FBQywyQ0FBRCxFQUFVLG1HQUFWLENBQUQsbUNBQTZCLFVBQVNFLENBQVQsRUFBVztBQUFDLFdBQU9ILENBQUMsQ0FBQ0csQ0FBRCxFQUFHQyxNQUFILEVBQVVDLFFBQVYsQ0FBUjtBQUE0QixHQUFyRTtBQUFBLGtHQUE3QyxHQUFvSCxDQUFwSDtBQUF1UyxDQUFwVCxFQUFzVCxVQUFTTCxDQUFULEVBQVdHLENBQVgsRUFBYUssQ0FBYixFQUFlTSxDQUFmLEVBQWlCO0FBQUMsTUFBSUMsQ0FBQyxHQUFDZixDQUFDLENBQUNTLEVBQUYsQ0FBS0MsU0FBWDtBQUFxQlYsRUFBQUEsQ0FBQyxDQUFDZ0IsTUFBRixDQUFTLENBQUMsQ0FBVixFQUFZRCxDQUFDLENBQUNFLFFBQWQsRUFBdUI7QUFBQ0MsSUFBQUEsR0FBRyxFQUFDLGtJQUFMO0FBQ3BYQyxJQUFBQSxRQUFRLEVBQUM7QUFEMlcsR0FBdkI7QUFDdFVuQixFQUFBQSxDQUFDLENBQUNnQixNQUFGLENBQVNELENBQUMsQ0FBQ0ssR0FBRixDQUFNQyxPQUFmLEVBQXVCO0FBQUNDLElBQUFBLFFBQVEsRUFBQyxrQ0FBVjtBQUE2Q0MsSUFBQUEsWUFBWSxFQUFDLDhCQUExRDtBQUF5RkMsSUFBQUEsYUFBYSxFQUFDLDZEQUF2RztBQUFxS0MsSUFBQUEsV0FBVyxFQUFDLDRCQUFqTDtBQUE4TUMsSUFBQUEsV0FBVyxFQUFDO0FBQTFOLEdBQXZCOztBQUErUVgsRUFBQUEsQ0FBQyxDQUFDSyxHQUFGLENBQU1ELFFBQU4sQ0FBZVEsVUFBZixDQUEwQkMsU0FBMUIsR0FBb0MsVUFBU3pCLENBQVQsRUFBVzBCLENBQVgsRUFBYUMsQ0FBYixFQUFlQyxDQUFmLEVBQWlC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QUFFOztBQUFBOUIsSUFBQUEsQ0FBQyxDQUFDL0MsQ0FBQyxDQUFDNkIsQ0FBRCxDQUFELENBQUtpRCxLQUFMLEdBQWFQLElBQWIsQ0FBa0IsMEJBQWxCLEVBQThDUSxRQUE5QyxDQUF1RCxJQUF2RCxDQUFELEVBQThEaEQsQ0FBOUQsQ0FBRDtBQUFrRWtCLElBQUFBLENBQUMsS0FBR25DLENBQUosSUFBT2QsQ0FBQyxDQUFDNkIsQ0FBRCxDQUFELENBQUs4QyxJQUFMLENBQVUsa0JBQWdCMUIsQ0FBaEIsR0FBa0IsR0FBNUIsRUFBaUMrQixPQUFqQyxDQUF5QyxPQUF6QyxDQUFQO0FBQXlELEdBRnRLOztBQUV1SyxTQUFPakUsQ0FBUDtBQUFTLENBSHRkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9kYXRhdGFibGVzL2RhdGFUYWJsZXMuYm9vdHN0cmFwNC5taW4uanM/YzY5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuIERhdGFUYWJsZXMgQm9vdHN0cmFwIDQgaW50ZWdyYXRpb25cclxuIMKpMjAxMS0yMDE3IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXHJcbiovXHJcbihmdW5jdGlvbihjKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJqcXVlcnlcIixcImRhdGF0YWJsZXMubmV0XCJdLGZ1bmN0aW9uKGEpe3JldHVybiBjKGEsd2luZG93LGRvY3VtZW50KX0pOlwib2JqZWN0XCI9PT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihhLGQpe2F8fChhPXdpbmRvdyk7aWYoIWR8fCFkLmZuLmRhdGFUYWJsZSlkPXJlcXVpcmUoXCJkYXRhdGFibGVzLm5ldFwiKShhLGQpLiQ7cmV0dXJuIGMoZCxhLGEuZG9jdW1lbnQpfTpjKGpRdWVyeSx3aW5kb3csZG9jdW1lbnQpfSkoZnVuY3Rpb24oYyxhLGQsbSl7dmFyIGY9Yy5mbi5kYXRhVGFibGU7Yy5leHRlbmQoITAsZi5kZWZhdWx0cyx7ZG9tOlwiPCdyb3cnPCdjb2wtc20tMTIgY29sLW1kLTYnbD48J2NvbC1zbS0xMiBjb2wtbWQtNidmPj48J3Jvdyc8J2NvbC1zbS0xMid0cj4+PCdyb3cnPCdjb2wtc20tMTIgY29sLW1kLTUnaT48J2NvbC1zbS0xMiBjb2wtbWQtNydwPj5cIixcclxucmVuZGVyZXI6XCJib290c3RyYXBcIn0pO2MuZXh0ZW5kKGYuZXh0LmNsYXNzZXMse3NXcmFwcGVyOlwiZGF0YVRhYmxlc193cmFwcGVyIGR0LWJvb3RzdHJhcDRcIixzRmlsdGVySW5wdXQ6XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXCIsc0xlbmd0aFNlbGVjdDpcImN1c3RvbS1zZWxlY3QgY3VzdG9tLXNlbGVjdC1zbSBmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXCIsc1Byb2Nlc3Npbmc6XCJkYXRhVGFibGVzX3Byb2Nlc3NpbmcgY2FyZFwiLHNQYWdlQnV0dG9uOlwicGFnaW5hdGVfYnV0dG9uIHBhZ2UtaXRlbVwifSk7Zi5leHQucmVuZGVyZXIucGFnZUJ1dHRvbi5ib290c3RyYXA9ZnVuY3Rpb24oYSxoLHIscyxqLG4pe3ZhciBvPW5ldyBmLkFwaShhKSx0PWEub0NsYXNzZXMsaz1hLm9MYW5ndWFnZS5vUGFnaW5hdGUsdT1hLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZXx8e30sZSxnLHA9MCxxPWZ1bmN0aW9uKGQsZil7dmFyIGwsaCxpLGIsbT1mdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCk7XHJcbiFjKGEuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoXCJkaXNhYmxlZFwiKSYmby5wYWdlKCkhPWEuZGF0YS5hY3Rpb24mJm8ucGFnZShhLmRhdGEuYWN0aW9uKS5kcmF3KFwicGFnZVwiKX07bD0wO2ZvcihoPWYubGVuZ3RoO2w8aDtsKyspaWYoYj1mW2xdLEFycmF5LmlzQXJyYXkoYikpcShkLGIpO2Vsc2V7Zz1lPVwiXCI7c3dpdGNoKGIpe2Nhc2UgXCJlbGxpcHNpc1wiOmU9XCImI3gyMDI2O1wiO2c9XCJkaXNhYmxlZFwiO2JyZWFrO2Nhc2UgXCJmaXJzdFwiOmU9ay5zRmlyc3Q7Zz1iKygwPGo/XCJcIjpcIiBkaXNhYmxlZFwiKTticmVhaztjYXNlIFwicHJldmlvdXNcIjplPWsuc1ByZXZpb3VzO2c9YisoMDxqP1wiXCI6XCIgZGlzYWJsZWRcIik7YnJlYWs7Y2FzZSBcIm5leHRcIjplPWsuc05leHQ7Zz1iKyhqPG4tMT9cIlwiOlwiIGRpc2FibGVkXCIpO2JyZWFrO2Nhc2UgXCJsYXN0XCI6ZT1rLnNMYXN0O2c9YisoajxuLTE/XCJcIjpcIiBkaXNhYmxlZFwiKTticmVhaztkZWZhdWx0OmU9YisxLGc9aj09PWI/XCJhY3RpdmVcIjpcIlwifWUmJihpPWMoXCI8bGk+XCIsXHJcbntcImNsYXNzXCI6dC5zUGFnZUJ1dHRvbitcIiBcIitnLGlkOjA9PT1yJiZcInN0cmluZ1wiPT09dHlwZW9mIGI/YS5zVGFibGVJZCtcIl9cIitiOm51bGx9KS5hcHBlbmQoYyhcIjxhPlwiLHtocmVmOlwiI1wiLFwiYXJpYS1jb250cm9sc1wiOmEuc1RhYmxlSWQsXCJhcmlhLWxhYmVsXCI6dVtiXSxcImRhdGEtZHQtaWR4XCI6cCx0YWJpbmRleDphLmlUYWJJbmRleCxcImNsYXNzXCI6XCJwYWdlLWxpbmtcIn0pLmh0bWwoZSkpLmFwcGVuZFRvKGQpLGEub0FwaS5fZm5CaW5kQWN0aW9uKGkse2FjdGlvbjpifSxtKSxwKyspfX0saTt0cnl7aT1jKGgpLmZpbmQoZC5hY3RpdmVFbGVtZW50KS5kYXRhKFwiZHQtaWR4XCIpfWNhdGNoKHYpe31xKGMoaCkuZW1wdHkoKS5odG1sKCc8dWwgY2xhc3M9XCJwYWdpbmF0aW9uXCIvPicpLmNoaWxkcmVuKFwidWxcIikscyk7aSE9PW0mJmMoaCkuZmluZChcIltkYXRhLWR0LWlkeD1cIitpK1wiXVwiKS50cmlnZ2VyKFwiZm9jdXNcIil9O3JldHVybiBmfSk7XHJcbiJdLCJuYW1lcyI6WyJjIiwiZGVmaW5lIiwiYW1kIiwiYSIsIndpbmRvdyIsImRvY3VtZW50IiwiZXhwb3J0cyIsIm1vZHVsZSIsImQiLCJmbiIsImRhdGFUYWJsZSIsInJlcXVpcmUiLCIkIiwialF1ZXJ5IiwibSIsImYiLCJleHRlbmQiLCJkZWZhdWx0cyIsImRvbSIsInJlbmRlcmVyIiwiZXh0IiwiY2xhc3NlcyIsInNXcmFwcGVyIiwic0ZpbHRlcklucHV0Iiwic0xlbmd0aFNlbGVjdCIsInNQcm9jZXNzaW5nIiwic1BhZ2VCdXR0b24iLCJwYWdlQnV0dG9uIiwiYm9vdHN0cmFwIiwiaCIsInIiLCJzIiwiaiIsIm4iLCJvIiwiQXBpIiwidCIsIm9DbGFzc2VzIiwiayIsIm9MYW5ndWFnZSIsIm9QYWdpbmF0ZSIsInUiLCJvQXJpYSIsInBhZ2luYXRlIiwiZSIsImciLCJwIiwicSIsImwiLCJpIiwiYiIsInByZXZlbnREZWZhdWx0IiwiY3VycmVudFRhcmdldCIsImhhc0NsYXNzIiwicGFnZSIsImRhdGEiLCJhY3Rpb24iLCJkcmF3IiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5Iiwic0ZpcnN0Iiwic1ByZXZpb3VzIiwic05leHQiLCJzTGFzdCIsImlkIiwic1RhYmxlSWQiLCJhcHBlbmQiLCJocmVmIiwidGFiaW5kZXgiLCJpVGFiSW5kZXgiLCJodG1sIiwiYXBwZW5kVG8iLCJvQXBpIiwiX2ZuQmluZEFjdGlvbiIsImZpbmQiLCJhY3RpdmVFbGVtZW50IiwidiIsImVtcHR5IiwiY2hpbGRyZW4iLCJ0cmlnZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/datatables/dataTables.bootstrap4.min.js\n");

/***/ }),

/***/ "./resources/vendor/datatables/jquery.dataTables.min.js":
/*!**************************************************************!*\
  !*** ./resources/vendor/datatables/jquery.dataTables.min.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\r\n DataTables 1.10.24\r\n ©2008-2021 SpryMedia Ltd - datatables.net/license\r\n*/\n(function (h) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (E) {\n    return h(E, window, document);\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n})(function (h, E, H, k) {\n  function $(a) {\n    var b,\n        c,\n        d = {};\n    h.each(a, function (e) {\n      if ((b = e.match(/^([^A-Z]+?)([A-Z])/)) && -1 !== \"a aa ai ao as b fn i m o s \".indexOf(b[1] + \" \")) c = e.replace(b[0], b[2].toLowerCase()), d[c] = e, \"o\" === b[1] && $(a[e]);\n    });\n    a._hungarianMap = d;\n  }\n\n  function J(a, b, c) {\n    a._hungarianMap || $(a);\n    var d;\n    h.each(b, function (e) {\n      d = a._hungarianMap[e];\n      if (d !== k && (c || b[d] === k)) \"o\" === d.charAt(0) ? (b[d] || (b[d] = {}), h.extend(!0, b[d], b[e]), J(a[d], b[d], c)) : b[d] = b[e];\n    });\n  }\n\n  function Ea(a) {\n    var b = l.defaults.oLanguage,\n        c = b.sDecimal;\n    c && Fa(c);\n\n    if (a) {\n      var d = a.sZeroRecords;\n      !a.sEmptyTable && d && \"No data available in table\" === b.sEmptyTable && F(a, a, \"sZeroRecords\", \"sEmptyTable\");\n      !a.sLoadingRecords && d && \"Loading...\" === b.sLoadingRecords && F(a, a, \"sZeroRecords\", \"sLoadingRecords\");\n      a.sInfoThousands && (a.sThousands = a.sInfoThousands);\n      (a = a.sDecimal) && c !== a && Fa(a);\n    }\n  }\n\n  function gb(a) {\n    A(a, \"ordering\", \"bSort\");\n    A(a, \"orderMulti\", \"bSortMulti\");\n    A(a, \"orderClasses\", \"bSortClasses\");\n    A(a, \"orderCellsTop\", \"bSortCellsTop\");\n    A(a, \"order\", \"aaSorting\");\n    A(a, \"orderFixed\", \"aaSortingFixed\");\n    A(a, \"paging\", \"bPaginate\");\n    A(a, \"pagingType\", \"sPaginationType\");\n    A(a, \"pageLength\", \"iDisplayLength\");\n    A(a, \"searching\", \"bFilter\");\n    \"boolean\" === typeof a.sScrollX && (a.sScrollX = a.sScrollX ? \"100%\" : \"\");\n    \"boolean\" === typeof a.scrollX && (a.scrollX = a.scrollX ? \"100%\" : \"\");\n    if (a = a.aoSearchCols) for (var b = 0, c = a.length; b < c; b++) {\n      a[b] && J(l.models.oSearch, a[b]);\n    }\n  }\n\n  function hb(a) {\n    A(a, \"orderable\", \"bSortable\");\n    A(a, \"orderData\", \"aDataSort\");\n    A(a, \"orderSequence\", \"asSorting\");\n    A(a, \"orderDataType\", \"sortDataType\");\n    var b = a.aDataSort;\n    \"number\" === typeof b && !Array.isArray(b) && (a.aDataSort = [b]);\n  }\n\n  function ib(a) {\n    if (!l.__browser) {\n      var b = {};\n      l.__browser = b;\n      var c = h(\"<div/>\").css({\n        position: \"fixed\",\n        top: 0,\n        left: -1 * h(E).scrollLeft(),\n        height: 1,\n        width: 1,\n        overflow: \"hidden\"\n      }).append(h(\"<div/>\").css({\n        position: \"absolute\",\n        top: 1,\n        left: 1,\n        width: 100,\n        overflow: \"scroll\"\n      }).append(h(\"<div/>\").css({\n        width: \"100%\",\n        height: 10\n      }))).appendTo(\"body\"),\n          d = c.children(),\n          e = d.children();\n      b.barWidth = d[0].offsetWidth - d[0].clientWidth;\n      b.bScrollOversize = 100 === e[0].offsetWidth && 100 !== d[0].clientWidth;\n      b.bScrollbarLeft = 1 !== Math.round(e.offset().left);\n      b.bBounding = c[0].getBoundingClientRect().width ? !0 : !1;\n      c.remove();\n    }\n\n    h.extend(a.oBrowser, l.__browser);\n    a.oScroll.iBarWidth = l.__browser.barWidth;\n  }\n\n  function jb(a, b, c, d, e, f) {\n    var g,\n        j = !1;\n    c !== k && (g = c, j = !0);\n\n    for (; d !== e;) {\n      a.hasOwnProperty(d) && (g = j ? b(g, a[d], d, a) : a[d], j = !0, d += f);\n    }\n\n    return g;\n  }\n\n  function Ga(a, b) {\n    var c = l.defaults.column,\n        d = a.aoColumns.length,\n        c = h.extend({}, l.models.oColumn, c, {\n      nTh: b ? b : H.createElement(\"th\"),\n      sTitle: c.sTitle ? c.sTitle : b ? b.innerHTML : \"\",\n      aDataSort: c.aDataSort ? c.aDataSort : [d],\n      mData: c.mData ? c.mData : d,\n      idx: d\n    });\n    a.aoColumns.push(c);\n    c = a.aoPreSearchCols;\n    c[d] = h.extend({}, l.models.oSearch, c[d]);\n    la(a, d, h(b).data());\n  }\n\n  function la(a, b, c) {\n    var b = a.aoColumns[b],\n        d = a.oClasses,\n        e = h(b.nTh);\n\n    if (!b.sWidthOrig) {\n      b.sWidthOrig = e.attr(\"width\") || null;\n      var f = (e.attr(\"style\") || \"\").match(/width:\\s*(\\d+[pxem%]+)/);\n      f && (b.sWidthOrig = f[1]);\n    }\n\n    c !== k && null !== c && (hb(c), J(l.defaults.column, c, !0), c.mDataProp !== k && !c.mData && (c.mData = c.mDataProp), c.sType && (b._sManualType = c.sType), c.className && !c.sClass && (c.sClass = c.className), c.sClass && e.addClass(c.sClass), h.extend(b, c), F(b, c, \"sWidth\", \"sWidthOrig\"), c.iDataSort !== k && (b.aDataSort = [c.iDataSort]), F(b, c, \"aDataSort\"));\n\n    var g = b.mData,\n        j = S(g),\n        i = b.mRender ? S(b.mRender) : null,\n        c = function c(a) {\n      return \"string\" === typeof a && -1 !== a.indexOf(\"@\");\n    };\n\n    b._bAttrSrc = h.isPlainObject(g) && (c(g.sort) || c(g.type) || c(g.filter));\n    b._setter = null;\n\n    b.fnGetData = function (a, b, c) {\n      var d = j(a, b, k, c);\n      return i && b ? i(d, b, a, c) : d;\n    };\n\n    b.fnSetData = function (a, b, c) {\n      return N(g)(a, b, c);\n    };\n\n    \"number\" !== typeof g && (a._rowReadObject = !0);\n    a.oFeatures.bSort || (b.bSortable = !1, e.addClass(d.sSortableNone));\n    a = -1 !== h.inArray(\"asc\", b.asSorting);\n    c = -1 !== h.inArray(\"desc\", b.asSorting);\n    !b.bSortable || !a && !c ? (b.sSortingClass = d.sSortableNone, b.sSortingClassJUI = \"\") : a && !c ? (b.sSortingClass = d.sSortableAsc, b.sSortingClassJUI = d.sSortJUIAscAllowed) : !a && c ? (b.sSortingClass = d.sSortableDesc, b.sSortingClassJUI = d.sSortJUIDescAllowed) : (b.sSortingClass = d.sSortable, b.sSortingClassJUI = d.sSortJUI);\n  }\n\n  function aa(a) {\n    if (!1 !== a.oFeatures.bAutoWidth) {\n      var b = a.aoColumns;\n      Ha(a);\n\n      for (var c = 0, d = b.length; c < d; c++) {\n        b[c].nTh.style.width = b[c].sWidth;\n      }\n    }\n\n    b = a.oScroll;\n    (\"\" !== b.sY || \"\" !== b.sX) && ma(a);\n    t(a, null, \"column-sizing\", [a]);\n  }\n\n  function ba(a, b) {\n    var c = na(a, \"bVisible\");\n    return \"number\" === typeof c[b] ? c[b] : null;\n  }\n\n  function ca(a, b) {\n    var c = na(a, \"bVisible\"),\n        c = h.inArray(b, c);\n    return -1 !== c ? c : null;\n  }\n\n  function W(a) {\n    var b = 0;\n    h.each(a.aoColumns, function (a, d) {\n      d.bVisible && \"none\" !== h(d.nTh).css(\"display\") && b++;\n    });\n    return b;\n  }\n\n  function na(a, b) {\n    var c = [];\n    h.map(a.aoColumns, function (a, e) {\n      a[b] && c.push(e);\n    });\n    return c;\n  }\n\n  function Ia(a) {\n    var b = a.aoColumns,\n        c = a.aoData,\n        d = l.ext.type.detect,\n        e,\n        f,\n        g,\n        j,\n        i,\n        h,\n        m,\n        q,\n        s;\n    e = 0;\n\n    for (f = b.length; e < f; e++) {\n      if (m = b[e], s = [], !m.sType && m._sManualType) m.sType = m._sManualType;else if (!m.sType) {\n        g = 0;\n\n        for (j = d.length; g < j; g++) {\n          i = 0;\n\n          for (h = c.length; i < h; i++) {\n            s[i] === k && (s[i] = B(a, i, e, \"type\"));\n            q = d[g](s[i], a);\n            if (!q && g !== d.length - 1) break;\n            if (\"html\" === q) break;\n          }\n\n          if (q) {\n            m.sType = q;\n            break;\n          }\n        }\n\n        m.sType || (m.sType = \"string\");\n      }\n    }\n  }\n\n  function kb(a, b, c, d) {\n    var e,\n        f,\n        g,\n        j,\n        i,\n        n,\n        m = a.aoColumns;\n    if (b) for (e = b.length - 1; 0 <= e; e--) {\n      n = b[e];\n      var q = n.targets !== k ? n.targets : n.aTargets;\n      Array.isArray(q) || (q = [q]);\n      f = 0;\n\n      for (g = q.length; f < g; f++) {\n        if (\"number\" === typeof q[f] && 0 <= q[f]) {\n          for (; m.length <= q[f];) {\n            Ga(a);\n          }\n\n          d(q[f], n);\n        } else if (\"number\" === typeof q[f] && 0 > q[f]) d(m.length + q[f], n);else if (\"string\" === typeof q[f]) {\n          j = 0;\n\n          for (i = m.length; j < i; j++) {\n            (\"_all\" == q[f] || h(m[j].nTh).hasClass(q[f])) && d(j, n);\n          }\n        }\n      }\n    }\n\n    if (c) {\n      e = 0;\n\n      for (a = c.length; e < a; e++) {\n        d(e, c[e]);\n      }\n    }\n  }\n\n  function O(a, b, c, d) {\n    var e = a.aoData.length,\n        f = h.extend(!0, {}, l.models.oRow, {\n      src: c ? \"dom\" : \"data\",\n      idx: e\n    });\n    f._aData = b;\n    a.aoData.push(f);\n\n    for (var g = a.aoColumns, j = 0, i = g.length; j < i; j++) {\n      g[j].sType = null;\n    }\n\n    a.aiDisplayMaster.push(e);\n    b = a.rowIdFn(b);\n    b !== k && (a.aIds[b] = f);\n    (c || !a.oFeatures.bDeferRender) && Ja(a, e, c, d);\n    return e;\n  }\n\n  function oa(a, b) {\n    var c;\n    b instanceof h || (b = h(b));\n    return b.map(function (b, e) {\n      c = Ka(a, e);\n      return O(a, c.data, e, c.cells);\n    });\n  }\n\n  function B(a, b, c, d) {\n    var e = a.iDraw,\n        f = a.aoColumns[c],\n        g = a.aoData[b]._aData,\n        j = f.sDefaultContent,\n        i = f.fnGetData(g, d, {\n      settings: a,\n      row: b,\n      col: c\n    });\n    if (i === k) return a.iDrawError != e && null === j && (K(a, 0, \"Requested unknown parameter \" + (\"function\" == typeof f.mData ? \"{function}\" : \"'\" + f.mData + \"'\") + \" for row \" + b + \", column \" + c, 4), a.iDrawError = e), j;\n    if ((i === g || null === i) && null !== j && d !== k) i = j;else if (\"function\" === typeof i) return i.call(g);\n    return null === i && \"display\" == d ? \"\" : i;\n  }\n\n  function lb(a, b, c, d) {\n    a.aoColumns[c].fnSetData(a.aoData[b]._aData, d, {\n      settings: a,\n      row: b,\n      col: c\n    });\n  }\n\n  function La(a) {\n    return h.map(a.match(/(\\\\.|[^\\.])+/g) || [\"\"], function (a) {\n      return a.replace(/\\\\\\./g, \".\");\n    });\n  }\n\n  function S(a) {\n    if (h.isPlainObject(a)) {\n      var b = {};\n      h.each(a, function (a, c) {\n        c && (b[a] = S(c));\n      });\n      return function (a, c, f, g) {\n        var j = b[c] || b._;\n        return j !== k ? j(a, c, f, g) : a;\n      };\n    }\n\n    if (null === a) return function (a) {\n      return a;\n    };\n    if (\"function\" === typeof a) return function (b, c, f, g) {\n      return a(b, c, f, g);\n    };\n\n    if (\"string\" === typeof a && (-1 !== a.indexOf(\".\") || -1 !== a.indexOf(\"[\") || -1 !== a.indexOf(\"(\"))) {\n      var c = function c(a, b, f) {\n        var g, j;\n\n        if (\"\" !== f) {\n          j = La(f);\n\n          for (var i = 0, h = j.length; i < h; i++) {\n            f = j[i].match(da);\n            g = j[i].match(X);\n\n            if (f) {\n              j[i] = j[i].replace(da, \"\");\n              \"\" !== j[i] && (a = a[j[i]]);\n              g = [];\n              j.splice(0, i + 1);\n              j = j.join(\".\");\n\n              if (Array.isArray(a)) {\n                i = 0;\n\n                for (h = a.length; i < h; i++) {\n                  g.push(c(a[i], b, j));\n                }\n              }\n\n              a = f[0].substring(1, f[0].length - 1);\n              a = \"\" === a ? g : g.join(a);\n              break;\n            } else if (g) {\n              j[i] = j[i].replace(X, \"\");\n              a = a[j[i]]();\n              continue;\n            }\n\n            if (null === a || a[j[i]] === k) return k;\n            a = a[j[i]];\n          }\n        }\n\n        return a;\n      };\n\n      return function (b, e) {\n        return c(b, e, a);\n      };\n    }\n\n    return function (b) {\n      return b[a];\n    };\n  }\n\n  function N(a) {\n    if (h.isPlainObject(a)) return N(a._);\n    if (null === a) return function () {};\n    if (\"function\" === typeof a) return function (b, d, e) {\n      a(b, \"set\", d, e);\n    };\n\n    if (\"string\" === typeof a && (-1 !== a.indexOf(\".\") || -1 !== a.indexOf(\"[\") || -1 !== a.indexOf(\"(\"))) {\n      var b = function b(a, d, e) {\n        var e = La(e),\n            f;\n        f = e[e.length - 1];\n\n        for (var g, j, i = 0, h = e.length - 1; i < h; i++) {\n          if (\"__proto__\" === e[i] || \"constructor\" === e[i]) throw Error(\"Cannot set prototype values\");\n          g = e[i].match(da);\n          j = e[i].match(X);\n\n          if (g) {\n            e[i] = e[i].replace(da, \"\");\n            a[e[i]] = [];\n            f = e.slice();\n            f.splice(0, i + 1);\n            g = f.join(\".\");\n\n            if (Array.isArray(d)) {\n              j = 0;\n\n              for (h = d.length; j < h; j++) {\n                f = {}, b(f, d[j], g), a[e[i]].push(f);\n              }\n            } else a[e[i]] = d;\n\n            return;\n          }\n\n          j && (e[i] = e[i].replace(X, \"\"), a = a[e[i]](d));\n          if (null === a[e[i]] || a[e[i]] === k) a[e[i]] = {};\n          a = a[e[i]];\n        }\n\n        if (f.match(X)) a[f.replace(X, \"\")](d);else a[f.replace(da, \"\")] = d;\n      };\n\n      return function (c, d) {\n        return b(c, d, a);\n      };\n    }\n\n    return function (b, d) {\n      b[a] = d;\n    };\n  }\n\n  function Ma(a) {\n    return C(a.aoData, \"_aData\");\n  }\n\n  function pa(a) {\n    a.aoData.length = 0;\n    a.aiDisplayMaster.length = 0;\n    a.aiDisplay.length = 0;\n    a.aIds = {};\n  }\n\n  function qa(a, b, c) {\n    for (var d = -1, e = 0, f = a.length; e < f; e++) {\n      a[e] == b ? d = e : a[e] > b && a[e]--;\n    }\n\n    -1 != d && c === k && a.splice(d, 1);\n  }\n\n  function ea(a, b, c, d) {\n    var e = a.aoData[b],\n        f,\n        g = function g(c, d) {\n      for (; c.childNodes.length;) {\n        c.removeChild(c.firstChild);\n      }\n\n      c.innerHTML = B(a, b, d, \"display\");\n    };\n\n    if (\"dom\" === c || (!c || \"auto\" === c) && \"dom\" === e.src) e._aData = Ka(a, e, d, d === k ? k : e._aData).data;else {\n      var j = e.anCells;\n      if (j) if (d !== k) g(j[d], d);else {\n        c = 0;\n\n        for (f = j.length; c < f; c++) {\n          g(j[c], c);\n        }\n      }\n    }\n    e._aSortData = null;\n    e._aFilterData = null;\n    g = a.aoColumns;\n    if (d !== k) g[d].sType = null;else {\n      c = 0;\n\n      for (f = g.length; c < f; c++) {\n        g[c].sType = null;\n      }\n\n      Na(a, e);\n    }\n  }\n\n  function Ka(a, b, c, d) {\n    var e = [],\n        f = b.firstChild,\n        g,\n        j,\n        i = 0,\n        h,\n        m = a.aoColumns,\n        q = a._rowReadObject,\n        d = d !== k ? d : q ? {} : [],\n        s = function s(a, b) {\n      if (\"string\" === typeof a) {\n        var c = a.indexOf(\"@\");\n        -1 !== c && (c = a.substring(c + 1), N(a)(d, b.getAttribute(c)));\n      }\n    },\n        G = function G(a) {\n      if (c === k || c === i) j = m[i], h = a.innerHTML.trim(), j && j._bAttrSrc ? (N(j.mData._)(d, h), s(j.mData.sort, a), s(j.mData.type, a), s(j.mData.filter, a)) : q ? (j._setter || (j._setter = N(j.mData)), j._setter(d, h)) : d[i] = h;\n      i++;\n    };\n\n    if (f) for (; f;) {\n      g = f.nodeName.toUpperCase();\n      if (\"TD\" == g || \"TH\" == g) G(f), e.push(f);\n      f = f.nextSibling;\n    } else {\n      e = b.anCells;\n      f = 0;\n\n      for (g = e.length; f < g; f++) {\n        G(e[f]);\n      }\n    }\n    if (b = b.firstChild ? b : b.nTr) (b = b.getAttribute(\"id\")) && N(a.rowId)(d, b);\n    return {\n      data: d,\n      cells: e\n    };\n  }\n\n  function Ja(a, b, c, d) {\n    var e = a.aoData[b],\n        f = e._aData,\n        g = [],\n        j,\n        i,\n        n,\n        m,\n        q;\n\n    if (null === e.nTr) {\n      j = c || H.createElement(\"tr\");\n      e.nTr = j;\n      e.anCells = g;\n      j._DT_RowIndex = b;\n      Na(a, e);\n      n = 0;\n\n      for (m = a.aoColumns.length; n < m; n++) {\n        i = a.aoColumns[n];\n        e = (q = c ? !1 : !0) ? H.createElement(i.sCellType) : d[n];\n        e._DT_CellIndex = {\n          row: b,\n          column: n\n        };\n        g.push(e);\n        if (q || (i.mRender || i.mData !== n) && (!h.isPlainObject(i.mData) || i.mData._ !== n + \".display\")) e.innerHTML = B(a, b, n, \"display\");\n        i.sClass && (e.className += \" \" + i.sClass);\n        i.bVisible && !c ? j.appendChild(e) : !i.bVisible && c && e.parentNode.removeChild(e);\n        i.fnCreatedCell && i.fnCreatedCell.call(a.oInstance, e, B(a, b, n), f, b, n);\n      }\n\n      t(a, \"aoRowCreatedCallback\", null, [j, f, b, g]);\n    }\n  }\n\n  function Na(a, b) {\n    var c = b.nTr,\n        d = b._aData;\n\n    if (c) {\n      var e = a.rowIdFn(d);\n      e && (c.id = e);\n      d.DT_RowClass && (e = d.DT_RowClass.split(\" \"), b.__rowc = b.__rowc ? ra(b.__rowc.concat(e)) : e, h(c).removeClass(b.__rowc.join(\" \")).addClass(d.DT_RowClass));\n      d.DT_RowAttr && h(c).attr(d.DT_RowAttr);\n      d.DT_RowData && h(c).data(d.DT_RowData);\n    }\n  }\n\n  function mb(a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g = a.nTHead,\n        j = a.nTFoot,\n        i = 0 === h(\"th, td\", g).length,\n        n = a.oClasses,\n        m = a.aoColumns;\n    i && (e = h(\"<tr/>\").appendTo(g));\n    b = 0;\n\n    for (c = m.length; b < c; b++) {\n      f = m[b], d = h(f.nTh).addClass(f.sClass), i && d.appendTo(e), a.oFeatures.bSort && (d.addClass(f.sSortingClass), !1 !== f.bSortable && (d.attr(\"tabindex\", a.iTabIndex).attr(\"aria-controls\", a.sTableId), Oa(a, f.nTh, b))), f.sTitle != d[0].innerHTML && d.html(f.sTitle), Pa(a, \"header\")(a, d, f, n);\n    }\n\n    i && fa(a.aoHeader, g);\n    h(g).children(\"tr\").attr(\"role\", \"row\");\n    h(g).children(\"tr\").children(\"th, td\").addClass(n.sHeaderTH);\n    h(j).children(\"tr\").children(\"th, td\").addClass(n.sFooterTH);\n\n    if (null !== j) {\n      a = a.aoFooter[0];\n      b = 0;\n\n      for (c = a.length; b < c; b++) {\n        f = m[b], f.nTf = a[b].cell, f.sClass && h(f.nTf).addClass(f.sClass);\n      }\n    }\n  }\n\n  function ga(a, b, c) {\n    var d,\n        e,\n        f,\n        g = [],\n        j = [],\n        i = a.aoColumns.length,\n        n;\n\n    if (b) {\n      c === k && (c = !1);\n      d = 0;\n\n      for (e = b.length; d < e; d++) {\n        g[d] = b[d].slice();\n        g[d].nTr = b[d].nTr;\n\n        for (f = i - 1; 0 <= f; f--) {\n          !a.aoColumns[f].bVisible && !c && g[d].splice(f, 1);\n        }\n\n        j.push([]);\n      }\n\n      d = 0;\n\n      for (e = g.length; d < e; d++) {\n        if (a = g[d].nTr) for (; f = a.firstChild;) {\n          a.removeChild(f);\n        }\n        f = 0;\n\n        for (b = g[d].length; f < b; f++) {\n          if (n = i = 1, j[d][f] === k) {\n            a.appendChild(g[d][f].cell);\n\n            for (j[d][f] = 1; g[d + i] !== k && g[d][f].cell == g[d + i][f].cell;) {\n              j[d + i][f] = 1, i++;\n            }\n\n            for (; g[d][f + n] !== k && g[d][f].cell == g[d][f + n].cell;) {\n              for (c = 0; c < i; c++) {\n                j[d + c][f + n] = 1;\n              }\n\n              n++;\n            }\n\n            h(g[d][f].cell).attr(\"rowspan\", i).attr(\"colspan\", n);\n          }\n        }\n      }\n    }\n  }\n\n  function P(a) {\n    var b = t(a, \"aoPreDrawCallback\", \"preDraw\", [a]);\n    if (-1 !== h.inArray(!1, b)) D(a, !1);else {\n      var b = [],\n          c = 0,\n          d = a.asStripeClasses,\n          e = d.length,\n          f = a.oLanguage,\n          g = a.iInitDisplayStart,\n          j = \"ssp\" == y(a),\n          i = a.aiDisplay;\n      a.bDrawing = !0;\n      g !== k && -1 !== g && (a._iDisplayStart = j ? g : g >= a.fnRecordsDisplay() ? 0 : g, a.iInitDisplayStart = -1);\n      var g = a._iDisplayStart,\n          n = a.fnDisplayEnd();\n      if (a.bDeferLoading) a.bDeferLoading = !1, a.iDraw++, D(a, !1);else if (j) {\n        if (!a.bDestroying && !nb(a)) return;\n      } else a.iDraw++;\n\n      if (0 !== i.length) {\n        f = j ? a.aoData.length : n;\n\n        for (j = j ? 0 : g; j < f; j++) {\n          var m = i[j],\n              q = a.aoData[m];\n          null === q.nTr && Ja(a, m);\n          var s = q.nTr;\n\n          if (0 !== e) {\n            var G = d[c % e];\n            q._sRowStripe != G && (h(s).removeClass(q._sRowStripe).addClass(G), q._sRowStripe = G);\n          }\n\n          t(a, \"aoRowCallback\", null, [s, q._aData, c, j, m]);\n          b.push(s);\n          c++;\n        }\n      } else c = f.sZeroRecords, 1 == a.iDraw && \"ajax\" == y(a) ? c = f.sLoadingRecords : f.sEmptyTable && 0 === a.fnRecordsTotal() && (c = f.sEmptyTable), b[0] = h(\"<tr/>\", {\n        \"class\": e ? d[0] : \"\"\n      }).append(h(\"<td />\", {\n        valign: \"top\",\n        colSpan: W(a),\n        \"class\": a.oClasses.sRowEmpty\n      }).html(c))[0];\n\n      t(a, \"aoHeaderCallback\", \"header\", [h(a.nTHead).children(\"tr\")[0], Ma(a), g, n, i]);\n      t(a, \"aoFooterCallback\", \"footer\", [h(a.nTFoot).children(\"tr\")[0], Ma(a), g, n, i]);\n      d = h(a.nTBody);\n      d.children().detach();\n      d.append(h(b));\n      t(a, \"aoDrawCallback\", \"draw\", [a]);\n      a.bSorted = !1;\n      a.bFiltered = !1;\n      a.bDrawing = !1;\n    }\n  }\n\n  function T(a, b) {\n    var c = a.oFeatures,\n        d = c.bFilter;\n    c.bSort && ob(a);\n    d ? ha(a, a.oPreviousSearch) : a.aiDisplay = a.aiDisplayMaster.slice();\n    !0 !== b && (a._iDisplayStart = 0);\n    a._drawHold = b;\n    P(a);\n    a._drawHold = !1;\n  }\n\n  function pb(a) {\n    var b = a.oClasses,\n        c = h(a.nTable),\n        c = h(\"<div/>\").insertBefore(c),\n        d = a.oFeatures,\n        e = h(\"<div/>\", {\n      id: a.sTableId + \"_wrapper\",\n      \"class\": b.sWrapper + (a.nTFoot ? \"\" : \" \" + b.sNoFooter)\n    });\n    a.nHolding = c[0];\n    a.nTableWrapper = e[0];\n    a.nTableReinsertBefore = a.nTable.nextSibling;\n\n    for (var f = a.sDom.split(\"\"), g, j, i, n, m, q, k = 0; k < f.length; k++) {\n      g = null;\n      j = f[k];\n\n      if (\"<\" == j) {\n        i = h(\"<div/>\")[0];\n        n = f[k + 1];\n\n        if (\"'\" == n || '\"' == n) {\n          m = \"\";\n\n          for (q = 2; f[k + q] != n;) {\n            m += f[k + q], q++;\n          }\n\n          \"H\" == m ? m = b.sJUIHeader : \"F\" == m && (m = b.sJUIFooter);\n          -1 != m.indexOf(\".\") ? (n = m.split(\".\"), i.id = n[0].substr(1, n[0].length - 1), i.className = n[1]) : \"#\" == m.charAt(0) ? i.id = m.substr(1, m.length - 1) : i.className = m;\n          k += q;\n        }\n\n        e.append(i);\n        e = h(i);\n      } else if (\">\" == j) e = e.parent();else if (\"l\" == j && d.bPaginate && d.bLengthChange) g = qb(a);else if (\"f\" == j && d.bFilter) g = rb(a);else if (\"r\" == j && d.bProcessing) g = sb(a);else if (\"t\" == j) g = tb(a);else if (\"i\" == j && d.bInfo) g = ub(a);else if (\"p\" == j && d.bPaginate) g = vb(a);else if (0 !== l.ext.feature.length) {\n        i = l.ext.feature;\n        q = 0;\n\n        for (n = i.length; q < n; q++) {\n          if (j == i[q].cFeature) {\n            g = i[q].fnInit(a);\n            break;\n          }\n        }\n      }\n\n      g && (i = a.aanFeatures, i[j] || (i[j] = []), i[j].push(g), e.append(g));\n    }\n\n    c.replaceWith(e);\n    a.nHolding = null;\n  }\n\n  function fa(a, b) {\n    var c = h(b).children(\"tr\"),\n        d,\n        e,\n        f,\n        g,\n        j,\n        i,\n        n,\n        m,\n        q,\n        k;\n    a.splice(0, a.length);\n    f = 0;\n\n    for (i = c.length; f < i; f++) {\n      a.push([]);\n    }\n\n    f = 0;\n\n    for (i = c.length; f < i; f++) {\n      d = c[f];\n\n      for (e = d.firstChild; e;) {\n        if (\"TD\" == e.nodeName.toUpperCase() || \"TH\" == e.nodeName.toUpperCase()) {\n          m = 1 * e.getAttribute(\"colspan\");\n          q = 1 * e.getAttribute(\"rowspan\");\n          m = !m || 0 === m || 1 === m ? 1 : m;\n          q = !q || 0 === q || 1 === q ? 1 : q;\n          g = 0;\n\n          for (j = a[f]; j[g];) {\n            g++;\n          }\n\n          n = g;\n          k = 1 === m ? !0 : !1;\n\n          for (j = 0; j < m; j++) {\n            for (g = 0; g < q; g++) {\n              a[f + g][n + j] = {\n                cell: e,\n                unique: k\n              }, a[f + g].nTr = d;\n            }\n          }\n        }\n\n        e = e.nextSibling;\n      }\n    }\n  }\n\n  function sa(a, b, c) {\n    var d = [];\n    c || (c = a.aoHeader, b && (c = [], fa(c, b)));\n\n    for (var b = 0, e = c.length; b < e; b++) {\n      for (var f = 0, g = c[b].length; f < g; f++) {\n        if (c[b][f].unique && (!d[f] || !a.bSortCellsTop)) d[f] = c[b][f].cell;\n      }\n    }\n\n    return d;\n  }\n\n  function ta(a, b, c) {\n    t(a, \"aoServerParams\", \"serverParams\", [b]);\n\n    if (b && Array.isArray(b)) {\n      var d = {},\n          e = /(.*?)\\[\\]$/;\n      h.each(b, function (a, b) {\n        var c = b.name.match(e);\n        c ? (c = c[0], d[c] || (d[c] = []), d[c].push(b.value)) : d[b.name] = b.value;\n      });\n      b = d;\n    }\n\n    var f,\n        g = a.ajax,\n        j = a.oInstance,\n        i = function i(b) {\n      t(a, null, \"xhr\", [a, b, a.jqXHR]);\n      c(b);\n    };\n\n    if (h.isPlainObject(g) && g.data) {\n      f = g.data;\n      var n = \"function\" === typeof f ? f(b, a) : f,\n          b = \"function\" === typeof f && n ? n : h.extend(!0, b, n);\n      delete g.data;\n    }\n\n    n = {\n      data: b,\n      success: function success(b) {\n        var c = b.error || b.sError;\n        c && K(a, 0, c);\n        a.json = b;\n        i(b);\n      },\n      dataType: \"json\",\n      cache: !1,\n      type: a.sServerMethod,\n      error: function error(b, c) {\n        var d = t(a, null, \"xhr\", [a, null, a.jqXHR]);\n        -1 === h.inArray(!0, d) && (\"parsererror\" == c ? K(a, 0, \"Invalid JSON response\", 1) : 4 === b.readyState && K(a, 0, \"Ajax error\", 7));\n        D(a, !1);\n      }\n    };\n    a.oAjaxData = b;\n    t(a, null, \"preXhr\", [a, b]);\n    a.fnServerData ? a.fnServerData.call(j, a.sAjaxSource, h.map(b, function (a, b) {\n      return {\n        name: b,\n        value: a\n      };\n    }), i, a) : a.sAjaxSource || \"string\" === typeof g ? a.jqXHR = h.ajax(h.extend(n, {\n      url: g || a.sAjaxSource\n    })) : \"function\" === typeof g ? a.jqXHR = g.call(j, b, i, a) : (a.jqXHR = h.ajax(h.extend(n, g)), g.data = f);\n  }\n\n  function nb(a) {\n    return a.bAjaxDataGet ? (a.iDraw++, D(a, !0), ta(a, wb(a), function (b) {\n      xb(a, b);\n    }), !1) : !0;\n  }\n\n  function wb(a) {\n    var b = a.aoColumns,\n        c = b.length,\n        d = a.oFeatures,\n        e = a.oPreviousSearch,\n        f = a.aoPreSearchCols,\n        g,\n        j = [],\n        i,\n        n,\n        m,\n        k = Y(a);\n    g = a._iDisplayStart;\n    i = !1 !== d.bPaginate ? a._iDisplayLength : -1;\n\n    var s = function s(a, b) {\n      j.push({\n        name: a,\n        value: b\n      });\n    };\n\n    s(\"sEcho\", a.iDraw);\n    s(\"iColumns\", c);\n    s(\"sColumns\", C(b, \"sName\").join(\",\"));\n    s(\"iDisplayStart\", g);\n    s(\"iDisplayLength\", i);\n    var G = {\n      draw: a.iDraw,\n      columns: [],\n      order: [],\n      start: g,\n      length: i,\n      search: {\n        value: e.sSearch,\n        regex: e.bRegex\n      }\n    };\n\n    for (g = 0; g < c; g++) {\n      n = b[g], m = f[g], i = \"function\" == typeof n.mData ? \"function\" : n.mData, G.columns.push({\n        data: i,\n        name: n.sName,\n        searchable: n.bSearchable,\n        orderable: n.bSortable,\n        search: {\n          value: m.sSearch,\n          regex: m.bRegex\n        }\n      }), s(\"mDataProp_\" + g, i), d.bFilter && (s(\"sSearch_\" + g, m.sSearch), s(\"bRegex_\" + g, m.bRegex), s(\"bSearchable_\" + g, n.bSearchable)), d.bSort && s(\"bSortable_\" + g, n.bSortable);\n    }\n\n    d.bFilter && (s(\"sSearch\", e.sSearch), s(\"bRegex\", e.bRegex));\n    d.bSort && (h.each(k, function (a, b) {\n      G.order.push({\n        column: b.col,\n        dir: b.dir\n      });\n      s(\"iSortCol_\" + a, b.col);\n      s(\"sSortDir_\" + a, b.dir);\n    }), s(\"iSortingCols\", k.length));\n    b = l.ext.legacy.ajax;\n    return null === b ? a.sAjaxSource ? j : G : b ? j : G;\n  }\n\n  function xb(a, b) {\n    var c = ua(a, b),\n        d = b.sEcho !== k ? b.sEcho : b.draw,\n        e = b.iTotalRecords !== k ? b.iTotalRecords : b.recordsTotal,\n        f = b.iTotalDisplayRecords !== k ? b.iTotalDisplayRecords : b.recordsFiltered;\n\n    if (d !== k) {\n      if (1 * d < a.iDraw) return;\n      a.iDraw = 1 * d;\n    }\n\n    pa(a);\n    a._iRecordsTotal = parseInt(e, 10);\n    a._iRecordsDisplay = parseInt(f, 10);\n    d = 0;\n\n    for (e = c.length; d < e; d++) {\n      O(a, c[d]);\n    }\n\n    a.aiDisplay = a.aiDisplayMaster.slice();\n    a.bAjaxDataGet = !1;\n    P(a);\n    a._bInitComplete || va(a, b);\n    a.bAjaxDataGet = !0;\n    D(a, !1);\n  }\n\n  function ua(a, b) {\n    var c = h.isPlainObject(a.ajax) && a.ajax.dataSrc !== k ? a.ajax.dataSrc : a.sAjaxDataProp;\n    return \"data\" === c ? b.aaData || b[c] : \"\" !== c ? S(c)(b) : b;\n  }\n\n  function rb(a) {\n    var b = a.oClasses,\n        c = a.sTableId,\n        d = a.oLanguage,\n        e = a.oPreviousSearch,\n        f = a.aanFeatures,\n        g = '<input type=\"search\" class=\"' + b.sFilterInput + '\"/>',\n        j = d.sSearch,\n        j = j.match(/_INPUT_/) ? j.replace(\"_INPUT_\", g) : j + g,\n        b = h(\"<div/>\", {\n      id: !f.f ? c + \"_filter\" : null,\n      \"class\": b.sFilter\n    }).append(h(\"<label/>\").append(j)),\n        i = function i() {\n      var b = !this.value ? \"\" : this.value;\n      b != e.sSearch && (ha(a, {\n        sSearch: b,\n        bRegex: e.bRegex,\n        bSmart: e.bSmart,\n        bCaseInsensitive: e.bCaseInsensitive\n      }), a._iDisplayStart = 0, P(a));\n    },\n        f = null !== a.searchDelay ? a.searchDelay : \"ssp\" === y(a) ? 400 : 0,\n        n = h(\"input\", b).val(e.sSearch).attr(\"placeholder\", d.sSearchPlaceholder).on(\"keyup.DT search.DT input.DT paste.DT cut.DT\", f ? Qa(i, f) : i).on(\"mouseup\", function () {\n      setTimeout(function () {\n        i.call(n[0]);\n      }, 10);\n    }).on(\"keypress.DT\", function (a) {\n      if (13 == a.keyCode) return !1;\n    }).attr(\"aria-controls\", c);\n\n    h(a.nTable).on(\"search.dt.DT\", function (b, c) {\n      if (a === c) try {\n        n[0] !== H.activeElement && n.val(e.sSearch);\n      } catch (d) {}\n    });\n    return b[0];\n  }\n\n  function ha(a, b, c) {\n    var d = a.oPreviousSearch,\n        e = a.aoPreSearchCols,\n        f = function f(a) {\n      d.sSearch = a.sSearch;\n      d.bRegex = a.bRegex;\n      d.bSmart = a.bSmart;\n      d.bCaseInsensitive = a.bCaseInsensitive;\n    };\n\n    Ia(a);\n\n    if (\"ssp\" != y(a)) {\n      yb(a, b.sSearch, c, b.bEscapeRegex !== k ? !b.bEscapeRegex : b.bRegex, b.bSmart, b.bCaseInsensitive);\n      f(b);\n\n      for (b = 0; b < e.length; b++) {\n        zb(a, e[b].sSearch, b, e[b].bEscapeRegex !== k ? !e[b].bEscapeRegex : e[b].bRegex, e[b].bSmart, e[b].bCaseInsensitive);\n      }\n\n      Ab(a);\n    } else f(b);\n\n    a.bFiltered = !0;\n    t(a, null, \"search\", [a]);\n  }\n\n  function Ab(a) {\n    for (var b = l.ext.search, c = a.aiDisplay, d, e, f = 0, g = b.length; f < g; f++) {\n      for (var j = [], i = 0, n = c.length; i < n; i++) {\n        e = c[i], d = a.aoData[e], b[f](a, d._aFilterData, e, d._aData, i) && j.push(e);\n      }\n\n      c.length = 0;\n      h.merge(c, j);\n    }\n  }\n\n  function zb(a, b, c, d, e, f) {\n    if (\"\" !== b) {\n      for (var g = [], j = a.aiDisplay, d = Ra(b, d, e, f), e = 0; e < j.length; e++) {\n        b = a.aoData[j[e]]._aFilterData[c], d.test(b) && g.push(j[e]);\n      }\n\n      a.aiDisplay = g;\n    }\n  }\n\n  function yb(a, b, c, d, e, f) {\n    var e = Ra(b, d, e, f),\n        g = a.oPreviousSearch.sSearch,\n        j = a.aiDisplayMaster,\n        i,\n        f = [];\n    0 !== l.ext.search.length && (c = !0);\n    i = Bb(a);\n    if (0 >= b.length) a.aiDisplay = j.slice();else {\n      if (i || c || d || g.length > b.length || 0 !== b.indexOf(g) || a.bSorted) a.aiDisplay = j.slice();\n      b = a.aiDisplay;\n\n      for (c = 0; c < b.length; c++) {\n        e.test(a.aoData[b[c]]._sFilterRow) && f.push(b[c]);\n      }\n\n      a.aiDisplay = f;\n    }\n  }\n\n  function Ra(a, b, c, d) {\n    a = b ? a : Sa(a);\n    c && (a = \"^(?=.*?\" + h.map(a.match(/\"[^\"]+\"|[^ ]+/g) || [\"\"], function (a) {\n      if ('\"' === a.charAt(0)) var b = a.match(/^\"(.*)\"$/),\n          a = b ? b[1] : a;\n      return a.replace('\"', \"\");\n    }).join(\")(?=.*?\") + \").*$\");\n    return RegExp(a, d ? \"i\" : \"\");\n  }\n\n  function Bb(a) {\n    var b = a.aoColumns,\n        c,\n        d,\n        e,\n        f,\n        g,\n        j,\n        i,\n        h,\n        m = l.ext.type.search;\n    c = !1;\n    d = 0;\n\n    for (f = a.aoData.length; d < f; d++) {\n      if (h = a.aoData[d], !h._aFilterData) {\n        j = [];\n        e = 0;\n\n        for (g = b.length; e < g; e++) {\n          c = b[e], c.bSearchable ? (i = B(a, d, e, \"filter\"), m[c.sType] && (i = m[c.sType](i)), null === i && (i = \"\"), \"string\" !== typeof i && i.toString && (i = i.toString())) : i = \"\", i.indexOf && -1 !== i.indexOf(\"&\") && (wa.innerHTML = i, i = Zb ? wa.textContent : wa.innerText), i.replace && (i = i.replace(/[\\r\\n\\u2028]/g, \"\")), j.push(i);\n        }\n\n        h._aFilterData = j;\n        h._sFilterRow = j.join(\"  \");\n        c = !0;\n      }\n    }\n\n    return c;\n  }\n\n  function Cb(a) {\n    return {\n      search: a.sSearch,\n      smart: a.bSmart,\n      regex: a.bRegex,\n      caseInsensitive: a.bCaseInsensitive\n    };\n  }\n\n  function Db(a) {\n    return {\n      sSearch: a.search,\n      bSmart: a.smart,\n      bRegex: a.regex,\n      bCaseInsensitive: a.caseInsensitive\n    };\n  }\n\n  function ub(a) {\n    var b = a.sTableId,\n        c = a.aanFeatures.i,\n        d = h(\"<div/>\", {\n      \"class\": a.oClasses.sInfo,\n      id: !c ? b + \"_info\" : null\n    });\n    c || (a.aoDrawCallback.push({\n      fn: Eb,\n      sName: \"information\"\n    }), d.attr(\"role\", \"status\").attr(\"aria-live\", \"polite\"), h(a.nTable).attr(\"aria-describedby\", b + \"_info\"));\n    return d[0];\n  }\n\n  function Eb(a) {\n    var b = a.aanFeatures.i;\n\n    if (0 !== b.length) {\n      var c = a.oLanguage,\n          d = a._iDisplayStart + 1,\n          e = a.fnDisplayEnd(),\n          f = a.fnRecordsTotal(),\n          g = a.fnRecordsDisplay(),\n          j = g ? c.sInfo : c.sInfoEmpty;\n      g !== f && (j += \" \" + c.sInfoFiltered);\n      j += c.sInfoPostFix;\n      j = Fb(a, j);\n      c = c.fnInfoCallback;\n      null !== c && (j = c.call(a.oInstance, a, d, e, f, g, j));\n      h(b).html(j);\n    }\n  }\n\n  function Fb(a, b) {\n    var c = a.fnFormatNumber,\n        d = a._iDisplayStart + 1,\n        e = a._iDisplayLength,\n        f = a.fnRecordsDisplay(),\n        g = -1 === e;\n    return b.replace(/_START_/g, c.call(a, d)).replace(/_END_/g, c.call(a, a.fnDisplayEnd())).replace(/_MAX_/g, c.call(a, a.fnRecordsTotal())).replace(/_TOTAL_/g, c.call(a, f)).replace(/_PAGE_/g, c.call(a, g ? 1 : Math.ceil(d / e))).replace(/_PAGES_/g, c.call(a, g ? 1 : Math.ceil(f / e)));\n  }\n\n  function ia(a) {\n    var b,\n        c,\n        d = a.iInitDisplayStart,\n        e = a.aoColumns,\n        f;\n    c = a.oFeatures;\n    var g = a.bDeferLoading;\n\n    if (a.bInitialised) {\n      pb(a);\n      mb(a);\n      ga(a, a.aoHeader);\n      ga(a, a.aoFooter);\n      D(a, !0);\n      c.bAutoWidth && Ha(a);\n      b = 0;\n\n      for (c = e.length; b < c; b++) {\n        f = e[b], f.sWidth && (f.nTh.style.width = w(f.sWidth));\n      }\n\n      t(a, null, \"preInit\", [a]);\n      T(a);\n      e = y(a);\n      if (\"ssp\" != e || g) \"ajax\" == e ? ta(a, [], function (c) {\n        var f = ua(a, c);\n\n        for (b = 0; b < f.length; b++) {\n          O(a, f[b]);\n        }\n\n        a.iInitDisplayStart = d;\n        T(a);\n        D(a, !1);\n        va(a, c);\n      }, a) : (D(a, !1), va(a));\n    } else setTimeout(function () {\n      ia(a);\n    }, 200);\n  }\n\n  function va(a, b) {\n    a._bInitComplete = !0;\n    (b || a.oInit.aaData) && aa(a);\n    t(a, null, \"plugin-init\", [a, b]);\n    t(a, \"aoInitComplete\", \"init\", [a, b]);\n  }\n\n  function Ta(a, b) {\n    var c = parseInt(b, 10);\n    a._iDisplayLength = c;\n    Ua(a);\n    t(a, null, \"length\", [a, c]);\n  }\n\n  function qb(a) {\n    for (var b = a.oClasses, c = a.sTableId, d = a.aLengthMenu, e = Array.isArray(d[0]), f = e ? d[0] : d, d = e ? d[1] : d, e = h(\"<select/>\", {\n      name: c + \"_length\",\n      \"aria-controls\": c,\n      \"class\": b.sLengthSelect\n    }), g = 0, j = f.length; g < j; g++) {\n      e[0][g] = new Option(\"number\" === typeof d[g] ? a.fnFormatNumber(d[g]) : d[g], f[g]);\n    }\n\n    var i = h(\"<div><label/></div>\").addClass(b.sLength);\n    a.aanFeatures.l || (i[0].id = c + \"_length\");\n    i.children().append(a.oLanguage.sLengthMenu.replace(\"_MENU_\", e[0].outerHTML));\n    h(\"select\", i).val(a._iDisplayLength).on(\"change.DT\", function () {\n      Ta(a, h(this).val());\n      P(a);\n    });\n    h(a.nTable).on(\"length.dt.DT\", function (b, c, d) {\n      a === c && h(\"select\", i).val(d);\n    });\n    return i[0];\n  }\n\n  function vb(a) {\n    var b = a.sPaginationType,\n        c = l.ext.pager[b],\n        d = \"function\" === typeof c,\n        e = function e(a) {\n      P(a);\n    },\n        b = h(\"<div/>\").addClass(a.oClasses.sPaging + b)[0],\n        f = a.aanFeatures;\n\n    d || c.fnInit(a, b, e);\n    f.p || (b.id = a.sTableId + \"_paginate\", a.aoDrawCallback.push({\n      fn: function fn(a) {\n        if (d) {\n          var b = a._iDisplayStart,\n              i = a._iDisplayLength,\n              h = a.fnRecordsDisplay(),\n              m = -1 === i,\n              b = m ? 0 : Math.ceil(b / i),\n              i = m ? 1 : Math.ceil(h / i),\n              h = c(b, i),\n              k,\n              m = 0;\n\n          for (k = f.p.length; m < k; m++) {\n            Pa(a, \"pageButton\")(a, f.p[m], m, h, b, i);\n          }\n        } else c.fnUpdate(a, e);\n      },\n      sName: \"pagination\"\n    }));\n    return b;\n  }\n\n  function Va(a, b, c) {\n    var d = a._iDisplayStart,\n        e = a._iDisplayLength,\n        f = a.fnRecordsDisplay();\n    0 === f || -1 === e ? d = 0 : \"number\" === typeof b ? (d = b * e, d > f && (d = 0)) : \"first\" == b ? d = 0 : \"previous\" == b ? (d = 0 <= e ? d - e : 0, 0 > d && (d = 0)) : \"next\" == b ? d + e < f && (d += e) : \"last\" == b ? d = Math.floor((f - 1) / e) * e : K(a, 0, \"Unknown paging action: \" + b, 5);\n    b = a._iDisplayStart !== d;\n    a._iDisplayStart = d;\n    b && (t(a, null, \"page\", [a]), c && P(a));\n    return b;\n  }\n\n  function sb(a) {\n    return h(\"<div/>\", {\n      id: !a.aanFeatures.r ? a.sTableId + \"_processing\" : null,\n      \"class\": a.oClasses.sProcessing\n    }).html(a.oLanguage.sProcessing).insertBefore(a.nTable)[0];\n  }\n\n  function D(a, b) {\n    a.oFeatures.bProcessing && h(a.aanFeatures.r).css(\"display\", b ? \"block\" : \"none\");\n    t(a, null, \"processing\", [a, b]);\n  }\n\n  function tb(a) {\n    var b = h(a.nTable);\n    b.attr(\"role\", \"grid\");\n    var c = a.oScroll;\n    if (\"\" === c.sX && \"\" === c.sY) return a.nTable;\n    var d = c.sX,\n        e = c.sY,\n        f = a.oClasses,\n        g = b.children(\"caption\"),\n        j = g.length ? g[0]._captionSide : null,\n        i = h(b[0].cloneNode(!1)),\n        n = h(b[0].cloneNode(!1)),\n        m = b.children(\"tfoot\");\n    m.length || (m = null);\n    i = h(\"<div/>\", {\n      \"class\": f.sScrollWrapper\n    }).append(h(\"<div/>\", {\n      \"class\": f.sScrollHead\n    }).css({\n      overflow: \"hidden\",\n      position: \"relative\",\n      border: 0,\n      width: d ? !d ? null : w(d) : \"100%\"\n    }).append(h(\"<div/>\", {\n      \"class\": f.sScrollHeadInner\n    }).css({\n      \"box-sizing\": \"content-box\",\n      width: c.sXInner || \"100%\"\n    }).append(i.removeAttr(\"id\").css(\"margin-left\", 0).append(\"top\" === j ? g : null).append(b.children(\"thead\"))))).append(h(\"<div/>\", {\n      \"class\": f.sScrollBody\n    }).css({\n      position: \"relative\",\n      overflow: \"auto\",\n      width: !d ? null : w(d)\n    }).append(b));\n    m && i.append(h(\"<div/>\", {\n      \"class\": f.sScrollFoot\n    }).css({\n      overflow: \"hidden\",\n      border: 0,\n      width: d ? !d ? null : w(d) : \"100%\"\n    }).append(h(\"<div/>\", {\n      \"class\": f.sScrollFootInner\n    }).append(n.removeAttr(\"id\").css(\"margin-left\", 0).append(\"bottom\" === j ? g : null).append(b.children(\"tfoot\")))));\n    var b = i.children(),\n        k = b[0],\n        f = b[1],\n        s = m ? b[2] : null;\n    if (d) h(f).on(\"scroll.DT\", function () {\n      var a = this.scrollLeft;\n      k.scrollLeft = a;\n      m && (s.scrollLeft = a);\n    });\n    h(f).css(\"max-height\", e);\n    c.bCollapse || h(f).css(\"height\", e);\n    a.nScrollHead = k;\n    a.nScrollBody = f;\n    a.nScrollFoot = s;\n    a.aoDrawCallback.push({\n      fn: ma,\n      sName: \"scrolling\"\n    });\n    return i[0];\n  }\n\n  function ma(a) {\n    var b = a.oScroll,\n        c = b.sX,\n        d = b.sXInner,\n        e = b.sY,\n        b = b.iBarWidth,\n        f = h(a.nScrollHead),\n        g = f[0].style,\n        j = f.children(\"div\"),\n        i = j[0].style,\n        n = j.children(\"table\"),\n        j = a.nScrollBody,\n        m = h(j),\n        q = j.style,\n        s = h(a.nScrollFoot).children(\"div\"),\n        l = s.children(\"table\"),\n        o = h(a.nTHead),\n        p = h(a.nTable),\n        r = p[0],\n        t = r.style,\n        u = a.nTFoot ? h(a.nTFoot) : null,\n        U = a.oBrowser,\n        V = U.bScrollOversize,\n        $b = C(a.aoColumns, \"nTh\"),\n        Q,\n        L,\n        R,\n        xa,\n        v = [],\n        x = [],\n        y = [],\n        z = [],\n        A,\n        B = function B(a) {\n      a = a.style;\n      a.paddingTop = \"0\";\n      a.paddingBottom = \"0\";\n      a.borderTopWidth = \"0\";\n      a.borderBottomWidth = \"0\";\n      a.height = 0;\n    };\n\n    L = j.scrollHeight > j.clientHeight;\n    if (a.scrollBarVis !== L && a.scrollBarVis !== k) a.scrollBarVis = L, aa(a);else {\n      a.scrollBarVis = L;\n      p.children(\"thead, tfoot\").remove();\n      u && (R = u.clone().prependTo(p), Q = u.find(\"tr\"), R = R.find(\"tr\"));\n      xa = o.clone().prependTo(p);\n      o = o.find(\"tr\");\n      L = xa.find(\"tr\");\n      xa.find(\"th, td\").removeAttr(\"tabindex\");\n      c || (q.width = \"100%\", f[0].style.width = \"100%\");\n      h.each(sa(a, xa), function (b, c) {\n        A = ba(a, b);\n        c.style.width = a.aoColumns[A].sWidth;\n      });\n      u && I(function (a) {\n        a.style.width = \"\";\n      }, R);\n      f = p.outerWidth();\n\n      if (\"\" === c) {\n        t.width = \"100%\";\n        if (V && (p.find(\"tbody\").height() > j.offsetHeight || \"scroll\" == m.css(\"overflow-y\"))) t.width = w(p.outerWidth() - b);\n        f = p.outerWidth();\n      } else \"\" !== d && (t.width = w(d), f = p.outerWidth());\n\n      I(B, L);\n      I(function (a) {\n        y.push(a.innerHTML);\n        v.push(w(h(a).css(\"width\")));\n      }, L);\n      I(function (a, b) {\n        if (h.inArray(a, $b) !== -1) a.style.width = v[b];\n      }, o);\n      h(L).height(0);\n      u && (I(B, R), I(function (a) {\n        z.push(a.innerHTML);\n        x.push(w(h(a).css(\"width\")));\n      }, R), I(function (a, b) {\n        a.style.width = x[b];\n      }, Q), h(R).height(0));\n      I(function (a, b) {\n        a.innerHTML = '<div class=\"dataTables_sizing\">' + y[b] + \"</div>\";\n        a.childNodes[0].style.height = \"0\";\n        a.childNodes[0].style.overflow = \"hidden\";\n        a.style.width = v[b];\n      }, L);\n      u && I(function (a, b) {\n        a.innerHTML = '<div class=\"dataTables_sizing\">' + z[b] + \"</div>\";\n        a.childNodes[0].style.height = \"0\";\n        a.childNodes[0].style.overflow = \"hidden\";\n        a.style.width = x[b];\n      }, R);\n\n      if (p.outerWidth() < f) {\n        Q = j.scrollHeight > j.offsetHeight || \"scroll\" == m.css(\"overflow-y\") ? f + b : f;\n        if (V && (j.scrollHeight > j.offsetHeight || \"scroll\" == m.css(\"overflow-y\"))) t.width = w(Q - b);\n        (\"\" === c || \"\" !== d) && K(a, 1, \"Possible column misalignment\", 6);\n      } else Q = \"100%\";\n\n      q.width = w(Q);\n      g.width = w(Q);\n      u && (a.nScrollFoot.style.width = w(Q));\n      !e && V && (q.height = w(r.offsetHeight + b));\n      c = p.outerWidth();\n      n[0].style.width = w(c);\n      i.width = w(c);\n      d = p.height() > j.clientHeight || \"scroll\" == m.css(\"overflow-y\");\n      e = \"padding\" + (U.bScrollbarLeft ? \"Left\" : \"Right\");\n      i[e] = d ? b + \"px\" : \"0px\";\n      u && (l[0].style.width = w(c), s[0].style.width = w(c), s[0].style[e] = d ? b + \"px\" : \"0px\");\n      p.children(\"colgroup\").insertBefore(p.children(\"thead\"));\n      m.trigger(\"scroll\");\n      if ((a.bSorted || a.bFiltered) && !a._drawHold) j.scrollTop = 0;\n    }\n  }\n\n  function I(a, b, c) {\n    for (var d = 0, e = 0, f = b.length, g, j; e < f;) {\n      g = b[e].firstChild;\n\n      for (j = c ? c[e].firstChild : null; g;) {\n        1 === g.nodeType && (c ? a(g, j, d) : a(g, d), d++), g = g.nextSibling, j = c ? j.nextSibling : null;\n      }\n\n      e++;\n    }\n  }\n\n  function Ha(a) {\n    var b = a.nTable,\n        c = a.aoColumns,\n        d = a.oScroll,\n        e = d.sY,\n        f = d.sX,\n        g = d.sXInner,\n        j = c.length,\n        i = na(a, \"bVisible\"),\n        n = h(\"th\", a.nTHead),\n        m = b.getAttribute(\"width\"),\n        k = b.parentNode,\n        s = !1,\n        l,\n        o,\n        p = a.oBrowser,\n        d = p.bScrollOversize;\n    (l = b.style.width) && -1 !== l.indexOf(\"%\") && (m = l);\n\n    for (l = 0; l < i.length; l++) {\n      o = c[i[l]], null !== o.sWidth && (o.sWidth = Gb(o.sWidthOrig, k), s = !0);\n    }\n\n    if (d || !s && !f && !e && j == W(a) && j == n.length) for (l = 0; l < j; l++) {\n      i = ba(a, l), null !== i && (c[i].sWidth = w(n.eq(l).width()));\n    } else {\n      j = h(b).clone().css(\"visibility\", \"hidden\").removeAttr(\"id\");\n      j.find(\"tbody tr\").remove();\n      var r = h(\"<tr/>\").appendTo(j.find(\"tbody\"));\n      j.find(\"thead, tfoot\").remove();\n      j.append(h(a.nTHead).clone()).append(h(a.nTFoot).clone());\n      j.find(\"tfoot th, tfoot td\").css(\"width\", \"\");\n      n = sa(a, j.find(\"thead\")[0]);\n\n      for (l = 0; l < i.length; l++) {\n        o = c[i[l]], n[l].style.width = null !== o.sWidthOrig && \"\" !== o.sWidthOrig ? w(o.sWidthOrig) : \"\", o.sWidthOrig && f && h(n[l]).append(h(\"<div/>\").css({\n          width: o.sWidthOrig,\n          margin: 0,\n          padding: 0,\n          border: 0,\n          height: 1\n        }));\n      }\n\n      if (a.aoData.length) for (l = 0; l < i.length; l++) {\n        s = i[l], o = c[s], h(Hb(a, s)).clone(!1).append(o.sContentPadding).appendTo(r);\n      }\n      h(\"[name]\", j).removeAttr(\"name\");\n      o = h(\"<div/>\").css(f || e ? {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        height: 1,\n        right: 0,\n        overflow: \"hidden\"\n      } : {}).append(j).appendTo(k);\n      f && g ? j.width(g) : f ? (j.css(\"width\", \"auto\"), j.removeAttr(\"width\"), j.width() < k.clientWidth && m && j.width(k.clientWidth)) : e ? j.width(k.clientWidth) : m && j.width(m);\n\n      for (l = e = 0; l < i.length; l++) {\n        k = h(n[l]), g = k.outerWidth() - k.width(), k = p.bBounding ? Math.ceil(n[l].getBoundingClientRect().width) : k.outerWidth(), e += k, c[i[l]].sWidth = w(k - g);\n      }\n\n      b.style.width = w(e);\n      o.remove();\n    }\n    m && (b.style.width = w(m));\n    if ((m || f) && !a._reszEvt) b = function b() {\n      h(E).on(\"resize.DT-\" + a.sInstance, Qa(function () {\n        aa(a);\n      }));\n    }, d ? setTimeout(b, 1E3) : b(), a._reszEvt = !0;\n  }\n\n  function Gb(a, b) {\n    if (!a) return 0;\n    var c = h(\"<div/>\").css(\"width\", w(a)).appendTo(b || H.body),\n        d = c[0].offsetWidth;\n    c.remove();\n    return d;\n  }\n\n  function Hb(a, b) {\n    var c = Ib(a, b);\n    if (0 > c) return null;\n    var d = a.aoData[c];\n    return !d.nTr ? h(\"<td/>\").html(B(a, c, b, \"display\"))[0] : d.anCells[b];\n  }\n\n  function Ib(a, b) {\n    for (var c, d = -1, e = -1, f = 0, g = a.aoData.length; f < g; f++) {\n      c = B(a, f, b, \"display\") + \"\", c = c.replace(ac, \"\"), c = c.replace(/&nbsp;/g, \" \"), c.length > d && (d = c.length, e = f);\n    }\n\n    return e;\n  }\n\n  function w(a) {\n    return null === a ? \"0px\" : \"number\" == typeof a ? 0 > a ? \"0px\" : a + \"px\" : a.match(/\\d$/) ? a + \"px\" : a;\n  }\n\n  function Y(a) {\n    var b,\n        c,\n        d = [],\n        e = a.aoColumns,\n        f,\n        g,\n        j,\n        i;\n    b = a.aaSortingFixed;\n    c = h.isPlainObject(b);\n    var n = [];\n\n    f = function f(a) {\n      a.length && !Array.isArray(a[0]) ? n.push(a) : h.merge(n, a);\n    };\n\n    Array.isArray(b) && f(b);\n    c && b.pre && f(b.pre);\n    f(a.aaSorting);\n    c && b.post && f(b.post);\n\n    for (a = 0; a < n.length; a++) {\n      i = n[a][0];\n      f = e[i].aDataSort;\n      b = 0;\n\n      for (c = f.length; b < c; b++) {\n        g = f[b], j = e[g].sType || \"string\", n[a]._idx === k && (n[a]._idx = h.inArray(n[a][1], e[g].asSorting)), d.push({\n          src: i,\n          col: g,\n          dir: n[a][1],\n          index: n[a]._idx,\n          type: j,\n          formatter: l.ext.type.order[j + \"-pre\"]\n        });\n      }\n    }\n\n    return d;\n  }\n\n  function ob(a) {\n    var b,\n        c,\n        d = [],\n        e = l.ext.type.order,\n        f = a.aoData,\n        g = 0,\n        j,\n        i = a.aiDisplayMaster,\n        h;\n    Ia(a);\n    h = Y(a);\n    b = 0;\n\n    for (c = h.length; b < c; b++) {\n      j = h[b], j.formatter && g++, Jb(a, j.col);\n    }\n\n    if (\"ssp\" != y(a) && 0 !== h.length) {\n      b = 0;\n\n      for (c = i.length; b < c; b++) {\n        d[i[b]] = b;\n      }\n\n      g === h.length ? i.sort(function (a, b) {\n        var c,\n            e,\n            g,\n            j,\n            i = h.length,\n            k = f[a]._aSortData,\n            l = f[b]._aSortData;\n\n        for (g = 0; g < i; g++) {\n          if (j = h[g], c = k[j.col], e = l[j.col], c = c < e ? -1 : c > e ? 1 : 0, 0 !== c) return \"asc\" === j.dir ? c : -c;\n        }\n\n        c = d[a];\n        e = d[b];\n        return c < e ? -1 : c > e ? 1 : 0;\n      }) : i.sort(function (a, b) {\n        var c,\n            g,\n            j,\n            i,\n            k = h.length,\n            l = f[a]._aSortData,\n            o = f[b]._aSortData;\n\n        for (j = 0; j < k; j++) {\n          if (i = h[j], c = l[i.col], g = o[i.col], i = e[i.type + \"-\" + i.dir] || e[\"string-\" + i.dir], c = i(c, g), 0 !== c) return c;\n        }\n\n        c = d[a];\n        g = d[b];\n        return c < g ? -1 : c > g ? 1 : 0;\n      });\n    }\n\n    a.bSorted = !0;\n  }\n\n  function Kb(a) {\n    for (var b, c, d = a.aoColumns, e = Y(a), a = a.oLanguage.oAria, f = 0, g = d.length; f < g; f++) {\n      c = d[f];\n      var j = c.asSorting;\n      b = c.sTitle.replace(/<.*?>/g, \"\");\n      var i = c.nTh;\n      i.removeAttribute(\"aria-sort\");\n      c.bSortable && (0 < e.length && e[0].col == f ? (i.setAttribute(\"aria-sort\", \"asc\" == e[0].dir ? \"ascending\" : \"descending\"), c = j[e[0].index + 1] || j[0]) : c = j[0], b += \"asc\" === c ? a.sSortAscending : a.sSortDescending);\n      i.setAttribute(\"aria-label\", b);\n    }\n  }\n\n  function Wa(a, b, c, d) {\n    var e = a.aaSorting,\n        f = a.aoColumns[b].asSorting,\n        g = function g(a, b) {\n      var c = a._idx;\n      c === k && (c = h.inArray(a[1], f));\n      return c + 1 < f.length ? c + 1 : b ? null : 0;\n    };\n\n    \"number\" === typeof e[0] && (e = a.aaSorting = [e]);\n    c && a.oFeatures.bSortMulti ? (c = h.inArray(b, C(e, \"0\")), -1 !== c ? (b = g(e[c], !0), null === b && 1 === e.length && (b = 0), null === b ? e.splice(c, 1) : (e[c][1] = f[b], e[c]._idx = b)) : (e.push([b, f[0], 0]), e[e.length - 1]._idx = 0)) : e.length && e[0][0] == b ? (b = g(e[0]), e.length = 1, e[0][1] = f[b], e[0]._idx = b) : (e.length = 0, e.push([b, f[0]]), e[0]._idx = 0);\n    T(a);\n    \"function\" == typeof d && d(a);\n  }\n\n  function Oa(a, b, c, d) {\n    var e = a.aoColumns[c];\n    Xa(b, {}, function (b) {\n      !1 !== e.bSortable && (a.oFeatures.bProcessing ? (D(a, !0), setTimeout(function () {\n        Wa(a, c, b.shiftKey, d);\n        \"ssp\" !== y(a) && D(a, !1);\n      }, 0)) : Wa(a, c, b.shiftKey, d));\n    });\n  }\n\n  function ya(a) {\n    var b = a.aLastSort,\n        c = a.oClasses.sSortColumn,\n        d = Y(a),\n        e = a.oFeatures,\n        f,\n        g;\n\n    if (e.bSort && e.bSortClasses) {\n      e = 0;\n\n      for (f = b.length; e < f; e++) {\n        g = b[e].src, h(C(a.aoData, \"anCells\", g)).removeClass(c + (2 > e ? e + 1 : 3));\n      }\n\n      e = 0;\n\n      for (f = d.length; e < f; e++) {\n        g = d[e].src, h(C(a.aoData, \"anCells\", g)).addClass(c + (2 > e ? e + 1 : 3));\n      }\n    }\n\n    a.aLastSort = d;\n  }\n\n  function Jb(a, b) {\n    var c = a.aoColumns[b],\n        d = l.ext.order[c.sSortDataType],\n        e;\n    d && (e = d.call(a.oInstance, a, b, ca(a, b)));\n\n    for (var f, g = l.ext.type.order[c.sType + \"-pre\"], j = 0, i = a.aoData.length; j < i; j++) {\n      if (c = a.aoData[j], c._aSortData || (c._aSortData = []), !c._aSortData[b] || d) f = d ? e[j] : B(a, j, b, \"sort\"), c._aSortData[b] = g ? g(f) : f;\n    }\n  }\n\n  function za(a) {\n    if (a.oFeatures.bStateSave && !a.bDestroying) {\n      var b = {\n        time: +new Date(),\n        start: a._iDisplayStart,\n        length: a._iDisplayLength,\n        order: h.extend(!0, [], a.aaSorting),\n        search: Cb(a.oPreviousSearch),\n        columns: h.map(a.aoColumns, function (b, d) {\n          return {\n            visible: b.bVisible,\n            search: Cb(a.aoPreSearchCols[d])\n          };\n        })\n      };\n      t(a, \"aoStateSaveParams\", \"stateSaveParams\", [a, b]);\n      a.oSavedState = b;\n      a.fnStateSaveCallback.call(a.oInstance, a, b);\n    }\n  }\n\n  function Lb(a, b, c) {\n    var d,\n        e,\n        f = a.aoColumns,\n        b = function b(_b) {\n      if (_b && _b.time) {\n        var g = t(a, \"aoStateLoadParams\", \"stateLoadParams\", [a, _b]);\n\n        if (-1 === h.inArray(!1, g) && (g = a.iStateDuration, !(0 < g && _b.time < +new Date() - 1E3 * g) && !(_b.columns && f.length !== _b.columns.length))) {\n          a.oLoadedState = h.extend(!0, {}, _b);\n          _b.start !== k && (a._iDisplayStart = _b.start, a.iInitDisplayStart = _b.start);\n          _b.length !== k && (a._iDisplayLength = _b.length);\n          _b.order !== k && (a.aaSorting = [], h.each(_b.order, function (b, c) {\n            a.aaSorting.push(c[0] >= f.length ? [0, c[1]] : c);\n          }));\n          _b.search !== k && h.extend(a.oPreviousSearch, Db(_b.search));\n\n          if (_b.columns) {\n            d = 0;\n\n            for (e = _b.columns.length; d < e; d++) {\n              g = _b.columns[d], g.visible !== k && (f[d].bVisible = g.visible), g.search !== k && h.extend(a.aoPreSearchCols[d], Db(g.search));\n            }\n          }\n\n          t(a, \"aoStateLoaded\", \"stateLoaded\", [a, _b]);\n        }\n      }\n\n      c();\n    };\n\n    if (a.oFeatures.bStateSave) {\n      var g = a.fnStateLoadCallback.call(a.oInstance, a, b);\n      g !== k && b(g);\n    } else c();\n  }\n\n  function Aa(a) {\n    var b = l.settings,\n        a = h.inArray(a, C(b, \"nTable\"));\n    return -1 !== a ? b[a] : null;\n  }\n\n  function K(a, b, c, d) {\n    c = \"DataTables warning: \" + (a ? \"table id=\" + a.sTableId + \" - \" : \"\") + c;\n    d && (c += \". For more information about this error, please see http://datatables.net/tn/\" + d);\n    if (b) E.console && console.log && console.log(c);else if (b = l.ext, b = b.sErrMode || b.errMode, a && t(a, null, \"error\", [a, d, c]), \"alert\" == b) alert(c);else {\n      if (\"throw\" == b) throw Error(c);\n      \"function\" == typeof b && b(a, d, c);\n    }\n  }\n\n  function F(a, b, c, d) {\n    Array.isArray(c) ? h.each(c, function (c, d) {\n      Array.isArray(d) ? F(a, b, d[0], d[1]) : F(a, b, d);\n    }) : (d === k && (d = c), b[c] !== k && (a[d] = b[c]));\n  }\n\n  function Ya(a, b, c) {\n    var d, e;\n\n    for (e in b) {\n      b.hasOwnProperty(e) && (d = b[e], h.isPlainObject(d) ? (h.isPlainObject(a[e]) || (a[e] = {}), h.extend(!0, a[e], d)) : a[e] = c && \"data\" !== e && \"aaData\" !== e && Array.isArray(d) ? d.slice() : d);\n    }\n\n    return a;\n  }\n\n  function Xa(a, b, c) {\n    h(a).on(\"click.DT\", b, function (b) {\n      h(a).trigger(\"blur\");\n      c(b);\n    }).on(\"keypress.DT\", b, function (a) {\n      13 === a.which && (a.preventDefault(), c(a));\n    }).on(\"selectstart.DT\", function () {\n      return !1;\n    });\n  }\n\n  function z(a, b, c, d) {\n    c && a[b].push({\n      fn: c,\n      sName: d\n    });\n  }\n\n  function t(a, b, c, d) {\n    var e = [];\n    b && (e = h.map(a[b].slice().reverse(), function (b) {\n      return b.fn.apply(a.oInstance, d);\n    }));\n    null !== c && (b = h.Event(c + \".dt\"), h(a.nTable).trigger(b, d), e.push(b.result));\n    return e;\n  }\n\n  function Ua(a) {\n    var b = a._iDisplayStart,\n        c = a.fnDisplayEnd(),\n        d = a._iDisplayLength;\n    b >= c && (b = c - d);\n    b -= b % d;\n    if (-1 === d || 0 > b) b = 0;\n    a._iDisplayStart = b;\n  }\n\n  function Pa(a, b) {\n    var c = a.renderer,\n        d = l.ext.renderer[b];\n    return h.isPlainObject(c) && c[b] ? d[c[b]] || d._ : \"string\" === typeof c ? d[c] || d._ : d._;\n  }\n\n  function y(a) {\n    return a.oFeatures.bServerSide ? \"ssp\" : a.ajax || a.sAjaxSource ? \"ajax\" : \"dom\";\n  }\n\n  function ja(a, b) {\n    var c = [],\n        c = Mb.numbers_length,\n        d = Math.floor(c / 2);\n    b <= c ? c = Z(0, b) : a <= d ? (c = Z(0, c - 2), c.push(\"ellipsis\"), c.push(b - 1)) : (a >= b - 1 - d ? c = Z(b - (c - 2), b) : (c = Z(a - d + 2, a + d - 1), c.push(\"ellipsis\"), c.push(b - 1)), c.splice(0, 0, \"ellipsis\"), c.splice(0, 0, 0));\n    c.DT_el = \"span\";\n    return c;\n  }\n\n  function Fa(a) {\n    h.each({\n      num: function num(b) {\n        return Ba(b, a);\n      },\n      \"num-fmt\": function numFmt(b) {\n        return Ba(b, a, Za);\n      },\n      \"html-num\": function htmlNum(b) {\n        return Ba(b, a, Ca);\n      },\n      \"html-num-fmt\": function htmlNumFmt(b) {\n        return Ba(b, a, Ca, Za);\n      }\n    }, function (b, c) {\n      v.type.order[b + a + \"-pre\"] = c;\n      b.match(/^html\\-/) && (v.type.search[b + a] = v.type.search.html);\n    });\n  }\n\n  function Nb(a) {\n    return function () {\n      var b = [Aa(this[l.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));\n      return l.ext.internal[a].apply(this, b);\n    };\n  }\n\n  var l = function l(a) {\n    this.$ = function (a, b) {\n      return this.api(!0).$(a, b);\n    };\n\n    this._ = function (a, b) {\n      return this.api(!0).rows(a, b).data();\n    };\n\n    this.api = function (a) {\n      return a ? new _r(Aa(this[v.iApiIndex])) : new _r(this);\n    };\n\n    this.fnAddData = function (a, b) {\n      var c = this.api(!0),\n          d = Array.isArray(a) && (Array.isArray(a[0]) || h.isPlainObject(a[0])) ? c.rows.add(a) : c.row.add(a);\n      (b === k || b) && c.draw();\n      return d.flatten().toArray();\n    };\n\n    this.fnAdjustColumnSizing = function (a) {\n      var b = this.api(!0).columns.adjust(),\n          c = b.settings()[0],\n          d = c.oScroll;\n      a === k || a ? b.draw(!1) : (\"\" !== d.sX || \"\" !== d.sY) && ma(c);\n    };\n\n    this.fnClearTable = function (a) {\n      var b = this.api(!0).clear();\n      (a === k || a) && b.draw();\n    };\n\n    this.fnClose = function (a) {\n      this.api(!0).row(a).child.hide();\n    };\n\n    this.fnDeleteRow = function (a, b, c) {\n      var d = this.api(!0),\n          a = d.rows(a),\n          e = a.settings()[0],\n          h = e.aoData[a[0][0]];\n      a.remove();\n      b && b.call(this, e, h);\n      (c === k || c) && d.draw();\n      return h;\n    };\n\n    this.fnDestroy = function (a) {\n      this.api(!0).destroy(a);\n    };\n\n    this.fnDraw = function (a) {\n      this.api(!0).draw(a);\n    };\n\n    this.fnFilter = function (a, b, c, d, e, h) {\n      e = this.api(!0);\n      null === b || b === k ? e.search(a, c, d, h) : e.column(b).search(a, c, d, h);\n      e.draw();\n    };\n\n    this.fnGetData = function (a, b) {\n      var c = this.api(!0);\n\n      if (a !== k) {\n        var d = a.nodeName ? a.nodeName.toLowerCase() : \"\";\n        return b !== k || \"td\" == d || \"th\" == d ? c.cell(a, b).data() : c.row(a).data() || null;\n      }\n\n      return c.data().toArray();\n    };\n\n    this.fnGetNodes = function (a) {\n      var b = this.api(!0);\n      return a !== k ? b.row(a).node() : b.rows().nodes().flatten().toArray();\n    };\n\n    this.fnGetPosition = function (a) {\n      var b = this.api(!0),\n          c = a.nodeName.toUpperCase();\n      return \"TR\" == c ? b.row(a).index() : \"TD\" == c || \"TH\" == c ? (a = b.cell(a).index(), [a.row, a.columnVisible, a.column]) : null;\n    };\n\n    this.fnIsOpen = function (a) {\n      return this.api(!0).row(a).child.isShown();\n    };\n\n    this.fnOpen = function (a, b, c) {\n      return this.api(!0).row(a).child(b, c).show().child()[0];\n    };\n\n    this.fnPageChange = function (a, b) {\n      var c = this.api(!0).page(a);\n      (b === k || b) && c.draw(!1);\n    };\n\n    this.fnSetColumnVis = function (a, b, c) {\n      a = this.api(!0).column(a).visible(b);\n      (c === k || c) && a.columns.adjust().draw();\n    };\n\n    this.fnSettings = function () {\n      return Aa(this[v.iApiIndex]);\n    };\n\n    this.fnSort = function (a) {\n      this.api(!0).order(a).draw();\n    };\n\n    this.fnSortListener = function (a, b, c) {\n      this.api(!0).order.listener(a, b, c);\n    };\n\n    this.fnUpdate = function (a, b, c, d, e) {\n      var h = this.api(!0);\n      c === k || null === c ? h.row(b).data(a) : h.cell(b, c).data(a);\n      (e === k || e) && h.columns.adjust();\n      (d === k || d) && h.draw();\n      return 0;\n    };\n\n    this.fnVersionCheck = v.fnVersionCheck;\n    var b = this,\n        c = a === k,\n        d = this.length;\n    c && (a = {});\n    this.oApi = this.internal = v.internal;\n\n    for (var e in l.ext.internal) {\n      e && (this[e] = Nb(e));\n    }\n\n    this.each(function () {\n      var e = {},\n          g = 1 < d ? Ya(e, a, !0) : a,\n          j = 0,\n          i,\n          e = this.getAttribute(\"id\"),\n          n = !1,\n          m = l.defaults,\n          q = h(this);\n      if (\"table\" != this.nodeName.toLowerCase()) K(null, 0, \"Non-table node initialisation (\" + this.nodeName + \")\", 2);else {\n        gb(m);\n        hb(m.column);\n        J(m, m, !0);\n        J(m.column, m.column, !0);\n        J(m, h.extend(g, q.data()), !0);\n        var s = l.settings,\n            j = 0;\n\n        for (i = s.length; j < i; j++) {\n          var o = s[j];\n\n          if (o.nTable == this || o.nTHead && o.nTHead.parentNode == this || o.nTFoot && o.nTFoot.parentNode == this) {\n            var r = g.bRetrieve !== k ? g.bRetrieve : m.bRetrieve;\n            if (c || r) return o.oInstance;\n\n            if (g.bDestroy !== k ? g.bDestroy : m.bDestroy) {\n              o.oInstance.fnDestroy();\n              break;\n            } else {\n              K(o, 0, \"Cannot reinitialise DataTable\", 3);\n              return;\n            }\n          }\n\n          if (o.sTableId == this.id) {\n            s.splice(j, 1);\n            break;\n          }\n        }\n\n        if (null === e || \"\" === e) this.id = e = \"DataTables_Table_\" + l.ext._unique++;\n        var p = h.extend(!0, {}, l.models.oSettings, {\n          sDestroyWidth: q[0].style.width,\n          sInstance: e,\n          sTableId: e\n        });\n        p.nTable = this;\n        p.oApi = b.internal;\n        p.oInit = g;\n        s.push(p);\n        p.oInstance = 1 === b.length ? b : q.dataTable();\n        gb(g);\n        Ea(g.oLanguage);\n        g.aLengthMenu && !g.iDisplayLength && (g.iDisplayLength = Array.isArray(g.aLengthMenu[0]) ? g.aLengthMenu[0][0] : g.aLengthMenu[0]);\n        g = Ya(h.extend(!0, {}, m), g);\n        F(p.oFeatures, g, \"bPaginate bLengthChange bFilter bSort bSortMulti bInfo bProcessing bAutoWidth bSortClasses bServerSide bDeferRender\".split(\" \"));\n        F(p, g, [\"asStripeClasses\", \"ajax\", \"fnServerData\", \"fnFormatNumber\", \"sServerMethod\", \"aaSorting\", \"aaSortingFixed\", \"aLengthMenu\", \"sPaginationType\", \"sAjaxSource\", \"sAjaxDataProp\", \"iStateDuration\", \"sDom\", \"bSortCellsTop\", \"iTabIndex\", \"fnStateLoadCallback\", \"fnStateSaveCallback\", \"renderer\", \"searchDelay\", \"rowId\", [\"iCookieDuration\", \"iStateDuration\"], [\"oSearch\", \"oPreviousSearch\"], [\"aoSearchCols\", \"aoPreSearchCols\"], [\"iDisplayLength\", \"_iDisplayLength\"]]);\n        F(p.oScroll, g, [[\"sScrollX\", \"sX\"], [\"sScrollXInner\", \"sXInner\"], [\"sScrollY\", \"sY\"], [\"bScrollCollapse\", \"bCollapse\"]]);\n        F(p.oLanguage, g, \"fnInfoCallback\");\n        z(p, \"aoDrawCallback\", g.fnDrawCallback, \"user\");\n        z(p, \"aoServerParams\", g.fnServerParams, \"user\");\n        z(p, \"aoStateSaveParams\", g.fnStateSaveParams, \"user\");\n        z(p, \"aoStateLoadParams\", g.fnStateLoadParams, \"user\");\n        z(p, \"aoStateLoaded\", g.fnStateLoaded, \"user\");\n        z(p, \"aoRowCallback\", g.fnRowCallback, \"user\");\n        z(p, \"aoRowCreatedCallback\", g.fnCreatedRow, \"user\");\n        z(p, \"aoHeaderCallback\", g.fnHeaderCallback, \"user\");\n        z(p, \"aoFooterCallback\", g.fnFooterCallback, \"user\");\n        z(p, \"aoInitComplete\", g.fnInitComplete, \"user\");\n        z(p, \"aoPreDrawCallback\", g.fnPreDrawCallback, \"user\");\n        p.rowIdFn = S(g.rowId);\n        ib(p);\n        var u = p.oClasses;\n        h.extend(u, l.ext.classes, g.oClasses);\n        q.addClass(u.sTable);\n        p.iInitDisplayStart === k && (p.iInitDisplayStart = g.iDisplayStart, p._iDisplayStart = g.iDisplayStart);\n        null !== g.iDeferLoading && (p.bDeferLoading = !0, e = Array.isArray(g.iDeferLoading), p._iRecordsDisplay = e ? g.iDeferLoading[0] : g.iDeferLoading, p._iRecordsTotal = e ? g.iDeferLoading[1] : g.iDeferLoading);\n        var w = p.oLanguage;\n        h.extend(!0, w, g.oLanguage);\n        w.sUrl ? (h.ajax({\n          dataType: \"json\",\n          url: w.sUrl,\n          success: function success(a) {\n            Ea(a);\n            J(m.oLanguage, a);\n            h.extend(true, w, a);\n            t(p, null, \"i18n\", [p]);\n            ia(p);\n          },\n          error: function error() {\n            ia(p);\n          }\n        }), n = !0) : t(p, null, \"i18n\", [p]);\n        null === g.asStripeClasses && (p.asStripeClasses = [u.sStripeOdd, u.sStripeEven]);\n        var e = p.asStripeClasses,\n            v = q.children(\"tbody\").find(\"tr\").eq(0);\n        -1 !== h.inArray(!0, h.map(e, function (a) {\n          return v.hasClass(a);\n        })) && (h(\"tbody tr\", this).removeClass(e.join(\" \")), p.asDestroyStripes = e.slice());\n        e = [];\n        s = this.getElementsByTagName(\"thead\");\n        0 !== s.length && (fa(p.aoHeader, s[0]), e = sa(p));\n\n        if (null === g.aoColumns) {\n          s = [];\n          j = 0;\n\n          for (i = e.length; j < i; j++) {\n            s.push(null);\n          }\n        } else s = g.aoColumns;\n\n        j = 0;\n\n        for (i = s.length; j < i; j++) {\n          Ga(p, e ? e[j] : null);\n        }\n\n        kb(p, g.aoColumnDefs, s, function (a, b) {\n          la(p, a, b);\n        });\n\n        if (v.length) {\n          var U = function U(a, b) {\n            return a.getAttribute(\"data-\" + b) !== null ? b : null;\n          };\n\n          h(v[0]).children(\"th, td\").each(function (a, b) {\n            var c = p.aoColumns[a];\n\n            if (c.mData === a) {\n              var d = U(b, \"sort\") || U(b, \"order\"),\n                  e = U(b, \"filter\") || U(b, \"search\");\n\n              if (d !== null || e !== null) {\n                c.mData = {\n                  _: a + \".display\",\n                  sort: d !== null ? a + \".@data-\" + d : k,\n                  type: d !== null ? a + \".@data-\" + d : k,\n                  filter: e !== null ? a + \".@data-\" + e : k\n                };\n                la(p, a);\n              }\n            }\n          });\n        }\n\n        var V = p.oFeatures,\n            e = function e() {\n          if (g.aaSorting === k) {\n            var a = p.aaSorting;\n            j = 0;\n\n            for (i = a.length; j < i; j++) {\n              a[j][1] = p.aoColumns[j].asSorting[0];\n            }\n          }\n\n          ya(p);\n          V.bSort && z(p, \"aoDrawCallback\", function () {\n            if (p.bSorted) {\n              var a = Y(p),\n                  b = {};\n              h.each(a, function (a, c) {\n                b[c.src] = c.dir;\n              });\n              t(p, null, \"order\", [p, a, b]);\n              Kb(p);\n            }\n          });\n          z(p, \"aoDrawCallback\", function () {\n            (p.bSorted || y(p) === \"ssp\" || V.bDeferRender) && ya(p);\n          }, \"sc\");\n          var a = q.children(\"caption\").each(function () {\n            this._captionSide = h(this).css(\"caption-side\");\n          }),\n              b = q.children(\"thead\");\n          b.length === 0 && (b = h(\"<thead/>\").appendTo(q));\n          p.nTHead = b[0];\n          b = q.children(\"tbody\");\n          b.length === 0 && (b = h(\"<tbody/>\").appendTo(q));\n          p.nTBody = b[0];\n          b = q.children(\"tfoot\");\n          if (b.length === 0 && a.length > 0 && (p.oScroll.sX !== \"\" || p.oScroll.sY !== \"\")) b = h(\"<tfoot/>\").appendTo(q);\n          if (b.length === 0 || b.children().length === 0) q.addClass(u.sNoFooter);else if (b.length > 0) {\n            p.nTFoot = b[0];\n            fa(p.aoFooter, p.nTFoot);\n          }\n          if (g.aaData) for (j = 0; j < g.aaData.length; j++) {\n            O(p, g.aaData[j]);\n          } else (p.bDeferLoading || y(p) == \"dom\") && oa(p, h(p.nTBody).children(\"tr\"));\n          p.aiDisplay = p.aiDisplayMaster.slice();\n          p.bInitialised = true;\n          n === false && ia(p);\n        };\n\n        g.bStateSave ? (V.bStateSave = !0, z(p, \"aoDrawCallback\", za, \"state_save\"), Lb(p, g, e)) : e();\n      }\n    });\n    b = null;\n    return this;\n  },\n      v,\n      _r,\n      o,\n      u,\n      $a = {},\n      Ob = /[\\r\\n\\u2028]/g,\n      Ca = /<.*?>/g,\n      bc = /^\\d{2,4}[\\.\\/\\-]\\d{1,2}[\\.\\/\\-]\\d{1,2}([T ]{1}\\d{1,2}[:\\.]\\d{2}([\\.:]\\d{2})?)?$/,\n      cc = RegExp(\"(\\\\/|\\\\.|\\\\*|\\\\+|\\\\?|\\\\||\\\\(|\\\\)|\\\\[|\\\\]|\\\\{|\\\\}|\\\\\\\\|\\\\$|\\\\^|\\\\-)\", \"g\"),\n      Za = /['\\u00A0,$£€¥%\\u2009\\u202F\\u20BD\\u20a9\\u20BArfkɃΞ]/gi,\n      M = function M(a) {\n    return !a || !0 === a || \"-\" === a ? !0 : !1;\n  },\n      Pb = function Pb(a) {\n    var b = parseInt(a, 10);\n    return !isNaN(b) && isFinite(a) ? b : null;\n  },\n      Qb = function Qb(a, b) {\n    $a[b] || ($a[b] = RegExp(Sa(b), \"g\"));\n    return \"string\" === typeof a && \".\" !== b ? a.replace(/\\./g, \"\").replace($a[b], \".\") : a;\n  },\n      ab = function ab(a, b, c) {\n    var d = \"string\" === typeof a;\n    if (M(a)) return !0;\n    b && d && (a = Qb(a, b));\n    c && d && (a = a.replace(Za, \"\"));\n    return !isNaN(parseFloat(a)) && isFinite(a);\n  },\n      Rb = function Rb(a, b, c) {\n    return M(a) ? !0 : !(M(a) || \"string\" === typeof a) ? null : ab(a.replace(Ca, \"\"), b, c) ? !0 : null;\n  },\n      C = function C(a, b, c) {\n    var d = [],\n        e = 0,\n        f = a.length;\n    if (c !== k) for (; e < f; e++) {\n      a[e] && a[e][b] && d.push(a[e][b][c]);\n    } else for (; e < f; e++) {\n      a[e] && d.push(a[e][b]);\n    }\n    return d;\n  },\n      ka = function ka(a, b, c, d) {\n    var e = [],\n        f = 0,\n        g = b.length;\n    if (d !== k) for (; f < g; f++) {\n      a[b[f]][c] && e.push(a[b[f]][c][d]);\n    } else for (; f < g; f++) {\n      e.push(a[b[f]][c]);\n    }\n    return e;\n  },\n      Z = function Z(a, b) {\n    var c = [],\n        d;\n    b === k ? (b = 0, d = a) : (d = b, b = a);\n\n    for (var e = b; e < d; e++) {\n      c.push(e);\n    }\n\n    return c;\n  },\n      Sb = function Sb(a) {\n    for (var b = [], c = 0, d = a.length; c < d; c++) {\n      a[c] && b.push(a[c]);\n    }\n\n    return b;\n  },\n      ra = function ra(a) {\n    var b;\n\n    a: {\n      if (!(2 > a.length)) {\n        b = a.slice().sort();\n\n        for (var c = b[0], d = 1, e = b.length; d < e; d++) {\n          if (b[d] === c) {\n            b = !1;\n            break a;\n          }\n\n          c = b[d];\n        }\n      }\n\n      b = !0;\n    }\n\n    if (b) return a.slice();\n    b = [];\n    var e = a.length,\n        f,\n        g = 0,\n        d = 0;\n\n    a: for (; d < e; d++) {\n      c = a[d];\n\n      for (f = 0; f < g; f++) {\n        if (b[f] === c) continue a;\n      }\n\n      b.push(c);\n      g++;\n    }\n\n    return b;\n  },\n      Tb = function Tb(a, b) {\n    if (Array.isArray(b)) for (var c = 0; c < b.length; c++) {\n      Tb(a, b[c]);\n    } else a.push(b);\n    return a;\n  };\n\n  Array.isArray || (Array.isArray = function (a) {\n    return \"[object Array]\" === Object.prototype.toString.call(a);\n  });\n  String.prototype.trim || (String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  });\n  l.util = {\n    throttle: function throttle(a, b) {\n      var c = b !== k ? b : 200,\n          d,\n          e;\n      return function () {\n        var b = this,\n            g = +new Date(),\n            j = arguments;\n\n        if (d && g < d + c) {\n          clearTimeout(e);\n          e = setTimeout(function () {\n            d = k;\n            a.apply(b, j);\n          }, c);\n        } else {\n          d = g;\n          a.apply(b, j);\n        }\n      };\n    },\n    escapeRegex: function escapeRegex(a) {\n      return a.replace(cc, \"\\\\$1\");\n    }\n  };\n\n  var A = function A(a, b, c) {\n    a[b] !== k && (a[c] = a[b]);\n  },\n      da = /\\[.*?\\]$/,\n      X = /\\(\\)$/,\n      Sa = l.util.escapeRegex,\n      wa = h(\"<div>\")[0],\n      Zb = wa.textContent !== k,\n      ac = /<.*?>/g,\n      Qa = l.util.throttle,\n      Ub = [],\n      x = Array.prototype,\n      dc = function dc(a) {\n    var b,\n        c,\n        d = l.settings,\n        e = h.map(d, function (a) {\n      return a.nTable;\n    });\n\n    if (a) {\n      if (a.nTable && a.oApi) return [a];\n\n      if (a.nodeName && a.nodeName.toLowerCase() === \"table\") {\n        b = h.inArray(a, e);\n        return b !== -1 ? [d[b]] : null;\n      }\n\n      if (a && typeof a.settings === \"function\") return a.settings().toArray();\n      typeof a === \"string\" ? c = h(a) : a instanceof h && (c = a);\n    } else return [];\n\n    if (c) return c.map(function () {\n      b = h.inArray(this, e);\n      return b !== -1 ? d[b] : null;\n    }).toArray();\n  };\n\n  _r = function r(a, b) {\n    if (!(this instanceof _r)) return new _r(a, b);\n\n    var c = [],\n        d = function d(a) {\n      (a = dc(a)) && c.push.apply(c, a);\n    };\n\n    if (Array.isArray(a)) for (var e = 0, f = a.length; e < f; e++) {\n      d(a[e]);\n    } else d(a);\n    this.context = ra(c);\n    b && h.merge(this, b);\n    this.selector = {\n      rows: null,\n      cols: null,\n      opts: null\n    };\n\n    _r.extend(this, this, Ub);\n  };\n\n  l.Api = _r;\n  h.extend(_r.prototype, {\n    any: function any() {\n      return this.count() !== 0;\n    },\n    concat: x.concat,\n    context: [],\n    count: function count() {\n      return this.flatten().length;\n    },\n    each: function each(a) {\n      for (var b = 0, c = this.length; b < c; b++) {\n        a.call(this, this[b], b, this);\n      }\n\n      return this;\n    },\n    eq: function eq(a) {\n      var b = this.context;\n      return b.length > a ? new _r(b[a], this[a]) : null;\n    },\n    filter: function filter(a) {\n      var b = [];\n      if (x.filter) b = x.filter.call(this, a, this);else for (var c = 0, d = this.length; c < d; c++) {\n        a.call(this, this[c], c, this) && b.push(this[c]);\n      }\n      return new _r(this.context, b);\n    },\n    flatten: function flatten() {\n      var a = [];\n      return new _r(this.context, a.concat.apply(a, this.toArray()));\n    },\n    join: x.join,\n    indexOf: x.indexOf || function (a, b) {\n      for (var c = b || 0, d = this.length; c < d; c++) {\n        if (this[c] === a) return c;\n      }\n\n      return -1;\n    },\n    iterator: function iterator(a, b, c, d) {\n      var e = [],\n          f,\n          g,\n          j,\n          i,\n          h,\n          m = this.context,\n          l,\n          o,\n          u = this.selector;\n\n      if (typeof a === \"string\") {\n        d = c;\n        c = b;\n        b = a;\n        a = false;\n      }\n\n      g = 0;\n\n      for (j = m.length; g < j; g++) {\n        var t = new _r(m[g]);\n\n        if (b === \"table\") {\n          f = c.call(t, m[g], g);\n          f !== k && e.push(f);\n        } else if (b === \"columns\" || b === \"rows\") {\n          f = c.call(t, m[g], this[g], g);\n          f !== k && e.push(f);\n        } else if (b === \"column\" || b === \"column-rows\" || b === \"row\" || b === \"cell\") {\n          o = this[g];\n          b === \"column-rows\" && (l = Da(m[g], u.opts));\n          i = 0;\n\n          for (h = o.length; i < h; i++) {\n            f = o[i];\n            f = b === \"cell\" ? c.call(t, m[g], f.row, f.column, g, i) : c.call(t, m[g], f, g, i, l);\n            f !== k && e.push(f);\n          }\n        }\n      }\n\n      if (e.length || d) {\n        a = new _r(m, a ? e.concat.apply([], e) : e);\n        b = a.selector;\n        b.rows = u.rows;\n        b.cols = u.cols;\n        b.opts = u.opts;\n        return a;\n      }\n\n      return this;\n    },\n    lastIndexOf: x.lastIndexOf || function (a, b) {\n      return this.indexOf.apply(this.toArray.reverse(), arguments);\n    },\n    length: 0,\n    map: function map(a) {\n      var b = [];\n      if (x.map) b = x.map.call(this, a, this);else for (var c = 0, d = this.length; c < d; c++) {\n        b.push(a.call(this, this[c], c));\n      }\n      return new _r(this.context, b);\n    },\n    pluck: function pluck(a) {\n      return this.map(function (b) {\n        return b[a];\n      });\n    },\n    pop: x.pop,\n    push: x.push,\n    reduce: x.reduce || function (a, b) {\n      return jb(this, a, b, 0, this.length, 1);\n    },\n    reduceRight: x.reduceRight || function (a, b) {\n      return jb(this, a, b, this.length - 1, -1, -1);\n    },\n    reverse: x.reverse,\n    selector: null,\n    shift: x.shift,\n    slice: function slice() {\n      return new _r(this.context, this);\n    },\n    sort: x.sort,\n    splice: x.splice,\n    toArray: function toArray() {\n      return x.slice.call(this);\n    },\n    to$: function to$() {\n      return h(this);\n    },\n    toJQuery: function toJQuery() {\n      return h(this);\n    },\n    unique: function unique() {\n      return new _r(this.context, ra(this));\n    },\n    unshift: x.unshift\n  });\n\n  _r.extend = function (a, b, c) {\n    if (c.length && b && (b instanceof _r || b.__dt_wrapper)) {\n      var d,\n          e,\n          f,\n          g = function g(a, b, c) {\n        return function () {\n          var d = b.apply(a, arguments);\n\n          _r.extend(d, d, c.methodExt);\n\n          return d;\n        };\n      };\n\n      d = 0;\n\n      for (e = c.length; d < e; d++) {\n        f = c[d];\n        b[f.name] = f.type === \"function\" ? g(a, f.val, f) : f.type === \"object\" ? {} : f.val;\n        b[f.name].__dt_wrapper = true;\n\n        _r.extend(a, b[f.name], f.propExt);\n      }\n    }\n  };\n\n  _r.register = o = function o(a, b) {\n    if (Array.isArray(a)) for (var c = 0, d = a.length; c < d; c++) {\n      _r.register(a[c], b);\n    } else for (var e = a.split(\".\"), f = Ub, g, j, c = 0, d = e.length; c < d; c++) {\n      g = (j = e[c].indexOf(\"()\") !== -1) ? e[c].replace(\"()\", \"\") : e[c];\n      var i;\n\n      a: {\n        i = 0;\n\n        for (var k = f.length; i < k; i++) {\n          if (f[i].name === g) {\n            i = f[i];\n            break a;\n          }\n        }\n\n        i = null;\n      }\n\n      if (!i) {\n        i = {\n          name: g,\n          val: {},\n          methodExt: [],\n          propExt: [],\n          type: \"object\"\n        };\n        f.push(i);\n      }\n\n      if (c === d - 1) {\n        i.val = b;\n        i.type = typeof b === \"function\" ? \"function\" : h.isPlainObject(b) ? \"object\" : \"other\";\n      } else f = j ? i.methodExt : i.propExt;\n    }\n  };\n\n  _r.registerPlural = u = function u(a, b, c) {\n    _r.register(a, c);\n\n    _r.register(b, function () {\n      var a = c.apply(this, arguments);\n      return a === this ? this : a instanceof _r ? a.length ? Array.isArray(a[0]) ? new _r(a.context, a[0]) : a[0] : k : a;\n    });\n  };\n\n  var Vb = function Vb(a, b) {\n    if (Array.isArray(a)) return h.map(a, function (a) {\n      return Vb(a, b);\n    });\n    if (typeof a === \"number\") return [b[a]];\n    var c = h.map(b, function (a) {\n      return a.nTable;\n    });\n    return h(c).filter(a).map(function () {\n      var a = h.inArray(this, c);\n      return b[a];\n    }).toArray();\n  };\n\n  o(\"tables()\", function (a) {\n    return a !== k && a !== null ? new _r(Vb(a, this.context)) : this;\n  });\n  o(\"table()\", function (a) {\n    var a = this.tables(a),\n        b = a.context;\n    return b.length ? new _r(b[0]) : a;\n  });\n  u(\"tables().nodes()\", \"table().node()\", function () {\n    return this.iterator(\"table\", function (a) {\n      return a.nTable;\n    }, 1);\n  });\n  u(\"tables().body()\", \"table().body()\", function () {\n    return this.iterator(\"table\", function (a) {\n      return a.nTBody;\n    }, 1);\n  });\n  u(\"tables().header()\", \"table().header()\", function () {\n    return this.iterator(\"table\", function (a) {\n      return a.nTHead;\n    }, 1);\n  });\n  u(\"tables().footer()\", \"table().footer()\", function () {\n    return this.iterator(\"table\", function (a) {\n      return a.nTFoot;\n    }, 1);\n  });\n  u(\"tables().containers()\", \"table().container()\", function () {\n    return this.iterator(\"table\", function (a) {\n      return a.nTableWrapper;\n    }, 1);\n  });\n  o(\"draw()\", function (a) {\n    return this.iterator(\"table\", function (b) {\n      if (a === \"page\") P(b);else {\n        typeof a === \"string\" && (a = a === \"full-hold\" ? false : true);\n        T(b, a === false);\n      }\n    });\n  });\n  o(\"page()\", function (a) {\n    return a === k ? this.page.info().page : this.iterator(\"table\", function (b) {\n      Va(b, a);\n    });\n  });\n  o(\"page.info()\", function () {\n    if (this.context.length === 0) return k;\n    var a = this.context[0],\n        b = a._iDisplayStart,\n        c = a.oFeatures.bPaginate ? a._iDisplayLength : -1,\n        d = a.fnRecordsDisplay(),\n        e = c === -1;\n    return {\n      page: e ? 0 : Math.floor(b / c),\n      pages: e ? 1 : Math.ceil(d / c),\n      start: b,\n      end: a.fnDisplayEnd(),\n      length: c,\n      recordsTotal: a.fnRecordsTotal(),\n      recordsDisplay: d,\n      serverSide: y(a) === \"ssp\"\n    };\n  });\n  o(\"page.len()\", function (a) {\n    return a === k ? this.context.length !== 0 ? this.context[0]._iDisplayLength : k : this.iterator(\"table\", function (b) {\n      Ta(b, a);\n    });\n  });\n\n  var Wb = function Wb(a, b, c) {\n    if (c) {\n      var d = new _r(a);\n      d.one(\"draw\", function () {\n        c(d.ajax.json());\n      });\n    }\n\n    if (y(a) == \"ssp\") T(a, b);else {\n      D(a, true);\n      var e = a.jqXHR;\n      e && e.readyState !== 4 && e.abort();\n      ta(a, [], function (c) {\n        pa(a);\n\n        for (var c = ua(a, c), d = 0, e = c.length; d < e; d++) {\n          O(a, c[d]);\n        }\n\n        T(a, b);\n        D(a, false);\n      });\n    }\n  };\n\n  o(\"ajax.json()\", function () {\n    var a = this.context;\n    if (a.length > 0) return a[0].json;\n  });\n  o(\"ajax.params()\", function () {\n    var a = this.context;\n    if (a.length > 0) return a[0].oAjaxData;\n  });\n  o(\"ajax.reload()\", function (a, b) {\n    return this.iterator(\"table\", function (c) {\n      Wb(c, b === false, a);\n    });\n  });\n  o(\"ajax.url()\", function (a) {\n    var b = this.context;\n\n    if (a === k) {\n      if (b.length === 0) return k;\n      b = b[0];\n      return b.ajax ? h.isPlainObject(b.ajax) ? b.ajax.url : b.ajax : b.sAjaxSource;\n    }\n\n    return this.iterator(\"table\", function (b) {\n      h.isPlainObject(b.ajax) ? b.ajax.url = a : b.ajax = a;\n    });\n  });\n  o(\"ajax.url().load()\", function (a, b) {\n    return this.iterator(\"table\", function (c) {\n      Wb(c, b === false, a);\n    });\n  });\n\n  var bb = function bb(a, b, c, d, e) {\n    var f = [],\n        g,\n        j,\n        i,\n        h,\n        m,\n        l;\n    i = _typeof(b);\n    if (!b || i === \"string\" || i === \"function\" || b.length === k) b = [b];\n    i = 0;\n\n    for (h = b.length; i < h; i++) {\n      j = b[i] && b[i].split && !b[i].match(/[\\[\\(:]/) ? b[i].split(\",\") : [b[i]];\n      m = 0;\n\n      for (l = j.length; m < l; m++) {\n        (g = c(typeof j[m] === \"string\" ? j[m].trim() : j[m])) && g.length && (f = f.concat(g));\n      }\n    }\n\n    a = v.selector[a];\n\n    if (a.length) {\n      i = 0;\n\n      for (h = a.length; i < h; i++) {\n        f = a[i](d, e, f);\n      }\n    }\n\n    return ra(f);\n  },\n      cb = function cb(a) {\n    a || (a = {});\n    if (a.filter && a.search === k) a.search = a.filter;\n    return h.extend({\n      search: \"none\",\n      order: \"current\",\n      page: \"all\"\n    }, a);\n  },\n      db = function db(a) {\n    for (var b = 0, c = a.length; b < c; b++) {\n      if (a[b].length > 0) {\n        a[0] = a[b];\n        a[0].length = 1;\n        a.length = 1;\n        a.context = [a.context[b]];\n        return a;\n      }\n    }\n\n    a.length = 0;\n    return a;\n  },\n      Da = function Da(a, b) {\n    var c,\n        d,\n        e,\n        f = [],\n        g = a.aiDisplay;\n    e = a.aiDisplayMaster;\n    var j = b.search;\n    c = b.order;\n    d = b.page;\n    if (y(a) == \"ssp\") return j === \"removed\" ? [] : Z(0, e.length);\n\n    if (d == \"current\") {\n      c = a._iDisplayStart;\n\n      for (d = a.fnDisplayEnd(); c < d; c++) {\n        f.push(g[c]);\n      }\n    } else if (c == \"current\" || c == \"applied\") {\n      if (j == \"none\") f = e.slice();else if (j == \"applied\") f = g.slice();else {\n        if (j == \"removed\") {\n          var i = {};\n          c = 0;\n\n          for (d = g.length; c < d; c++) {\n            i[g[c]] = null;\n          }\n\n          f = h.map(e, function (a) {\n            return !i.hasOwnProperty(a) ? a : null;\n          });\n        }\n      }\n    } else if (c == \"index\" || c == \"original\") {\n      c = 0;\n\n      for (d = a.aoData.length; c < d; c++) {\n        if (j == \"none\") f.push(c);else {\n          e = h.inArray(c, g);\n          (e === -1 && j == \"removed\" || e >= 0 && j == \"applied\") && f.push(c);\n        }\n      }\n    }\n\n    return f;\n  };\n\n  o(\"rows()\", function (a, b) {\n    if (a === k) a = \"\";else if (h.isPlainObject(a)) {\n      b = a;\n      a = \"\";\n    }\n    var b = cb(b),\n        c = this.iterator(\"table\", function (c) {\n      var e = b,\n          f;\n      return bb(\"row\", a, function (a) {\n        var b = Pb(a),\n            i = c.aoData;\n        if (b !== null && !e) return [b];\n        f || (f = Da(c, e));\n        if (b !== null && h.inArray(b, f) !== -1) return [b];\n        if (a === null || a === k || a === \"\") return f;\n        if (typeof a === \"function\") return h.map(f, function (b) {\n          var c = i[b];\n          return a(b, c._aData, c.nTr) ? b : null;\n        });\n\n        if (a.nodeName) {\n          var b = a._DT_RowIndex,\n              n = a._DT_CellIndex;\n          if (b !== k) return i[b] && i[b].nTr === a ? [b] : [];\n          if (n) return i[n.row] && i[n.row].nTr === a.parentNode ? [n.row] : [];\n          b = h(a).closest(\"*[data-dt-row]\");\n          return b.length ? [b.data(\"dt-row\")] : [];\n        }\n\n        if (typeof a === \"string\" && a.charAt(0) === \"#\") {\n          b = c.aIds[a.replace(/^#/, \"\")];\n          if (b !== k) return [b.idx];\n        }\n\n        b = Sb(ka(c.aoData, f, \"nTr\"));\n        return h(b).filter(a).map(function () {\n          return this._DT_RowIndex;\n        }).toArray();\n      }, c, e);\n    }, 1);\n    c.selector.rows = a;\n    c.selector.opts = b;\n    return c;\n  });\n  o(\"rows().nodes()\", function () {\n    return this.iterator(\"row\", function (a, b) {\n      return a.aoData[b].nTr || k;\n    }, 1);\n  });\n  o(\"rows().data()\", function () {\n    return this.iterator(true, \"rows\", function (a, b) {\n      return ka(a.aoData, b, \"_aData\");\n    }, 1);\n  });\n  u(\"rows().cache()\", \"row().cache()\", function (a) {\n    return this.iterator(\"row\", function (b, c) {\n      var d = b.aoData[c];\n      return a === \"search\" ? d._aFilterData : d._aSortData;\n    }, 1);\n  });\n  u(\"rows().invalidate()\", \"row().invalidate()\", function (a) {\n    return this.iterator(\"row\", function (b, c) {\n      ea(b, c, a);\n    });\n  });\n  u(\"rows().indexes()\", \"row().index()\", function () {\n    return this.iterator(\"row\", function (a, b) {\n      return b;\n    }, 1);\n  });\n  u(\"rows().ids()\", \"row().id()\", function (a) {\n    for (var b = [], c = this.context, d = 0, e = c.length; d < e; d++) {\n      for (var f = 0, g = this[d].length; f < g; f++) {\n        var h = c[d].rowIdFn(c[d].aoData[this[d][f]]._aData);\n        b.push((a === true ? \"#\" : \"\") + h);\n      }\n    }\n\n    return new _r(c, b);\n  });\n  u(\"rows().remove()\", \"row().remove()\", function () {\n    var a = this;\n    this.iterator(\"row\", function (b, c, d) {\n      var e = b.aoData,\n          f = e[c],\n          g,\n          h,\n          i,\n          n,\n          m;\n      e.splice(c, 1);\n      g = 0;\n\n      for (h = e.length; g < h; g++) {\n        i = e[g];\n        m = i.anCells;\n        if (i.nTr !== null) i.nTr._DT_RowIndex = g;\n\n        if (m !== null) {\n          i = 0;\n\n          for (n = m.length; i < n; i++) {\n            m[i]._DT_CellIndex.row = g;\n          }\n        }\n      }\n\n      qa(b.aiDisplayMaster, c);\n      qa(b.aiDisplay, c);\n      qa(a[d], c, false);\n      b._iRecordsDisplay > 0 && b._iRecordsDisplay--;\n      Ua(b);\n      c = b.rowIdFn(f._aData);\n      c !== k && delete b.aIds[c];\n    });\n    this.iterator(\"table\", function (a) {\n      for (var c = 0, d = a.aoData.length; c < d; c++) {\n        a.aoData[c].idx = c;\n      }\n    });\n    return this;\n  });\n  o(\"rows.add()\", function (a) {\n    var b = this.iterator(\"table\", function (b) {\n      var c,\n          f,\n          g,\n          h = [];\n      f = 0;\n\n      for (g = a.length; f < g; f++) {\n        c = a[f];\n        c.nodeName && c.nodeName.toUpperCase() === \"TR\" ? h.push(oa(b, c)[0]) : h.push(O(b, c));\n      }\n\n      return h;\n    }, 1),\n        c = this.rows(-1);\n    c.pop();\n    h.merge(c, b);\n    return c;\n  });\n  o(\"row()\", function (a, b) {\n    return db(this.rows(a, b));\n  });\n  o(\"row().data()\", function (a) {\n    var b = this.context;\n    if (a === k) return b.length && this.length ? b[0].aoData[this[0]]._aData : k;\n    var c = b[0].aoData[this[0]];\n    c._aData = a;\n    Array.isArray(a) && c.nTr && c.nTr.id && N(b[0].rowId)(a, c.nTr.id);\n    ea(b[0], this[0], \"data\");\n    return this;\n  });\n  o(\"row().node()\", function () {\n    var a = this.context;\n    return a.length && this.length ? a[0].aoData[this[0]].nTr || null : null;\n  });\n  o(\"row.add()\", function (a) {\n    a instanceof h && a.length && (a = a[0]);\n    var b = this.iterator(\"table\", function (b) {\n      return a.nodeName && a.nodeName.toUpperCase() === \"TR\" ? oa(b, a)[0] : O(b, a);\n    });\n    return this.row(b[0]);\n  });\n\n  var eb = function eb(a, b) {\n    var c = a.context;\n    if (c.length) if ((c = c[0].aoData[b !== k ? b : a[0]]) && c._details) {\n      c._details.remove();\n\n      c._detailsShow = k;\n      c._details = k;\n    }\n  },\n      Xb = function Xb(a, b) {\n    var c = a.context;\n\n    if (c.length && a.length) {\n      var d = c[0].aoData[a[0]];\n\n      if (d._details) {\n        (d._detailsShow = b) ? d._details.insertAfter(d.nTr) : d._details.detach();\n        var e = c[0],\n            f = new _r(e),\n            g = e.aoData;\n        f.off(\"draw.dt.DT_details column-visibility.dt.DT_details destroy.dt.DT_details\");\n\n        if (C(g, \"_details\").length > 0) {\n          f.on(\"draw.dt.DT_details\", function (a, b) {\n            e === b && f.rows({\n              page: \"current\"\n            }).eq(0).each(function (a) {\n              a = g[a];\n              a._detailsShow && a._details.insertAfter(a.nTr);\n            });\n          });\n          f.on(\"column-visibility.dt.DT_details\", function (a, b) {\n            if (e === b) for (var c, d = W(b), f = 0, h = g.length; f < h; f++) {\n              c = g[f];\n              c._details && c._details.children(\"td[colspan]\").attr(\"colspan\", d);\n            }\n          });\n          f.on(\"destroy.dt.DT_details\", function (a, b) {\n            if (e === b) for (var c = 0, d = g.length; c < d; c++) {\n              g[c]._details && eb(f, c);\n            }\n          });\n        }\n      }\n    }\n  };\n\n  o(\"row().child()\", function (a, b) {\n    var c = this.context;\n    if (a === k) return c.length && this.length ? c[0].aoData[this[0]]._details : k;\n    if (a === true) this.child.show();else if (a === false) eb(this);else if (c.length && this.length) {\n      var d = c[0],\n          c = c[0].aoData[this[0]],\n          e = [],\n          f = function f(a, b) {\n        if (Array.isArray(a) || a instanceof h) for (var c = 0, k = a.length; c < k; c++) {\n          f(a[c], b);\n        } else if (a.nodeName && a.nodeName.toLowerCase() === \"tr\") e.push(a);else {\n          c = h(\"<tr><td></td></tr>\").addClass(b);\n          h(\"td\", c).addClass(b).html(a)[0].colSpan = W(d);\n          e.push(c[0]);\n        }\n      };\n\n      f(a, b);\n      c._details && c._details.detach();\n      c._details = h(e);\n      c._detailsShow && c._details.insertAfter(c.nTr);\n    }\n    return this;\n  });\n  o([\"row().child.show()\", \"row().child().show()\"], function () {\n    Xb(this, true);\n    return this;\n  });\n  o([\"row().child.hide()\", \"row().child().hide()\"], function () {\n    Xb(this, false);\n    return this;\n  });\n  o([\"row().child.remove()\", \"row().child().remove()\"], function () {\n    eb(this);\n    return this;\n  });\n  o(\"row().child.isShown()\", function () {\n    var a = this.context;\n    return a.length && this.length ? a[0].aoData[this[0]]._detailsShow || false : false;\n  });\n\n  var ec = /^([^:]+):(name|visIdx|visible)$/,\n      Yb = function Yb(a, b, c, d, e) {\n    for (var c = [], d = 0, f = e.length; d < f; d++) {\n      c.push(B(a, e[d], b));\n    }\n\n    return c;\n  };\n\n  o(\"columns()\", function (a, b) {\n    if (a === k) a = \"\";else if (h.isPlainObject(a)) {\n      b = a;\n      a = \"\";\n    }\n    var b = cb(b),\n        c = this.iterator(\"table\", function (c) {\n      var e = a,\n          f = b,\n          g = c.aoColumns,\n          j = C(g, \"sName\"),\n          i = C(g, \"nTh\");\n      return bb(\"column\", e, function (a) {\n        var b = Pb(a);\n        if (a === \"\") return Z(g.length);\n        if (b !== null) return [b >= 0 ? b : g.length + b];\n\n        if (typeof a === \"function\") {\n          var e = Da(c, f);\n          return h.map(g, function (b, f) {\n            return a(f, Yb(c, f, 0, 0, e), i[f]) ? f : null;\n          });\n        }\n\n        var k = typeof a === \"string\" ? a.match(ec) : \"\";\n        if (k) switch (k[2]) {\n          case \"visIdx\":\n          case \"visible\":\n            b = parseInt(k[1], 10);\n\n            if (b < 0) {\n              var l = h.map(g, function (a, b) {\n                return a.bVisible ? b : null;\n              });\n              return [l[l.length + b]];\n            }\n\n            return [ba(c, b)];\n\n          case \"name\":\n            return h.map(j, function (a, b) {\n              return a === k[1] ? b : null;\n            });\n\n          default:\n            return [];\n        }\n        if (a.nodeName && a._DT_CellIndex) return [a._DT_CellIndex.column];\n        b = h(i).filter(a).map(function () {\n          return h.inArray(this, i);\n        }).toArray();\n        if (b.length || !a.nodeName) return b;\n        b = h(a).closest(\"*[data-dt-column]\");\n        return b.length ? [b.data(\"dt-column\")] : [];\n      }, c, f);\n    }, 1);\n    c.selector.cols = a;\n    c.selector.opts = b;\n    return c;\n  });\n  u(\"columns().header()\", \"column().header()\", function () {\n    return this.iterator(\"column\", function (a, b) {\n      return a.aoColumns[b].nTh;\n    }, 1);\n  });\n  u(\"columns().footer()\", \"column().footer()\", function () {\n    return this.iterator(\"column\", function (a, b) {\n      return a.aoColumns[b].nTf;\n    }, 1);\n  });\n  u(\"columns().data()\", \"column().data()\", function () {\n    return this.iterator(\"column-rows\", Yb, 1);\n  });\n  u(\"columns().dataSrc()\", \"column().dataSrc()\", function () {\n    return this.iterator(\"column\", function (a, b) {\n      return a.aoColumns[b].mData;\n    }, 1);\n  });\n  u(\"columns().cache()\", \"column().cache()\", function (a) {\n    return this.iterator(\"column-rows\", function (b, c, d, e, f) {\n      return ka(b.aoData, f, a === \"search\" ? \"_aFilterData\" : \"_aSortData\", c);\n    }, 1);\n  });\n  u(\"columns().nodes()\", \"column().nodes()\", function () {\n    return this.iterator(\"column-rows\", function (a, b, c, d, e) {\n      return ka(a.aoData, e, \"anCells\", b);\n    }, 1);\n  });\n  u(\"columns().visible()\", \"column().visible()\", function (a, b) {\n    var c = this,\n        d = this.iterator(\"column\", function (b, c) {\n      if (a === k) return b.aoColumns[c].bVisible;\n      var d = b.aoColumns,\n          j = d[c],\n          i = b.aoData,\n          n,\n          m,\n          l;\n\n      if (a !== k && j.bVisible !== a) {\n        if (a) {\n          var o = h.inArray(true, C(d, \"bVisible\"), c + 1);\n          n = 0;\n\n          for (m = i.length; n < m; n++) {\n            l = i[n].nTr;\n            d = i[n].anCells;\n            l && l.insertBefore(d[c], d[o] || null);\n          }\n        } else h(C(b.aoData, \"anCells\", c)).detach();\n\n        j.bVisible = a;\n      }\n    });\n    a !== k && this.iterator(\"table\", function (d) {\n      ga(d, d.aoHeader);\n      ga(d, d.aoFooter);\n      d.aiDisplay.length || h(d.nTBody).find(\"td[colspan]\").attr(\"colspan\", W(d));\n      za(d);\n      c.iterator(\"column\", function (c, d) {\n        t(c, null, \"column-visibility\", [c, d, a, b]);\n      });\n      (b === k || b) && c.columns.adjust();\n    });\n    return d;\n  });\n  u(\"columns().indexes()\", \"column().index()\", function (a) {\n    return this.iterator(\"column\", function (b, c) {\n      return a === \"visible\" ? ca(b, c) : c;\n    }, 1);\n  });\n  o(\"columns.adjust()\", function () {\n    return this.iterator(\"table\", function (a) {\n      aa(a);\n    }, 1);\n  });\n  o(\"column.index()\", function (a, b) {\n    if (this.context.length !== 0) {\n      var c = this.context[0];\n      if (a === \"fromVisible\" || a === \"toData\") return ba(c, b);\n      if (a === \"fromData\" || a === \"toVisible\") return ca(c, b);\n    }\n  });\n  o(\"column()\", function (a, b) {\n    return db(this.columns(a, b));\n  });\n  o(\"cells()\", function (a, b, c) {\n    if (h.isPlainObject(a)) if (a.row === k) {\n      c = a;\n      a = null;\n    } else {\n      c = b;\n      b = null;\n    }\n\n    if (h.isPlainObject(b)) {\n      c = b;\n      b = null;\n    }\n\n    if (b === null || b === k) return this.iterator(\"table\", function (b) {\n      var d = a,\n          e = cb(c),\n          f = b.aoData,\n          g = Da(b, e),\n          i = Sb(ka(f, g, \"anCells\")),\n          j = h(Tb([], i)),\n          l,\n          n = b.aoColumns.length,\n          o,\n          u,\n          r,\n          t,\n          w,\n          v;\n      return bb(\"cell\", d, function (a) {\n        var c = typeof a === \"function\";\n\n        if (a === null || a === k || c) {\n          o = [];\n          u = 0;\n\n          for (r = g.length; u < r; u++) {\n            l = g[u];\n\n            for (t = 0; t < n; t++) {\n              w = {\n                row: l,\n                column: t\n              };\n\n              if (c) {\n                v = f[l];\n                a(w, B(b, l, t), v.anCells ? v.anCells[t] : null) && o.push(w);\n              } else o.push(w);\n            }\n          }\n\n          return o;\n        }\n\n        if (h.isPlainObject(a)) return a.column !== k && a.row !== k && h.inArray(a.row, g) !== -1 ? [a] : [];\n        c = j.filter(a).map(function (a, b) {\n          return {\n            row: b._DT_CellIndex.row,\n            column: b._DT_CellIndex.column\n          };\n        }).toArray();\n        if (c.length || !a.nodeName) return c;\n        v = h(a).closest(\"*[data-dt-row]\");\n        return v.length ? [{\n          row: v.data(\"dt-row\"),\n          column: v.data(\"dt-column\")\n        }] : [];\n      }, b, e);\n    });\n    var d = c ? {\n      page: c.page,\n      order: c.order,\n      search: c.search\n    } : {},\n        e = this.columns(b, d),\n        f = this.rows(a, d),\n        g,\n        j,\n        i,\n        l,\n        d = this.iterator(\"table\", function (a, b) {\n      var c = [];\n      g = 0;\n\n      for (j = f[b].length; g < j; g++) {\n        i = 0;\n\n        for (l = e[b].length; i < l; i++) {\n          c.push({\n            row: f[b][g],\n            column: e[b][i]\n          });\n        }\n      }\n\n      return c;\n    }, 1),\n        d = c && c.selected ? this.cells(d, c) : d;\n    h.extend(d.selector, {\n      cols: b,\n      rows: a,\n      opts: c\n    });\n    return d;\n  });\n  u(\"cells().nodes()\", \"cell().node()\", function () {\n    return this.iterator(\"cell\", function (a, b, c) {\n      return (a = a.aoData[b]) && a.anCells ? a.anCells[c] : k;\n    }, 1);\n  });\n  o(\"cells().data()\", function () {\n    return this.iterator(\"cell\", function (a, b, c) {\n      return B(a, b, c);\n    }, 1);\n  });\n  u(\"cells().cache()\", \"cell().cache()\", function (a) {\n    a = a === \"search\" ? \"_aFilterData\" : \"_aSortData\";\n    return this.iterator(\"cell\", function (b, c, d) {\n      return b.aoData[c][a][d];\n    }, 1);\n  });\n  u(\"cells().render()\", \"cell().render()\", function (a) {\n    return this.iterator(\"cell\", function (b, c, d) {\n      return B(b, c, d, a);\n    }, 1);\n  });\n  u(\"cells().indexes()\", \"cell().index()\", function () {\n    return this.iterator(\"cell\", function (a, b, c) {\n      return {\n        row: b,\n        column: c,\n        columnVisible: ca(a, c)\n      };\n    }, 1);\n  });\n  u(\"cells().invalidate()\", \"cell().invalidate()\", function (a) {\n    return this.iterator(\"cell\", function (b, c, d) {\n      ea(b, c, a, d);\n    });\n  });\n  o(\"cell()\", function (a, b, c) {\n    return db(this.cells(a, b, c));\n  });\n  o(\"cell().data()\", function (a) {\n    var b = this.context,\n        c = this[0];\n    if (a === k) return b.length && c.length ? B(b[0], c[0].row, c[0].column) : k;\n    lb(b[0], c[0].row, c[0].column, a);\n    ea(b[0], c[0].row, \"data\", c[0].column);\n    return this;\n  });\n  o(\"order()\", function (a, b) {\n    var c = this.context;\n    if (a === k) return c.length !== 0 ? c[0].aaSorting : k;\n    typeof a === \"number\" ? a = [[a, b]] : a.length && !Array.isArray(a[0]) && (a = Array.prototype.slice.call(arguments));\n    return this.iterator(\"table\", function (b) {\n      b.aaSorting = a.slice();\n    });\n  });\n  o(\"order.listener()\", function (a, b, c) {\n    return this.iterator(\"table\", function (d) {\n      Oa(d, a, b, c);\n    });\n  });\n  o(\"order.fixed()\", function (a) {\n    if (!a) {\n      var b = this.context,\n          b = b.length ? b[0].aaSortingFixed : k;\n      return Array.isArray(b) ? {\n        pre: b\n      } : b;\n    }\n\n    return this.iterator(\"table\", function (b) {\n      b.aaSortingFixed = h.extend(true, {}, a);\n    });\n  });\n  o([\"columns().order()\", \"column().order()\"], function (a) {\n    var b = this;\n    return this.iterator(\"table\", function (c, d) {\n      var e = [];\n      h.each(b[d], function (b, c) {\n        e.push([c, a]);\n      });\n      c.aaSorting = e;\n    });\n  });\n  o(\"search()\", function (a, b, c, d) {\n    var e = this.context;\n    return a === k ? e.length !== 0 ? e[0].oPreviousSearch.sSearch : k : this.iterator(\"table\", function (e) {\n      e.oFeatures.bFilter && ha(e, h.extend({}, e.oPreviousSearch, {\n        sSearch: a + \"\",\n        bRegex: b === null ? false : b,\n        bSmart: c === null ? true : c,\n        bCaseInsensitive: d === null ? true : d\n      }), 1);\n    });\n  });\n  u(\"columns().search()\", \"column().search()\", function (a, b, c, d) {\n    return this.iterator(\"column\", function (e, f) {\n      var g = e.aoPreSearchCols;\n      if (a === k) return g[f].sSearch;\n\n      if (e.oFeatures.bFilter) {\n        h.extend(g[f], {\n          sSearch: a + \"\",\n          bRegex: b === null ? false : b,\n          bSmart: c === null ? true : c,\n          bCaseInsensitive: d === null ? true : d\n        });\n        ha(e, e.oPreviousSearch, 1);\n      }\n    });\n  });\n  o(\"state()\", function () {\n    return this.context.length ? this.context[0].oSavedState : null;\n  });\n  o(\"state.clear()\", function () {\n    return this.iterator(\"table\", function (a) {\n      a.fnStateSaveCallback.call(a.oInstance, a, {});\n    });\n  });\n  o(\"state.loaded()\", function () {\n    return this.context.length ? this.context[0].oLoadedState : null;\n  });\n  o(\"state.save()\", function () {\n    return this.iterator(\"table\", function (a) {\n      za(a);\n    });\n  });\n\n  l.versionCheck = l.fnVersionCheck = function (a) {\n    for (var b = l.version.split(\".\"), a = a.split(\".\"), c, d, e = 0, f = a.length; e < f; e++) {\n      c = parseInt(b[e], 10) || 0;\n      d = parseInt(a[e], 10) || 0;\n      if (c !== d) return c > d;\n    }\n\n    return true;\n  };\n\n  l.isDataTable = l.fnIsDataTable = function (a) {\n    var b = h(a).get(0),\n        c = false;\n    if (a instanceof l.Api) return true;\n    h.each(l.settings, function (a, e) {\n      var f = e.nScrollHead ? h(\"table\", e.nScrollHead)[0] : null,\n          g = e.nScrollFoot ? h(\"table\", e.nScrollFoot)[0] : null;\n      if (e.nTable === b || f === b || g === b) c = true;\n    });\n    return c;\n  };\n\n  l.tables = l.fnTables = function (a) {\n    var b = false;\n\n    if (h.isPlainObject(a)) {\n      b = a.api;\n      a = a.visible;\n    }\n\n    var c = h.map(l.settings, function (b) {\n      if (!a || a && h(b.nTable).is(\":visible\")) return b.nTable;\n    });\n    return b ? new _r(c) : c;\n  };\n\n  l.camelToHungarian = J;\n  o(\"$()\", function (a, b) {\n    var c = this.rows(b).nodes(),\n        c = h(c);\n    return h([].concat(c.filter(a).toArray(), c.find(a).toArray()));\n  });\n  h.each([\"on\", \"one\", \"off\"], function (a, b) {\n    o(b + \"()\", function () {\n      var a = Array.prototype.slice.call(arguments);\n      a[0] = h.map(a[0].split(/\\s/), function (a) {\n        return !a.match(/\\.dt\\b/) ? a + \".dt\" : a;\n      }).join(\" \");\n      var d = h(this.tables().nodes());\n      d[b].apply(d, a);\n      return this;\n    });\n  });\n  o(\"clear()\", function () {\n    return this.iterator(\"table\", function (a) {\n      pa(a);\n    });\n  });\n  o(\"settings()\", function () {\n    return new _r(this.context, this.context);\n  });\n  o(\"init()\", function () {\n    var a = this.context;\n    return a.length ? a[0].oInit : null;\n  });\n  o(\"data()\", function () {\n    return this.iterator(\"table\", function (a) {\n      return C(a.aoData, \"_aData\");\n    }).flatten();\n  });\n  o(\"destroy()\", function (a) {\n    a = a || false;\n    return this.iterator(\"table\", function (b) {\n      var c = b.nTableWrapper.parentNode,\n          d = b.oClasses,\n          e = b.nTable,\n          f = b.nTBody,\n          g = b.nTHead,\n          j = b.nTFoot,\n          i = h(e),\n          f = h(f),\n          k = h(b.nTableWrapper),\n          m = h.map(b.aoData, function (a) {\n        return a.nTr;\n      }),\n          o;\n      b.bDestroying = true;\n      t(b, \"aoDestroyCallback\", \"destroy\", [b]);\n      a || new _r(b).columns().visible(true);\n      k.off(\".DT\").find(\":not(tbody *)\").off(\".DT\");\n      h(E).off(\".DT-\" + b.sInstance);\n\n      if (e != g.parentNode) {\n        i.children(\"thead\").detach();\n        i.append(g);\n      }\n\n      if (j && e != j.parentNode) {\n        i.children(\"tfoot\").detach();\n        i.append(j);\n      }\n\n      b.aaSorting = [];\n      b.aaSortingFixed = [];\n      ya(b);\n      h(m).removeClass(b.asStripeClasses.join(\" \"));\n      h(\"th, td\", g).removeClass(d.sSortable + \" \" + d.sSortableAsc + \" \" + d.sSortableDesc + \" \" + d.sSortableNone);\n      f.children().detach();\n      f.append(m);\n      g = a ? \"remove\" : \"detach\";\n      i[g]();\n      k[g]();\n\n      if (!a && c) {\n        c.insertBefore(e, b.nTableReinsertBefore);\n        i.css(\"width\", b.sDestroyWidth).removeClass(d.sTable);\n        (o = b.asDestroyStripes.length) && f.children().each(function (a) {\n          h(this).addClass(b.asDestroyStripes[a % o]);\n        });\n      }\n\n      c = h.inArray(b, l.settings);\n      c !== -1 && l.settings.splice(c, 1);\n    });\n  });\n  h.each([\"column\", \"row\", \"cell\"], function (a, b) {\n    o(b + \"s().every()\", function (a) {\n      var d = this.selector.opts,\n          e = this;\n      return this.iterator(b, function (f, g, h, i, l) {\n        a.call(e[b](g, b === \"cell\" ? h : d, b === \"cell\" ? d : k), g, h, i, l);\n      });\n    });\n  });\n  o(\"i18n()\", function (a, b, c) {\n    var d = this.context[0],\n        a = S(a)(d.oLanguage);\n    a === k && (a = b);\n    c !== k && h.isPlainObject(a) && (a = a[c] !== k ? a[c] : a._);\n    return a.replace(\"%d\", c);\n  });\n  l.version = \"1.10.24\";\n  l.settings = [];\n  l.models = {};\n  l.models.oSearch = {\n    bCaseInsensitive: !0,\n    sSearch: \"\",\n    bRegex: !1,\n    bSmart: !0\n  };\n  l.models.oRow = {\n    nTr: null,\n    anCells: null,\n    _aData: [],\n    _aSortData: null,\n    _aFilterData: null,\n    _sFilterRow: null,\n    _sRowStripe: \"\",\n    src: null,\n    idx: -1\n  };\n  l.models.oColumn = {\n    idx: null,\n    aDataSort: null,\n    asSorting: null,\n    bSearchable: null,\n    bSortable: null,\n    bVisible: null,\n    _sManualType: null,\n    _bAttrSrc: !1,\n    fnCreatedCell: null,\n    fnGetData: null,\n    fnSetData: null,\n    mData: null,\n    mRender: null,\n    nTh: null,\n    nTf: null,\n    sClass: null,\n    sContentPadding: null,\n    sDefaultContent: null,\n    sName: null,\n    sSortDataType: \"std\",\n    sSortingClass: null,\n    sSortingClassJUI: null,\n    sTitle: null,\n    sType: null,\n    sWidth: null,\n    sWidthOrig: null\n  };\n  l.defaults = {\n    aaData: null,\n    aaSorting: [[0, \"asc\"]],\n    aaSortingFixed: [],\n    ajax: null,\n    aLengthMenu: [10, 25, 50, 100],\n    aoColumns: null,\n    aoColumnDefs: null,\n    aoSearchCols: [],\n    asStripeClasses: null,\n    bAutoWidth: !0,\n    bDeferRender: !1,\n    bDestroy: !1,\n    bFilter: !0,\n    bInfo: !0,\n    bLengthChange: !0,\n    bPaginate: !0,\n    bProcessing: !1,\n    bRetrieve: !1,\n    bScrollCollapse: !1,\n    bServerSide: !1,\n    bSort: !0,\n    bSortMulti: !0,\n    bSortCellsTop: !1,\n    bSortClasses: !0,\n    bStateSave: !1,\n    fnCreatedRow: null,\n    fnDrawCallback: null,\n    fnFooterCallback: null,\n    fnFormatNumber: function fnFormatNumber(a) {\n      return a.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.oLanguage.sThousands);\n    },\n    fnHeaderCallback: null,\n    fnInfoCallback: null,\n    fnInitComplete: null,\n    fnPreDrawCallback: null,\n    fnRowCallback: null,\n    fnServerData: null,\n    fnServerParams: null,\n    fnStateLoadCallback: function fnStateLoadCallback(a) {\n      try {\n        return JSON.parse((a.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\"DataTables_\" + a.sInstance + \"_\" + location.pathname));\n      } catch (b) {\n        return {};\n      }\n    },\n    fnStateLoadParams: null,\n    fnStateLoaded: null,\n    fnStateSaveCallback: function fnStateSaveCallback(a, b) {\n      try {\n        (a.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\"DataTables_\" + a.sInstance + \"_\" + location.pathname, JSON.stringify(b));\n      } catch (c) {}\n    },\n    fnStateSaveParams: null,\n    iStateDuration: 7200,\n    iDeferLoading: null,\n    iDisplayLength: 10,\n    iDisplayStart: 0,\n    iTabIndex: 0,\n    oClasses: {},\n    oLanguage: {\n      oAria: {\n        sSortAscending: \": activate to sort column ascending\",\n        sSortDescending: \": activate to sort column descending\"\n      },\n      oPaginate: {\n        sFirst: \"First\",\n        sLast: \"Last\",\n        sNext: \"Next\",\n        sPrevious: \"Previous\"\n      },\n      sEmptyTable: \"No data available in table\",\n      sInfo: \"Showing _START_ to _END_ of _TOTAL_ entries\",\n      sInfoEmpty: \"Showing 0 to 0 of 0 entries\",\n      sInfoFiltered: \"(filtered from _MAX_ total entries)\",\n      sInfoPostFix: \"\",\n      sDecimal: \"\",\n      sThousands: \",\",\n      sLengthMenu: \"Show _MENU_ entries\",\n      sLoadingRecords: \"Loading...\",\n      sProcessing: \"Processing...\",\n      sSearch: \"Search:\",\n      sSearchPlaceholder: \"\",\n      sUrl: \"\",\n      sZeroRecords: \"No matching records found\"\n    },\n    oSearch: h.extend({}, l.models.oSearch),\n    sAjaxDataProp: \"data\",\n    sAjaxSource: null,\n    sDom: \"lfrtip\",\n    searchDelay: null,\n    sPaginationType: \"simple_numbers\",\n    sScrollX: \"\",\n    sScrollXInner: \"\",\n    sScrollY: \"\",\n    sServerMethod: \"GET\",\n    renderer: null,\n    rowId: \"DT_RowId\"\n  };\n  $(l.defaults);\n  l.defaults.column = {\n    aDataSort: null,\n    iDataSort: -1,\n    asSorting: [\"asc\", \"desc\"],\n    bSearchable: !0,\n    bSortable: !0,\n    bVisible: !0,\n    fnCreatedCell: null,\n    mData: null,\n    mRender: null,\n    sCellType: \"td\",\n    sClass: \"\",\n    sContentPadding: \"\",\n    sDefaultContent: null,\n    sName: \"\",\n    sSortDataType: \"std\",\n    sTitle: null,\n    sType: null,\n    sWidth: null\n  };\n  $(l.defaults.column);\n  l.models.oSettings = {\n    oFeatures: {\n      bAutoWidth: null,\n      bDeferRender: null,\n      bFilter: null,\n      bInfo: null,\n      bLengthChange: null,\n      bPaginate: null,\n      bProcessing: null,\n      bServerSide: null,\n      bSort: null,\n      bSortMulti: null,\n      bSortClasses: null,\n      bStateSave: null\n    },\n    oScroll: {\n      bCollapse: null,\n      iBarWidth: 0,\n      sX: null,\n      sXInner: null,\n      sY: null\n    },\n    oLanguage: {\n      fnInfoCallback: null\n    },\n    oBrowser: {\n      bScrollOversize: !1,\n      bScrollbarLeft: !1,\n      bBounding: !1,\n      barWidth: 0\n    },\n    ajax: null,\n    aanFeatures: [],\n    aoData: [],\n    aiDisplay: [],\n    aiDisplayMaster: [],\n    aIds: {},\n    aoColumns: [],\n    aoHeader: [],\n    aoFooter: [],\n    oPreviousSearch: {},\n    aoPreSearchCols: [],\n    aaSorting: null,\n    aaSortingFixed: [],\n    asStripeClasses: null,\n    asDestroyStripes: [],\n    sDestroyWidth: 0,\n    aoRowCallback: [],\n    aoHeaderCallback: [],\n    aoFooterCallback: [],\n    aoDrawCallback: [],\n    aoRowCreatedCallback: [],\n    aoPreDrawCallback: [],\n    aoInitComplete: [],\n    aoStateSaveParams: [],\n    aoStateLoadParams: [],\n    aoStateLoaded: [],\n    sTableId: \"\",\n    nTable: null,\n    nTHead: null,\n    nTFoot: null,\n    nTBody: null,\n    nTableWrapper: null,\n    bDeferLoading: !1,\n    bInitialised: !1,\n    aoOpenRows: [],\n    sDom: null,\n    searchDelay: null,\n    sPaginationType: \"two_button\",\n    iStateDuration: 0,\n    aoStateSave: [],\n    aoStateLoad: [],\n    oSavedState: null,\n    oLoadedState: null,\n    sAjaxSource: null,\n    sAjaxDataProp: null,\n    bAjaxDataGet: !0,\n    jqXHR: null,\n    json: k,\n    oAjaxData: k,\n    fnServerData: null,\n    aoServerParams: [],\n    sServerMethod: null,\n    fnFormatNumber: null,\n    aLengthMenu: null,\n    iDraw: 0,\n    bDrawing: !1,\n    iDrawError: -1,\n    _iDisplayLength: 10,\n    _iDisplayStart: 0,\n    _iRecordsTotal: 0,\n    _iRecordsDisplay: 0,\n    oClasses: {},\n    bFiltered: !1,\n    bSorted: !1,\n    bSortCellsTop: null,\n    oInit: null,\n    aoDestroyCallback: [],\n    fnRecordsTotal: function fnRecordsTotal() {\n      return y(this) == \"ssp\" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;\n    },\n    fnRecordsDisplay: function fnRecordsDisplay() {\n      return y(this) == \"ssp\" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;\n    },\n    fnDisplayEnd: function fnDisplayEnd() {\n      var a = this._iDisplayLength,\n          b = this._iDisplayStart,\n          c = b + a,\n          d = this.aiDisplay.length,\n          e = this.oFeatures,\n          f = e.bPaginate;\n      return e.bServerSide ? f === false || a === -1 ? b + d : Math.min(b + a, this._iRecordsDisplay) : !f || c > d || a === -1 ? d : c;\n    },\n    oInstance: null,\n    sInstance: null,\n    iTabIndex: 0,\n    nScrollHead: null,\n    nScrollFoot: null,\n    aLastSort: [],\n    oPlugins: {},\n    rowIdFn: null,\n    rowId: null\n  };\n  l.ext = v = {\n    buttons: {},\n    classes: {},\n    builder: \"-source-\",\n    errMode: \"alert\",\n    feature: [],\n    search: [],\n    selector: {\n      cell: [],\n      column: [],\n      row: []\n    },\n    internal: {},\n    legacy: {\n      ajax: null\n    },\n    pager: {},\n    renderer: {\n      pageButton: {},\n      header: {}\n    },\n    order: {},\n    type: {\n      detect: [],\n      search: {},\n      order: {}\n    },\n    _unique: 0,\n    fnVersionCheck: l.fnVersionCheck,\n    iApiIndex: 0,\n    oJUIClasses: {},\n    sVersion: l.version\n  };\n  h.extend(v, {\n    afnFiltering: v.search,\n    aTypes: v.type.detect,\n    ofnSearch: v.type.search,\n    oSort: v.type.order,\n    afnSortData: v.order,\n    aoFeatures: v.feature,\n    oApi: v.internal,\n    oStdClasses: v.classes,\n    oPagination: v.pager\n  });\n  h.extend(l.ext.classes, {\n    sTable: \"dataTable\",\n    sNoFooter: \"no-footer\",\n    sPageButton: \"paginate_button\",\n    sPageButtonActive: \"current\",\n    sPageButtonDisabled: \"disabled\",\n    sStripeOdd: \"odd\",\n    sStripeEven: \"even\",\n    sRowEmpty: \"dataTables_empty\",\n    sWrapper: \"dataTables_wrapper\",\n    sFilter: \"dataTables_filter\",\n    sInfo: \"dataTables_info\",\n    sPaging: \"dataTables_paginate paging_\",\n    sLength: \"dataTables_length\",\n    sProcessing: \"dataTables_processing\",\n    sSortAsc: \"sorting_asc\",\n    sSortDesc: \"sorting_desc\",\n    sSortable: \"sorting\",\n    sSortableAsc: \"sorting_desc_disabled\",\n    sSortableDesc: \"sorting_asc_disabled\",\n    sSortableNone: \"sorting_disabled\",\n    sSortColumn: \"sorting_\",\n    sFilterInput: \"\",\n    sLengthSelect: \"\",\n    sScrollWrapper: \"dataTables_scroll\",\n    sScrollHead: \"dataTables_scrollHead\",\n    sScrollHeadInner: \"dataTables_scrollHeadInner\",\n    sScrollBody: \"dataTables_scrollBody\",\n    sScrollFoot: \"dataTables_scrollFoot\",\n    sScrollFootInner: \"dataTables_scrollFootInner\",\n    sHeaderTH: \"\",\n    sFooterTH: \"\",\n    sSortJUIAsc: \"\",\n    sSortJUIDesc: \"\",\n    sSortJUI: \"\",\n    sSortJUIAscAllowed: \"\",\n    sSortJUIDescAllowed: \"\",\n    sSortJUIWrapper: \"\",\n    sSortIcon: \"\",\n    sJUIHeader: \"\",\n    sJUIFooter: \"\"\n  });\n  var Mb = l.ext.pager;\n  h.extend(Mb, {\n    simple: function simple() {\n      return [\"previous\", \"next\"];\n    },\n    full: function full() {\n      return [\"first\", \"previous\", \"next\", \"last\"];\n    },\n    numbers: function numbers(a, b) {\n      return [ja(a, b)];\n    },\n    simple_numbers: function simple_numbers(a, b) {\n      return [\"previous\", ja(a, b), \"next\"];\n    },\n    full_numbers: function full_numbers(a, b) {\n      return [\"first\", \"previous\", ja(a, b), \"next\", \"last\"];\n    },\n    first_last_numbers: function first_last_numbers(a, b) {\n      return [\"first\", ja(a, b), \"last\"];\n    },\n    _numbers: ja,\n    numbers_length: 7\n  });\n  h.extend(!0, l.ext.renderer, {\n    pageButton: {\n      _: function _(a, b, c, d, e, f) {\n        var g = a.oClasses,\n            j = a.oLanguage.oPaginate,\n            i = a.oLanguage.oAria.paginate || {},\n            l,\n            m,\n            o = 0,\n            s = function s(b, d) {\n          var k,\n              u,\n              t,\n              r,\n              v = g.sPageButtonDisabled,\n              w = function w(b) {\n            Va(a, b.data.action, true);\n          };\n\n          k = 0;\n\n          for (u = d.length; k < u; k++) {\n            r = d[k];\n\n            if (Array.isArray(r)) {\n              t = h(\"<\" + (r.DT_el || \"div\") + \"/>\").appendTo(b);\n              s(t, r);\n            } else {\n              l = null;\n              m = r;\n              t = a.iTabIndex;\n\n              switch (r) {\n                case \"ellipsis\":\n                  b.append('<span class=\"ellipsis\">&#x2026;</span>');\n                  break;\n\n                case \"first\":\n                  l = j.sFirst;\n\n                  if (e === 0) {\n                    t = -1;\n                    m = m + (\" \" + v);\n                  }\n\n                  break;\n\n                case \"previous\":\n                  l = j.sPrevious;\n\n                  if (e === 0) {\n                    t = -1;\n                    m = m + (\" \" + v);\n                  }\n\n                  break;\n\n                case \"next\":\n                  l = j.sNext;\n\n                  if (f === 0 || e === f - 1) {\n                    t = -1;\n                    m = m + (\" \" + v);\n                  }\n\n                  break;\n\n                case \"last\":\n                  l = j.sLast;\n\n                  if (f === 0 || e === f - 1) {\n                    t = -1;\n                    m = m + (\" \" + v);\n                  }\n\n                  break;\n\n                default:\n                  l = a.fnFormatNumber(r + 1);\n                  m = e === r ? g.sPageButtonActive : \"\";\n              }\n\n              if (l !== null) {\n                t = h(\"<a>\", {\n                  \"class\": g.sPageButton + \" \" + m,\n                  \"aria-controls\": a.sTableId,\n                  \"aria-label\": i[r],\n                  \"data-dt-idx\": o,\n                  tabindex: t,\n                  id: c === 0 && typeof r === \"string\" ? a.sTableId + \"_\" + r : null\n                }).html(l).appendTo(b);\n                Xa(t, {\n                  action: r\n                }, w);\n                o++;\n              }\n            }\n          }\n        },\n            u;\n\n        try {\n          u = h(b).find(H.activeElement).data(\"dt-idx\");\n        } catch (t) {}\n\n        s(h(b).empty(), d);\n        u !== k && h(b).find(\"[data-dt-idx=\" + u + \"]\").trigger(\"focus\");\n      }\n    }\n  });\n  h.extend(l.ext.type.detect, [function (a, b) {\n    var c = b.oLanguage.sDecimal;\n    return ab(a, c) ? \"num\" + c : null;\n  }, function (a) {\n    if (a && !(a instanceof Date) && !bc.test(a)) return null;\n    var b = Date.parse(a);\n    return b !== null && !isNaN(b) || M(a) ? \"date\" : null;\n  }, function (a, b) {\n    var c = b.oLanguage.sDecimal;\n    return ab(a, c, true) ? \"num-fmt\" + c : null;\n  }, function (a, b) {\n    var c = b.oLanguage.sDecimal;\n    return Rb(a, c) ? \"html-num\" + c : null;\n  }, function (a, b) {\n    var c = b.oLanguage.sDecimal;\n    return Rb(a, c, true) ? \"html-num-fmt\" + c : null;\n  }, function (a) {\n    return M(a) || typeof a === \"string\" && a.indexOf(\"<\") !== -1 ? \"html\" : null;\n  }]);\n  h.extend(l.ext.type.search, {\n    html: function html(a) {\n      return M(a) ? a : typeof a === \"string\" ? a.replace(Ob, \" \").replace(Ca, \"\") : \"\";\n    },\n    string: function string(a) {\n      return M(a) ? a : typeof a === \"string\" ? a.replace(Ob, \" \") : a;\n    }\n  });\n\n  var Ba = function Ba(a, b, c, d) {\n    if (a !== 0 && (!a || a === \"-\")) return -Infinity;\n    b && (a = Qb(a, b));\n\n    if (a.replace) {\n      c && (a = a.replace(c, \"\"));\n      d && (a = a.replace(d, \"\"));\n    }\n\n    return a * 1;\n  };\n\n  h.extend(v.type.order, {\n    \"date-pre\": function datePre(a) {\n      a = Date.parse(a);\n      return isNaN(a) ? -Infinity : a;\n    },\n    \"html-pre\": function htmlPre(a) {\n      return M(a) ? \"\" : a.replace ? a.replace(/<.*?>/g, \"\").toLowerCase() : a + \"\";\n    },\n    \"string-pre\": function stringPre(a) {\n      return M(a) ? \"\" : typeof a === \"string\" ? a.toLowerCase() : !a.toString ? \"\" : a.toString();\n    },\n    \"string-asc\": function stringAsc(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    \"string-desc\": function stringDesc(a, b) {\n      return a < b ? 1 : a > b ? -1 : 0;\n    }\n  });\n  Fa(\"\");\n  h.extend(!0, l.ext.renderer, {\n    header: {\n      _: function _(a, b, c, d) {\n        h(a.nTable).on(\"order.dt.DT\", function (e, f, g, h) {\n          if (a === f) {\n            e = c.idx;\n            b.removeClass(d.sSortAsc + \" \" + d.sSortDesc).addClass(h[e] == \"asc\" ? d.sSortAsc : h[e] == \"desc\" ? d.sSortDesc : c.sSortingClass);\n          }\n        });\n      },\n      jqueryui: function jqueryui(a, b, c, d) {\n        h(\"<div/>\").addClass(d.sSortJUIWrapper).append(b.contents()).append(h(\"<span/>\").addClass(d.sSortIcon + \" \" + c.sSortingClassJUI)).appendTo(b);\n        h(a.nTable).on(\"order.dt.DT\", function (e, f, g, h) {\n          if (a === f) {\n            e = c.idx;\n            b.removeClass(d.sSortAsc + \" \" + d.sSortDesc).addClass(h[e] == \"asc\" ? d.sSortAsc : h[e] == \"desc\" ? d.sSortDesc : c.sSortingClass);\n            b.find(\"span.\" + d.sSortIcon).removeClass(d.sSortJUIAsc + \" \" + d.sSortJUIDesc + \" \" + d.sSortJUI + \" \" + d.sSortJUIAscAllowed + \" \" + d.sSortJUIDescAllowed).addClass(h[e] == \"asc\" ? d.sSortJUIAsc : h[e] == \"desc\" ? d.sSortJUIDesc : c.sSortingClassJUI);\n          }\n        });\n      }\n    }\n  });\n\n  var fb = function fb(a) {\n    return typeof a === \"string\" ? a.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\") : a;\n  };\n\n  l.render = {\n    number: function number(a, b, c, d, e) {\n      return {\n        display: function display(f) {\n          if (typeof f !== \"number\" && typeof f !== \"string\") return f;\n          var g = f < 0 ? \"-\" : \"\",\n              h = parseFloat(f);\n          if (isNaN(h)) return fb(f);\n          h = h.toFixed(c);\n          f = Math.abs(h);\n          h = parseInt(f, 10);\n          f = c ? b + (f - h).toFixed(c).substring(2) : \"\";\n          return g + (d || \"\") + h.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, a) + f + (e || \"\");\n        }\n      };\n    },\n    text: function text() {\n      return {\n        display: fb,\n        filter: fb\n      };\n    }\n  };\n  h.extend(l.ext.internal, {\n    _fnExternApiFunc: Nb,\n    _fnBuildAjax: ta,\n    _fnAjaxUpdate: nb,\n    _fnAjaxParameters: wb,\n    _fnAjaxUpdateDraw: xb,\n    _fnAjaxDataSrc: ua,\n    _fnAddColumn: Ga,\n    _fnColumnOptions: la,\n    _fnAdjustColumnSizing: aa,\n    _fnVisibleToColumnIndex: ba,\n    _fnColumnIndexToVisible: ca,\n    _fnVisbleColumns: W,\n    _fnGetColumns: na,\n    _fnColumnTypes: Ia,\n    _fnApplyColumnDefs: kb,\n    _fnHungarianMap: $,\n    _fnCamelToHungarian: J,\n    _fnLanguageCompat: Ea,\n    _fnBrowserDetect: ib,\n    _fnAddData: O,\n    _fnAddTr: oa,\n    _fnNodeToDataIndex: function _fnNodeToDataIndex(a, b) {\n      return b._DT_RowIndex !== k ? b._DT_RowIndex : null;\n    },\n    _fnNodeToColumnIndex: function _fnNodeToColumnIndex(a, b, c) {\n      return h.inArray(c, a.aoData[b].anCells);\n    },\n    _fnGetCellData: B,\n    _fnSetCellData: lb,\n    _fnSplitObjNotation: La,\n    _fnGetObjectDataFn: S,\n    _fnSetObjectDataFn: N,\n    _fnGetDataMaster: Ma,\n    _fnClearTable: pa,\n    _fnDeleteIndex: qa,\n    _fnInvalidate: ea,\n    _fnGetRowElements: Ka,\n    _fnCreateTr: Ja,\n    _fnBuildHead: mb,\n    _fnDrawHead: ga,\n    _fnDraw: P,\n    _fnReDraw: T,\n    _fnAddOptionsHtml: pb,\n    _fnDetectHeader: fa,\n    _fnGetUniqueThs: sa,\n    _fnFeatureHtmlFilter: rb,\n    _fnFilterComplete: ha,\n    _fnFilterCustom: Ab,\n    _fnFilterColumn: zb,\n    _fnFilter: yb,\n    _fnFilterCreateSearch: Ra,\n    _fnEscapeRegex: Sa,\n    _fnFilterData: Bb,\n    _fnFeatureHtmlInfo: ub,\n    _fnUpdateInfo: Eb,\n    _fnInfoMacros: Fb,\n    _fnInitialise: ia,\n    _fnInitComplete: va,\n    _fnLengthChange: Ta,\n    _fnFeatureHtmlLength: qb,\n    _fnFeatureHtmlPaginate: vb,\n    _fnPageChange: Va,\n    _fnFeatureHtmlProcessing: sb,\n    _fnProcessingDisplay: D,\n    _fnFeatureHtmlTable: tb,\n    _fnScrollDraw: ma,\n    _fnApplyToChildren: I,\n    _fnCalculateColumnWidths: Ha,\n    _fnThrottle: Qa,\n    _fnConvertToWidth: Gb,\n    _fnGetWidestNode: Hb,\n    _fnGetMaxLenString: Ib,\n    _fnStringToCss: w,\n    _fnSortFlatten: Y,\n    _fnSort: ob,\n    _fnSortAria: Kb,\n    _fnSortListener: Wa,\n    _fnSortAttachListener: Oa,\n    _fnSortingClasses: ya,\n    _fnSortData: Jb,\n    _fnSaveState: za,\n    _fnLoadState: Lb,\n    _fnSettingsFromNode: Aa,\n    _fnLog: K,\n    _fnMap: F,\n    _fnBindAction: Xa,\n    _fnCallbackReg: z,\n    _fnCallbackFire: t,\n    _fnLengthOverflow: Ua,\n    _fnRenderer: Pa,\n    _fnDataSource: y,\n    _fnRowAttributes: Na,\n    _fnExtend: Ya,\n    _fnCalculateEnd: function _fnCalculateEnd() {}\n  });\n  h.fn.dataTable = l;\n  l.$ = h;\n  h.fn.dataTableSettings = l.settings;\n  h.fn.dataTableExt = l.ext;\n\n  h.fn.DataTable = function (a) {\n    return h(this).dataTable(a).api();\n  };\n\n  h.each(l, function (a, b) {\n    h.fn.DataTable[a] = b;\n  });\n  return h.fn.dataTable;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL2RhdGF0YWJsZXMvanF1ZXJ5LmRhdGFUYWJsZXMubWluLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUFDLFVBQXVDQyxpQ0FBTyxDQUFDLDJDQUFELENBQUQsbUNBQVksVUFBU0UsQ0FBVCxFQUFXO0FBQUMsV0FBT0gsQ0FBQyxDQUFDRyxDQUFELEVBQUdDLE1BQUgsRUFBVUMsUUFBVixDQUFSO0FBQTRCLEdBQXBEO0FBQUEsa0dBQTdDLEdBQW1HLENBQW5HO0FBQXNTLENBQW5ULEVBQXFULFVBQVNMLENBQVQsRUFBV0csQ0FBWCxFQUFhSyxDQUFiLEVBQWVHLENBQWYsRUFBaUI7QUFBQyxXQUFTQyxDQUFULENBQVdDLENBQVgsRUFBYTtBQUFDLFFBQUlDLENBQUo7QUFBQSxRQUFNQyxDQUFOO0FBQUEsUUFBUUMsQ0FBQyxHQUFDLEVBQVY7QUFBYWhCLElBQUFBLENBQUMsQ0FBQ2lCLElBQUYsQ0FBT0osQ0FBUCxFQUFTLFVBQVNLLENBQVQsRUFBVztBQUFDLFVBQUcsQ0FBQ0osQ0FBQyxHQUFDSSxDQUFDLENBQUNDLEtBQUYsQ0FBUSxvQkFBUixDQUFILEtBQW1DLENBQUMsQ0FBRCxLQUFLLDhCQUE4QkMsT0FBOUIsQ0FBc0NOLENBQUMsQ0FBQyxDQUFELENBQUQsR0FBSyxHQUEzQyxDQUEzQyxFQUEyRkMsQ0FBQyxHQUFDRyxDQUFDLENBQUNHLE9BQUYsQ0FBVVAsQ0FBQyxDQUFDLENBQUQsQ0FBWCxFQUFlQSxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUtRLFdBQUwsRUFBZixDQUFGLEVBQ2xkTixDQUFDLENBQUNELENBQUQsQ0FBRCxHQUFLRyxDQUQ2YyxFQUMzYyxRQUFNSixDQUFDLENBQUMsQ0FBRCxDQUFQLElBQVlGLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDSyxDQUFELENBQUYsQ0FEOGI7QUFDdmIsS0FEdVU7QUFDclVMLElBQUFBLENBQUMsQ0FB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SjtBQUFNQSxFQUFBQSxDQUFDLENBQUNtWSxFQUFGLENBQUt5YyxpQkFBTCxHQUF1Qmh6QixDQUFDLENBQUNvSixRQUF6QjtBQUFrQ2hMLEVBQUFBLENBQUMsQ0FBQ21ZLEVBQUYsQ0FBSzBjLFlBQUwsR0FBa0JqekIsQ0FBQyxDQUFDMkgsR0FBcEI7O0FBQXdCdkosRUFBQUEsQ0FBQyxDQUFDbVksRUFBRixDQUFLMmMsU0FBTCxHQUFlLFVBQVNqMEIsQ0FBVCxFQUFXO0FBQUMsV0FBT2IsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRZ2tCLFNBQVIsQ0FBa0JuakIsQ0FBbEIsRUFBcUIwZ0IsR0FBckIsRUFBUDtBQUFrQyxHQUE3RDs7QUFBOER2aEIsRUFBQUEsQ0FBQyxDQUFDaUIsSUFBRixDQUFPVyxDQUFQLEVBQVMsVUFBU2YsQ0FBVCxFQUFXQyxDQUFYLEVBQWE7QUFBQ2QsSUFBQUEsQ0FBQyxDQUFDbVksRUFBRixDQUFLMmMsU0FBTCxDQUFlajBCLENBQWYsSUFBa0JDLENBQWxCO0FBQW9CLEdBQTNDO0FBQTZDLFNBQU9kLENBQUMsQ0FBQ21ZLEVBQUYsQ0FBSzZMLFNBQVo7QUFBc0IsQ0FuS3ZlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9kYXRhdGFibGVzL2pxdWVyeS5kYXRhVGFibGVzLm1pbi5qcz85ZWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gRGF0YVRhYmxlcyAxLjEwLjI0XHJcbiDCqTIwMDgtMjAyMSBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxyXG4qL1xyXG4oZnVuY3Rpb24oaCl7XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGZ1bmN0aW9uKEUpe3JldHVybiBoKEUsd2luZG93LGRvY3VtZW50KX0pOlwib2JqZWN0XCI9PT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihFLEgpe0V8fChFPXdpbmRvdyk7SHx8KEg9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcImpxdWVyeVwiKTpyZXF1aXJlKFwianF1ZXJ5XCIpKEUpKTtyZXR1cm4gaChILEUsRS5kb2N1bWVudCl9OmgoalF1ZXJ5LHdpbmRvdyxkb2N1bWVudCl9KShmdW5jdGlvbihoLEUsSCxrKXtmdW5jdGlvbiAkKGEpe3ZhciBiLGMsZD17fTtoLmVhY2goYSxmdW5jdGlvbihlKXtpZigoYj1lLm1hdGNoKC9eKFteQS1aXSs/KShbQS1aXSkvKSkmJi0xIT09XCJhIGFhIGFpIGFvIGFzIGIgZm4gaSBtIG8gcyBcIi5pbmRleE9mKGJbMV0rXCIgXCIpKWM9ZS5yZXBsYWNlKGJbMF0sYlsyXS50b0xvd2VyQ2FzZSgpKSxcclxuZFtjXT1lLFwib1wiPT09YlsxXSYmJChhW2VdKX0pO2EuX2h1bmdhcmlhbk1hcD1kfWZ1bmN0aW9uIEooYSxiLGMpe2EuX2h1bmdhcmlhbk1hcHx8JChhKTt2YXIgZDtoLmVhY2goYixmdW5jdGlvbihlKXtkPWEuX2h1bmdhcmlhbk1hcFtlXTtpZihkIT09ayYmKGN8fGJbZF09PT1rKSlcIm9cIj09PWQuY2hhckF0KDApPyhiW2RdfHwoYltkXT17fSksaC5leHRlbmQoITAsYltkXSxiW2VdKSxKKGFbZF0sYltkXSxjKSk6YltkXT1iW2VdfSl9ZnVuY3Rpb24gRWEoYSl7dmFyIGI9bC5kZWZhdWx0cy5vTGFuZ3VhZ2UsYz1iLnNEZWNpbWFsO2MmJkZhKGMpO2lmKGEpe3ZhciBkPWEuc1plcm9SZWNvcmRzOyFhLnNFbXB0eVRhYmxlJiYoZCYmXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiPT09Yi5zRW1wdHlUYWJsZSkmJkYoYSxhLFwic1plcm9SZWNvcmRzXCIsXCJzRW1wdHlUYWJsZVwiKTshYS5zTG9hZGluZ1JlY29yZHMmJihkJiZcIkxvYWRpbmcuLi5cIj09PWIuc0xvYWRpbmdSZWNvcmRzKSYmRihhLFxyXG5hLFwic1plcm9SZWNvcmRzXCIsXCJzTG9hZGluZ1JlY29yZHNcIik7YS5zSW5mb1Rob3VzYW5kcyYmKGEuc1Rob3VzYW5kcz1hLnNJbmZvVGhvdXNhbmRzKTsoYT1hLnNEZWNpbWFsKSYmYyE9PWEmJkZhKGEpfX1mdW5jdGlvbiBnYihhKXtBKGEsXCJvcmRlcmluZ1wiLFwiYlNvcnRcIik7QShhLFwib3JkZXJNdWx0aVwiLFwiYlNvcnRNdWx0aVwiKTtBKGEsXCJvcmRlckNsYXNzZXNcIixcImJTb3J0Q2xhc3Nlc1wiKTtBKGEsXCJvcmRlckNlbGxzVG9wXCIsXCJiU29ydENlbGxzVG9wXCIpO0EoYSxcIm9yZGVyXCIsXCJhYVNvcnRpbmdcIik7QShhLFwib3JkZXJGaXhlZFwiLFwiYWFTb3J0aW5nRml4ZWRcIik7QShhLFwicGFnaW5nXCIsXCJiUGFnaW5hdGVcIik7QShhLFwicGFnaW5nVHlwZVwiLFwic1BhZ2luYXRpb25UeXBlXCIpO0EoYSxcInBhZ2VMZW5ndGhcIixcImlEaXNwbGF5TGVuZ3RoXCIpO0EoYSxcInNlYXJjaGluZ1wiLFwiYkZpbHRlclwiKTtcImJvb2xlYW5cIj09PXR5cGVvZiBhLnNTY3JvbGxYJiYoYS5zU2Nyb2xsWD1hLnNTY3JvbGxYP1wiMTAwJVwiOlxyXG5cIlwiKTtcImJvb2xlYW5cIj09PXR5cGVvZiBhLnNjcm9sbFgmJihhLnNjcm9sbFg9YS5zY3JvbGxYP1wiMTAwJVwiOlwiXCIpO2lmKGE9YS5hb1NlYXJjaENvbHMpZm9yKHZhciBiPTAsYz1hLmxlbmd0aDtiPGM7YisrKWFbYl0mJkoobC5tb2RlbHMub1NlYXJjaCxhW2JdKX1mdW5jdGlvbiBoYihhKXtBKGEsXCJvcmRlcmFibGVcIixcImJTb3J0YWJsZVwiKTtBKGEsXCJvcmRlckRhdGFcIixcImFEYXRhU29ydFwiKTtBKGEsXCJvcmRlclNlcXVlbmNlXCIsXCJhc1NvcnRpbmdcIik7QShhLFwib3JkZXJEYXRhVHlwZVwiLFwic29ydERhdGFUeXBlXCIpO3ZhciBiPWEuYURhdGFTb3J0O1wibnVtYmVyXCI9PT10eXBlb2YgYiYmIUFycmF5LmlzQXJyYXkoYikmJihhLmFEYXRhU29ydD1bYl0pfWZ1bmN0aW9uIGliKGEpe2lmKCFsLl9fYnJvd3Nlcil7dmFyIGI9e307bC5fX2Jyb3dzZXI9Yjt2YXIgYz1oKFwiPGRpdi8+XCIpLmNzcyh7cG9zaXRpb246XCJmaXhlZFwiLHRvcDowLGxlZnQ6LTEqaChFKS5zY3JvbGxMZWZ0KCksaGVpZ2h0OjEsXHJcbndpZHRoOjEsb3ZlcmZsb3c6XCJoaWRkZW5cIn0pLmFwcGVuZChoKFwiPGRpdi8+XCIpLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDoxLGxlZnQ6MSx3aWR0aDoxMDAsb3ZlcmZsb3c6XCJzY3JvbGxcIn0pLmFwcGVuZChoKFwiPGRpdi8+XCIpLmNzcyh7d2lkdGg6XCIxMDAlXCIsaGVpZ2h0OjEwfSkpKS5hcHBlbmRUbyhcImJvZHlcIiksZD1jLmNoaWxkcmVuKCksZT1kLmNoaWxkcmVuKCk7Yi5iYXJXaWR0aD1kWzBdLm9mZnNldFdpZHRoLWRbMF0uY2xpZW50V2lkdGg7Yi5iU2Nyb2xsT3ZlcnNpemU9MTAwPT09ZVswXS5vZmZzZXRXaWR0aCYmMTAwIT09ZFswXS5jbGllbnRXaWR0aDtiLmJTY3JvbGxiYXJMZWZ0PTEhPT1NYXRoLnJvdW5kKGUub2Zmc2V0KCkubGVmdCk7Yi5iQm91bmRpbmc9Y1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aD8hMDohMTtjLnJlbW92ZSgpfWguZXh0ZW5kKGEub0Jyb3dzZXIsbC5fX2Jyb3dzZXIpO2Eub1Njcm9sbC5pQmFyV2lkdGg9bC5fX2Jyb3dzZXIuYmFyV2lkdGh9XHJcbmZ1bmN0aW9uIGpiKGEsYixjLGQsZSxmKXt2YXIgZyxqPSExO2MhPT1rJiYoZz1jLGo9ITApO2Zvcig7ZCE9PWU7KWEuaGFzT3duUHJvcGVydHkoZCkmJihnPWo/YihnLGFbZF0sZCxhKTphW2RdLGo9ITAsZCs9Zik7cmV0dXJuIGd9ZnVuY3Rpb24gR2EoYSxiKXt2YXIgYz1sLmRlZmF1bHRzLmNvbHVtbixkPWEuYW9Db2x1bW5zLmxlbmd0aCxjPWguZXh0ZW5kKHt9LGwubW9kZWxzLm9Db2x1bW4sYyx7blRoOmI/YjpILmNyZWF0ZUVsZW1lbnQoXCJ0aFwiKSxzVGl0bGU6Yy5zVGl0bGU/Yy5zVGl0bGU6Yj9iLmlubmVySFRNTDpcIlwiLGFEYXRhU29ydDpjLmFEYXRhU29ydD9jLmFEYXRhU29ydDpbZF0sbURhdGE6Yy5tRGF0YT9jLm1EYXRhOmQsaWR4OmR9KTthLmFvQ29sdW1ucy5wdXNoKGMpO2M9YS5hb1ByZVNlYXJjaENvbHM7Y1tkXT1oLmV4dGVuZCh7fSxsLm1vZGVscy5vU2VhcmNoLGNbZF0pO2xhKGEsZCxoKGIpLmRhdGEoKSl9ZnVuY3Rpb24gbGEoYSxiLGMpe3ZhciBiPWEuYW9Db2x1bW5zW2JdLFxyXG5kPWEub0NsYXNzZXMsZT1oKGIublRoKTtpZighYi5zV2lkdGhPcmlnKXtiLnNXaWR0aE9yaWc9ZS5hdHRyKFwid2lkdGhcIil8fG51bGw7dmFyIGY9KGUuYXR0cihcInN0eWxlXCIpfHxcIlwiKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7ZiYmKGIuc1dpZHRoT3JpZz1mWzFdKX1jIT09ayYmbnVsbCE9PWMmJihoYihjKSxKKGwuZGVmYXVsdHMuY29sdW1uLGMsITApLGMubURhdGFQcm9wIT09ayYmIWMubURhdGEmJihjLm1EYXRhPWMubURhdGFQcm9wKSxjLnNUeXBlJiYoYi5fc01hbnVhbFR5cGU9Yy5zVHlwZSksYy5jbGFzc05hbWUmJiFjLnNDbGFzcyYmKGMuc0NsYXNzPWMuY2xhc3NOYW1lKSxjLnNDbGFzcyYmZS5hZGRDbGFzcyhjLnNDbGFzcyksaC5leHRlbmQoYixjKSxGKGIsYyxcInNXaWR0aFwiLFwic1dpZHRoT3JpZ1wiKSxjLmlEYXRhU29ydCE9PWsmJihiLmFEYXRhU29ydD1bYy5pRGF0YVNvcnRdKSxGKGIsYyxcImFEYXRhU29ydFwiKSk7dmFyIGc9Yi5tRGF0YSxqPVMoZyksaT1cclxuYi5tUmVuZGVyP1MoYi5tUmVuZGVyKTpudWxsLGM9ZnVuY3Rpb24oYSl7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhJiYtMSE9PWEuaW5kZXhPZihcIkBcIil9O2IuX2JBdHRyU3JjPWguaXNQbGFpbk9iamVjdChnKSYmKGMoZy5zb3J0KXx8YyhnLnR5cGUpfHxjKGcuZmlsdGVyKSk7Yi5fc2V0dGVyPW51bGw7Yi5mbkdldERhdGE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWooYSxiLGssYyk7cmV0dXJuIGkmJmI/aShkLGIsYSxjKTpkfTtiLmZuU2V0RGF0YT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIE4oZykoYSxiLGMpfTtcIm51bWJlclwiIT09dHlwZW9mIGcmJihhLl9yb3dSZWFkT2JqZWN0PSEwKTthLm9GZWF0dXJlcy5iU29ydHx8KGIuYlNvcnRhYmxlPSExLGUuYWRkQ2xhc3MoZC5zU29ydGFibGVOb25lKSk7YT0tMSE9PWguaW5BcnJheShcImFzY1wiLGIuYXNTb3J0aW5nKTtjPS0xIT09aC5pbkFycmF5KFwiZGVzY1wiLGIuYXNTb3J0aW5nKTshYi5iU29ydGFibGV8fCFhJiYhYz8oYi5zU29ydGluZ0NsYXNzPVxyXG5kLnNTb3J0YWJsZU5vbmUsYi5zU29ydGluZ0NsYXNzSlVJPVwiXCIpOmEmJiFjPyhiLnNTb3J0aW5nQ2xhc3M9ZC5zU29ydGFibGVBc2MsYi5zU29ydGluZ0NsYXNzSlVJPWQuc1NvcnRKVUlBc2NBbGxvd2VkKTohYSYmYz8oYi5zU29ydGluZ0NsYXNzPWQuc1NvcnRhYmxlRGVzYyxiLnNTb3J0aW5nQ2xhc3NKVUk9ZC5zU29ydEpVSURlc2NBbGxvd2VkKTooYi5zU29ydGluZ0NsYXNzPWQuc1NvcnRhYmxlLGIuc1NvcnRpbmdDbGFzc0pVST1kLnNTb3J0SlVJKX1mdW5jdGlvbiBhYShhKXtpZighMSE9PWEub0ZlYXR1cmVzLmJBdXRvV2lkdGgpe3ZhciBiPWEuYW9Db2x1bW5zO0hhKGEpO2Zvcih2YXIgYz0wLGQ9Yi5sZW5ndGg7YzxkO2MrKyliW2NdLm5UaC5zdHlsZS53aWR0aD1iW2NdLnNXaWR0aH1iPWEub1Njcm9sbDsoXCJcIiE9PWIuc1l8fFwiXCIhPT1iLnNYKSYmbWEoYSk7dChhLG51bGwsXCJjb2x1bW4tc2l6aW5nXCIsW2FdKX1mdW5jdGlvbiBiYShhLGIpe3ZhciBjPW5hKGEsXCJiVmlzaWJsZVwiKTtcclxucmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBjW2JdP2NbYl06bnVsbH1mdW5jdGlvbiBjYShhLGIpe3ZhciBjPW5hKGEsXCJiVmlzaWJsZVwiKSxjPWguaW5BcnJheShiLGMpO3JldHVybi0xIT09Yz9jOm51bGx9ZnVuY3Rpb24gVyhhKXt2YXIgYj0wO2guZWFjaChhLmFvQ29sdW1ucyxmdW5jdGlvbihhLGQpe2QuYlZpc2libGUmJlwibm9uZVwiIT09aChkLm5UaCkuY3NzKFwiZGlzcGxheVwiKSYmYisrfSk7cmV0dXJuIGJ9ZnVuY3Rpb24gbmEoYSxiKXt2YXIgYz1bXTtoLm1hcChhLmFvQ29sdW1ucyxmdW5jdGlvbihhLGUpe2FbYl0mJmMucHVzaChlKX0pO3JldHVybiBjfWZ1bmN0aW9uIElhKGEpe3ZhciBiPWEuYW9Db2x1bW5zLGM9YS5hb0RhdGEsZD1sLmV4dC50eXBlLmRldGVjdCxlLGYsZyxqLGksaCxtLHEscztlPTA7Zm9yKGY9Yi5sZW5ndGg7ZTxmO2UrKylpZihtPWJbZV0scz1bXSwhbS5zVHlwZSYmbS5fc01hbnVhbFR5cGUpbS5zVHlwZT1tLl9zTWFudWFsVHlwZTtlbHNlIGlmKCFtLnNUeXBlKXtnPVxyXG4wO2ZvcihqPWQubGVuZ3RoO2c8ajtnKyspe2k9MDtmb3IoaD1jLmxlbmd0aDtpPGg7aSsrKXtzW2ldPT09ayYmKHNbaV09QihhLGksZSxcInR5cGVcIikpO3E9ZFtnXShzW2ldLGEpO2lmKCFxJiZnIT09ZC5sZW5ndGgtMSlicmVhaztpZihcImh0bWxcIj09PXEpYnJlYWt9aWYocSl7bS5zVHlwZT1xO2JyZWFrfX1tLnNUeXBlfHwobS5zVHlwZT1cInN0cmluZ1wiKX19ZnVuY3Rpb24ga2IoYSxiLGMsZCl7dmFyIGUsZixnLGosaSxuLG09YS5hb0NvbHVtbnM7aWYoYilmb3IoZT1iLmxlbmd0aC0xOzA8PWU7ZS0tKXtuPWJbZV07dmFyIHE9bi50YXJnZXRzIT09az9uLnRhcmdldHM6bi5hVGFyZ2V0cztBcnJheS5pc0FycmF5KHEpfHwocT1bcV0pO2Y9MDtmb3IoZz1xLmxlbmd0aDtmPGc7ZisrKWlmKFwibnVtYmVyXCI9PT10eXBlb2YgcVtmXSYmMDw9cVtmXSl7Zm9yKDttLmxlbmd0aDw9cVtmXTspR2EoYSk7ZChxW2ZdLG4pfWVsc2UgaWYoXCJudW1iZXJcIj09PXR5cGVvZiBxW2ZdJiYwPnFbZl0pZChtLmxlbmd0aCtcclxucVtmXSxuKTtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2YgcVtmXSl7aj0wO2ZvcihpPW0ubGVuZ3RoO2o8aTtqKyspKFwiX2FsbFwiPT1xW2ZdfHxoKG1bal0ublRoKS5oYXNDbGFzcyhxW2ZdKSkmJmQoaixuKX19aWYoYyl7ZT0wO2ZvcihhPWMubGVuZ3RoO2U8YTtlKyspZChlLGNbZV0pfX1mdW5jdGlvbiBPKGEsYixjLGQpe3ZhciBlPWEuYW9EYXRhLmxlbmd0aCxmPWguZXh0ZW5kKCEwLHt9LGwubW9kZWxzLm9Sb3cse3NyYzpjP1wiZG9tXCI6XCJkYXRhXCIsaWR4OmV9KTtmLl9hRGF0YT1iO2EuYW9EYXRhLnB1c2goZik7Zm9yKHZhciBnPWEuYW9Db2x1bW5zLGo9MCxpPWcubGVuZ3RoO2o8aTtqKyspZ1tqXS5zVHlwZT1udWxsO2EuYWlEaXNwbGF5TWFzdGVyLnB1c2goZSk7Yj1hLnJvd0lkRm4oYik7YiE9PWsmJihhLmFJZHNbYl09Zik7KGN8fCFhLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIpJiZKYShhLGUsYyxkKTtyZXR1cm4gZX1mdW5jdGlvbiBvYShhLGIpe3ZhciBjO2IgaW5zdGFuY2VvZlxyXG5ofHwoYj1oKGIpKTtyZXR1cm4gYi5tYXAoZnVuY3Rpb24oYixlKXtjPUthKGEsZSk7cmV0dXJuIE8oYSxjLmRhdGEsZSxjLmNlbGxzKX0pfWZ1bmN0aW9uIEIoYSxiLGMsZCl7dmFyIGU9YS5pRHJhdyxmPWEuYW9Db2x1bW5zW2NdLGc9YS5hb0RhdGFbYl0uX2FEYXRhLGo9Zi5zRGVmYXVsdENvbnRlbnQsaT1mLmZuR2V0RGF0YShnLGQse3NldHRpbmdzOmEscm93OmIsY29sOmN9KTtpZihpPT09aylyZXR1cm4gYS5pRHJhd0Vycm9yIT1lJiZudWxsPT09aiYmKEsoYSwwLFwiUmVxdWVzdGVkIHVua25vd24gcGFyYW1ldGVyIFwiKyhcImZ1bmN0aW9uXCI9PXR5cGVvZiBmLm1EYXRhP1wie2Z1bmN0aW9ufVwiOlwiJ1wiK2YubURhdGErXCInXCIpK1wiIGZvciByb3cgXCIrYitcIiwgY29sdW1uIFwiK2MsNCksYS5pRHJhd0Vycm9yPWUpLGo7aWYoKGk9PT1nfHxudWxsPT09aSkmJm51bGwhPT1qJiZkIT09aylpPWo7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgaSlyZXR1cm4gaS5jYWxsKGcpO3JldHVybiBudWxsPT09XHJcbmkmJlwiZGlzcGxheVwiPT1kP1wiXCI6aX1mdW5jdGlvbiBsYihhLGIsYyxkKXthLmFvQ29sdW1uc1tjXS5mblNldERhdGEoYS5hb0RhdGFbYl0uX2FEYXRhLGQse3NldHRpbmdzOmEscm93OmIsY29sOmN9KX1mdW5jdGlvbiBMYShhKXtyZXR1cm4gaC5tYXAoYS5tYXRjaCgvKFxcXFwufFteXFwuXSkrL2cpfHxbXCJcIl0sZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKX0pfWZ1bmN0aW9uIFMoYSl7aWYoaC5pc1BsYWluT2JqZWN0KGEpKXt2YXIgYj17fTtoLmVhY2goYSxmdW5jdGlvbihhLGMpe2MmJihiW2FdPVMoYykpfSk7cmV0dXJuIGZ1bmN0aW9uKGEsYyxmLGcpe3ZhciBqPWJbY118fGIuXztyZXR1cm4gaiE9PWs/aihhLGMsZixnKTphfX1pZihudWxsPT09YSlyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGF9O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBmdW5jdGlvbihiLGMsZixnKXtyZXR1cm4gYShiLGMsZixnKX07aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhJiZcclxuKC0xIT09YS5pbmRleE9mKFwiLlwiKXx8LTEhPT1hLmluZGV4T2YoXCJbXCIpfHwtMSE9PWEuaW5kZXhPZihcIihcIikpKXt2YXIgYz1mdW5jdGlvbihhLGIsZil7dmFyIGcsajtpZihcIlwiIT09Zil7aj1MYShmKTtmb3IodmFyIGk9MCxoPWoubGVuZ3RoO2k8aDtpKyspe2Y9altpXS5tYXRjaChkYSk7Zz1qW2ldLm1hdGNoKFgpO2lmKGYpe2pbaV09altpXS5yZXBsYWNlKGRhLFwiXCIpO1wiXCIhPT1qW2ldJiYoYT1hW2pbaV1dKTtnPVtdO2ouc3BsaWNlKDAsaSsxKTtqPWouam9pbihcIi5cIik7aWYoQXJyYXkuaXNBcnJheShhKSl7aT0wO2ZvcihoPWEubGVuZ3RoO2k8aDtpKyspZy5wdXNoKGMoYVtpXSxiLGopKX1hPWZbMF0uc3Vic3RyaW5nKDEsZlswXS5sZW5ndGgtMSk7YT1cIlwiPT09YT9nOmcuam9pbihhKTticmVha31lbHNlIGlmKGcpe2pbaV09altpXS5yZXBsYWNlKFgsXCJcIik7YT1hW2pbaV1dKCk7Y29udGludWV9aWYobnVsbD09PWF8fGFbaltpXV09PT1rKXJldHVybiBrO2E9YVtqW2ldXX19cmV0dXJuIGF9O1xyXG5yZXR1cm4gZnVuY3Rpb24oYixlKXtyZXR1cm4gYyhiLGUsYSl9fXJldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYlthXX19ZnVuY3Rpb24gTihhKXtpZihoLmlzUGxhaW5PYmplY3QoYSkpcmV0dXJuIE4oYS5fKTtpZihudWxsPT09YSlyZXR1cm4gZnVuY3Rpb24oKXt9O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBmdW5jdGlvbihiLGQsZSl7YShiLFwic2V0XCIsZCxlKX07aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoLTEhPT1hLmluZGV4T2YoXCIuXCIpfHwtMSE9PWEuaW5kZXhPZihcIltcIil8fC0xIT09YS5pbmRleE9mKFwiKFwiKSkpe3ZhciBiPWZ1bmN0aW9uKGEsZCxlKXt2YXIgZT1MYShlKSxmO2Y9ZVtlLmxlbmd0aC0xXTtmb3IodmFyIGcsaixpPTAsaD1lLmxlbmd0aC0xO2k8aDtpKyspe2lmKFwiX19wcm90b19fXCI9PT1lW2ldfHxcImNvbnN0cnVjdG9yXCI9PT1lW2ldKXRocm93IEVycm9yKFwiQ2Fubm90IHNldCBwcm90b3R5cGUgdmFsdWVzXCIpO2c9ZVtpXS5tYXRjaChkYSk7aj1cclxuZVtpXS5tYXRjaChYKTtpZihnKXtlW2ldPWVbaV0ucmVwbGFjZShkYSxcIlwiKTthW2VbaV1dPVtdO2Y9ZS5zbGljZSgpO2Yuc3BsaWNlKDAsaSsxKTtnPWYuam9pbihcIi5cIik7aWYoQXJyYXkuaXNBcnJheShkKSl7aj0wO2ZvcihoPWQubGVuZ3RoO2o8aDtqKyspZj17fSxiKGYsZFtqXSxnKSxhW2VbaV1dLnB1c2goZil9ZWxzZSBhW2VbaV1dPWQ7cmV0dXJufWomJihlW2ldPWVbaV0ucmVwbGFjZShYLFwiXCIpLGE9YVtlW2ldXShkKSk7aWYobnVsbD09PWFbZVtpXV18fGFbZVtpXV09PT1rKWFbZVtpXV09e307YT1hW2VbaV1dfWlmKGYubWF0Y2goWCkpYVtmLnJlcGxhY2UoWCxcIlwiKV0oZCk7ZWxzZSBhW2YucmVwbGFjZShkYSxcIlwiKV09ZH07cmV0dXJuIGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGIoYyxkLGEpfX1yZXR1cm4gZnVuY3Rpb24oYixkKXtiW2FdPWR9fWZ1bmN0aW9uIE1hKGEpe3JldHVybiBDKGEuYW9EYXRhLFwiX2FEYXRhXCIpfWZ1bmN0aW9uIHBhKGEpe2EuYW9EYXRhLmxlbmd0aD0wO1xyXG5hLmFpRGlzcGxheU1hc3Rlci5sZW5ndGg9MDthLmFpRGlzcGxheS5sZW5ndGg9MDthLmFJZHM9e319ZnVuY3Rpb24gcWEoYSxiLGMpe2Zvcih2YXIgZD0tMSxlPTAsZj1hLmxlbmd0aDtlPGY7ZSsrKWFbZV09PWI/ZD1lOmFbZV0+YiYmYVtlXS0tOyAtMSE9ZCYmYz09PWsmJmEuc3BsaWNlKGQsMSl9ZnVuY3Rpb24gZWEoYSxiLGMsZCl7dmFyIGU9YS5hb0RhdGFbYl0sZixnPWZ1bmN0aW9uKGMsZCl7Zm9yKDtjLmNoaWxkTm9kZXMubGVuZ3RoOyljLnJlbW92ZUNoaWxkKGMuZmlyc3RDaGlsZCk7Yy5pbm5lckhUTUw9QihhLGIsZCxcImRpc3BsYXlcIil9O2lmKFwiZG9tXCI9PT1jfHwoIWN8fFwiYXV0b1wiPT09YykmJlwiZG9tXCI9PT1lLnNyYyllLl9hRGF0YT1LYShhLGUsZCxkPT09az9rOmUuX2FEYXRhKS5kYXRhO2Vsc2V7dmFyIGo9ZS5hbkNlbGxzO2lmKGopaWYoZCE9PWspZyhqW2RdLGQpO2Vsc2V7Yz0wO2ZvcihmPWoubGVuZ3RoO2M8ZjtjKyspZyhqW2NdLGMpfX1lLl9hU29ydERhdGE9bnVsbDtcclxuZS5fYUZpbHRlckRhdGE9bnVsbDtnPWEuYW9Db2x1bW5zO2lmKGQhPT1rKWdbZF0uc1R5cGU9bnVsbDtlbHNle2M9MDtmb3IoZj1nLmxlbmd0aDtjPGY7YysrKWdbY10uc1R5cGU9bnVsbDtOYShhLGUpfX1mdW5jdGlvbiBLYShhLGIsYyxkKXt2YXIgZT1bXSxmPWIuZmlyc3RDaGlsZCxnLGosaT0wLGgsbT1hLmFvQ29sdW1ucyxxPWEuX3Jvd1JlYWRPYmplY3QsZD1kIT09az9kOnE/e306W10scz1mdW5jdGlvbihhLGIpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSl7dmFyIGM9YS5pbmRleE9mKFwiQFwiKTstMSE9PWMmJihjPWEuc3Vic3RyaW5nKGMrMSksTihhKShkLGIuZ2V0QXR0cmlidXRlKGMpKSl9fSxHPWZ1bmN0aW9uKGEpe2lmKGM9PT1rfHxjPT09aSlqPW1baV0saD1hLmlubmVySFRNTC50cmltKCksaiYmai5fYkF0dHJTcmM/KE4oai5tRGF0YS5fKShkLGgpLHMoai5tRGF0YS5zb3J0LGEpLHMoai5tRGF0YS50eXBlLGEpLHMoai5tRGF0YS5maWx0ZXIsYSkpOnE/KGouX3NldHRlcnx8XHJcbihqLl9zZXR0ZXI9TihqLm1EYXRhKSksai5fc2V0dGVyKGQsaCkpOmRbaV09aDtpKyt9O2lmKGYpZm9yKDtmOyl7Zz1mLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7aWYoXCJURFwiPT1nfHxcIlRIXCI9PWcpRyhmKSxlLnB1c2goZik7Zj1mLm5leHRTaWJsaW5nfWVsc2V7ZT1iLmFuQ2VsbHM7Zj0wO2ZvcihnPWUubGVuZ3RoO2Y8ZztmKyspRyhlW2ZdKX1pZihiPWIuZmlyc3RDaGlsZD9iOmIublRyKShiPWIuZ2V0QXR0cmlidXRlKFwiaWRcIikpJiZOKGEucm93SWQpKGQsYik7cmV0dXJue2RhdGE6ZCxjZWxsczplfX1mdW5jdGlvbiBKYShhLGIsYyxkKXt2YXIgZT1hLmFvRGF0YVtiXSxmPWUuX2FEYXRhLGc9W10saixpLG4sbSxxO2lmKG51bGw9PT1lLm5Ucil7aj1jfHxILmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtlLm5Ucj1qO2UuYW5DZWxscz1nO2ouX0RUX1Jvd0luZGV4PWI7TmEoYSxlKTtuPTA7Zm9yKG09YS5hb0NvbHVtbnMubGVuZ3RoO248bTtuKyspe2k9YS5hb0NvbHVtbnNbbl07ZT0ocT1jP1xyXG4hMTohMCk/SC5jcmVhdGVFbGVtZW50KGkuc0NlbGxUeXBlKTpkW25dO2UuX0RUX0NlbGxJbmRleD17cm93OmIsY29sdW1uOm59O2cucHVzaChlKTtpZihxfHwoaS5tUmVuZGVyfHxpLm1EYXRhIT09bikmJighaC5pc1BsYWluT2JqZWN0KGkubURhdGEpfHxpLm1EYXRhLl8hPT1uK1wiLmRpc3BsYXlcIikpZS5pbm5lckhUTUw9QihhLGIsbixcImRpc3BsYXlcIik7aS5zQ2xhc3MmJihlLmNsYXNzTmFtZSs9XCIgXCIraS5zQ2xhc3MpO2kuYlZpc2libGUmJiFjP2ouYXBwZW5kQ2hpbGQoZSk6IWkuYlZpc2libGUmJmMmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtpLmZuQ3JlYXRlZENlbGwmJmkuZm5DcmVhdGVkQ2VsbC5jYWxsKGEub0luc3RhbmNlLGUsQihhLGIsbiksZixiLG4pfXQoYSxcImFvUm93Q3JlYXRlZENhbGxiYWNrXCIsbnVsbCxbaixmLGIsZ10pfX1mdW5jdGlvbiBOYShhLGIpe3ZhciBjPWIublRyLGQ9Yi5fYURhdGE7aWYoYyl7dmFyIGU9YS5yb3dJZEZuKGQpO2UmJihjLmlkPVxyXG5lKTtkLkRUX1Jvd0NsYXNzJiYoZT1kLkRUX1Jvd0NsYXNzLnNwbGl0KFwiIFwiKSxiLl9fcm93Yz1iLl9fcm93Yz9yYShiLl9fcm93Yy5jb25jYXQoZSkpOmUsaChjKS5yZW1vdmVDbGFzcyhiLl9fcm93Yy5qb2luKFwiIFwiKSkuYWRkQ2xhc3MoZC5EVF9Sb3dDbGFzcykpO2QuRFRfUm93QXR0ciYmaChjKS5hdHRyKGQuRFRfUm93QXR0cik7ZC5EVF9Sb3dEYXRhJiZoKGMpLmRhdGEoZC5EVF9Sb3dEYXRhKX19ZnVuY3Rpb24gbWIoYSl7dmFyIGIsYyxkLGUsZixnPWEublRIZWFkLGo9YS5uVEZvb3QsaT0wPT09aChcInRoLCB0ZFwiLGcpLmxlbmd0aCxuPWEub0NsYXNzZXMsbT1hLmFvQ29sdW1ucztpJiYoZT1oKFwiPHRyLz5cIikuYXBwZW5kVG8oZykpO2I9MDtmb3IoYz1tLmxlbmd0aDtiPGM7YisrKWY9bVtiXSxkPWgoZi5uVGgpLmFkZENsYXNzKGYuc0NsYXNzKSxpJiZkLmFwcGVuZFRvKGUpLGEub0ZlYXR1cmVzLmJTb3J0JiYoZC5hZGRDbGFzcyhmLnNTb3J0aW5nQ2xhc3MpLCExIT09Zi5iU29ydGFibGUmJlxyXG4oZC5hdHRyKFwidGFiaW5kZXhcIixhLmlUYWJJbmRleCkuYXR0cihcImFyaWEtY29udHJvbHNcIixhLnNUYWJsZUlkKSxPYShhLGYublRoLGIpKSksZi5zVGl0bGUhPWRbMF0uaW5uZXJIVE1MJiZkLmh0bWwoZi5zVGl0bGUpLFBhKGEsXCJoZWFkZXJcIikoYSxkLGYsbik7aSYmZmEoYS5hb0hlYWRlcixnKTtoKGcpLmNoaWxkcmVuKFwidHJcIikuYXR0cihcInJvbGVcIixcInJvd1wiKTtoKGcpLmNoaWxkcmVuKFwidHJcIikuY2hpbGRyZW4oXCJ0aCwgdGRcIikuYWRkQ2xhc3Mobi5zSGVhZGVyVEgpO2goaikuY2hpbGRyZW4oXCJ0clwiKS5jaGlsZHJlbihcInRoLCB0ZFwiKS5hZGRDbGFzcyhuLnNGb290ZXJUSCk7aWYobnVsbCE9PWope2E9YS5hb0Zvb3RlclswXTtiPTA7Zm9yKGM9YS5sZW5ndGg7YjxjO2IrKylmPW1bYl0sZi5uVGY9YVtiXS5jZWxsLGYuc0NsYXNzJiZoKGYublRmKS5hZGRDbGFzcyhmLnNDbGFzcyl9fWZ1bmN0aW9uIGdhKGEsYixjKXt2YXIgZCxlLGYsZz1bXSxqPVtdLGk9YS5hb0NvbHVtbnMubGVuZ3RoLFxyXG5uO2lmKGIpe2M9PT1rJiYoYz0hMSk7ZD0wO2ZvcihlPWIubGVuZ3RoO2Q8ZTtkKyspe2dbZF09YltkXS5zbGljZSgpO2dbZF0ublRyPWJbZF0ublRyO2ZvcihmPWktMTswPD1mO2YtLSkhYS5hb0NvbHVtbnNbZl0uYlZpc2libGUmJiFjJiZnW2RdLnNwbGljZShmLDEpO2oucHVzaChbXSl9ZD0wO2ZvcihlPWcubGVuZ3RoO2Q8ZTtkKyspe2lmKGE9Z1tkXS5uVHIpZm9yKDtmPWEuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChmKTtmPTA7Zm9yKGI9Z1tkXS5sZW5ndGg7ZjxiO2YrKylpZihuPWk9MSxqW2RdW2ZdPT09ayl7YS5hcHBlbmRDaGlsZChnW2RdW2ZdLmNlbGwpO2ZvcihqW2RdW2ZdPTE7Z1tkK2ldIT09ayYmZ1tkXVtmXS5jZWxsPT1nW2QraV1bZl0uY2VsbDspaltkK2ldW2ZdPTEsaSsrO2Zvcig7Z1tkXVtmK25dIT09ayYmZ1tkXVtmXS5jZWxsPT1nW2RdW2Yrbl0uY2VsbDspe2ZvcihjPTA7YzxpO2MrKylqW2QrY11bZituXT0xO24rK31oKGdbZF1bZl0uY2VsbCkuYXR0cihcInJvd3NwYW5cIixcclxuaSkuYXR0cihcImNvbHNwYW5cIixuKX19fX1mdW5jdGlvbiBQKGEpe3ZhciBiPXQoYSxcImFvUHJlRHJhd0NhbGxiYWNrXCIsXCJwcmVEcmF3XCIsW2FdKTtpZigtMSE9PWguaW5BcnJheSghMSxiKSlEKGEsITEpO2Vsc2V7dmFyIGI9W10sYz0wLGQ9YS5hc1N0cmlwZUNsYXNzZXMsZT1kLmxlbmd0aCxmPWEub0xhbmd1YWdlLGc9YS5pSW5pdERpc3BsYXlTdGFydCxqPVwic3NwXCI9PXkoYSksaT1hLmFpRGlzcGxheTthLmJEcmF3aW5nPSEwO2chPT1rJiYtMSE9PWcmJihhLl9pRGlzcGxheVN0YXJ0PWo/ZzpnPj1hLmZuUmVjb3Jkc0Rpc3BsYXkoKT8wOmcsYS5pSW5pdERpc3BsYXlTdGFydD0tMSk7dmFyIGc9YS5faURpc3BsYXlTdGFydCxuPWEuZm5EaXNwbGF5RW5kKCk7aWYoYS5iRGVmZXJMb2FkaW5nKWEuYkRlZmVyTG9hZGluZz0hMSxhLmlEcmF3KyssRChhLCExKTtlbHNlIGlmKGope2lmKCFhLmJEZXN0cm95aW5nJiYhbmIoYSkpcmV0dXJufWVsc2UgYS5pRHJhdysrO2lmKDAhPT1pLmxlbmd0aCl7Zj1cclxuaj9hLmFvRGF0YS5sZW5ndGg6bjtmb3Ioaj1qPzA6ZztqPGY7aisrKXt2YXIgbT1pW2pdLHE9YS5hb0RhdGFbbV07bnVsbD09PXEublRyJiZKYShhLG0pO3ZhciBzPXEublRyO2lmKDAhPT1lKXt2YXIgRz1kW2MlZV07cS5fc1Jvd1N0cmlwZSE9RyYmKGgocykucmVtb3ZlQ2xhc3MocS5fc1Jvd1N0cmlwZSkuYWRkQ2xhc3MoRykscS5fc1Jvd1N0cmlwZT1HKX10KGEsXCJhb1Jvd0NhbGxiYWNrXCIsbnVsbCxbcyxxLl9hRGF0YSxjLGosbV0pO2IucHVzaChzKTtjKyt9fWVsc2UgYz1mLnNaZXJvUmVjb3JkcywxPT1hLmlEcmF3JiZcImFqYXhcIj09eShhKT9jPWYuc0xvYWRpbmdSZWNvcmRzOmYuc0VtcHR5VGFibGUmJjA9PT1hLmZuUmVjb3Jkc1RvdGFsKCkmJihjPWYuc0VtcHR5VGFibGUpLGJbMF09aChcIjx0ci8+XCIse1wiY2xhc3NcIjplP2RbMF06XCJcIn0pLmFwcGVuZChoKFwiPHRkIC8+XCIse3ZhbGlnbjpcInRvcFwiLGNvbFNwYW46VyhhKSxcImNsYXNzXCI6YS5vQ2xhc3Nlcy5zUm93RW1wdHl9KS5odG1sKGMpKVswXTtcclxudChhLFwiYW9IZWFkZXJDYWxsYmFja1wiLFwiaGVhZGVyXCIsW2goYS5uVEhlYWQpLmNoaWxkcmVuKFwidHJcIilbMF0sTWEoYSksZyxuLGldKTt0KGEsXCJhb0Zvb3RlckNhbGxiYWNrXCIsXCJmb290ZXJcIixbaChhLm5URm9vdCkuY2hpbGRyZW4oXCJ0clwiKVswXSxNYShhKSxnLG4saV0pO2Q9aChhLm5UQm9keSk7ZC5jaGlsZHJlbigpLmRldGFjaCgpO2QuYXBwZW5kKGgoYikpO3QoYSxcImFvRHJhd0NhbGxiYWNrXCIsXCJkcmF3XCIsW2FdKTthLmJTb3J0ZWQ9ITE7YS5iRmlsdGVyZWQ9ITE7YS5iRHJhd2luZz0hMX19ZnVuY3Rpb24gVChhLGIpe3ZhciBjPWEub0ZlYXR1cmVzLGQ9Yy5iRmlsdGVyO2MuYlNvcnQmJm9iKGEpO2Q/aGEoYSxhLm9QcmV2aW91c1NlYXJjaCk6YS5haURpc3BsYXk9YS5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTshMCE9PWImJihhLl9pRGlzcGxheVN0YXJ0PTApO2EuX2RyYXdIb2xkPWI7UChhKTthLl9kcmF3SG9sZD0hMX1mdW5jdGlvbiBwYihhKXt2YXIgYj1hLm9DbGFzc2VzLFxyXG5jPWgoYS5uVGFibGUpLGM9aChcIjxkaXYvPlwiKS5pbnNlcnRCZWZvcmUoYyksZD1hLm9GZWF0dXJlcyxlPWgoXCI8ZGl2Lz5cIix7aWQ6YS5zVGFibGVJZCtcIl93cmFwcGVyXCIsXCJjbGFzc1wiOmIuc1dyYXBwZXIrKGEublRGb290P1wiXCI6XCIgXCIrYi5zTm9Gb290ZXIpfSk7YS5uSG9sZGluZz1jWzBdO2EublRhYmxlV3JhcHBlcj1lWzBdO2EublRhYmxlUmVpbnNlcnRCZWZvcmU9YS5uVGFibGUubmV4dFNpYmxpbmc7Zm9yKHZhciBmPWEuc0RvbS5zcGxpdChcIlwiKSxnLGosaSxuLG0scSxrPTA7azxmLmxlbmd0aDtrKyspe2c9bnVsbDtqPWZba107aWYoXCI8XCI9PWope2k9aChcIjxkaXYvPlwiKVswXTtuPWZbaysxXTtpZihcIidcIj09bnx8J1wiJz09bil7bT1cIlwiO2ZvcihxPTI7ZltrK3FdIT1uOyltKz1mW2srcV0scSsrO1wiSFwiPT1tP209Yi5zSlVJSGVhZGVyOlwiRlwiPT1tJiYobT1iLnNKVUlGb290ZXIpOy0xIT1tLmluZGV4T2YoXCIuXCIpPyhuPW0uc3BsaXQoXCIuXCIpLGkuaWQ9blswXS5zdWJzdHIoMSxuWzBdLmxlbmd0aC1cclxuMSksaS5jbGFzc05hbWU9blsxXSk6XCIjXCI9PW0uY2hhckF0KDApP2kuaWQ9bS5zdWJzdHIoMSxtLmxlbmd0aC0xKTppLmNsYXNzTmFtZT1tO2srPXF9ZS5hcHBlbmQoaSk7ZT1oKGkpfWVsc2UgaWYoXCI+XCI9PWopZT1lLnBhcmVudCgpO2Vsc2UgaWYoXCJsXCI9PWomJmQuYlBhZ2luYXRlJiZkLmJMZW5ndGhDaGFuZ2UpZz1xYihhKTtlbHNlIGlmKFwiZlwiPT1qJiZkLmJGaWx0ZXIpZz1yYihhKTtlbHNlIGlmKFwiclwiPT1qJiZkLmJQcm9jZXNzaW5nKWc9c2IoYSk7ZWxzZSBpZihcInRcIj09ailnPXRiKGEpO2Vsc2UgaWYoXCJpXCI9PWomJmQuYkluZm8pZz11YihhKTtlbHNlIGlmKFwicFwiPT1qJiZkLmJQYWdpbmF0ZSlnPXZiKGEpO2Vsc2UgaWYoMCE9PWwuZXh0LmZlYXR1cmUubGVuZ3RoKXtpPWwuZXh0LmZlYXR1cmU7cT0wO2ZvcihuPWkubGVuZ3RoO3E8bjtxKyspaWYoaj09aVtxXS5jRmVhdHVyZSl7Zz1pW3FdLmZuSW5pdChhKTticmVha319ZyYmKGk9YS5hYW5GZWF0dXJlcyxpW2pdfHwoaVtqXT1cclxuW10pLGlbal0ucHVzaChnKSxlLmFwcGVuZChnKSl9Yy5yZXBsYWNlV2l0aChlKTthLm5Ib2xkaW5nPW51bGx9ZnVuY3Rpb24gZmEoYSxiKXt2YXIgYz1oKGIpLmNoaWxkcmVuKFwidHJcIiksZCxlLGYsZyxqLGksbixtLHEsazthLnNwbGljZSgwLGEubGVuZ3RoKTtmPTA7Zm9yKGk9Yy5sZW5ndGg7ZjxpO2YrKylhLnB1c2goW10pO2Y9MDtmb3IoaT1jLmxlbmd0aDtmPGk7ZisrKXtkPWNbZl07Zm9yKGU9ZC5maXJzdENoaWxkO2U7KXtpZihcIlREXCI9PWUubm9kZU5hbWUudG9VcHBlckNhc2UoKXx8XCJUSFwiPT1lLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpe209MSplLmdldEF0dHJpYnV0ZShcImNvbHNwYW5cIik7cT0xKmUuZ2V0QXR0cmlidXRlKFwicm93c3BhblwiKTttPSFtfHwwPT09bXx8MT09PW0/MTptO3E9IXF8fDA9PT1xfHwxPT09cT8xOnE7Zz0wO2ZvcihqPWFbZl07altnXTspZysrO249ZztrPTE9PT1tPyEwOiExO2ZvcihqPTA7ajxtO2orKylmb3IoZz0wO2c8cTtnKyspYVtmK2ddW24ral09XHJcbntjZWxsOmUsdW5pcXVlOmt9LGFbZitnXS5uVHI9ZH1lPWUubmV4dFNpYmxpbmd9fX1mdW5jdGlvbiBzYShhLGIsYyl7dmFyIGQ9W107Y3x8KGM9YS5hb0hlYWRlcixiJiYoYz1bXSxmYShjLGIpKSk7Zm9yKHZhciBiPTAsZT1jLmxlbmd0aDtiPGU7YisrKWZvcih2YXIgZj0wLGc9Y1tiXS5sZW5ndGg7ZjxnO2YrKylpZihjW2JdW2ZdLnVuaXF1ZSYmKCFkW2ZdfHwhYS5iU29ydENlbGxzVG9wKSlkW2ZdPWNbYl1bZl0uY2VsbDtyZXR1cm4gZH1mdW5jdGlvbiB0YShhLGIsYyl7dChhLFwiYW9TZXJ2ZXJQYXJhbXNcIixcInNlcnZlclBhcmFtc1wiLFtiXSk7aWYoYiYmQXJyYXkuaXNBcnJheShiKSl7dmFyIGQ9e30sZT0vKC4qPylcXFtcXF0kLztoLmVhY2goYixmdW5jdGlvbihhLGIpe3ZhciBjPWIubmFtZS5tYXRjaChlKTtjPyhjPWNbMF0sZFtjXXx8KGRbY109W10pLGRbY10ucHVzaChiLnZhbHVlKSk6ZFtiLm5hbWVdPWIudmFsdWV9KTtiPWR9dmFyIGYsZz1hLmFqYXgsaj1hLm9JbnN0YW5jZSxcclxuaT1mdW5jdGlvbihiKXt0KGEsbnVsbCxcInhoclwiLFthLGIsYS5qcVhIUl0pO2MoYil9O2lmKGguaXNQbGFpbk9iamVjdChnKSYmZy5kYXRhKXtmPWcuZGF0YTt2YXIgbj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZj9mKGIsYSk6ZixiPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmJiZuP246aC5leHRlbmQoITAsYixuKTtkZWxldGUgZy5kYXRhfW49e2RhdGE6YixzdWNjZXNzOmZ1bmN0aW9uKGIpe3ZhciBjPWIuZXJyb3J8fGIuc0Vycm9yO2MmJksoYSwwLGMpO2EuanNvbj1iO2koYil9LGRhdGFUeXBlOlwianNvblwiLGNhY2hlOiExLHR5cGU6YS5zU2VydmVyTWV0aG9kLGVycm9yOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9dChhLG51bGwsXCJ4aHJcIixbYSxudWxsLGEuanFYSFJdKTstMT09PWguaW5BcnJheSghMCxkKSYmKFwicGFyc2VyZXJyb3JcIj09Yz9LKGEsMCxcIkludmFsaWQgSlNPTiByZXNwb25zZVwiLDEpOjQ9PT1iLnJlYWR5U3RhdGUmJksoYSwwLFwiQWpheCBlcnJvclwiLDcpKTtEKGEsITEpfX07YS5vQWpheERhdGE9XHJcbmI7dChhLG51bGwsXCJwcmVYaHJcIixbYSxiXSk7YS5mblNlcnZlckRhdGE/YS5mblNlcnZlckRhdGEuY2FsbChqLGEuc0FqYXhTb3VyY2UsaC5tYXAoYixmdW5jdGlvbihhLGIpe3JldHVybntuYW1lOmIsdmFsdWU6YX19KSxpLGEpOmEuc0FqYXhTb3VyY2V8fFwic3RyaW5nXCI9PT10eXBlb2YgZz9hLmpxWEhSPWguYWpheChoLmV4dGVuZChuLHt1cmw6Z3x8YS5zQWpheFNvdXJjZX0pKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZz9hLmpxWEhSPWcuY2FsbChqLGIsaSxhKTooYS5qcVhIUj1oLmFqYXgoaC5leHRlbmQobixnKSksZy5kYXRhPWYpfWZ1bmN0aW9uIG5iKGEpe3JldHVybiBhLmJBamF4RGF0YUdldD8oYS5pRHJhdysrLEQoYSwhMCksdGEoYSx3YihhKSxmdW5jdGlvbihiKXt4YihhLGIpfSksITEpOiEwfWZ1bmN0aW9uIHdiKGEpe3ZhciBiPWEuYW9Db2x1bW5zLGM9Yi5sZW5ndGgsZD1hLm9GZWF0dXJlcyxlPWEub1ByZXZpb3VzU2VhcmNoLGY9YS5hb1ByZVNlYXJjaENvbHMsZyxqPVxyXG5bXSxpLG4sbSxrPVkoYSk7Zz1hLl9pRGlzcGxheVN0YXJ0O2k9ITEhPT1kLmJQYWdpbmF0ZT9hLl9pRGlzcGxheUxlbmd0aDotMTt2YXIgcz1mdW5jdGlvbihhLGIpe2oucHVzaCh7bmFtZTphLHZhbHVlOmJ9KX07cyhcInNFY2hvXCIsYS5pRHJhdyk7cyhcImlDb2x1bW5zXCIsYyk7cyhcInNDb2x1bW5zXCIsQyhiLFwic05hbWVcIikuam9pbihcIixcIikpO3MoXCJpRGlzcGxheVN0YXJ0XCIsZyk7cyhcImlEaXNwbGF5TGVuZ3RoXCIsaSk7dmFyIEc9e2RyYXc6YS5pRHJhdyxjb2x1bW5zOltdLG9yZGVyOltdLHN0YXJ0OmcsbGVuZ3RoOmksc2VhcmNoOnt2YWx1ZTplLnNTZWFyY2gscmVnZXg6ZS5iUmVnZXh9fTtmb3IoZz0wO2c8YztnKyspbj1iW2ddLG09ZltnXSxpPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4ubURhdGE/XCJmdW5jdGlvblwiOm4ubURhdGEsRy5jb2x1bW5zLnB1c2goe2RhdGE6aSxuYW1lOm4uc05hbWUsc2VhcmNoYWJsZTpuLmJTZWFyY2hhYmxlLG9yZGVyYWJsZTpuLmJTb3J0YWJsZSxzZWFyY2g6e3ZhbHVlOm0uc1NlYXJjaCxcclxucmVnZXg6bS5iUmVnZXh9fSkscyhcIm1EYXRhUHJvcF9cIitnLGkpLGQuYkZpbHRlciYmKHMoXCJzU2VhcmNoX1wiK2csbS5zU2VhcmNoKSxzKFwiYlJlZ2V4X1wiK2csbS5iUmVnZXgpLHMoXCJiU2VhcmNoYWJsZV9cIitnLG4uYlNlYXJjaGFibGUpKSxkLmJTb3J0JiZzKFwiYlNvcnRhYmxlX1wiK2csbi5iU29ydGFibGUpO2QuYkZpbHRlciYmKHMoXCJzU2VhcmNoXCIsZS5zU2VhcmNoKSxzKFwiYlJlZ2V4XCIsZS5iUmVnZXgpKTtkLmJTb3J0JiYoaC5lYWNoKGssZnVuY3Rpb24oYSxiKXtHLm9yZGVyLnB1c2goe2NvbHVtbjpiLmNvbCxkaXI6Yi5kaXJ9KTtzKFwiaVNvcnRDb2xfXCIrYSxiLmNvbCk7cyhcInNTb3J0RGlyX1wiK2EsYi5kaXIpfSkscyhcImlTb3J0aW5nQ29sc1wiLGsubGVuZ3RoKSk7Yj1sLmV4dC5sZWdhY3kuYWpheDtyZXR1cm4gbnVsbD09PWI/YS5zQWpheFNvdXJjZT9qOkc6Yj9qOkd9ZnVuY3Rpb24geGIoYSxiKXt2YXIgYz11YShhLGIpLGQ9Yi5zRWNobyE9PWs/Yi5zRWNobzpiLmRyYXcsZT1cclxuYi5pVG90YWxSZWNvcmRzIT09az9iLmlUb3RhbFJlY29yZHM6Yi5yZWNvcmRzVG90YWwsZj1iLmlUb3RhbERpc3BsYXlSZWNvcmRzIT09az9iLmlUb3RhbERpc3BsYXlSZWNvcmRzOmIucmVjb3Jkc0ZpbHRlcmVkO2lmKGQhPT1rKXtpZigxKmQ8YS5pRHJhdylyZXR1cm47YS5pRHJhdz0xKmR9cGEoYSk7YS5faVJlY29yZHNUb3RhbD1wYXJzZUludChlLDEwKTthLl9pUmVjb3Jkc0Rpc3BsYXk9cGFyc2VJbnQoZiwxMCk7ZD0wO2ZvcihlPWMubGVuZ3RoO2Q8ZTtkKyspTyhhLGNbZF0pO2EuYWlEaXNwbGF5PWEuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7YS5iQWpheERhdGFHZXQ9ITE7UChhKTthLl9iSW5pdENvbXBsZXRlfHx2YShhLGIpO2EuYkFqYXhEYXRhR2V0PSEwO0QoYSwhMSl9ZnVuY3Rpb24gdWEoYSxiKXt2YXIgYz1oLmlzUGxhaW5PYmplY3QoYS5hamF4KSYmYS5hamF4LmRhdGFTcmMhPT1rP2EuYWpheC5kYXRhU3JjOmEuc0FqYXhEYXRhUHJvcDtyZXR1cm5cImRhdGFcIj09PWM/XHJcbmIuYWFEYXRhfHxiW2NdOlwiXCIhPT1jP1MoYykoYik6Yn1mdW5jdGlvbiByYihhKXt2YXIgYj1hLm9DbGFzc2VzLGM9YS5zVGFibGVJZCxkPWEub0xhbmd1YWdlLGU9YS5vUHJldmlvdXNTZWFyY2gsZj1hLmFhbkZlYXR1cmVzLGc9JzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInK2Iuc0ZpbHRlcklucHV0KydcIi8+JyxqPWQuc1NlYXJjaCxqPWoubWF0Y2goL19JTlBVVF8vKT9qLnJlcGxhY2UoXCJfSU5QVVRfXCIsZyk6aitnLGI9aChcIjxkaXYvPlwiLHtpZDohZi5mP2MrXCJfZmlsdGVyXCI6bnVsbCxcImNsYXNzXCI6Yi5zRmlsdGVyfSkuYXBwZW5kKGgoXCI8bGFiZWwvPlwiKS5hcHBlbmQoaikpLGk9ZnVuY3Rpb24oKXt2YXIgYj0hdGhpcy52YWx1ZT9cIlwiOnRoaXMudmFsdWU7YiE9ZS5zU2VhcmNoJiYoaGEoYSx7c1NlYXJjaDpiLGJSZWdleDplLmJSZWdleCxiU21hcnQ6ZS5iU21hcnQsYkNhc2VJbnNlbnNpdGl2ZTplLmJDYXNlSW5zZW5zaXRpdmV9KSxhLl9pRGlzcGxheVN0YXJ0PTAsUChhKSl9LFxyXG5mPW51bGwhPT1hLnNlYXJjaERlbGF5P2Euc2VhcmNoRGVsYXk6XCJzc3BcIj09PXkoYSk/NDAwOjAsbj1oKFwiaW5wdXRcIixiKS52YWwoZS5zU2VhcmNoKS5hdHRyKFwicGxhY2Vob2xkZXJcIixkLnNTZWFyY2hQbGFjZWhvbGRlcikub24oXCJrZXl1cC5EVCBzZWFyY2guRFQgaW5wdXQuRFQgcGFzdGUuRFQgY3V0LkRUXCIsZj9RYShpLGYpOmkpLm9uKFwibW91c2V1cFwiLGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe2kuY2FsbChuWzBdKX0sMTApfSkub24oXCJrZXlwcmVzcy5EVFwiLGZ1bmN0aW9uKGEpe2lmKDEzPT1hLmtleUNvZGUpcmV0dXJuITF9KS5hdHRyKFwiYXJpYS1jb250cm9sc1wiLGMpO2goYS5uVGFibGUpLm9uKFwic2VhcmNoLmR0LkRUXCIsZnVuY3Rpb24oYixjKXtpZihhPT09Yyl0cnl7blswXSE9PUguYWN0aXZlRWxlbWVudCYmbi52YWwoZS5zU2VhcmNoKX1jYXRjaChkKXt9fSk7cmV0dXJuIGJbMF19ZnVuY3Rpb24gaGEoYSxiLGMpe3ZhciBkPWEub1ByZXZpb3VzU2VhcmNoLFxyXG5lPWEuYW9QcmVTZWFyY2hDb2xzLGY9ZnVuY3Rpb24oYSl7ZC5zU2VhcmNoPWEuc1NlYXJjaDtkLmJSZWdleD1hLmJSZWdleDtkLmJTbWFydD1hLmJTbWFydDtkLmJDYXNlSW5zZW5zaXRpdmU9YS5iQ2FzZUluc2Vuc2l0aXZlfTtJYShhKTtpZihcInNzcFwiIT15KGEpKXt5YihhLGIuc1NlYXJjaCxjLGIuYkVzY2FwZVJlZ2V4IT09az8hYi5iRXNjYXBlUmVnZXg6Yi5iUmVnZXgsYi5iU21hcnQsYi5iQ2FzZUluc2Vuc2l0aXZlKTtmKGIpO2ZvcihiPTA7YjxlLmxlbmd0aDtiKyspemIoYSxlW2JdLnNTZWFyY2gsYixlW2JdLmJFc2NhcGVSZWdleCE9PWs/IWVbYl0uYkVzY2FwZVJlZ2V4OmVbYl0uYlJlZ2V4LGVbYl0uYlNtYXJ0LGVbYl0uYkNhc2VJbnNlbnNpdGl2ZSk7QWIoYSl9ZWxzZSBmKGIpO2EuYkZpbHRlcmVkPSEwO3QoYSxudWxsLFwic2VhcmNoXCIsW2FdKX1mdW5jdGlvbiBBYihhKXtmb3IodmFyIGI9bC5leHQuc2VhcmNoLGM9YS5haURpc3BsYXksZCxlLGY9MCxnPWIubGVuZ3RoO2Y8XHJcbmc7ZisrKXtmb3IodmFyIGo9W10saT0wLG49Yy5sZW5ndGg7aTxuO2krKyllPWNbaV0sZD1hLmFvRGF0YVtlXSxiW2ZdKGEsZC5fYUZpbHRlckRhdGEsZSxkLl9hRGF0YSxpKSYmai5wdXNoKGUpO2MubGVuZ3RoPTA7aC5tZXJnZShjLGopfX1mdW5jdGlvbiB6YihhLGIsYyxkLGUsZil7aWYoXCJcIiE9PWIpe2Zvcih2YXIgZz1bXSxqPWEuYWlEaXNwbGF5LGQ9UmEoYixkLGUsZiksZT0wO2U8ai5sZW5ndGg7ZSsrKWI9YS5hb0RhdGFbaltlXV0uX2FGaWx0ZXJEYXRhW2NdLGQudGVzdChiKSYmZy5wdXNoKGpbZV0pO2EuYWlEaXNwbGF5PWd9fWZ1bmN0aW9uIHliKGEsYixjLGQsZSxmKXt2YXIgZT1SYShiLGQsZSxmKSxnPWEub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2gsaj1hLmFpRGlzcGxheU1hc3RlcixpLGY9W107MCE9PWwuZXh0LnNlYXJjaC5sZW5ndGgmJihjPSEwKTtpPUJiKGEpO2lmKDA+PWIubGVuZ3RoKWEuYWlEaXNwbGF5PWouc2xpY2UoKTtlbHNle2lmKGl8fGN8fGR8fGcubGVuZ3RoPlxyXG5iLmxlbmd0aHx8MCE9PWIuaW5kZXhPZihnKXx8YS5iU29ydGVkKWEuYWlEaXNwbGF5PWouc2xpY2UoKTtiPWEuYWlEaXNwbGF5O2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspZS50ZXN0KGEuYW9EYXRhW2JbY11dLl9zRmlsdGVyUm93KSYmZi5wdXNoKGJbY10pO2EuYWlEaXNwbGF5PWZ9fWZ1bmN0aW9uIFJhKGEsYixjLGQpe2E9Yj9hOlNhKGEpO2MmJihhPVwiXig/PS4qP1wiK2gubWFwKGEubWF0Y2goL1wiW15cIl0rXCJ8W14gXSsvZyl8fFtcIlwiXSxmdW5jdGlvbihhKXtpZignXCInPT09YS5jaGFyQXQoMCkpdmFyIGI9YS5tYXRjaCgvXlwiKC4qKVwiJC8pLGE9Yj9iWzFdOmE7cmV0dXJuIGEucmVwbGFjZSgnXCInLFwiXCIpfSkuam9pbihcIikoPz0uKj9cIikrXCIpLiokXCIpO3JldHVybiBSZWdFeHAoYSxkP1wiaVwiOlwiXCIpfWZ1bmN0aW9uIEJiKGEpe3ZhciBiPWEuYW9Db2x1bW5zLGMsZCxlLGYsZyxqLGksaCxtPWwuZXh0LnR5cGUuc2VhcmNoO2M9ITE7ZD0wO2ZvcihmPWEuYW9EYXRhLmxlbmd0aDtkPGY7ZCsrKWlmKGg9XHJcbmEuYW9EYXRhW2RdLCFoLl9hRmlsdGVyRGF0YSl7aj1bXTtlPTA7Zm9yKGc9Yi5sZW5ndGg7ZTxnO2UrKyljPWJbZV0sYy5iU2VhcmNoYWJsZT8oaT1CKGEsZCxlLFwiZmlsdGVyXCIpLG1bYy5zVHlwZV0mJihpPW1bYy5zVHlwZV0oaSkpLG51bGw9PT1pJiYoaT1cIlwiKSxcInN0cmluZ1wiIT09dHlwZW9mIGkmJmkudG9TdHJpbmcmJihpPWkudG9TdHJpbmcoKSkpOmk9XCJcIixpLmluZGV4T2YmJi0xIT09aS5pbmRleE9mKFwiJlwiKSYmKHdhLmlubmVySFRNTD1pLGk9WmI/d2EudGV4dENvbnRlbnQ6d2EuaW5uZXJUZXh0KSxpLnJlcGxhY2UmJihpPWkucmVwbGFjZSgvW1xcclxcblxcdTIwMjhdL2csXCJcIikpLGoucHVzaChpKTtoLl9hRmlsdGVyRGF0YT1qO2guX3NGaWx0ZXJSb3c9ai5qb2luKFwiICBcIik7Yz0hMH1yZXR1cm4gY31mdW5jdGlvbiBDYihhKXtyZXR1cm57c2VhcmNoOmEuc1NlYXJjaCxzbWFydDphLmJTbWFydCxyZWdleDphLmJSZWdleCxjYXNlSW5zZW5zaXRpdmU6YS5iQ2FzZUluc2Vuc2l0aXZlfX1cclxuZnVuY3Rpb24gRGIoYSl7cmV0dXJue3NTZWFyY2g6YS5zZWFyY2gsYlNtYXJ0OmEuc21hcnQsYlJlZ2V4OmEucmVnZXgsYkNhc2VJbnNlbnNpdGl2ZTphLmNhc2VJbnNlbnNpdGl2ZX19ZnVuY3Rpb24gdWIoYSl7dmFyIGI9YS5zVGFibGVJZCxjPWEuYWFuRmVhdHVyZXMuaSxkPWgoXCI8ZGl2Lz5cIix7XCJjbGFzc1wiOmEub0NsYXNzZXMuc0luZm8saWQ6IWM/YitcIl9pbmZvXCI6bnVsbH0pO2N8fChhLmFvRHJhd0NhbGxiYWNrLnB1c2goe2ZuOkViLHNOYW1lOlwiaW5mb3JtYXRpb25cIn0pLGQuYXR0cihcInJvbGVcIixcInN0YXR1c1wiKS5hdHRyKFwiYXJpYS1saXZlXCIsXCJwb2xpdGVcIiksaChhLm5UYWJsZSkuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIixiK1wiX2luZm9cIikpO3JldHVybiBkWzBdfWZ1bmN0aW9uIEViKGEpe3ZhciBiPWEuYWFuRmVhdHVyZXMuaTtpZigwIT09Yi5sZW5ndGgpe3ZhciBjPWEub0xhbmd1YWdlLGQ9YS5faURpc3BsYXlTdGFydCsxLGU9YS5mbkRpc3BsYXlFbmQoKSxmPWEuZm5SZWNvcmRzVG90YWwoKSxcclxuZz1hLmZuUmVjb3Jkc0Rpc3BsYXkoKSxqPWc/Yy5zSW5mbzpjLnNJbmZvRW1wdHk7ZyE9PWYmJihqKz1cIiBcIitjLnNJbmZvRmlsdGVyZWQpO2orPWMuc0luZm9Qb3N0Rml4O2o9RmIoYSxqKTtjPWMuZm5JbmZvQ2FsbGJhY2s7bnVsbCE9PWMmJihqPWMuY2FsbChhLm9JbnN0YW5jZSxhLGQsZSxmLGcsaikpO2goYikuaHRtbChqKX19ZnVuY3Rpb24gRmIoYSxiKXt2YXIgYz1hLmZuRm9ybWF0TnVtYmVyLGQ9YS5faURpc3BsYXlTdGFydCsxLGU9YS5faURpc3BsYXlMZW5ndGgsZj1hLmZuUmVjb3Jkc0Rpc3BsYXkoKSxnPS0xPT09ZTtyZXR1cm4gYi5yZXBsYWNlKC9fU1RBUlRfL2csYy5jYWxsKGEsZCkpLnJlcGxhY2UoL19FTkRfL2csYy5jYWxsKGEsYS5mbkRpc3BsYXlFbmQoKSkpLnJlcGxhY2UoL19NQVhfL2csYy5jYWxsKGEsYS5mblJlY29yZHNUb3RhbCgpKSkucmVwbGFjZSgvX1RPVEFMXy9nLGMuY2FsbChhLGYpKS5yZXBsYWNlKC9fUEFHRV8vZyxjLmNhbGwoYSxnPzE6TWF0aC5jZWlsKGQvXHJcbmUpKSkucmVwbGFjZSgvX1BBR0VTXy9nLGMuY2FsbChhLGc/MTpNYXRoLmNlaWwoZi9lKSkpfWZ1bmN0aW9uIGlhKGEpe3ZhciBiLGMsZD1hLmlJbml0RGlzcGxheVN0YXJ0LGU9YS5hb0NvbHVtbnMsZjtjPWEub0ZlYXR1cmVzO3ZhciBnPWEuYkRlZmVyTG9hZGluZztpZihhLmJJbml0aWFsaXNlZCl7cGIoYSk7bWIoYSk7Z2EoYSxhLmFvSGVhZGVyKTtnYShhLGEuYW9Gb290ZXIpO0QoYSwhMCk7Yy5iQXV0b1dpZHRoJiZIYShhKTtiPTA7Zm9yKGM9ZS5sZW5ndGg7YjxjO2IrKylmPWVbYl0sZi5zV2lkdGgmJihmLm5UaC5zdHlsZS53aWR0aD13KGYuc1dpZHRoKSk7dChhLG51bGwsXCJwcmVJbml0XCIsW2FdKTtUKGEpO2U9eShhKTtpZihcInNzcFwiIT1lfHxnKVwiYWpheFwiPT1lP3RhKGEsW10sZnVuY3Rpb24oYyl7dmFyIGY9dWEoYSxjKTtmb3IoYj0wO2I8Zi5sZW5ndGg7YisrKU8oYSxmW2JdKTthLmlJbml0RGlzcGxheVN0YXJ0PWQ7VChhKTtEKGEsITEpO3ZhKGEsYyl9LGEpOihEKGEsITEpLFxyXG52YShhKSl9ZWxzZSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWEoYSl9LDIwMCl9ZnVuY3Rpb24gdmEoYSxiKXthLl9iSW5pdENvbXBsZXRlPSEwOyhifHxhLm9Jbml0LmFhRGF0YSkmJmFhKGEpO3QoYSxudWxsLFwicGx1Z2luLWluaXRcIixbYSxiXSk7dChhLFwiYW9Jbml0Q29tcGxldGVcIixcImluaXRcIixbYSxiXSl9ZnVuY3Rpb24gVGEoYSxiKXt2YXIgYz1wYXJzZUludChiLDEwKTthLl9pRGlzcGxheUxlbmd0aD1jO1VhKGEpO3QoYSxudWxsLFwibGVuZ3RoXCIsW2EsY10pfWZ1bmN0aW9uIHFiKGEpe2Zvcih2YXIgYj1hLm9DbGFzc2VzLGM9YS5zVGFibGVJZCxkPWEuYUxlbmd0aE1lbnUsZT1BcnJheS5pc0FycmF5KGRbMF0pLGY9ZT9kWzBdOmQsZD1lP2RbMV06ZCxlPWgoXCI8c2VsZWN0Lz5cIix7bmFtZTpjK1wiX2xlbmd0aFwiLFwiYXJpYS1jb250cm9sc1wiOmMsXCJjbGFzc1wiOmIuc0xlbmd0aFNlbGVjdH0pLGc9MCxqPWYubGVuZ3RoO2c8ajtnKyspZVswXVtnXT1uZXcgT3B0aW9uKFwibnVtYmVyXCI9PT1cclxudHlwZW9mIGRbZ10/YS5mbkZvcm1hdE51bWJlcihkW2ddKTpkW2ddLGZbZ10pO3ZhciBpPWgoXCI8ZGl2PjxsYWJlbC8+PC9kaXY+XCIpLmFkZENsYXNzKGIuc0xlbmd0aCk7YS5hYW5GZWF0dXJlcy5sfHwoaVswXS5pZD1jK1wiX2xlbmd0aFwiKTtpLmNoaWxkcmVuKCkuYXBwZW5kKGEub0xhbmd1YWdlLnNMZW5ndGhNZW51LnJlcGxhY2UoXCJfTUVOVV9cIixlWzBdLm91dGVySFRNTCkpO2goXCJzZWxlY3RcIixpKS52YWwoYS5faURpc3BsYXlMZW5ndGgpLm9uKFwiY2hhbmdlLkRUXCIsZnVuY3Rpb24oKXtUYShhLGgodGhpcykudmFsKCkpO1AoYSl9KTtoKGEublRhYmxlKS5vbihcImxlbmd0aC5kdC5EVFwiLGZ1bmN0aW9uKGIsYyxkKXthPT09YyYmaChcInNlbGVjdFwiLGkpLnZhbChkKX0pO3JldHVybiBpWzBdfWZ1bmN0aW9uIHZiKGEpe3ZhciBiPWEuc1BhZ2luYXRpb25UeXBlLGM9bC5leHQucGFnZXJbYl0sZD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgYyxlPWZ1bmN0aW9uKGEpe1AoYSl9LGI9aChcIjxkaXYvPlwiKS5hZGRDbGFzcyhhLm9DbGFzc2VzLnNQYWdpbmcrXHJcbmIpWzBdLGY9YS5hYW5GZWF0dXJlcztkfHxjLmZuSW5pdChhLGIsZSk7Zi5wfHwoYi5pZD1hLnNUYWJsZUlkK1wiX3BhZ2luYXRlXCIsYS5hb0RyYXdDYWxsYmFjay5wdXNoKHtmbjpmdW5jdGlvbihhKXtpZihkKXt2YXIgYj1hLl9pRGlzcGxheVN0YXJ0LGk9YS5faURpc3BsYXlMZW5ndGgsaD1hLmZuUmVjb3Jkc0Rpc3BsYXkoKSxtPS0xPT09aSxiPW0/MDpNYXRoLmNlaWwoYi9pKSxpPW0/MTpNYXRoLmNlaWwoaC9pKSxoPWMoYixpKSxrLG09MDtmb3Ioaz1mLnAubGVuZ3RoO208azttKyspUGEoYSxcInBhZ2VCdXR0b25cIikoYSxmLnBbbV0sbSxoLGIsaSl9ZWxzZSBjLmZuVXBkYXRlKGEsZSl9LHNOYW1lOlwicGFnaW5hdGlvblwifSkpO3JldHVybiBifWZ1bmN0aW9uIFZhKGEsYixjKXt2YXIgZD1hLl9pRGlzcGxheVN0YXJ0LGU9YS5faURpc3BsYXlMZW5ndGgsZj1hLmZuUmVjb3Jkc0Rpc3BsYXkoKTswPT09Znx8LTE9PT1lP2Q9MDpcIm51bWJlclwiPT09dHlwZW9mIGI/KGQ9YiplLGQ+ZiYmXHJcbihkPTApKTpcImZpcnN0XCI9PWI/ZD0wOlwicHJldmlvdXNcIj09Yj8oZD0wPD1lP2QtZTowLDA+ZCYmKGQ9MCkpOlwibmV4dFwiPT1iP2QrZTxmJiYoZCs9ZSk6XCJsYXN0XCI9PWI/ZD1NYXRoLmZsb29yKChmLTEpL2UpKmU6SyhhLDAsXCJVbmtub3duIHBhZ2luZyBhY3Rpb246IFwiK2IsNSk7Yj1hLl9pRGlzcGxheVN0YXJ0IT09ZDthLl9pRGlzcGxheVN0YXJ0PWQ7YiYmKHQoYSxudWxsLFwicGFnZVwiLFthXSksYyYmUChhKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gc2IoYSl7cmV0dXJuIGgoXCI8ZGl2Lz5cIix7aWQ6IWEuYWFuRmVhdHVyZXMucj9hLnNUYWJsZUlkK1wiX3Byb2Nlc3NpbmdcIjpudWxsLFwiY2xhc3NcIjphLm9DbGFzc2VzLnNQcm9jZXNzaW5nfSkuaHRtbChhLm9MYW5ndWFnZS5zUHJvY2Vzc2luZykuaW5zZXJ0QmVmb3JlKGEublRhYmxlKVswXX1mdW5jdGlvbiBEKGEsYil7YS5vRmVhdHVyZXMuYlByb2Nlc3NpbmcmJmgoYS5hYW5GZWF0dXJlcy5yKS5jc3MoXCJkaXNwbGF5XCIsYj9cImJsb2NrXCI6XCJub25lXCIpO1xyXG50KGEsbnVsbCxcInByb2Nlc3NpbmdcIixbYSxiXSl9ZnVuY3Rpb24gdGIoYSl7dmFyIGI9aChhLm5UYWJsZSk7Yi5hdHRyKFwicm9sZVwiLFwiZ3JpZFwiKTt2YXIgYz1hLm9TY3JvbGw7aWYoXCJcIj09PWMuc1gmJlwiXCI9PT1jLnNZKXJldHVybiBhLm5UYWJsZTt2YXIgZD1jLnNYLGU9Yy5zWSxmPWEub0NsYXNzZXMsZz1iLmNoaWxkcmVuKFwiY2FwdGlvblwiKSxqPWcubGVuZ3RoP2dbMF0uX2NhcHRpb25TaWRlOm51bGwsaT1oKGJbMF0uY2xvbmVOb2RlKCExKSksbj1oKGJbMF0uY2xvbmVOb2RlKCExKSksbT1iLmNoaWxkcmVuKFwidGZvb3RcIik7bS5sZW5ndGh8fChtPW51bGwpO2k9aChcIjxkaXYvPlwiLHtcImNsYXNzXCI6Zi5zU2Nyb2xsV3JhcHBlcn0pLmFwcGVuZChoKFwiPGRpdi8+XCIse1wiY2xhc3NcIjpmLnNTY3JvbGxIZWFkfSkuY3NzKHtvdmVyZmxvdzpcImhpZGRlblwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIixib3JkZXI6MCx3aWR0aDpkPyFkP251bGw6dyhkKTpcIjEwMCVcIn0pLmFwcGVuZChoKFwiPGRpdi8+XCIsXHJcbntcImNsYXNzXCI6Zi5zU2Nyb2xsSGVhZElubmVyfSkuY3NzKHtcImJveC1zaXppbmdcIjpcImNvbnRlbnQtYm94XCIsd2lkdGg6Yy5zWElubmVyfHxcIjEwMCVcIn0pLmFwcGVuZChpLnJlbW92ZUF0dHIoXCJpZFwiKS5jc3MoXCJtYXJnaW4tbGVmdFwiLDApLmFwcGVuZChcInRvcFwiPT09aj9nOm51bGwpLmFwcGVuZChiLmNoaWxkcmVuKFwidGhlYWRcIikpKSkpLmFwcGVuZChoKFwiPGRpdi8+XCIse1wiY2xhc3NcIjpmLnNTY3JvbGxCb2R5fSkuY3NzKHtwb3NpdGlvbjpcInJlbGF0aXZlXCIsb3ZlcmZsb3c6XCJhdXRvXCIsd2lkdGg6IWQ/bnVsbDp3KGQpfSkuYXBwZW5kKGIpKTttJiZpLmFwcGVuZChoKFwiPGRpdi8+XCIse1wiY2xhc3NcIjpmLnNTY3JvbGxGb290fSkuY3NzKHtvdmVyZmxvdzpcImhpZGRlblwiLGJvcmRlcjowLHdpZHRoOmQ/IWQ/bnVsbDp3KGQpOlwiMTAwJVwifSkuYXBwZW5kKGgoXCI8ZGl2Lz5cIix7XCJjbGFzc1wiOmYuc1Njcm9sbEZvb3RJbm5lcn0pLmFwcGVuZChuLnJlbW92ZUF0dHIoXCJpZFwiKS5jc3MoXCJtYXJnaW4tbGVmdFwiLFxyXG4wKS5hcHBlbmQoXCJib3R0b21cIj09PWo/ZzpudWxsKS5hcHBlbmQoYi5jaGlsZHJlbihcInRmb290XCIpKSkpKTt2YXIgYj1pLmNoaWxkcmVuKCksaz1iWzBdLGY9YlsxXSxzPW0/YlsyXTpudWxsO2lmKGQpaChmKS5vbihcInNjcm9sbC5EVFwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zY3JvbGxMZWZ0O2suc2Nyb2xsTGVmdD1hO20mJihzLnNjcm9sbExlZnQ9YSl9KTtoKGYpLmNzcyhcIm1heC1oZWlnaHRcIixlKTtjLmJDb2xsYXBzZXx8aChmKS5jc3MoXCJoZWlnaHRcIixlKTthLm5TY3JvbGxIZWFkPWs7YS5uU2Nyb2xsQm9keT1mO2EublNjcm9sbEZvb3Q9czthLmFvRHJhd0NhbGxiYWNrLnB1c2goe2ZuOm1hLHNOYW1lOlwic2Nyb2xsaW5nXCJ9KTtyZXR1cm4gaVswXX1mdW5jdGlvbiBtYShhKXt2YXIgYj1hLm9TY3JvbGwsYz1iLnNYLGQ9Yi5zWElubmVyLGU9Yi5zWSxiPWIuaUJhcldpZHRoLGY9aChhLm5TY3JvbGxIZWFkKSxnPWZbMF0uc3R5bGUsaj1mLmNoaWxkcmVuKFwiZGl2XCIpLGk9alswXS5zdHlsZSxcclxubj1qLmNoaWxkcmVuKFwidGFibGVcIiksaj1hLm5TY3JvbGxCb2R5LG09aChqKSxxPWouc3R5bGUscz1oKGEublNjcm9sbEZvb3QpLmNoaWxkcmVuKFwiZGl2XCIpLGw9cy5jaGlsZHJlbihcInRhYmxlXCIpLG89aChhLm5USGVhZCkscD1oKGEublRhYmxlKSxyPXBbMF0sdD1yLnN0eWxlLHU9YS5uVEZvb3Q/aChhLm5URm9vdCk6bnVsbCxVPWEub0Jyb3dzZXIsVj1VLmJTY3JvbGxPdmVyc2l6ZSwkYj1DKGEuYW9Db2x1bW5zLFwiblRoXCIpLFEsTCxSLHhhLHY9W10seD1bXSx5PVtdLHo9W10sQSxCPWZ1bmN0aW9uKGEpe2E9YS5zdHlsZTthLnBhZGRpbmdUb3A9XCIwXCI7YS5wYWRkaW5nQm90dG9tPVwiMFwiO2EuYm9yZGVyVG9wV2lkdGg9XCIwXCI7YS5ib3JkZXJCb3R0b21XaWR0aD1cIjBcIjthLmhlaWdodD0wfTtMPWouc2Nyb2xsSGVpZ2h0PmouY2xpZW50SGVpZ2h0O2lmKGEuc2Nyb2xsQmFyVmlzIT09TCYmYS5zY3JvbGxCYXJWaXMhPT1rKWEuc2Nyb2xsQmFyVmlzPUwsYWEoYSk7ZWxzZXthLnNjcm9sbEJhclZpcz1cclxuTDtwLmNoaWxkcmVuKFwidGhlYWQsIHRmb290XCIpLnJlbW92ZSgpO3UmJihSPXUuY2xvbmUoKS5wcmVwZW5kVG8ocCksUT11LmZpbmQoXCJ0clwiKSxSPVIuZmluZChcInRyXCIpKTt4YT1vLmNsb25lKCkucHJlcGVuZFRvKHApO289by5maW5kKFwidHJcIik7TD14YS5maW5kKFwidHJcIik7eGEuZmluZChcInRoLCB0ZFwiKS5yZW1vdmVBdHRyKFwidGFiaW5kZXhcIik7Y3x8KHEud2lkdGg9XCIxMDAlXCIsZlswXS5zdHlsZS53aWR0aD1cIjEwMCVcIik7aC5lYWNoKHNhKGEseGEpLGZ1bmN0aW9uKGIsYyl7QT1iYShhLGIpO2Muc3R5bGUud2lkdGg9YS5hb0NvbHVtbnNbQV0uc1dpZHRofSk7dSYmSShmdW5jdGlvbihhKXthLnN0eWxlLndpZHRoPVwiXCJ9LFIpO2Y9cC5vdXRlcldpZHRoKCk7aWYoXCJcIj09PWMpe3Qud2lkdGg9XCIxMDAlXCI7aWYoViYmKHAuZmluZChcInRib2R5XCIpLmhlaWdodCgpPmoub2Zmc2V0SGVpZ2h0fHxcInNjcm9sbFwiPT1tLmNzcyhcIm92ZXJmbG93LXlcIikpKXQud2lkdGg9dyhwLm91dGVyV2lkdGgoKS1cclxuYik7Zj1wLm91dGVyV2lkdGgoKX1lbHNlXCJcIiE9PWQmJih0LndpZHRoPXcoZCksZj1wLm91dGVyV2lkdGgoKSk7SShCLEwpO0koZnVuY3Rpb24oYSl7eS5wdXNoKGEuaW5uZXJIVE1MKTt2LnB1c2godyhoKGEpLmNzcyhcIndpZHRoXCIpKSl9LEwpO0koZnVuY3Rpb24oYSxiKXtpZihoLmluQXJyYXkoYSwkYikhPT0tMSlhLnN0eWxlLndpZHRoPXZbYl19LG8pO2goTCkuaGVpZ2h0KDApO3UmJihJKEIsUiksSShmdW5jdGlvbihhKXt6LnB1c2goYS5pbm5lckhUTUwpO3gucHVzaCh3KGgoYSkuY3NzKFwid2lkdGhcIikpKX0sUiksSShmdW5jdGlvbihhLGIpe2Euc3R5bGUud2lkdGg9eFtiXX0sUSksaChSKS5oZWlnaHQoMCkpO0koZnVuY3Rpb24oYSxiKXthLmlubmVySFRNTD0nPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfc2l6aW5nXCI+Jyt5W2JdK1wiPC9kaXY+XCI7YS5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodD1cIjBcIjthLmNoaWxkTm9kZXNbMF0uc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIjthLnN0eWxlLndpZHRoPVxyXG52W2JdfSxMKTt1JiZJKGZ1bmN0aW9uKGEsYil7YS5pbm5lckhUTUw9JzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicreltiXStcIjwvZGl2PlwiO2EuY2hpbGROb2Rlc1swXS5zdHlsZS5oZWlnaHQ9XCIwXCI7YS5jaGlsZE5vZGVzWzBdLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCI7YS5zdHlsZS53aWR0aD14W2JdfSxSKTtpZihwLm91dGVyV2lkdGgoKTxmKXtRPWouc2Nyb2xsSGVpZ2h0Pmoub2Zmc2V0SGVpZ2h0fHxcInNjcm9sbFwiPT1tLmNzcyhcIm92ZXJmbG93LXlcIik/ZitiOmY7aWYoViYmKGouc2Nyb2xsSGVpZ2h0Pmoub2Zmc2V0SGVpZ2h0fHxcInNjcm9sbFwiPT1tLmNzcyhcIm92ZXJmbG93LXlcIikpKXQud2lkdGg9dyhRLWIpOyhcIlwiPT09Y3x8XCJcIiE9PWQpJiZLKGEsMSxcIlBvc3NpYmxlIGNvbHVtbiBtaXNhbGlnbm1lbnRcIiw2KX1lbHNlIFE9XCIxMDAlXCI7cS53aWR0aD13KFEpO2cud2lkdGg9dyhRKTt1JiYoYS5uU2Nyb2xsRm9vdC5zdHlsZS53aWR0aD13KFEpKTshZSYmViYmKHEuaGVpZ2h0PVxyXG53KHIub2Zmc2V0SGVpZ2h0K2IpKTtjPXAub3V0ZXJXaWR0aCgpO25bMF0uc3R5bGUud2lkdGg9dyhjKTtpLndpZHRoPXcoYyk7ZD1wLmhlaWdodCgpPmouY2xpZW50SGVpZ2h0fHxcInNjcm9sbFwiPT1tLmNzcyhcIm92ZXJmbG93LXlcIik7ZT1cInBhZGRpbmdcIisoVS5iU2Nyb2xsYmFyTGVmdD9cIkxlZnRcIjpcIlJpZ2h0XCIpO2lbZV09ZD9iK1wicHhcIjpcIjBweFwiO3UmJihsWzBdLnN0eWxlLndpZHRoPXcoYyksc1swXS5zdHlsZS53aWR0aD13KGMpLHNbMF0uc3R5bGVbZV09ZD9iK1wicHhcIjpcIjBweFwiKTtwLmNoaWxkcmVuKFwiY29sZ3JvdXBcIikuaW5zZXJ0QmVmb3JlKHAuY2hpbGRyZW4oXCJ0aGVhZFwiKSk7bS50cmlnZ2VyKFwic2Nyb2xsXCIpO2lmKChhLmJTb3J0ZWR8fGEuYkZpbHRlcmVkKSYmIWEuX2RyYXdIb2xkKWouc2Nyb2xsVG9wPTB9fWZ1bmN0aW9uIEkoYSxiLGMpe2Zvcih2YXIgZD0wLGU9MCxmPWIubGVuZ3RoLGcsajtlPGY7KXtnPWJbZV0uZmlyc3RDaGlsZDtmb3Ioaj1jP2NbZV0uZmlyc3RDaGlsZDpcclxubnVsbDtnOykxPT09Zy5ub2RlVHlwZSYmKGM/YShnLGosZCk6YShnLGQpLGQrKyksZz1nLm5leHRTaWJsaW5nLGo9Yz9qLm5leHRTaWJsaW5nOm51bGw7ZSsrfX1mdW5jdGlvbiBIYShhKXt2YXIgYj1hLm5UYWJsZSxjPWEuYW9Db2x1bW5zLGQ9YS5vU2Nyb2xsLGU9ZC5zWSxmPWQuc1gsZz1kLnNYSW5uZXIsaj1jLmxlbmd0aCxpPW5hKGEsXCJiVmlzaWJsZVwiKSxuPWgoXCJ0aFwiLGEublRIZWFkKSxtPWIuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksaz1iLnBhcmVudE5vZGUscz0hMSxsLG8scD1hLm9Ccm93c2VyLGQ9cC5iU2Nyb2xsT3ZlcnNpemU7KGw9Yi5zdHlsZS53aWR0aCkmJi0xIT09bC5pbmRleE9mKFwiJVwiKSYmKG09bCk7Zm9yKGw9MDtsPGkubGVuZ3RoO2wrKylvPWNbaVtsXV0sbnVsbCE9PW8uc1dpZHRoJiYoby5zV2lkdGg9R2Ioby5zV2lkdGhPcmlnLGspLHM9ITApO2lmKGR8fCFzJiYhZiYmIWUmJmo9PVcoYSkmJmo9PW4ubGVuZ3RoKWZvcihsPTA7bDxqO2wrKylpPWJhKGEsbCksXHJcbm51bGwhPT1pJiYoY1tpXS5zV2lkdGg9dyhuLmVxKGwpLndpZHRoKCkpKTtlbHNle2o9aChiKS5jbG9uZSgpLmNzcyhcInZpc2liaWxpdHlcIixcImhpZGRlblwiKS5yZW1vdmVBdHRyKFwiaWRcIik7ai5maW5kKFwidGJvZHkgdHJcIikucmVtb3ZlKCk7dmFyIHI9aChcIjx0ci8+XCIpLmFwcGVuZFRvKGouZmluZChcInRib2R5XCIpKTtqLmZpbmQoXCJ0aGVhZCwgdGZvb3RcIikucmVtb3ZlKCk7ai5hcHBlbmQoaChhLm5USGVhZCkuY2xvbmUoKSkuYXBwZW5kKGgoYS5uVEZvb3QpLmNsb25lKCkpO2ouZmluZChcInRmb290IHRoLCB0Zm9vdCB0ZFwiKS5jc3MoXCJ3aWR0aFwiLFwiXCIpO249c2EoYSxqLmZpbmQoXCJ0aGVhZFwiKVswXSk7Zm9yKGw9MDtsPGkubGVuZ3RoO2wrKylvPWNbaVtsXV0sbltsXS5zdHlsZS53aWR0aD1udWxsIT09by5zV2lkdGhPcmlnJiZcIlwiIT09by5zV2lkdGhPcmlnP3coby5zV2lkdGhPcmlnKTpcIlwiLG8uc1dpZHRoT3JpZyYmZiYmaChuW2xdKS5hcHBlbmQoaChcIjxkaXYvPlwiKS5jc3Moe3dpZHRoOm8uc1dpZHRoT3JpZyxcclxubWFyZ2luOjAscGFkZGluZzowLGJvcmRlcjowLGhlaWdodDoxfSkpO2lmKGEuYW9EYXRhLmxlbmd0aClmb3IobD0wO2w8aS5sZW5ndGg7bCsrKXM9aVtsXSxvPWNbc10saChIYihhLHMpKS5jbG9uZSghMSkuYXBwZW5kKG8uc0NvbnRlbnRQYWRkaW5nKS5hcHBlbmRUbyhyKTtoKFwiW25hbWVdXCIsaikucmVtb3ZlQXR0cihcIm5hbWVcIik7bz1oKFwiPGRpdi8+XCIpLmNzcyhmfHxlP3twb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOjAsbGVmdDowLGhlaWdodDoxLHJpZ2h0OjAsb3ZlcmZsb3c6XCJoaWRkZW5cIn06e30pLmFwcGVuZChqKS5hcHBlbmRUbyhrKTtmJiZnP2oud2lkdGgoZyk6Zj8oai5jc3MoXCJ3aWR0aFwiLFwiYXV0b1wiKSxqLnJlbW92ZUF0dHIoXCJ3aWR0aFwiKSxqLndpZHRoKCk8ay5jbGllbnRXaWR0aCYmbSYmai53aWR0aChrLmNsaWVudFdpZHRoKSk6ZT9qLndpZHRoKGsuY2xpZW50V2lkdGgpOm0mJmoud2lkdGgobSk7Zm9yKGw9ZT0wO2w8aS5sZW5ndGg7bCsrKWs9aChuW2xdKSxnPWsub3V0ZXJXaWR0aCgpLVxyXG5rLndpZHRoKCksaz1wLmJCb3VuZGluZz9NYXRoLmNlaWwobltsXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk6ay5vdXRlcldpZHRoKCksZSs9ayxjW2lbbF1dLnNXaWR0aD13KGstZyk7Yi5zdHlsZS53aWR0aD13KGUpO28ucmVtb3ZlKCl9bSYmKGIuc3R5bGUud2lkdGg9dyhtKSk7aWYoKG18fGYpJiYhYS5fcmVzekV2dCliPWZ1bmN0aW9uKCl7aChFKS5vbihcInJlc2l6ZS5EVC1cIithLnNJbnN0YW5jZSxRYShmdW5jdGlvbigpe2FhKGEpfSkpfSxkP3NldFRpbWVvdXQoYiwxRTMpOmIoKSxhLl9yZXN6RXZ0PSEwfWZ1bmN0aW9uIEdiKGEsYil7aWYoIWEpcmV0dXJuIDA7dmFyIGM9aChcIjxkaXYvPlwiKS5jc3MoXCJ3aWR0aFwiLHcoYSkpLmFwcGVuZFRvKGJ8fEguYm9keSksZD1jWzBdLm9mZnNldFdpZHRoO2MucmVtb3ZlKCk7cmV0dXJuIGR9ZnVuY3Rpb24gSGIoYSxiKXt2YXIgYz1JYihhLGIpO2lmKDA+YylyZXR1cm4gbnVsbDt2YXIgZD1hLmFvRGF0YVtjXTtyZXR1cm4hZC5uVHI/XHJcbmgoXCI8dGQvPlwiKS5odG1sKEIoYSxjLGIsXCJkaXNwbGF5XCIpKVswXTpkLmFuQ2VsbHNbYl19ZnVuY3Rpb24gSWIoYSxiKXtmb3IodmFyIGMsZD0tMSxlPS0xLGY9MCxnPWEuYW9EYXRhLmxlbmd0aDtmPGc7ZisrKWM9QihhLGYsYixcImRpc3BsYXlcIikrXCJcIixjPWMucmVwbGFjZShhYyxcIlwiKSxjPWMucmVwbGFjZSgvJm5ic3A7L2csXCIgXCIpLGMubGVuZ3RoPmQmJihkPWMubGVuZ3RoLGU9Zik7cmV0dXJuIGV9ZnVuY3Rpb24gdyhhKXtyZXR1cm4gbnVsbD09PWE/XCIwcHhcIjpcIm51bWJlclwiPT10eXBlb2YgYT8wPmE/XCIwcHhcIjphK1wicHhcIjphLm1hdGNoKC9cXGQkLyk/YStcInB4XCI6YX1mdW5jdGlvbiBZKGEpe3ZhciBiLGMsZD1bXSxlPWEuYW9Db2x1bW5zLGYsZyxqLGk7Yj1hLmFhU29ydGluZ0ZpeGVkO2M9aC5pc1BsYWluT2JqZWN0KGIpO3ZhciBuPVtdO2Y9ZnVuY3Rpb24oYSl7YS5sZW5ndGgmJiFBcnJheS5pc0FycmF5KGFbMF0pP24ucHVzaChhKTpoLm1lcmdlKG4sYSl9O0FycmF5LmlzQXJyYXkoYikmJlxyXG5mKGIpO2MmJmIucHJlJiZmKGIucHJlKTtmKGEuYWFTb3J0aW5nKTtjJiZiLnBvc3QmJmYoYi5wb3N0KTtmb3IoYT0wO2E8bi5sZW5ndGg7YSsrKXtpPW5bYV1bMF07Zj1lW2ldLmFEYXRhU29ydDtiPTA7Zm9yKGM9Zi5sZW5ndGg7YjxjO2IrKylnPWZbYl0saj1lW2ddLnNUeXBlfHxcInN0cmluZ1wiLG5bYV0uX2lkeD09PWsmJihuW2FdLl9pZHg9aC5pbkFycmF5KG5bYV1bMV0sZVtnXS5hc1NvcnRpbmcpKSxkLnB1c2goe3NyYzppLGNvbDpnLGRpcjpuW2FdWzFdLGluZGV4Om5bYV0uX2lkeCx0eXBlOmosZm9ybWF0dGVyOmwuZXh0LnR5cGUub3JkZXJbaitcIi1wcmVcIl19KX1yZXR1cm4gZH1mdW5jdGlvbiBvYihhKXt2YXIgYixjLGQ9W10sZT1sLmV4dC50eXBlLm9yZGVyLGY9YS5hb0RhdGEsZz0wLGosaT1hLmFpRGlzcGxheU1hc3RlcixoO0lhKGEpO2g9WShhKTtiPTA7Zm9yKGM9aC5sZW5ndGg7YjxjO2IrKylqPWhbYl0sai5mb3JtYXR0ZXImJmcrKyxKYihhLGouY29sKTtpZihcInNzcFwiIT1cclxueShhKSYmMCE9PWgubGVuZ3RoKXtiPTA7Zm9yKGM9aS5sZW5ndGg7YjxjO2IrKylkW2lbYl1dPWI7Zz09PWgubGVuZ3RoP2kuc29ydChmdW5jdGlvbihhLGIpe3ZhciBjLGUsZyxqLGk9aC5sZW5ndGgsaz1mW2FdLl9hU29ydERhdGEsbD1mW2JdLl9hU29ydERhdGE7Zm9yKGc9MDtnPGk7ZysrKWlmKGo9aFtnXSxjPWtbai5jb2xdLGU9bFtqLmNvbF0sYz1jPGU/LTE6Yz5lPzE6MCwwIT09YylyZXR1cm5cImFzY1wiPT09ai5kaXI/YzotYztjPWRbYV07ZT1kW2JdO3JldHVybiBjPGU/LTE6Yz5lPzE6MH0pOmkuc29ydChmdW5jdGlvbihhLGIpe3ZhciBjLGcsaixpLGs9aC5sZW5ndGgsbD1mW2FdLl9hU29ydERhdGEsbz1mW2JdLl9hU29ydERhdGE7Zm9yKGo9MDtqPGs7aisrKWlmKGk9aFtqXSxjPWxbaS5jb2xdLGc9b1tpLmNvbF0saT1lW2kudHlwZStcIi1cIitpLmRpcl18fGVbXCJzdHJpbmctXCIraS5kaXJdLGM9aShjLGcpLDAhPT1jKXJldHVybiBjO2M9ZFthXTtnPWRbYl07cmV0dXJuIGM8XHJcbmc/LTE6Yz5nPzE6MH0pfWEuYlNvcnRlZD0hMH1mdW5jdGlvbiBLYihhKXtmb3IodmFyIGIsYyxkPWEuYW9Db2x1bW5zLGU9WShhKSxhPWEub0xhbmd1YWdlLm9BcmlhLGY9MCxnPWQubGVuZ3RoO2Y8ZztmKyspe2M9ZFtmXTt2YXIgaj1jLmFzU29ydGluZztiPWMuc1RpdGxlLnJlcGxhY2UoLzwuKj8+L2csXCJcIik7dmFyIGk9Yy5uVGg7aS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNvcnRcIik7Yy5iU29ydGFibGUmJigwPGUubGVuZ3RoJiZlWzBdLmNvbD09Zj8oaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNvcnRcIixcImFzY1wiPT1lWzBdLmRpcj9cImFzY2VuZGluZ1wiOlwiZGVzY2VuZGluZ1wiKSxjPWpbZVswXS5pbmRleCsxXXx8alswXSk6Yz1qWzBdLGIrPVwiYXNjXCI9PT1jP2Euc1NvcnRBc2NlbmRpbmc6YS5zU29ydERlc2NlbmRpbmcpO2kuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLGIpfX1mdW5jdGlvbiBXYShhLGIsYyxkKXt2YXIgZT1hLmFhU29ydGluZyxmPWEuYW9Db2x1bW5zW2JdLmFzU29ydGluZyxcclxuZz1mdW5jdGlvbihhLGIpe3ZhciBjPWEuX2lkeDtjPT09ayYmKGM9aC5pbkFycmF5KGFbMV0sZikpO3JldHVybiBjKzE8Zi5sZW5ndGg/YysxOmI/bnVsbDowfTtcIm51bWJlclwiPT09dHlwZW9mIGVbMF0mJihlPWEuYWFTb3J0aW5nPVtlXSk7YyYmYS5vRmVhdHVyZXMuYlNvcnRNdWx0aT8oYz1oLmluQXJyYXkoYixDKGUsXCIwXCIpKSwtMSE9PWM/KGI9ZyhlW2NdLCEwKSxudWxsPT09YiYmMT09PWUubGVuZ3RoJiYoYj0wKSxudWxsPT09Yj9lLnNwbGljZShjLDEpOihlW2NdWzFdPWZbYl0sZVtjXS5faWR4PWIpKTooZS5wdXNoKFtiLGZbMF0sMF0pLGVbZS5sZW5ndGgtMV0uX2lkeD0wKSk6ZS5sZW5ndGgmJmVbMF1bMF09PWI/KGI9ZyhlWzBdKSxlLmxlbmd0aD0xLGVbMF1bMV09ZltiXSxlWzBdLl9pZHg9Yik6KGUubGVuZ3RoPTAsZS5wdXNoKFtiLGZbMF1dKSxlWzBdLl9pZHg9MCk7VChhKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkJiZkKGEpfWZ1bmN0aW9uIE9hKGEsYixjLGQpe3ZhciBlPVxyXG5hLmFvQ29sdW1uc1tjXTtYYShiLHt9LGZ1bmN0aW9uKGIpeyExIT09ZS5iU29ydGFibGUmJihhLm9GZWF0dXJlcy5iUHJvY2Vzc2luZz8oRChhLCEwKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7V2EoYSxjLGIuc2hpZnRLZXksZCk7XCJzc3BcIiE9PXkoYSkmJkQoYSwhMSl9LDApKTpXYShhLGMsYi5zaGlmdEtleSxkKSl9KX1mdW5jdGlvbiB5YShhKXt2YXIgYj1hLmFMYXN0U29ydCxjPWEub0NsYXNzZXMuc1NvcnRDb2x1bW4sZD1ZKGEpLGU9YS5vRmVhdHVyZXMsZixnO2lmKGUuYlNvcnQmJmUuYlNvcnRDbGFzc2VzKXtlPTA7Zm9yKGY9Yi5sZW5ndGg7ZTxmO2UrKylnPWJbZV0uc3JjLGgoQyhhLmFvRGF0YSxcImFuQ2VsbHNcIixnKSkucmVtb3ZlQ2xhc3MoYysoMj5lP2UrMTozKSk7ZT0wO2ZvcihmPWQubGVuZ3RoO2U8ZjtlKyspZz1kW2VdLnNyYyxoKEMoYS5hb0RhdGEsXCJhbkNlbGxzXCIsZykpLmFkZENsYXNzKGMrKDI+ZT9lKzE6MykpfWEuYUxhc3RTb3J0PWR9ZnVuY3Rpb24gSmIoYSxcclxuYil7dmFyIGM9YS5hb0NvbHVtbnNbYl0sZD1sLmV4dC5vcmRlcltjLnNTb3J0RGF0YVR5cGVdLGU7ZCYmKGU9ZC5jYWxsKGEub0luc3RhbmNlLGEsYixjYShhLGIpKSk7Zm9yKHZhciBmLGc9bC5leHQudHlwZS5vcmRlcltjLnNUeXBlK1wiLXByZVwiXSxqPTAsaT1hLmFvRGF0YS5sZW5ndGg7ajxpO2orKylpZihjPWEuYW9EYXRhW2pdLGMuX2FTb3J0RGF0YXx8KGMuX2FTb3J0RGF0YT1bXSksIWMuX2FTb3J0RGF0YVtiXXx8ZClmPWQ/ZVtqXTpCKGEsaixiLFwic29ydFwiKSxjLl9hU29ydERhdGFbYl09Zz9nKGYpOmZ9ZnVuY3Rpb24gemEoYSl7aWYoYS5vRmVhdHVyZXMuYlN0YXRlU2F2ZSYmIWEuYkRlc3Ryb3lpbmcpe3ZhciBiPXt0aW1lOituZXcgRGF0ZSxzdGFydDphLl9pRGlzcGxheVN0YXJ0LGxlbmd0aDphLl9pRGlzcGxheUxlbmd0aCxvcmRlcjpoLmV4dGVuZCghMCxbXSxhLmFhU29ydGluZyksc2VhcmNoOkNiKGEub1ByZXZpb3VzU2VhcmNoKSxjb2x1bW5zOmgubWFwKGEuYW9Db2x1bW5zLFxyXG5mdW5jdGlvbihiLGQpe3JldHVybnt2aXNpYmxlOmIuYlZpc2libGUsc2VhcmNoOkNiKGEuYW9QcmVTZWFyY2hDb2xzW2RdKX19KX07dChhLFwiYW9TdGF0ZVNhdmVQYXJhbXNcIixcInN0YXRlU2F2ZVBhcmFtc1wiLFthLGJdKTthLm9TYXZlZFN0YXRlPWI7YS5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoYS5vSW5zdGFuY2UsYSxiKX19ZnVuY3Rpb24gTGIoYSxiLGMpe3ZhciBkLGUsZj1hLmFvQ29sdW1ucyxiPWZ1bmN0aW9uKGIpe2lmKGImJmIudGltZSl7dmFyIGc9dChhLFwiYW9TdGF0ZUxvYWRQYXJhbXNcIixcInN0YXRlTG9hZFBhcmFtc1wiLFthLGJdKTtpZigtMT09PWguaW5BcnJheSghMSxnKSYmKGc9YS5pU3RhdGVEdXJhdGlvbiwhKDA8ZyYmYi50aW1lPCtuZXcgRGF0ZS0xRTMqZykmJiEoYi5jb2x1bW5zJiZmLmxlbmd0aCE9PWIuY29sdW1ucy5sZW5ndGgpKSl7YS5vTG9hZGVkU3RhdGU9aC5leHRlbmQoITAse30sYik7Yi5zdGFydCE9PWsmJihhLl9pRGlzcGxheVN0YXJ0PWIuc3RhcnQsXHJcbmEuaUluaXREaXNwbGF5U3RhcnQ9Yi5zdGFydCk7Yi5sZW5ndGghPT1rJiYoYS5faURpc3BsYXlMZW5ndGg9Yi5sZW5ndGgpO2Iub3JkZXIhPT1rJiYoYS5hYVNvcnRpbmc9W10saC5lYWNoKGIub3JkZXIsZnVuY3Rpb24oYixjKXthLmFhU29ydGluZy5wdXNoKGNbMF0+PWYubGVuZ3RoP1swLGNbMV1dOmMpfSkpO2Iuc2VhcmNoIT09ayYmaC5leHRlbmQoYS5vUHJldmlvdXNTZWFyY2gsRGIoYi5zZWFyY2gpKTtpZihiLmNvbHVtbnMpe2Q9MDtmb3IoZT1iLmNvbHVtbnMubGVuZ3RoO2Q8ZTtkKyspZz1iLmNvbHVtbnNbZF0sZy52aXNpYmxlIT09ayYmKGZbZF0uYlZpc2libGU9Zy52aXNpYmxlKSxnLnNlYXJjaCE9PWsmJmguZXh0ZW5kKGEuYW9QcmVTZWFyY2hDb2xzW2RdLERiKGcuc2VhcmNoKSl9dChhLFwiYW9TdGF0ZUxvYWRlZFwiLFwic3RhdGVMb2FkZWRcIixbYSxiXSl9fWMoKX07aWYoYS5vRmVhdHVyZXMuYlN0YXRlU2F2ZSl7dmFyIGc9YS5mblN0YXRlTG9hZENhbGxiYWNrLmNhbGwoYS5vSW5zdGFuY2UsXHJcbmEsYik7ZyE9PWsmJmIoZyl9ZWxzZSBjKCl9ZnVuY3Rpb24gQWEoYSl7dmFyIGI9bC5zZXR0aW5ncyxhPWguaW5BcnJheShhLEMoYixcIm5UYWJsZVwiKSk7cmV0dXJuLTEhPT1hP2JbYV06bnVsbH1mdW5jdGlvbiBLKGEsYixjLGQpe2M9XCJEYXRhVGFibGVzIHdhcm5pbmc6IFwiKyhhP1widGFibGUgaWQ9XCIrYS5zVGFibGVJZCtcIiAtIFwiOlwiXCIpK2M7ZCYmKGMrPVwiLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC90bi9cIitkKTtpZihiKUUuY29uc29sZSYmY29uc29sZS5sb2cmJmNvbnNvbGUubG9nKGMpO2Vsc2UgaWYoYj1sLmV4dCxiPWIuc0Vyck1vZGV8fGIuZXJyTW9kZSxhJiZ0KGEsbnVsbCxcImVycm9yXCIsW2EsZCxjXSksXCJhbGVydFwiPT1iKWFsZXJ0KGMpO2Vsc2V7aWYoXCJ0aHJvd1wiPT1iKXRocm93IEVycm9yKGMpO1wiZnVuY3Rpb25cIj09dHlwZW9mIGImJmIoYSxkLGMpfX1mdW5jdGlvbiBGKGEsYixjLGQpe0FycmF5LmlzQXJyYXkoYyk/XHJcbmguZWFjaChjLGZ1bmN0aW9uKGMsZCl7QXJyYXkuaXNBcnJheShkKT9GKGEsYixkWzBdLGRbMV0pOkYoYSxiLGQpfSk6KGQ9PT1rJiYoZD1jKSxiW2NdIT09ayYmKGFbZF09YltjXSkpfWZ1bmN0aW9uIFlhKGEsYixjKXt2YXIgZCxlO2ZvcihlIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShlKSYmKGQ9YltlXSxoLmlzUGxhaW5PYmplY3QoZCk/KGguaXNQbGFpbk9iamVjdChhW2VdKXx8KGFbZV09e30pLGguZXh0ZW5kKCEwLGFbZV0sZCkpOmFbZV09YyYmXCJkYXRhXCIhPT1lJiZcImFhRGF0YVwiIT09ZSYmQXJyYXkuaXNBcnJheShkKT9kLnNsaWNlKCk6ZCk7cmV0dXJuIGF9ZnVuY3Rpb24gWGEoYSxiLGMpe2goYSkub24oXCJjbGljay5EVFwiLGIsZnVuY3Rpb24oYil7aChhKS50cmlnZ2VyKFwiYmx1clwiKTtjKGIpfSkub24oXCJrZXlwcmVzcy5EVFwiLGIsZnVuY3Rpb24oYSl7MTM9PT1hLndoaWNoJiYoYS5wcmV2ZW50RGVmYXVsdCgpLGMoYSkpfSkub24oXCJzZWxlY3RzdGFydC5EVFwiLGZ1bmN0aW9uKCl7cmV0dXJuITF9KX1cclxuZnVuY3Rpb24geihhLGIsYyxkKXtjJiZhW2JdLnB1c2goe2ZuOmMsc05hbWU6ZH0pfWZ1bmN0aW9uIHQoYSxiLGMsZCl7dmFyIGU9W107YiYmKGU9aC5tYXAoYVtiXS5zbGljZSgpLnJldmVyc2UoKSxmdW5jdGlvbihiKXtyZXR1cm4gYi5mbi5hcHBseShhLm9JbnN0YW5jZSxkKX0pKTtudWxsIT09YyYmKGI9aC5FdmVudChjK1wiLmR0XCIpLGgoYS5uVGFibGUpLnRyaWdnZXIoYixkKSxlLnB1c2goYi5yZXN1bHQpKTtyZXR1cm4gZX1mdW5jdGlvbiBVYShhKXt2YXIgYj1hLl9pRGlzcGxheVN0YXJ0LGM9YS5mbkRpc3BsYXlFbmQoKSxkPWEuX2lEaXNwbGF5TGVuZ3RoO2I+PWMmJihiPWMtZCk7Yi09YiVkO2lmKC0xPT09ZHx8MD5iKWI9MDthLl9pRGlzcGxheVN0YXJ0PWJ9ZnVuY3Rpb24gUGEoYSxiKXt2YXIgYz1hLnJlbmRlcmVyLGQ9bC5leHQucmVuZGVyZXJbYl07cmV0dXJuIGguaXNQbGFpbk9iamVjdChjKSYmY1tiXT9kW2NbYl1dfHxkLl86XCJzdHJpbmdcIj09PXR5cGVvZiBjP2RbY118fFxyXG5kLl86ZC5ffWZ1bmN0aW9uIHkoYSl7cmV0dXJuIGEub0ZlYXR1cmVzLmJTZXJ2ZXJTaWRlP1wic3NwXCI6YS5hamF4fHxhLnNBamF4U291cmNlP1wiYWpheFwiOlwiZG9tXCJ9ZnVuY3Rpb24gamEoYSxiKXt2YXIgYz1bXSxjPU1iLm51bWJlcnNfbGVuZ3RoLGQ9TWF0aC5mbG9vcihjLzIpO2I8PWM/Yz1aKDAsYik6YTw9ZD8oYz1aKDAsYy0yKSxjLnB1c2goXCJlbGxpcHNpc1wiKSxjLnB1c2goYi0xKSk6KGE+PWItMS1kP2M9WihiLShjLTIpLGIpOihjPVooYS1kKzIsYStkLTEpLGMucHVzaChcImVsbGlwc2lzXCIpLGMucHVzaChiLTEpKSxjLnNwbGljZSgwLDAsXCJlbGxpcHNpc1wiKSxjLnNwbGljZSgwLDAsMCkpO2MuRFRfZWw9XCJzcGFuXCI7cmV0dXJuIGN9ZnVuY3Rpb24gRmEoYSl7aC5lYWNoKHtudW06ZnVuY3Rpb24oYil7cmV0dXJuIEJhKGIsYSl9LFwibnVtLWZtdFwiOmZ1bmN0aW9uKGIpe3JldHVybiBCYShiLGEsWmEpfSxcImh0bWwtbnVtXCI6ZnVuY3Rpb24oYil7cmV0dXJuIEJhKGIsYSxDYSl9LFwiaHRtbC1udW0tZm10XCI6ZnVuY3Rpb24oYil7cmV0dXJuIEJhKGIsXHJcbmEsQ2EsWmEpfX0sZnVuY3Rpb24oYixjKXt2LnR5cGUub3JkZXJbYithK1wiLXByZVwiXT1jO2IubWF0Y2goL15odG1sXFwtLykmJih2LnR5cGUuc2VhcmNoW2IrYV09di50eXBlLnNlYXJjaC5odG1sKX0pfWZ1bmN0aW9uIE5iKGEpe3JldHVybiBmdW5jdGlvbigpe3ZhciBiPVtBYSh0aGlzW2wuZXh0LmlBcGlJbmRleF0pXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7cmV0dXJuIGwuZXh0LmludGVybmFsW2FdLmFwcGx5KHRoaXMsYil9fXZhciBsPWZ1bmN0aW9uKGEpe3RoaXMuJD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmFwaSghMCkuJChhLGIpfTt0aGlzLl89ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hcGkoITApLnJvd3MoYSxiKS5kYXRhKCl9O3RoaXMuYXBpPWZ1bmN0aW9uKGEpe3JldHVybiBhP25ldyByKEFhKHRoaXNbdi5pQXBpSW5kZXhdKSk6bmV3IHIodGhpcyl9O3RoaXMuZm5BZGREYXRhPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hcGkoITApLFxyXG5kPUFycmF5LmlzQXJyYXkoYSkmJihBcnJheS5pc0FycmF5KGFbMF0pfHxoLmlzUGxhaW5PYmplY3QoYVswXSkpP2Mucm93cy5hZGQoYSk6Yy5yb3cuYWRkKGEpOyhiPT09a3x8YikmJmMuZHJhdygpO3JldHVybiBkLmZsYXR0ZW4oKS50b0FycmF5KCl9O3RoaXMuZm5BZGp1c3RDb2x1bW5TaXppbmc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hcGkoITApLmNvbHVtbnMuYWRqdXN0KCksYz1iLnNldHRpbmdzKClbMF0sZD1jLm9TY3JvbGw7YT09PWt8fGE/Yi5kcmF3KCExKTooXCJcIiE9PWQuc1h8fFwiXCIhPT1kLnNZKSYmbWEoYyl9O3RoaXMuZm5DbGVhclRhYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYXBpKCEwKS5jbGVhcigpOyhhPT09a3x8YSkmJmIuZHJhdygpfTt0aGlzLmZuQ2xvc2U9ZnVuY3Rpb24oYSl7dGhpcy5hcGkoITApLnJvdyhhKS5jaGlsZC5oaWRlKCl9O3RoaXMuZm5EZWxldGVSb3c9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuYXBpKCEwKSxhPWQucm93cyhhKSxlPVxyXG5hLnNldHRpbmdzKClbMF0saD1lLmFvRGF0YVthWzBdWzBdXTthLnJlbW92ZSgpO2ImJmIuY2FsbCh0aGlzLGUsaCk7KGM9PT1rfHxjKSYmZC5kcmF3KCk7cmV0dXJuIGh9O3RoaXMuZm5EZXN0cm95PWZ1bmN0aW9uKGEpe3RoaXMuYXBpKCEwKS5kZXN0cm95KGEpfTt0aGlzLmZuRHJhdz1mdW5jdGlvbihhKXt0aGlzLmFwaSghMCkuZHJhdyhhKX07dGhpcy5mbkZpbHRlcj1mdW5jdGlvbihhLGIsYyxkLGUsaCl7ZT10aGlzLmFwaSghMCk7bnVsbD09PWJ8fGI9PT1rP2Uuc2VhcmNoKGEsYyxkLGgpOmUuY29sdW1uKGIpLnNlYXJjaChhLGMsZCxoKTtlLmRyYXcoKX07dGhpcy5mbkdldERhdGE9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFwaSghMCk7aWYoYSE9PWspe3ZhciBkPWEubm9kZU5hbWU/YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOlwiXCI7cmV0dXJuIGIhPT1rfHxcInRkXCI9PWR8fFwidGhcIj09ZD9jLmNlbGwoYSxiKS5kYXRhKCk6Yy5yb3coYSkuZGF0YSgpfHxudWxsfXJldHVybiBjLmRhdGEoKS50b0FycmF5KCl9O1xyXG50aGlzLmZuR2V0Tm9kZXM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hcGkoITApO3JldHVybiBhIT09az9iLnJvdyhhKS5ub2RlKCk6Yi5yb3dzKCkubm9kZXMoKS5mbGF0dGVuKCkudG9BcnJheSgpfTt0aGlzLmZuR2V0UG9zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hcGkoITApLGM9YS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO3JldHVyblwiVFJcIj09Yz9iLnJvdyhhKS5pbmRleCgpOlwiVERcIj09Y3x8XCJUSFwiPT1jPyhhPWIuY2VsbChhKS5pbmRleCgpLFthLnJvdyxhLmNvbHVtblZpc2libGUsYS5jb2x1bW5dKTpudWxsfTt0aGlzLmZuSXNPcGVuPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmFwaSghMCkucm93KGEpLmNoaWxkLmlzU2hvd24oKX07dGhpcy5mbk9wZW49ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLmFwaSghMCkucm93KGEpLmNoaWxkKGIsYykuc2hvdygpLmNoaWxkKClbMF19O3RoaXMuZm5QYWdlQ2hhbmdlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hcGkoITApLnBhZ2UoYSk7XHJcbihiPT09a3x8YikmJmMuZHJhdyghMSl9O3RoaXMuZm5TZXRDb2x1bW5WaXM9ZnVuY3Rpb24oYSxiLGMpe2E9dGhpcy5hcGkoITApLmNvbHVtbihhKS52aXNpYmxlKGIpOyhjPT09a3x8YykmJmEuY29sdW1ucy5hZGp1c3QoKS5kcmF3KCl9O3RoaXMuZm5TZXR0aW5ncz1mdW5jdGlvbigpe3JldHVybiBBYSh0aGlzW3YuaUFwaUluZGV4XSl9O3RoaXMuZm5Tb3J0PWZ1bmN0aW9uKGEpe3RoaXMuYXBpKCEwKS5vcmRlcihhKS5kcmF3KCl9O3RoaXMuZm5Tb3J0TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYXBpKCEwKS5vcmRlci5saXN0ZW5lcihhLGIsYyl9O3RoaXMuZm5VcGRhdGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgaD10aGlzLmFwaSghMCk7Yz09PWt8fG51bGw9PT1jP2gucm93KGIpLmRhdGEoYSk6aC5jZWxsKGIsYykuZGF0YShhKTsoZT09PWt8fGUpJiZoLmNvbHVtbnMuYWRqdXN0KCk7KGQ9PT1rfHxkKSYmaC5kcmF3KCk7cmV0dXJuIDB9O3RoaXMuZm5WZXJzaW9uQ2hlY2s9XHJcbnYuZm5WZXJzaW9uQ2hlY2s7dmFyIGI9dGhpcyxjPWE9PT1rLGQ9dGhpcy5sZW5ndGg7YyYmKGE9e30pO3RoaXMub0FwaT10aGlzLmludGVybmFsPXYuaW50ZXJuYWw7Zm9yKHZhciBlIGluIGwuZXh0LmludGVybmFsKWUmJih0aGlzW2VdPU5iKGUpKTt0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT17fSxnPTE8ZD9ZYShlLGEsITApOmEsaj0wLGksZT10aGlzLmdldEF0dHJpYnV0ZShcImlkXCIpLG49ITEsbT1sLmRlZmF1bHRzLHE9aCh0aGlzKTtpZihcInRhYmxlXCIhPXRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSlLKG51bGwsMCxcIk5vbi10YWJsZSBub2RlIGluaXRpYWxpc2F0aW9uIChcIit0aGlzLm5vZGVOYW1lK1wiKVwiLDIpO2Vsc2V7Z2IobSk7aGIobS5jb2x1bW4pO0oobSxtLCEwKTtKKG0uY29sdW1uLG0uY29sdW1uLCEwKTtKKG0saC5leHRlbmQoZyxxLmRhdGEoKSksITApO3ZhciBzPWwuc2V0dGluZ3Msaj0wO2ZvcihpPXMubGVuZ3RoO2o8aTtqKyspe3ZhciBvPXNbal07aWYoby5uVGFibGU9PVxyXG50aGlzfHxvLm5USGVhZCYmby5uVEhlYWQucGFyZW50Tm9kZT09dGhpc3x8by5uVEZvb3QmJm8ublRGb290LnBhcmVudE5vZGU9PXRoaXMpe3ZhciByPWcuYlJldHJpZXZlIT09az9nLmJSZXRyaWV2ZTptLmJSZXRyaWV2ZTtpZihjfHxyKXJldHVybiBvLm9JbnN0YW5jZTtpZihnLmJEZXN0cm95IT09az9nLmJEZXN0cm95Om0uYkRlc3Ryb3kpe28ub0luc3RhbmNlLmZuRGVzdHJveSgpO2JyZWFrfWVsc2V7SyhvLDAsXCJDYW5ub3QgcmVpbml0aWFsaXNlIERhdGFUYWJsZVwiLDMpO3JldHVybn19aWYoby5zVGFibGVJZD09dGhpcy5pZCl7cy5zcGxpY2UoaiwxKTticmVha319aWYobnVsbD09PWV8fFwiXCI9PT1lKXRoaXMuaWQ9ZT1cIkRhdGFUYWJsZXNfVGFibGVfXCIrbC5leHQuX3VuaXF1ZSsrO3ZhciBwPWguZXh0ZW5kKCEwLHt9LGwubW9kZWxzLm9TZXR0aW5ncyx7c0Rlc3Ryb3lXaWR0aDpxWzBdLnN0eWxlLndpZHRoLHNJbnN0YW5jZTplLHNUYWJsZUlkOmV9KTtwLm5UYWJsZT10aGlzO3Aub0FwaT1cclxuYi5pbnRlcm5hbDtwLm9Jbml0PWc7cy5wdXNoKHApO3Aub0luc3RhbmNlPTE9PT1iLmxlbmd0aD9iOnEuZGF0YVRhYmxlKCk7Z2IoZyk7RWEoZy5vTGFuZ3VhZ2UpO2cuYUxlbmd0aE1lbnUmJiFnLmlEaXNwbGF5TGVuZ3RoJiYoZy5pRGlzcGxheUxlbmd0aD1BcnJheS5pc0FycmF5KGcuYUxlbmd0aE1lbnVbMF0pP2cuYUxlbmd0aE1lbnVbMF1bMF06Zy5hTGVuZ3RoTWVudVswXSk7Zz1ZYShoLmV4dGVuZCghMCx7fSxtKSxnKTtGKHAub0ZlYXR1cmVzLGcsXCJiUGFnaW5hdGUgYkxlbmd0aENoYW5nZSBiRmlsdGVyIGJTb3J0IGJTb3J0TXVsdGkgYkluZm8gYlByb2Nlc3NpbmcgYkF1dG9XaWR0aCBiU29ydENsYXNzZXMgYlNlcnZlclNpZGUgYkRlZmVyUmVuZGVyXCIuc3BsaXQoXCIgXCIpKTtGKHAsZyxbXCJhc1N0cmlwZUNsYXNzZXNcIixcImFqYXhcIixcImZuU2VydmVyRGF0YVwiLFwiZm5Gb3JtYXROdW1iZXJcIixcInNTZXJ2ZXJNZXRob2RcIixcImFhU29ydGluZ1wiLFwiYWFTb3J0aW5nRml4ZWRcIixcImFMZW5ndGhNZW51XCIsXHJcblwic1BhZ2luYXRpb25UeXBlXCIsXCJzQWpheFNvdXJjZVwiLFwic0FqYXhEYXRhUHJvcFwiLFwiaVN0YXRlRHVyYXRpb25cIixcInNEb21cIixcImJTb3J0Q2VsbHNUb3BcIixcImlUYWJJbmRleFwiLFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiLFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiLFwicmVuZGVyZXJcIixcInNlYXJjaERlbGF5XCIsXCJyb3dJZFwiLFtcImlDb29raWVEdXJhdGlvblwiLFwiaVN0YXRlRHVyYXRpb25cIl0sW1wib1NlYXJjaFwiLFwib1ByZXZpb3VzU2VhcmNoXCJdLFtcImFvU2VhcmNoQ29sc1wiLFwiYW9QcmVTZWFyY2hDb2xzXCJdLFtcImlEaXNwbGF5TGVuZ3RoXCIsXCJfaURpc3BsYXlMZW5ndGhcIl1dKTtGKHAub1Njcm9sbCxnLFtbXCJzU2Nyb2xsWFwiLFwic1hcIl0sW1wic1Njcm9sbFhJbm5lclwiLFwic1hJbm5lclwiXSxbXCJzU2Nyb2xsWVwiLFwic1lcIl0sW1wiYlNjcm9sbENvbGxhcHNlXCIsXCJiQ29sbGFwc2VcIl1dKTtGKHAub0xhbmd1YWdlLGcsXCJmbkluZm9DYWxsYmFja1wiKTt6KHAsXCJhb0RyYXdDYWxsYmFja1wiLGcuZm5EcmF3Q2FsbGJhY2ssXHJcblwidXNlclwiKTt6KHAsXCJhb1NlcnZlclBhcmFtc1wiLGcuZm5TZXJ2ZXJQYXJhbXMsXCJ1c2VyXCIpO3oocCxcImFvU3RhdGVTYXZlUGFyYW1zXCIsZy5mblN0YXRlU2F2ZVBhcmFtcyxcInVzZXJcIik7eihwLFwiYW9TdGF0ZUxvYWRQYXJhbXNcIixnLmZuU3RhdGVMb2FkUGFyYW1zLFwidXNlclwiKTt6KHAsXCJhb1N0YXRlTG9hZGVkXCIsZy5mblN0YXRlTG9hZGVkLFwidXNlclwiKTt6KHAsXCJhb1Jvd0NhbGxiYWNrXCIsZy5mblJvd0NhbGxiYWNrLFwidXNlclwiKTt6KHAsXCJhb1Jvd0NyZWF0ZWRDYWxsYmFja1wiLGcuZm5DcmVhdGVkUm93LFwidXNlclwiKTt6KHAsXCJhb0hlYWRlckNhbGxiYWNrXCIsZy5mbkhlYWRlckNhbGxiYWNrLFwidXNlclwiKTt6KHAsXCJhb0Zvb3RlckNhbGxiYWNrXCIsZy5mbkZvb3RlckNhbGxiYWNrLFwidXNlclwiKTt6KHAsXCJhb0luaXRDb21wbGV0ZVwiLGcuZm5Jbml0Q29tcGxldGUsXCJ1c2VyXCIpO3oocCxcImFvUHJlRHJhd0NhbGxiYWNrXCIsZy5mblByZURyYXdDYWxsYmFjayxcInVzZXJcIik7cC5yb3dJZEZuPVxyXG5TKGcucm93SWQpO2liKHApO3ZhciB1PXAub0NsYXNzZXM7aC5leHRlbmQodSxsLmV4dC5jbGFzc2VzLGcub0NsYXNzZXMpO3EuYWRkQ2xhc3ModS5zVGFibGUpO3AuaUluaXREaXNwbGF5U3RhcnQ9PT1rJiYocC5pSW5pdERpc3BsYXlTdGFydD1nLmlEaXNwbGF5U3RhcnQscC5faURpc3BsYXlTdGFydD1nLmlEaXNwbGF5U3RhcnQpO251bGwhPT1nLmlEZWZlckxvYWRpbmcmJihwLmJEZWZlckxvYWRpbmc9ITAsZT1BcnJheS5pc0FycmF5KGcuaURlZmVyTG9hZGluZykscC5faVJlY29yZHNEaXNwbGF5PWU/Zy5pRGVmZXJMb2FkaW5nWzBdOmcuaURlZmVyTG9hZGluZyxwLl9pUmVjb3Jkc1RvdGFsPWU/Zy5pRGVmZXJMb2FkaW5nWzFdOmcuaURlZmVyTG9hZGluZyk7dmFyIHc9cC5vTGFuZ3VhZ2U7aC5leHRlbmQoITAsdyxnLm9MYW5ndWFnZSk7dy5zVXJsPyhoLmFqYXgoe2RhdGFUeXBlOlwianNvblwiLHVybDp3LnNVcmwsc3VjY2VzczpmdW5jdGlvbihhKXtFYShhKTtKKG0ub0xhbmd1YWdlLFxyXG5hKTtoLmV4dGVuZCh0cnVlLHcsYSk7dChwLG51bGwsXCJpMThuXCIsW3BdKTtpYShwKX0sZXJyb3I6ZnVuY3Rpb24oKXtpYShwKX19KSxuPSEwKTp0KHAsbnVsbCxcImkxOG5cIixbcF0pO251bGw9PT1nLmFzU3RyaXBlQ2xhc3NlcyYmKHAuYXNTdHJpcGVDbGFzc2VzPVt1LnNTdHJpcGVPZGQsdS5zU3RyaXBlRXZlbl0pO3ZhciBlPXAuYXNTdHJpcGVDbGFzc2VzLHY9cS5jaGlsZHJlbihcInRib2R5XCIpLmZpbmQoXCJ0clwiKS5lcSgwKTstMSE9PWguaW5BcnJheSghMCxoLm1hcChlLGZ1bmN0aW9uKGEpe3JldHVybiB2Lmhhc0NsYXNzKGEpfSkpJiYoaChcInRib2R5IHRyXCIsdGhpcykucmVtb3ZlQ2xhc3MoZS5qb2luKFwiIFwiKSkscC5hc0Rlc3Ryb3lTdHJpcGVzPWUuc2xpY2UoKSk7ZT1bXTtzPXRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aGVhZFwiKTswIT09cy5sZW5ndGgmJihmYShwLmFvSGVhZGVyLHNbMF0pLGU9c2EocCkpO2lmKG51bGw9PT1nLmFvQ29sdW1ucyl7cz1bXTtqPTA7Zm9yKGk9XHJcbmUubGVuZ3RoO2o8aTtqKyspcy5wdXNoKG51bGwpfWVsc2Ugcz1nLmFvQ29sdW1ucztqPTA7Zm9yKGk9cy5sZW5ndGg7ajxpO2orKylHYShwLGU/ZVtqXTpudWxsKTtrYihwLGcuYW9Db2x1bW5EZWZzLHMsZnVuY3Rpb24oYSxiKXtsYShwLGEsYil9KTtpZih2Lmxlbmd0aCl7dmFyIFU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiK2IpIT09bnVsbD9iOm51bGx9O2godlswXSkuY2hpbGRyZW4oXCJ0aCwgdGRcIikuZWFjaChmdW5jdGlvbihhLGIpe3ZhciBjPXAuYW9Db2x1bW5zW2FdO2lmKGMubURhdGE9PT1hKXt2YXIgZD1VKGIsXCJzb3J0XCIpfHxVKGIsXCJvcmRlclwiKSxlPVUoYixcImZpbHRlclwiKXx8VShiLFwic2VhcmNoXCIpO2lmKGQhPT1udWxsfHxlIT09bnVsbCl7Yy5tRGF0YT17XzphK1wiLmRpc3BsYXlcIixzb3J0OmQhPT1udWxsP2ErXCIuQGRhdGEtXCIrZDprLHR5cGU6ZCE9PW51bGw/YStcIi5AZGF0YS1cIitkOmssZmlsdGVyOmUhPT1udWxsP2ErXCIuQGRhdGEtXCIrXHJcbmU6a307bGEocCxhKX19fSl9dmFyIFY9cC5vRmVhdHVyZXMsZT1mdW5jdGlvbigpe2lmKGcuYWFTb3J0aW5nPT09ayl7dmFyIGE9cC5hYVNvcnRpbmc7aj0wO2ZvcihpPWEubGVuZ3RoO2o8aTtqKyspYVtqXVsxXT1wLmFvQ29sdW1uc1tqXS5hc1NvcnRpbmdbMF19eWEocCk7Vi5iU29ydCYmeihwLFwiYW9EcmF3Q2FsbGJhY2tcIixmdW5jdGlvbigpe2lmKHAuYlNvcnRlZCl7dmFyIGE9WShwKSxiPXt9O2guZWFjaChhLGZ1bmN0aW9uKGEsYyl7YltjLnNyY109Yy5kaXJ9KTt0KHAsbnVsbCxcIm9yZGVyXCIsW3AsYSxiXSk7S2IocCl9fSk7eihwLFwiYW9EcmF3Q2FsbGJhY2tcIixmdW5jdGlvbigpeyhwLmJTb3J0ZWR8fHkocCk9PT1cInNzcFwifHxWLmJEZWZlclJlbmRlcikmJnlhKHApfSxcInNjXCIpO3ZhciBhPXEuY2hpbGRyZW4oXCJjYXB0aW9uXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLl9jYXB0aW9uU2lkZT1oKHRoaXMpLmNzcyhcImNhcHRpb24tc2lkZVwiKX0pLGI9cS5jaGlsZHJlbihcInRoZWFkXCIpO1xyXG5iLmxlbmd0aD09PTAmJihiPWgoXCI8dGhlYWQvPlwiKS5hcHBlbmRUbyhxKSk7cC5uVEhlYWQ9YlswXTtiPXEuY2hpbGRyZW4oXCJ0Ym9keVwiKTtiLmxlbmd0aD09PTAmJihiPWgoXCI8dGJvZHkvPlwiKS5hcHBlbmRUbyhxKSk7cC5uVEJvZHk9YlswXTtiPXEuY2hpbGRyZW4oXCJ0Zm9vdFwiKTtpZihiLmxlbmd0aD09PTAmJmEubGVuZ3RoPjAmJihwLm9TY3JvbGwuc1ghPT1cIlwifHxwLm9TY3JvbGwuc1khPT1cIlwiKSliPWgoXCI8dGZvb3QvPlwiKS5hcHBlbmRUbyhxKTtpZihiLmxlbmd0aD09PTB8fGIuY2hpbGRyZW4oKS5sZW5ndGg9PT0wKXEuYWRkQ2xhc3ModS5zTm9Gb290ZXIpO2Vsc2UgaWYoYi5sZW5ndGg+MCl7cC5uVEZvb3Q9YlswXTtmYShwLmFvRm9vdGVyLHAublRGb290KX1pZihnLmFhRGF0YSlmb3Ioaj0wO2o8Zy5hYURhdGEubGVuZ3RoO2orKylPKHAsZy5hYURhdGFbal0pO2Vsc2UocC5iRGVmZXJMb2FkaW5nfHx5KHApPT1cImRvbVwiKSYmb2EocCxoKHAublRCb2R5KS5jaGlsZHJlbihcInRyXCIpKTtcclxucC5haURpc3BsYXk9cC5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtwLmJJbml0aWFsaXNlZD10cnVlO249PT1mYWxzZSYmaWEocCl9O2cuYlN0YXRlU2F2ZT8oVi5iU3RhdGVTYXZlPSEwLHoocCxcImFvRHJhd0NhbGxiYWNrXCIsemEsXCJzdGF0ZV9zYXZlXCIpLExiKHAsZyxlKSk6ZSgpfX0pO2I9bnVsbDtyZXR1cm4gdGhpc30sdixyLG8sdSwkYT17fSxPYj0vW1xcclxcblxcdTIwMjhdL2csQ2E9LzwuKj8+L2csYmM9L15cXGR7Miw0fVtcXC5cXC9cXC1dXFxkezEsMn1bXFwuXFwvXFwtXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6XFwuXVxcZHsyfShbXFwuOl1cXGR7Mn0pPyk/JC8sY2M9UmVnRXhwKFwiKFxcXFwvfFxcXFwufFxcXFwqfFxcXFwrfFxcXFw/fFxcXFx8fFxcXFwofFxcXFwpfFxcXFxbfFxcXFxdfFxcXFx7fFxcXFx9fFxcXFxcXFxcfFxcXFwkfFxcXFxefFxcXFwtKVwiLFwiZ1wiKSxaYT0vWydcXHUwMEEwLCTCo+KCrMKlJVxcdTIwMDlcXHUyMDJGXFx1MjBCRFxcdTIwYTlcXHUyMEJBcmZryYPOnl0vZ2ksTT1mdW5jdGlvbihhKXtyZXR1cm4hYXx8ITA9PT1hfHxcIi1cIj09PWE/ITA6ITF9LFxyXG5QYj1mdW5jdGlvbihhKXt2YXIgYj1wYXJzZUludChhLDEwKTtyZXR1cm4haXNOYU4oYikmJmlzRmluaXRlKGEpP2I6bnVsbH0sUWI9ZnVuY3Rpb24oYSxiKXskYVtiXXx8KCRhW2JdPVJlZ0V4cChTYShiKSxcImdcIikpO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYSYmXCIuXCIhPT1iP2EucmVwbGFjZSgvXFwuL2csXCJcIikucmVwbGFjZSgkYVtiXSxcIi5cIik6YX0sYWI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVwic3RyaW5nXCI9PT10eXBlb2YgYTtpZihNKGEpKXJldHVybiEwO2ImJmQmJihhPVFiKGEsYikpO2MmJmQmJihhPWEucmVwbGFjZShaYSxcIlwiKSk7cmV0dXJuIWlzTmFOKHBhcnNlRmxvYXQoYSkpJiZpc0Zpbml0ZShhKX0sUmI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBNKGEpPyEwOiEoTShhKXx8XCJzdHJpbmdcIj09PXR5cGVvZiBhKT9udWxsOmFiKGEucmVwbGFjZShDYSxcIlwiKSxiLGMpPyEwOm51bGx9LEM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdLGU9MCxmPWEubGVuZ3RoO2lmKGMhPT1rKWZvcig7ZTxcclxuZjtlKyspYVtlXSYmYVtlXVtiXSYmZC5wdXNoKGFbZV1bYl1bY10pO2Vsc2UgZm9yKDtlPGY7ZSsrKWFbZV0mJmQucHVzaChhW2VdW2JdKTtyZXR1cm4gZH0sa2E9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9W10sZj0wLGc9Yi5sZW5ndGg7aWYoZCE9PWspZm9yKDtmPGc7ZisrKWFbYltmXV1bY10mJmUucHVzaChhW2JbZl1dW2NdW2RdKTtlbHNlIGZvcig7ZjxnO2YrKyllLnB1c2goYVtiW2ZdXVtjXSk7cmV0dXJuIGV9LFo9ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXSxkO2I9PT1rPyhiPTAsZD1hKTooZD1iLGI9YSk7Zm9yKHZhciBlPWI7ZTxkO2UrKyljLnB1c2goZSk7cmV0dXJuIGN9LFNiPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD1hLmxlbmd0aDtjPGQ7YysrKWFbY10mJmIucHVzaChhW2NdKTtyZXR1cm4gYn0scmE9ZnVuY3Rpb24oYSl7dmFyIGI7YTp7aWYoISgyPmEubGVuZ3RoKSl7Yj1hLnNsaWNlKCkuc29ydCgpO2Zvcih2YXIgYz1iWzBdLGQ9MSxlPWIubGVuZ3RoO2Q8XHJcbmU7ZCsrKXtpZihiW2RdPT09Yyl7Yj0hMTticmVhayBhfWM9YltkXX19Yj0hMH1pZihiKXJldHVybiBhLnNsaWNlKCk7Yj1bXTt2YXIgZT1hLmxlbmd0aCxmLGc9MCxkPTA7YTpmb3IoO2Q8ZTtkKyspe2M9YVtkXTtmb3IoZj0wO2Y8ZztmKyspaWYoYltmXT09PWMpY29udGludWUgYTtiLnB1c2goYyk7ZysrfXJldHVybiBifSxUYj1mdW5jdGlvbihhLGIpe2lmKEFycmF5LmlzQXJyYXkoYikpZm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspVGIoYSxiW2NdKTtlbHNlIGEucHVzaChiKTtyZXR1cm4gYX07QXJyYXkuaXNBcnJheXx8KEFycmF5LmlzQXJyYXk9ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfSk7U3RyaW5nLnByb3RvdHlwZS50cmltfHwoU3RyaW5nLnByb3RvdHlwZS50cmltPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXHJcblwiXCIpfSk7bC51dGlsPXt0aHJvdHRsZTpmdW5jdGlvbihhLGIpe3ZhciBjPWIhPT1rP2I6MjAwLGQsZTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYj10aGlzLGc9K25ldyBEYXRlLGo9YXJndW1lbnRzO2lmKGQmJmc8ZCtjKXtjbGVhclRpbWVvdXQoZSk7ZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZD1rO2EuYXBwbHkoYixqKX0sYyl9ZWxzZXtkPWc7YS5hcHBseShiLGopfX19LGVzY2FwZVJlZ2V4OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoY2MsXCJcXFxcJDFcIil9fTt2YXIgQT1mdW5jdGlvbihhLGIsYyl7YVtiXSE9PWsmJihhW2NdPWFbYl0pfSxkYT0vXFxbLio/XFxdJC8sWD0vXFwoXFwpJC8sU2E9bC51dGlsLmVzY2FwZVJlZ2V4LHdhPWgoXCI8ZGl2PlwiKVswXSxaYj13YS50ZXh0Q29udGVudCE9PWssYWM9LzwuKj8+L2csUWE9bC51dGlsLnRocm90dGxlLFViPVtdLHg9QXJyYXkucHJvdG90eXBlLGRjPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZD1sLnNldHRpbmdzLGU9aC5tYXAoZCxmdW5jdGlvbihhKXtyZXR1cm4gYS5uVGFibGV9KTtcclxuaWYoYSl7aWYoYS5uVGFibGUmJmEub0FwaSlyZXR1cm5bYV07aWYoYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09XCJ0YWJsZVwiKXtiPWguaW5BcnJheShhLGUpO3JldHVybiBiIT09LTE/W2RbYl1dOm51bGx9aWYoYSYmdHlwZW9mIGEuc2V0dGluZ3M9PT1cImZ1bmN0aW9uXCIpcmV0dXJuIGEuc2V0dGluZ3MoKS50b0FycmF5KCk7dHlwZW9mIGE9PT1cInN0cmluZ1wiP2M9aChhKTphIGluc3RhbmNlb2YgaCYmKGM9YSl9ZWxzZSByZXR1cm5bXTtpZihjKXJldHVybiBjLm1hcChmdW5jdGlvbigpe2I9aC5pbkFycmF5KHRoaXMsZSk7cmV0dXJuIGIhPT0tMT9kW2JdOm51bGx9KS50b0FycmF5KCl9O3I9ZnVuY3Rpb24oYSxiKXtpZighKHRoaXMgaW5zdGFuY2VvZiByKSlyZXR1cm4gbmV3IHIoYSxiKTt2YXIgYz1bXSxkPWZ1bmN0aW9uKGEpeyhhPWRjKGEpKSYmYy5wdXNoLmFwcGx5KGMsYSl9O2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKHZhciBlPTAsZj1hLmxlbmd0aDtlPFxyXG5mO2UrKylkKGFbZV0pO2Vsc2UgZChhKTt0aGlzLmNvbnRleHQ9cmEoYyk7YiYmaC5tZXJnZSh0aGlzLGIpO3RoaXMuc2VsZWN0b3I9e3Jvd3M6bnVsbCxjb2xzOm51bGwsb3B0czpudWxsfTtyLmV4dGVuZCh0aGlzLHRoaXMsVWIpfTtsLkFwaT1yO2guZXh0ZW5kKHIucHJvdG90eXBlLHthbnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3VudCgpIT09MH0sY29uY2F0OnguY29uY2F0LGNvbnRleHQ6W10sY291bnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGF0dGVuKCkubGVuZ3RofSxlYWNoOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9dGhpcy5sZW5ndGg7YjxjO2IrKylhLmNhbGwodGhpcyx0aGlzW2JdLGIsdGhpcyk7cmV0dXJuIHRoaXN9LGVxOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY29udGV4dDtyZXR1cm4gYi5sZW5ndGg+YT9uZXcgcihiW2FdLHRoaXNbYV0pOm51bGx9LGZpbHRlcjpmdW5jdGlvbihhKXt2YXIgYj1bXTtpZih4LmZpbHRlciliPXguZmlsdGVyLmNhbGwodGhpcyxcclxuYSx0aGlzKTtlbHNlIGZvcih2YXIgYz0wLGQ9dGhpcy5sZW5ndGg7YzxkO2MrKylhLmNhbGwodGhpcyx0aGlzW2NdLGMsdGhpcykmJmIucHVzaCh0aGlzW2NdKTtyZXR1cm4gbmV3IHIodGhpcy5jb250ZXh0LGIpfSxmbGF0dGVuOmZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIG5ldyByKHRoaXMuY29udGV4dCxhLmNvbmNhdC5hcHBseShhLHRoaXMudG9BcnJheSgpKSl9LGpvaW46eC5qb2luLGluZGV4T2Y6eC5pbmRleE9mfHxmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1ifHwwLGQ9dGhpcy5sZW5ndGg7YzxkO2MrKylpZih0aGlzW2NdPT09YSlyZXR1cm4gYztyZXR1cm4tMX0saXRlcmF0b3I6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9W10sZixnLGosaSxoLG09dGhpcy5jb250ZXh0LGwsbyx1PXRoaXMuc2VsZWN0b3I7aWYodHlwZW9mIGE9PT1cInN0cmluZ1wiKXtkPWM7Yz1iO2I9YTthPWZhbHNlfWc9MDtmb3Ioaj1tLmxlbmd0aDtnPGo7ZysrKXt2YXIgdD1uZXcgcihtW2ddKTtpZihiPT09XHJcblwidGFibGVcIil7Zj1jLmNhbGwodCxtW2ddLGcpO2YhPT1rJiZlLnB1c2goZil9ZWxzZSBpZihiPT09XCJjb2x1bW5zXCJ8fGI9PT1cInJvd3NcIil7Zj1jLmNhbGwodCxtW2ddLHRoaXNbZ10sZyk7ZiE9PWsmJmUucHVzaChmKX1lbHNlIGlmKGI9PT1cImNvbHVtblwifHxiPT09XCJjb2x1bW4tcm93c1wifHxiPT09XCJyb3dcInx8Yj09PVwiY2VsbFwiKXtvPXRoaXNbZ107Yj09PVwiY29sdW1uLXJvd3NcIiYmKGw9RGEobVtnXSx1Lm9wdHMpKTtpPTA7Zm9yKGg9by5sZW5ndGg7aTxoO2krKyl7Zj1vW2ldO2Y9Yj09PVwiY2VsbFwiP2MuY2FsbCh0LG1bZ10sZi5yb3csZi5jb2x1bW4sZyxpKTpjLmNhbGwodCxtW2ddLGYsZyxpLGwpO2YhPT1rJiZlLnB1c2goZil9fX1pZihlLmxlbmd0aHx8ZCl7YT1uZXcgcihtLGE/ZS5jb25jYXQuYXBwbHkoW10sZSk6ZSk7Yj1hLnNlbGVjdG9yO2Iucm93cz11LnJvd3M7Yi5jb2xzPXUuY29scztiLm9wdHM9dS5vcHRzO3JldHVybiBhfXJldHVybiB0aGlzfSxsYXN0SW5kZXhPZjp4Lmxhc3RJbmRleE9mfHxcclxuZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KHRoaXMudG9BcnJheS5yZXZlcnNlKCksYXJndW1lbnRzKX0sbGVuZ3RoOjAsbWFwOmZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKHgubWFwKWI9eC5tYXAuY2FsbCh0aGlzLGEsdGhpcyk7ZWxzZSBmb3IodmFyIGM9MCxkPXRoaXMubGVuZ3RoO2M8ZDtjKyspYi5wdXNoKGEuY2FsbCh0aGlzLHRoaXNbY10sYykpO3JldHVybiBuZXcgcih0aGlzLmNvbnRleHQsYil9LHBsdWNrOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gYlthXX0pfSxwb3A6eC5wb3AscHVzaDp4LnB1c2gscmVkdWNlOngucmVkdWNlfHxmdW5jdGlvbihhLGIpe3JldHVybiBqYih0aGlzLGEsYiwwLHRoaXMubGVuZ3RoLDEpfSxyZWR1Y2VSaWdodDp4LnJlZHVjZVJpZ2h0fHxmdW5jdGlvbihhLGIpe3JldHVybiBqYih0aGlzLGEsYix0aGlzLmxlbmd0aC0xLC0xLC0xKX0scmV2ZXJzZTp4LnJldmVyc2Usc2VsZWN0b3I6bnVsbCxcclxuc2hpZnQ6eC5zaGlmdCxzbGljZTpmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLmNvbnRleHQsdGhpcyl9LHNvcnQ6eC5zb3J0LHNwbGljZTp4LnNwbGljZSx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHguc2xpY2UuY2FsbCh0aGlzKX0sdG8kOmZ1bmN0aW9uKCl7cmV0dXJuIGgodGhpcyl9LHRvSlF1ZXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIGgodGhpcyl9LHVuaXF1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLmNvbnRleHQscmEodGhpcykpfSx1bnNoaWZ0OngudW5zaGlmdH0pO3IuZXh0ZW5kPWZ1bmN0aW9uKGEsYixjKXtpZihjLmxlbmd0aCYmYiYmKGIgaW5zdGFuY2VvZiByfHxiLl9fZHRfd3JhcHBlcikpe3ZhciBkLGUsZixnPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZD1iLmFwcGx5KGEsYXJndW1lbnRzKTtyLmV4dGVuZChkLGQsYy5tZXRob2RFeHQpO3JldHVybiBkfX07ZD0wO2ZvcihlPWMubGVuZ3RoO2Q8ZTtkKyspe2Y9Y1tkXTtiW2YubmFtZV09XHJcbmYudHlwZT09PVwiZnVuY3Rpb25cIj9nKGEsZi52YWwsZik6Zi50eXBlPT09XCJvYmplY3RcIj97fTpmLnZhbDtiW2YubmFtZV0uX19kdF93cmFwcGVyPXRydWU7ci5leHRlbmQoYSxiW2YubmFtZV0sZi5wcm9wRXh0KX19fTtyLnJlZ2lzdGVyPW89ZnVuY3Rpb24oYSxiKXtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKylyLnJlZ2lzdGVyKGFbY10sYik7ZWxzZSBmb3IodmFyIGU9YS5zcGxpdChcIi5cIiksZj1VYixnLGosYz0wLGQ9ZS5sZW5ndGg7YzxkO2MrKyl7Zz0oaj1lW2NdLmluZGV4T2YoXCIoKVwiKSE9PS0xKT9lW2NdLnJlcGxhY2UoXCIoKVwiLFwiXCIpOmVbY107dmFyIGk7YTp7aT0wO2Zvcih2YXIgaz1mLmxlbmd0aDtpPGs7aSsrKWlmKGZbaV0ubmFtZT09PWcpe2k9ZltpXTticmVhayBhfWk9bnVsbH1pZighaSl7aT17bmFtZTpnLHZhbDp7fSxtZXRob2RFeHQ6W10scHJvcEV4dDpbXSx0eXBlOlwib2JqZWN0XCJ9O2YucHVzaChpKX1pZihjPT09ZC0xKXtpLnZhbD1cclxuYjtpLnR5cGU9dHlwZW9mIGI9PT1cImZ1bmN0aW9uXCI/XCJmdW5jdGlvblwiOmguaXNQbGFpbk9iamVjdChiKT9cIm9iamVjdFwiOlwib3RoZXJcIn1lbHNlIGY9aj9pLm1ldGhvZEV4dDppLnByb3BFeHR9fTtyLnJlZ2lzdGVyUGx1cmFsPXU9ZnVuY3Rpb24oYSxiLGMpe3IucmVnaXN0ZXIoYSxjKTtyLnJlZ2lzdGVyKGIsZnVuY3Rpb24oKXt2YXIgYT1jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gYT09PXRoaXM/dGhpczphIGluc3RhbmNlb2Ygcj9hLmxlbmd0aD9BcnJheS5pc0FycmF5KGFbMF0pP25ldyByKGEuY29udGV4dCxhWzBdKTphWzBdOms6YX0pfTt2YXIgVmI9ZnVuY3Rpb24oYSxiKXtpZihBcnJheS5pc0FycmF5KGEpKXJldHVybiBoLm1hcChhLGZ1bmN0aW9uKGEpe3JldHVybiBWYihhLGIpfSk7aWYodHlwZW9mIGE9PT1cIm51bWJlclwiKXJldHVybltiW2FdXTt2YXIgYz1oLm1hcChiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5UYWJsZX0pO3JldHVybiBoKGMpLmZpbHRlcihhKS5tYXAoZnVuY3Rpb24oKXt2YXIgYT1cclxuaC5pbkFycmF5KHRoaXMsYyk7cmV0dXJuIGJbYV19KS50b0FycmF5KCl9O28oXCJ0YWJsZXMoKVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhIT09ayYmYSE9PW51bGw/bmV3IHIoVmIoYSx0aGlzLmNvbnRleHQpKTp0aGlzfSk7byhcInRhYmxlKClcIixmdW5jdGlvbihhKXt2YXIgYT10aGlzLnRhYmxlcyhhKSxiPWEuY29udGV4dDtyZXR1cm4gYi5sZW5ndGg/bmV3IHIoYlswXSk6YX0pO3UoXCJ0YWJsZXMoKS5ub2RlcygpXCIsXCJ0YWJsZSgpLm5vZGUoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5UYWJsZX0sMSl9KTt1KFwidGFibGVzKCkuYm9keSgpXCIsXCJ0YWJsZSgpLmJvZHkoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5UQm9keX0sMSl9KTt1KFwidGFibGVzKCkuaGVhZGVyKClcIixcInRhYmxlKCkuaGVhZGVyKClcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwidGFibGVcIixcclxuZnVuY3Rpb24oYSl7cmV0dXJuIGEublRIZWFkfSwxKX0pO3UoXCJ0YWJsZXMoKS5mb290ZXIoKVwiLFwidGFibGUoKS5mb290ZXIoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5URm9vdH0sMSl9KTt1KFwidGFibGVzKCkuY29udGFpbmVycygpXCIsXCJ0YWJsZSgpLmNvbnRhaW5lcigpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcInRhYmxlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEublRhYmxlV3JhcHBlcn0sMSl9KTtvKFwiZHJhdygpXCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGIpe2lmKGE9PT1cInBhZ2VcIilQKGIpO2Vsc2V7dHlwZW9mIGE9PT1cInN0cmluZ1wiJiYoYT1hPT09XCJmdWxsLWhvbGRcIj9mYWxzZTp0cnVlKTtUKGIsYT09PWZhbHNlKX19KX0pO28oXCJwYWdlKClcIixmdW5jdGlvbihhKXtyZXR1cm4gYT09PWs/dGhpcy5wYWdlLmluZm8oKS5wYWdlOnRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLFxyXG5mdW5jdGlvbihiKXtWYShiLGEpfSl9KTtvKFwicGFnZS5pbmZvKClcIixmdW5jdGlvbigpe2lmKHRoaXMuY29udGV4dC5sZW5ndGg9PT0wKXJldHVybiBrO3ZhciBhPXRoaXMuY29udGV4dFswXSxiPWEuX2lEaXNwbGF5U3RhcnQsYz1hLm9GZWF0dXJlcy5iUGFnaW5hdGU/YS5faURpc3BsYXlMZW5ndGg6LTEsZD1hLmZuUmVjb3Jkc0Rpc3BsYXkoKSxlPWM9PT0tMTtyZXR1cm57cGFnZTplPzA6TWF0aC5mbG9vcihiL2MpLHBhZ2VzOmU/MTpNYXRoLmNlaWwoZC9jKSxzdGFydDpiLGVuZDphLmZuRGlzcGxheUVuZCgpLGxlbmd0aDpjLHJlY29yZHNUb3RhbDphLmZuUmVjb3Jkc1RvdGFsKCkscmVjb3Jkc0Rpc3BsYXk6ZCxzZXJ2ZXJTaWRlOnkoYSk9PT1cInNzcFwifX0pO28oXCJwYWdlLmxlbigpXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1rP3RoaXMuY29udGV4dC5sZW5ndGghPT0wP3RoaXMuY29udGV4dFswXS5faURpc3BsYXlMZW5ndGg6azp0aGlzLml0ZXJhdG9yKFwidGFibGVcIixmdW5jdGlvbihiKXtUYShiLFxyXG5hKX0pfSk7dmFyIFdiPWZ1bmN0aW9uKGEsYixjKXtpZihjKXt2YXIgZD1uZXcgcihhKTtkLm9uZShcImRyYXdcIixmdW5jdGlvbigpe2MoZC5hamF4Lmpzb24oKSl9KX1pZih5KGEpPT1cInNzcFwiKVQoYSxiKTtlbHNle0QoYSx0cnVlKTt2YXIgZT1hLmpxWEhSO2UmJmUucmVhZHlTdGF0ZSE9PTQmJmUuYWJvcnQoKTt0YShhLFtdLGZ1bmN0aW9uKGMpe3BhKGEpO2Zvcih2YXIgYz11YShhLGMpLGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspTyhhLGNbZF0pO1QoYSxiKTtEKGEsZmFsc2UpfSl9fTtvKFwiYWpheC5qc29uKClcIixmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29udGV4dDtpZihhLmxlbmd0aD4wKXJldHVybiBhWzBdLmpzb259KTtvKFwiYWpheC5wYXJhbXMoKVwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jb250ZXh0O2lmKGEubGVuZ3RoPjApcmV0dXJuIGFbMF0ub0FqYXhEYXRhfSk7byhcImFqYXgucmVsb2FkKClcIixmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwidGFibGVcIixcclxuZnVuY3Rpb24oYyl7V2IoYyxiPT09ZmFsc2UsYSl9KX0pO28oXCJhamF4LnVybCgpXCIsZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jb250ZXh0O2lmKGE9PT1rKXtpZihiLmxlbmd0aD09PTApcmV0dXJuIGs7Yj1iWzBdO3JldHVybiBiLmFqYXg/aC5pc1BsYWluT2JqZWN0KGIuYWpheCk/Yi5hamF4LnVybDpiLmFqYXg6Yi5zQWpheFNvdXJjZX1yZXR1cm4gdGhpcy5pdGVyYXRvcihcInRhYmxlXCIsZnVuY3Rpb24oYil7aC5pc1BsYWluT2JqZWN0KGIuYWpheCk/Yi5hamF4LnVybD1hOmIuYWpheD1hfSl9KTtvKFwiYWpheC51cmwoKS5sb2FkKClcIixmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwidGFibGVcIixmdW5jdGlvbihjKXtXYihjLGI9PT1mYWxzZSxhKX0pfSk7dmFyIGJiPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9W10sZyxqLGksaCxtLGw7aT10eXBlb2YgYjtpZighYnx8aT09PVwic3RyaW5nXCJ8fGk9PT1cImZ1bmN0aW9uXCJ8fGIubGVuZ3RoPT09ayliPVtiXTtpPTA7XHJcbmZvcihoPWIubGVuZ3RoO2k8aDtpKyspe2o9YltpXSYmYltpXS5zcGxpdCYmIWJbaV0ubWF0Y2goL1tcXFtcXCg6XS8pP2JbaV0uc3BsaXQoXCIsXCIpOltiW2ldXTttPTA7Zm9yKGw9ai5sZW5ndGg7bTxsO20rKykoZz1jKHR5cGVvZiBqW21dPT09XCJzdHJpbmdcIj9qW21dLnRyaW0oKTpqW21dKSkmJmcubGVuZ3RoJiYoZj1mLmNvbmNhdChnKSl9YT12LnNlbGVjdG9yW2FdO2lmKGEubGVuZ3RoKXtpPTA7Zm9yKGg9YS5sZW5ndGg7aTxoO2krKylmPWFbaV0oZCxlLGYpfXJldHVybiByYShmKX0sY2I9ZnVuY3Rpb24oYSl7YXx8KGE9e30pO2lmKGEuZmlsdGVyJiZhLnNlYXJjaD09PWspYS5zZWFyY2g9YS5maWx0ZXI7cmV0dXJuIGguZXh0ZW5kKHtzZWFyY2g6XCJub25lXCIsb3JkZXI6XCJjdXJyZW50XCIscGFnZTpcImFsbFwifSxhKX0sZGI9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aDtiPGM7YisrKWlmKGFbYl0ubGVuZ3RoPjApe2FbMF09YVtiXTthWzBdLmxlbmd0aD0xO2EubGVuZ3RoPVxyXG4xO2EuY29udGV4dD1bYS5jb250ZXh0W2JdXTtyZXR1cm4gYX1hLmxlbmd0aD0wO3JldHVybiBhfSxEYT1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPVtdLGc9YS5haURpc3BsYXk7ZT1hLmFpRGlzcGxheU1hc3Rlcjt2YXIgaj1iLnNlYXJjaDtjPWIub3JkZXI7ZD1iLnBhZ2U7aWYoeShhKT09XCJzc3BcIilyZXR1cm4gaj09PVwicmVtb3ZlZFwiP1tdOlooMCxlLmxlbmd0aCk7aWYoZD09XCJjdXJyZW50XCIpe2M9YS5faURpc3BsYXlTdGFydDtmb3IoZD1hLmZuRGlzcGxheUVuZCgpO2M8ZDtjKyspZi5wdXNoKGdbY10pfWVsc2UgaWYoYz09XCJjdXJyZW50XCJ8fGM9PVwiYXBwbGllZFwiKWlmKGo9PVwibm9uZVwiKWY9ZS5zbGljZSgpO2Vsc2UgaWYoaj09XCJhcHBsaWVkXCIpZj1nLnNsaWNlKCk7ZWxzZXtpZihqPT1cInJlbW92ZWRcIil7dmFyIGk9e307Yz0wO2ZvcihkPWcubGVuZ3RoO2M8ZDtjKyspaVtnW2NdXT1udWxsO2Y9aC5tYXAoZSxmdW5jdGlvbihhKXtyZXR1cm4haS5oYXNPd25Qcm9wZXJ0eShhKT9cclxuYTpudWxsfSl9fWVsc2UgaWYoYz09XCJpbmRleFwifHxjPT1cIm9yaWdpbmFsXCIpe2M9MDtmb3IoZD1hLmFvRGF0YS5sZW5ndGg7YzxkO2MrKylpZihqPT1cIm5vbmVcIilmLnB1c2goYyk7ZWxzZXtlPWguaW5BcnJheShjLGcpOyhlPT09LTEmJmo9PVwicmVtb3ZlZFwifHxlPj0wJiZqPT1cImFwcGxpZWRcIikmJmYucHVzaChjKX19cmV0dXJuIGZ9O28oXCJyb3dzKClcIixmdW5jdGlvbihhLGIpe2lmKGE9PT1rKWE9XCJcIjtlbHNlIGlmKGguaXNQbGFpbk9iamVjdChhKSl7Yj1hO2E9XCJcIn12YXIgYj1jYihiKSxjPXRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGMpe3ZhciBlPWIsZjtyZXR1cm4gYmIoXCJyb3dcIixhLGZ1bmN0aW9uKGEpe3ZhciBiPVBiKGEpLGk9Yy5hb0RhdGE7aWYoYiE9PW51bGwmJiFlKXJldHVybltiXTtmfHwoZj1EYShjLGUpKTtpZihiIT09bnVsbCYmaC5pbkFycmF5KGIsZikhPT0tMSlyZXR1cm5bYl07aWYoYT09PW51bGx8fGE9PT1rfHxhPT09XCJcIilyZXR1cm4gZjtpZih0eXBlb2YgYT09PVxyXG5cImZ1bmN0aW9uXCIpcmV0dXJuIGgubWFwKGYsZnVuY3Rpb24oYil7dmFyIGM9aVtiXTtyZXR1cm4gYShiLGMuX2FEYXRhLGMublRyKT9iOm51bGx9KTtpZihhLm5vZGVOYW1lKXt2YXIgYj1hLl9EVF9Sb3dJbmRleCxuPWEuX0RUX0NlbGxJbmRleDtpZihiIT09aylyZXR1cm4gaVtiXSYmaVtiXS5uVHI9PT1hP1tiXTpbXTtpZihuKXJldHVybiBpW24ucm93XSYmaVtuLnJvd10ublRyPT09YS5wYXJlbnROb2RlP1tuLnJvd106W107Yj1oKGEpLmNsb3Nlc3QoXCIqW2RhdGEtZHQtcm93XVwiKTtyZXR1cm4gYi5sZW5ndGg/W2IuZGF0YShcImR0LXJvd1wiKV06W119aWYodHlwZW9mIGE9PT1cInN0cmluZ1wiJiZhLmNoYXJBdCgwKT09PVwiI1wiKXtiPWMuYUlkc1thLnJlcGxhY2UoL14jLyxcIlwiKV07aWYoYiE9PWspcmV0dXJuW2IuaWR4XX1iPVNiKGthKGMuYW9EYXRhLGYsXCJuVHJcIikpO3JldHVybiBoKGIpLmZpbHRlcihhKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fRFRfUm93SW5kZXh9KS50b0FycmF5KCl9LFxyXG5jLGUpfSwxKTtjLnNlbGVjdG9yLnJvd3M9YTtjLnNlbGVjdG9yLm9wdHM9YjtyZXR1cm4gY30pO28oXCJyb3dzKCkubm9kZXMoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJyb3dcIixmdW5jdGlvbihhLGIpe3JldHVybiBhLmFvRGF0YVtiXS5uVHJ8fGt9LDEpfSk7byhcInJvd3MoKS5kYXRhKClcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdG9yKHRydWUsXCJyb3dzXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4ga2EoYS5hb0RhdGEsYixcIl9hRGF0YVwiKX0sMSl9KTt1KFwicm93cygpLmNhY2hlKClcIixcInJvdygpLmNhY2hlKClcIixmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcInJvd1wiLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yi5hb0RhdGFbY107cmV0dXJuIGE9PT1cInNlYXJjaFwiP2QuX2FGaWx0ZXJEYXRhOmQuX2FTb3J0RGF0YX0sMSl9KTt1KFwicm93cygpLmludmFsaWRhdGUoKVwiLFwicm93KCkuaW52YWxpZGF0ZSgpXCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJyb3dcIixcclxuZnVuY3Rpb24oYixjKXtlYShiLGMsYSl9KX0pO3UoXCJyb3dzKCkuaW5kZXhlcygpXCIsXCJyb3coKS5pbmRleCgpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcInJvd1wiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGJ9LDEpfSk7dShcInJvd3MoKS5pZHMoKVwiLFwicm93KCkuaWQoKVwiLGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPXRoaXMuY29udGV4dCxkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKWZvcih2YXIgZj0wLGc9dGhpc1tkXS5sZW5ndGg7ZjxnO2YrKyl7dmFyIGg9Y1tkXS5yb3dJZEZuKGNbZF0uYW9EYXRhW3RoaXNbZF1bZl1dLl9hRGF0YSk7Yi5wdXNoKChhPT09dHJ1ZT9cIiNcIjpcIlwiKStoKX1yZXR1cm4gbmV3IHIoYyxiKX0pO3UoXCJyb3dzKCkucmVtb3ZlKClcIixcInJvdygpLnJlbW92ZSgpXCIsZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuaXRlcmF0b3IoXCJyb3dcIixmdW5jdGlvbihiLGMsZCl7dmFyIGU9Yi5hb0RhdGEsZj1lW2NdLGcsaCxpLG4sbTtlLnNwbGljZShjLDEpO1xyXG5nPTA7Zm9yKGg9ZS5sZW5ndGg7ZzxoO2crKyl7aT1lW2ddO209aS5hbkNlbGxzO2lmKGkublRyIT09bnVsbClpLm5Uci5fRFRfUm93SW5kZXg9ZztpZihtIT09bnVsbCl7aT0wO2ZvcihuPW0ubGVuZ3RoO2k8bjtpKyspbVtpXS5fRFRfQ2VsbEluZGV4LnJvdz1nfX1xYShiLmFpRGlzcGxheU1hc3RlcixjKTtxYShiLmFpRGlzcGxheSxjKTtxYShhW2RdLGMsZmFsc2UpO2IuX2lSZWNvcmRzRGlzcGxheT4wJiZiLl9pUmVjb3Jkc0Rpc3BsYXktLTtVYShiKTtjPWIucm93SWRGbihmLl9hRGF0YSk7YyE9PWsmJmRlbGV0ZSBiLmFJZHNbY119KTt0aGlzLml0ZXJhdG9yKFwidGFibGVcIixmdW5jdGlvbihhKXtmb3IodmFyIGM9MCxkPWEuYW9EYXRhLmxlbmd0aDtjPGQ7YysrKWEuYW9EYXRhW2NdLmlkeD1jfSk7cmV0dXJuIHRoaXN9KTtvKFwicm93cy5hZGQoKVwiLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGIpe3ZhciBjLGYsZyxoPVtdO2Y9MDtmb3IoZz1cclxuYS5sZW5ndGg7ZjxnO2YrKyl7Yz1hW2ZdO2Mubm9kZU5hbWUmJmMubm9kZU5hbWUudG9VcHBlckNhc2UoKT09PVwiVFJcIj9oLnB1c2gob2EoYixjKVswXSk6aC5wdXNoKE8oYixjKSl9cmV0dXJuIGh9LDEpLGM9dGhpcy5yb3dzKC0xKTtjLnBvcCgpO2gubWVyZ2UoYyxiKTtyZXR1cm4gY30pO28oXCJyb3coKVwiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGRiKHRoaXMucm93cyhhLGIpKX0pO28oXCJyb3coKS5kYXRhKClcIixmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNvbnRleHQ7aWYoYT09PWspcmV0dXJuIGIubGVuZ3RoJiZ0aGlzLmxlbmd0aD9iWzBdLmFvRGF0YVt0aGlzWzBdXS5fYURhdGE6azt2YXIgYz1iWzBdLmFvRGF0YVt0aGlzWzBdXTtjLl9hRGF0YT1hO0FycmF5LmlzQXJyYXkoYSkmJihjLm5UciYmYy5uVHIuaWQpJiZOKGJbMF0ucm93SWQpKGEsYy5uVHIuaWQpO2VhKGJbMF0sdGhpc1swXSxcImRhdGFcIik7cmV0dXJuIHRoaXN9KTtvKFwicm93KCkubm9kZSgpXCIsZnVuY3Rpb24oKXt2YXIgYT1cclxudGhpcy5jb250ZXh0O3JldHVybiBhLmxlbmd0aCYmdGhpcy5sZW5ndGg/YVswXS5hb0RhdGFbdGhpc1swXV0ublRyfHxudWxsOm51bGx9KTtvKFwicm93LmFkZCgpXCIsZnVuY3Rpb24oYSl7YSBpbnN0YW5jZW9mIGgmJmEubGVuZ3RoJiYoYT1hWzBdKTt2YXIgYj10aGlzLml0ZXJhdG9yKFwidGFibGVcIixmdW5jdGlvbihiKXtyZXR1cm4gYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpPT09XCJUUlwiP29hKGIsYSlbMF06TyhiLGEpfSk7cmV0dXJuIHRoaXMucm93KGJbMF0pfSk7dmFyIGViPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5jb250ZXh0O2lmKGMubGVuZ3RoKWlmKChjPWNbMF0uYW9EYXRhW2IhPT1rP2I6YVswXV0pJiZjLl9kZXRhaWxzKXtjLl9kZXRhaWxzLnJlbW92ZSgpO2MuX2RldGFpbHNTaG93PWs7Yy5fZGV0YWlscz1rfX0sWGI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmNvbnRleHQ7aWYoYy5sZW5ndGgmJmEubGVuZ3RoKXt2YXIgZD1jWzBdLmFvRGF0YVthWzBdXTtcclxuaWYoZC5fZGV0YWlscyl7KGQuX2RldGFpbHNTaG93PWIpP2QuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoZC5uVHIpOmQuX2RldGFpbHMuZGV0YWNoKCk7dmFyIGU9Y1swXSxmPW5ldyByKGUpLGc9ZS5hb0RhdGE7Zi5vZmYoXCJkcmF3LmR0LkRUX2RldGFpbHMgY29sdW1uLXZpc2liaWxpdHkuZHQuRFRfZGV0YWlscyBkZXN0cm95LmR0LkRUX2RldGFpbHNcIik7aWYoQyhnLFwiX2RldGFpbHNcIikubGVuZ3RoPjApe2Yub24oXCJkcmF3LmR0LkRUX2RldGFpbHNcIixmdW5jdGlvbihhLGIpe2U9PT1iJiZmLnJvd3Moe3BhZ2U6XCJjdXJyZW50XCJ9KS5lcSgwKS5lYWNoKGZ1bmN0aW9uKGEpe2E9Z1thXTthLl9kZXRhaWxzU2hvdyYmYS5fZGV0YWlscy5pbnNlcnRBZnRlcihhLm5Ucil9KX0pO2Yub24oXCJjb2x1bW4tdmlzaWJpbGl0eS5kdC5EVF9kZXRhaWxzXCIsZnVuY3Rpb24oYSxiKXtpZihlPT09Yilmb3IodmFyIGMsZD1XKGIpLGY9MCxoPWcubGVuZ3RoO2Y8aDtmKyspe2M9Z1tmXTtjLl9kZXRhaWxzJiZcclxuYy5fZGV0YWlscy5jaGlsZHJlbihcInRkW2NvbHNwYW5dXCIpLmF0dHIoXCJjb2xzcGFuXCIsZCl9fSk7Zi5vbihcImRlc3Ryb3kuZHQuRFRfZGV0YWlsc1wiLGZ1bmN0aW9uKGEsYil7aWYoZT09PWIpZm9yKHZhciBjPTAsZD1nLmxlbmd0aDtjPGQ7YysrKWdbY10uX2RldGFpbHMmJmViKGYsYyl9KX19fX07byhcInJvdygpLmNoaWxkKClcIixmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY29udGV4dDtpZihhPT09aylyZXR1cm4gYy5sZW5ndGgmJnRoaXMubGVuZ3RoP2NbMF0uYW9EYXRhW3RoaXNbMF1dLl9kZXRhaWxzOms7aWYoYT09PXRydWUpdGhpcy5jaGlsZC5zaG93KCk7ZWxzZSBpZihhPT09ZmFsc2UpZWIodGhpcyk7ZWxzZSBpZihjLmxlbmd0aCYmdGhpcy5sZW5ndGgpe3ZhciBkPWNbMF0sYz1jWzBdLmFvRGF0YVt0aGlzWzBdXSxlPVtdLGY9ZnVuY3Rpb24oYSxiKXtpZihBcnJheS5pc0FycmF5KGEpfHxhIGluc3RhbmNlb2YgaClmb3IodmFyIGM9MCxrPWEubGVuZ3RoO2M8aztjKyspZihhW2NdLFxyXG5iKTtlbHNlIGlmKGEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PVwidHJcIillLnB1c2goYSk7ZWxzZXtjPWgoXCI8dHI+PHRkPjwvdGQ+PC90cj5cIikuYWRkQ2xhc3MoYik7aChcInRkXCIsYykuYWRkQ2xhc3MoYikuaHRtbChhKVswXS5jb2xTcGFuPVcoZCk7ZS5wdXNoKGNbMF0pfX07ZihhLGIpO2MuX2RldGFpbHMmJmMuX2RldGFpbHMuZGV0YWNoKCk7Yy5fZGV0YWlscz1oKGUpO2MuX2RldGFpbHNTaG93JiZjLl9kZXRhaWxzLmluc2VydEFmdGVyKGMublRyKX1yZXR1cm4gdGhpc30pO28oW1wicm93KCkuY2hpbGQuc2hvdygpXCIsXCJyb3coKS5jaGlsZCgpLnNob3coKVwiXSxmdW5jdGlvbigpe1hiKHRoaXMsdHJ1ZSk7cmV0dXJuIHRoaXN9KTtvKFtcInJvdygpLmNoaWxkLmhpZGUoKVwiLFwicm93KCkuY2hpbGQoKS5oaWRlKClcIl0sZnVuY3Rpb24oKXtYYih0aGlzLGZhbHNlKTtyZXR1cm4gdGhpc30pO28oW1wicm93KCkuY2hpbGQucmVtb3ZlKClcIixcInJvdygpLmNoaWxkKCkucmVtb3ZlKClcIl0sXHJcbmZ1bmN0aW9uKCl7ZWIodGhpcyk7cmV0dXJuIHRoaXN9KTtvKFwicm93KCkuY2hpbGQuaXNTaG93bigpXCIsZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnRleHQ7cmV0dXJuIGEubGVuZ3RoJiZ0aGlzLmxlbmd0aD9hWzBdLmFvRGF0YVt0aGlzWzBdXS5fZGV0YWlsc1Nob3d8fGZhbHNlOmZhbHNlfSk7dmFyIGVjPS9eKFteOl0rKToobmFtZXx2aXNJZHh8dmlzaWJsZSkkLyxZYj1mdW5jdGlvbihhLGIsYyxkLGUpe2Zvcih2YXIgYz1bXSxkPTAsZj1lLmxlbmd0aDtkPGY7ZCsrKWMucHVzaChCKGEsZVtkXSxiKSk7cmV0dXJuIGN9O28oXCJjb2x1bW5zKClcIixmdW5jdGlvbihhLGIpe2lmKGE9PT1rKWE9XCJcIjtlbHNlIGlmKGguaXNQbGFpbk9iamVjdChhKSl7Yj1hO2E9XCJcIn12YXIgYj1jYihiKSxjPXRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGMpe3ZhciBlPWEsZj1iLGc9Yy5hb0NvbHVtbnMsaj1DKGcsXCJzTmFtZVwiKSxpPUMoZyxcIm5UaFwiKTtyZXR1cm4gYmIoXCJjb2x1bW5cIixlLGZ1bmN0aW9uKGEpe3ZhciBiPVxyXG5QYihhKTtpZihhPT09XCJcIilyZXR1cm4gWihnLmxlbmd0aCk7aWYoYiE9PW51bGwpcmV0dXJuW2I+PTA/YjpnLmxlbmd0aCtiXTtpZih0eXBlb2YgYT09PVwiZnVuY3Rpb25cIil7dmFyIGU9RGEoYyxmKTtyZXR1cm4gaC5tYXAoZyxmdW5jdGlvbihiLGYpe3JldHVybiBhKGYsWWIoYyxmLDAsMCxlKSxpW2ZdKT9mOm51bGx9KX12YXIgaz10eXBlb2YgYT09PVwic3RyaW5nXCI/YS5tYXRjaChlYyk6XCJcIjtpZihrKXN3aXRjaChrWzJdKXtjYXNlIFwidmlzSWR4XCI6Y2FzZSBcInZpc2libGVcIjpiPXBhcnNlSW50KGtbMV0sMTApO2lmKGI8MCl7dmFyIGw9aC5tYXAoZyxmdW5jdGlvbihhLGIpe3JldHVybiBhLmJWaXNpYmxlP2I6bnVsbH0pO3JldHVybltsW2wubGVuZ3RoK2JdXX1yZXR1cm5bYmEoYyxiKV07Y2FzZSBcIm5hbWVcIjpyZXR1cm4gaC5tYXAoaixmdW5jdGlvbihhLGIpe3JldHVybiBhPT09a1sxXT9iOm51bGx9KTtkZWZhdWx0OnJldHVybltdfWlmKGEubm9kZU5hbWUmJmEuX0RUX0NlbGxJbmRleClyZXR1cm5bYS5fRFRfQ2VsbEluZGV4LmNvbHVtbl07XHJcbmI9aChpKS5maWx0ZXIoYSkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIGguaW5BcnJheSh0aGlzLGkpfSkudG9BcnJheSgpO2lmKGIubGVuZ3RofHwhYS5ub2RlTmFtZSlyZXR1cm4gYjtiPWgoYSkuY2xvc2VzdChcIipbZGF0YS1kdC1jb2x1bW5dXCIpO3JldHVybiBiLmxlbmd0aD9bYi5kYXRhKFwiZHQtY29sdW1uXCIpXTpbXX0sYyxmKX0sMSk7Yy5zZWxlY3Rvci5jb2xzPWE7Yy5zZWxlY3Rvci5vcHRzPWI7cmV0dXJuIGN9KTt1KFwiY29sdW1ucygpLmhlYWRlcigpXCIsXCJjb2x1bW4oKS5oZWFkZXIoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJjb2x1bW5cIixmdW5jdGlvbihhLGIpe3JldHVybiBhLmFvQ29sdW1uc1tiXS5uVGh9LDEpfSk7dShcImNvbHVtbnMoKS5mb290ZXIoKVwiLFwiY29sdW1uKCkuZm9vdGVyKClcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwiY29sdW1uXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5hb0NvbHVtbnNbYl0ublRmfSwxKX0pO3UoXCJjb2x1bW5zKCkuZGF0YSgpXCIsXHJcblwiY29sdW1uKCkuZGF0YSgpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcImNvbHVtbi1yb3dzXCIsWWIsMSl9KTt1KFwiY29sdW1ucygpLmRhdGFTcmMoKVwiLFwiY29sdW1uKCkuZGF0YVNyYygpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcImNvbHVtblwiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuYW9Db2x1bW5zW2JdLm1EYXRhfSwxKX0pO3UoXCJjb2x1bW5zKCkuY2FjaGUoKVwiLFwiY29sdW1uKCkuY2FjaGUoKVwiLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwiY29sdW1uLXJvd3NcIixmdW5jdGlvbihiLGMsZCxlLGYpe3JldHVybiBrYShiLmFvRGF0YSxmLGE9PT1cInNlYXJjaFwiP1wiX2FGaWx0ZXJEYXRhXCI6XCJfYVNvcnREYXRhXCIsYyl9LDEpfSk7dShcImNvbHVtbnMoKS5ub2RlcygpXCIsXCJjb2x1bW4oKS5ub2RlcygpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcImNvbHVtbi1yb3dzXCIsZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4ga2EoYS5hb0RhdGEsXHJcbmUsXCJhbkNlbGxzXCIsYil9LDEpfSk7dShcImNvbHVtbnMoKS52aXNpYmxlKClcIixcImNvbHVtbigpLnZpc2libGUoKVwiLGZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPXRoaXMuaXRlcmF0b3IoXCJjb2x1bW5cIixmdW5jdGlvbihiLGMpe2lmKGE9PT1rKXJldHVybiBiLmFvQ29sdW1uc1tjXS5iVmlzaWJsZTt2YXIgZD1iLmFvQ29sdW1ucyxqPWRbY10saT1iLmFvRGF0YSxuLG0sbDtpZihhIT09ayYmai5iVmlzaWJsZSE9PWEpe2lmKGEpe3ZhciBvPWguaW5BcnJheSh0cnVlLEMoZCxcImJWaXNpYmxlXCIpLGMrMSk7bj0wO2ZvcihtPWkubGVuZ3RoO248bTtuKyspe2w9aVtuXS5uVHI7ZD1pW25dLmFuQ2VsbHM7bCYmbC5pbnNlcnRCZWZvcmUoZFtjXSxkW29dfHxudWxsKX19ZWxzZSBoKEMoYi5hb0RhdGEsXCJhbkNlbGxzXCIsYykpLmRldGFjaCgpO2ouYlZpc2libGU9YX19KTthIT09ayYmdGhpcy5pdGVyYXRvcihcInRhYmxlXCIsZnVuY3Rpb24oZCl7Z2EoZCxkLmFvSGVhZGVyKTtnYShkLGQuYW9Gb290ZXIpO1xyXG5kLmFpRGlzcGxheS5sZW5ndGh8fGgoZC5uVEJvZHkpLmZpbmQoXCJ0ZFtjb2xzcGFuXVwiKS5hdHRyKFwiY29sc3BhblwiLFcoZCkpO3phKGQpO2MuaXRlcmF0b3IoXCJjb2x1bW5cIixmdW5jdGlvbihjLGQpe3QoYyxudWxsLFwiY29sdW1uLXZpc2liaWxpdHlcIixbYyxkLGEsYl0pfSk7KGI9PT1rfHxiKSYmYy5jb2x1bW5zLmFkanVzdCgpfSk7cmV0dXJuIGR9KTt1KFwiY29sdW1ucygpLmluZGV4ZXMoKVwiLFwiY29sdW1uKCkuaW5kZXgoKVwiLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwiY29sdW1uXCIsZnVuY3Rpb24oYixjKXtyZXR1cm4gYT09PVwidmlzaWJsZVwiP2NhKGIsYyk6Y30sMSl9KTtvKFwiY29sdW1ucy5hZGp1c3QoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGEpe2FhKGEpfSwxKX0pO28oXCJjb2x1bW4uaW5kZXgoKVwiLGZ1bmN0aW9uKGEsYil7aWYodGhpcy5jb250ZXh0Lmxlbmd0aCE9PTApe3ZhciBjPXRoaXMuY29udGV4dFswXTtcclxuaWYoYT09PVwiZnJvbVZpc2libGVcInx8YT09PVwidG9EYXRhXCIpcmV0dXJuIGJhKGMsYik7aWYoYT09PVwiZnJvbURhdGFcInx8YT09PVwidG9WaXNpYmxlXCIpcmV0dXJuIGNhKGMsYil9fSk7byhcImNvbHVtbigpXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4gZGIodGhpcy5jb2x1bW5zKGEsYikpfSk7byhcImNlbGxzKClcIixmdW5jdGlvbihhLGIsYyl7aWYoaC5pc1BsYWluT2JqZWN0KGEpKWlmKGEucm93PT09ayl7Yz1hO2E9bnVsbH1lbHNle2M9YjtiPW51bGx9aWYoaC5pc1BsYWluT2JqZWN0KGIpKXtjPWI7Yj1udWxsfWlmKGI9PT1udWxsfHxiPT09aylyZXR1cm4gdGhpcy5pdGVyYXRvcihcInRhYmxlXCIsZnVuY3Rpb24oYil7dmFyIGQ9YSxlPWNiKGMpLGY9Yi5hb0RhdGEsZz1EYShiLGUpLGk9U2Ioa2EoZixnLFwiYW5DZWxsc1wiKSksaj1oKFRiKFtdLGkpKSxsLG49Yi5hb0NvbHVtbnMubGVuZ3RoLG8sdSxyLHQsdyx2O3JldHVybiBiYihcImNlbGxcIixkLGZ1bmN0aW9uKGEpe3ZhciBjPXR5cGVvZiBhPT09XHJcblwiZnVuY3Rpb25cIjtpZihhPT09bnVsbHx8YT09PWt8fGMpe289W107dT0wO2ZvcihyPWcubGVuZ3RoO3U8cjt1Kyspe2w9Z1t1XTtmb3IodD0wO3Q8bjt0Kyspe3c9e3JvdzpsLGNvbHVtbjp0fTtpZihjKXt2PWZbbF07YSh3LEIoYixsLHQpLHYuYW5DZWxscz92LmFuQ2VsbHNbdF06bnVsbCkmJm8ucHVzaCh3KX1lbHNlIG8ucHVzaCh3KX19cmV0dXJuIG99aWYoaC5pc1BsYWluT2JqZWN0KGEpKXJldHVybiBhLmNvbHVtbiE9PWsmJmEucm93IT09ayYmaC5pbkFycmF5KGEucm93LGcpIT09LTE/W2FdOltdO2M9ai5maWx0ZXIoYSkubWFwKGZ1bmN0aW9uKGEsYil7cmV0dXJue3JvdzpiLl9EVF9DZWxsSW5kZXgucm93LGNvbHVtbjpiLl9EVF9DZWxsSW5kZXguY29sdW1ufX0pLnRvQXJyYXkoKTtpZihjLmxlbmd0aHx8IWEubm9kZU5hbWUpcmV0dXJuIGM7dj1oKGEpLmNsb3Nlc3QoXCIqW2RhdGEtZHQtcm93XVwiKTtyZXR1cm4gdi5sZW5ndGg/W3tyb3c6di5kYXRhKFwiZHQtcm93XCIpLGNvbHVtbjp2LmRhdGEoXCJkdC1jb2x1bW5cIil9XTpcclxuW119LGIsZSl9KTt2YXIgZD1jP3twYWdlOmMucGFnZSxvcmRlcjpjLm9yZGVyLHNlYXJjaDpjLnNlYXJjaH06e30sZT10aGlzLmNvbHVtbnMoYixkKSxmPXRoaXMucm93cyhhLGQpLGcsaixpLGwsZD10aGlzLml0ZXJhdG9yKFwidGFibGVcIixmdW5jdGlvbihhLGIpe3ZhciBjPVtdO2c9MDtmb3Ioaj1mW2JdLmxlbmd0aDtnPGo7ZysrKXtpPTA7Zm9yKGw9ZVtiXS5sZW5ndGg7aTxsO2krKyljLnB1c2goe3JvdzpmW2JdW2ddLGNvbHVtbjplW2JdW2ldfSl9cmV0dXJuIGN9LDEpLGQ9YyYmYy5zZWxlY3RlZD90aGlzLmNlbGxzKGQsYyk6ZDtoLmV4dGVuZChkLnNlbGVjdG9yLHtjb2xzOmIscm93czphLG9wdHM6Y30pO3JldHVybiBkfSk7dShcImNlbGxzKCkubm9kZXMoKVwiLFwiY2VsbCgpLm5vZGUoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJjZWxsXCIsZnVuY3Rpb24oYSxiLGMpe3JldHVybihhPWEuYW9EYXRhW2JdKSYmYS5hbkNlbGxzP2EuYW5DZWxsc1tjXTprfSwxKX0pO1xyXG5vKFwiY2VsbHMoKS5kYXRhKClcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwiY2VsbFwiLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gQihhLGIsYyl9LDEpfSk7dShcImNlbGxzKCkuY2FjaGUoKVwiLFwiY2VsbCgpLmNhY2hlKClcIixmdW5jdGlvbihhKXthPWE9PT1cInNlYXJjaFwiP1wiX2FGaWx0ZXJEYXRhXCI6XCJfYVNvcnREYXRhXCI7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJjZWxsXCIsZnVuY3Rpb24oYixjLGQpe3JldHVybiBiLmFvRGF0YVtjXVthXVtkXX0sMSl9KTt1KFwiY2VsbHMoKS5yZW5kZXIoKVwiLFwiY2VsbCgpLnJlbmRlcigpXCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJjZWxsXCIsZnVuY3Rpb24oYixjLGQpe3JldHVybiBCKGIsYyxkLGEpfSwxKX0pO3UoXCJjZWxscygpLmluZGV4ZXMoKVwiLFwiY2VsbCgpLmluZGV4KClcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdG9yKFwiY2VsbFwiLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm57cm93OmIsY29sdW1uOmMsY29sdW1uVmlzaWJsZTpjYShhLFxyXG5jKX19LDEpfSk7dShcImNlbGxzKCkuaW52YWxpZGF0ZSgpXCIsXCJjZWxsKCkuaW52YWxpZGF0ZSgpXCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJjZWxsXCIsZnVuY3Rpb24oYixjLGQpe2VhKGIsYyxhLGQpfSl9KTtvKFwiY2VsbCgpXCIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBkYih0aGlzLmNlbGxzKGEsYixjKSl9KTtvKFwiY2VsbCgpLmRhdGEoKVwiLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY29udGV4dCxjPXRoaXNbMF07aWYoYT09PWspcmV0dXJuIGIubGVuZ3RoJiZjLmxlbmd0aD9CKGJbMF0sY1swXS5yb3csY1swXS5jb2x1bW4pOms7bGIoYlswXSxjWzBdLnJvdyxjWzBdLmNvbHVtbixhKTtlYShiWzBdLGNbMF0ucm93LFwiZGF0YVwiLGNbMF0uY29sdW1uKTtyZXR1cm4gdGhpc30pO28oXCJvcmRlcigpXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNvbnRleHQ7aWYoYT09PWspcmV0dXJuIGMubGVuZ3RoIT09MD9jWzBdLmFhU29ydGluZzprO3R5cGVvZiBhPT09XCJudW1iZXJcIj9cclxuYT1bW2EsYl1dOmEubGVuZ3RoJiYhQXJyYXkuaXNBcnJheShhWzBdKSYmKGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGIpe2IuYWFTb3J0aW5nPWEuc2xpY2UoKX0pfSk7byhcIm9yZGVyLmxpc3RlbmVyKClcIixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGQpe09hKGQsYSxiLGMpfSl9KTtvKFwib3JkZXIuZml4ZWQoKVwiLGZ1bmN0aW9uKGEpe2lmKCFhKXt2YXIgYj10aGlzLmNvbnRleHQsYj1iLmxlbmd0aD9iWzBdLmFhU29ydGluZ0ZpeGVkOms7cmV0dXJuIEFycmF5LmlzQXJyYXkoYik/e3ByZTpifTpifXJldHVybiB0aGlzLml0ZXJhdG9yKFwidGFibGVcIixmdW5jdGlvbihiKXtiLmFhU29ydGluZ0ZpeGVkPWguZXh0ZW5kKHRydWUse30sYSl9KX0pO28oW1wiY29sdW1ucygpLm9yZGVyKClcIixcImNvbHVtbigpLm9yZGVyKClcIl0sZnVuY3Rpb24oYSl7dmFyIGI9XHJcbnRoaXM7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGMsZCl7dmFyIGU9W107aC5lYWNoKGJbZF0sZnVuY3Rpb24oYixjKXtlLnB1c2goW2MsYV0pfSk7Yy5hYVNvcnRpbmc9ZX0pfSk7byhcInNlYXJjaCgpXCIsZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5jb250ZXh0O3JldHVybiBhPT09az9lLmxlbmd0aCE9PTA/ZVswXS5vUHJldmlvdXNTZWFyY2guc1NlYXJjaDprOnRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGUpe2Uub0ZlYXR1cmVzLmJGaWx0ZXImJmhhKGUsaC5leHRlbmQoe30sZS5vUHJldmlvdXNTZWFyY2gse3NTZWFyY2g6YStcIlwiLGJSZWdleDpiPT09bnVsbD9mYWxzZTpiLGJTbWFydDpjPT09bnVsbD90cnVlOmMsYkNhc2VJbnNlbnNpdGl2ZTpkPT09bnVsbD90cnVlOmR9KSwxKX0pfSk7dShcImNvbHVtbnMoKS5zZWFyY2goKVwiLFwiY29sdW1uKCkuc2VhcmNoKClcIixmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcImNvbHVtblwiLFxyXG5mdW5jdGlvbihlLGYpe3ZhciBnPWUuYW9QcmVTZWFyY2hDb2xzO2lmKGE9PT1rKXJldHVybiBnW2ZdLnNTZWFyY2g7aWYoZS5vRmVhdHVyZXMuYkZpbHRlcil7aC5leHRlbmQoZ1tmXSx7c1NlYXJjaDphK1wiXCIsYlJlZ2V4OmI9PT1udWxsP2ZhbHNlOmIsYlNtYXJ0OmM9PT1udWxsP3RydWU6YyxiQ2FzZUluc2Vuc2l0aXZlOmQ9PT1udWxsP3RydWU6ZH0pO2hhKGUsZS5vUHJldmlvdXNTZWFyY2gsMSl9fSl9KTtvKFwic3RhdGUoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGg/dGhpcy5jb250ZXh0WzBdLm9TYXZlZFN0YXRlOm51bGx9KTtvKFwic3RhdGUuY2xlYXIoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGEpe2EuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKGEub0luc3RhbmNlLGEse30pfSl9KTtvKFwic3RhdGUubG9hZGVkKClcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoP3RoaXMuY29udGV4dFswXS5vTG9hZGVkU3RhdGU6XHJcbm51bGx9KTtvKFwic3RhdGUuc2F2ZSgpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcInRhYmxlXCIsZnVuY3Rpb24oYSl7emEoYSl9KX0pO2wudmVyc2lvbkNoZWNrPWwuZm5WZXJzaW9uQ2hlY2s9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWwudmVyc2lvbi5zcGxpdChcIi5cIiksYT1hLnNwbGl0KFwiLlwiKSxjLGQsZT0wLGY9YS5sZW5ndGg7ZTxmO2UrKyl7Yz1wYXJzZUludChiW2VdLDEwKXx8MDtkPXBhcnNlSW50KGFbZV0sMTApfHwwO2lmKGMhPT1kKXJldHVybiBjPmR9cmV0dXJuIHRydWV9O2wuaXNEYXRhVGFibGU9bC5mbklzRGF0YVRhYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPWgoYSkuZ2V0KDApLGM9ZmFsc2U7aWYoYSBpbnN0YW5jZW9mIGwuQXBpKXJldHVybiB0cnVlO2guZWFjaChsLnNldHRpbmdzLGZ1bmN0aW9uKGEsZSl7dmFyIGY9ZS5uU2Nyb2xsSGVhZD9oKFwidGFibGVcIixlLm5TY3JvbGxIZWFkKVswXTpudWxsLGc9ZS5uU2Nyb2xsRm9vdD9oKFwidGFibGVcIixlLm5TY3JvbGxGb290KVswXTpcclxubnVsbDtpZihlLm5UYWJsZT09PWJ8fGY9PT1ifHxnPT09YiljPXRydWV9KTtyZXR1cm4gY307bC50YWJsZXM9bC5mblRhYmxlcz1mdW5jdGlvbihhKXt2YXIgYj1mYWxzZTtpZihoLmlzUGxhaW5PYmplY3QoYSkpe2I9YS5hcGk7YT1hLnZpc2libGV9dmFyIGM9aC5tYXAobC5zZXR0aW5ncyxmdW5jdGlvbihiKXtpZighYXx8YSYmaChiLm5UYWJsZSkuaXMoXCI6dmlzaWJsZVwiKSlyZXR1cm4gYi5uVGFibGV9KTtyZXR1cm4gYj9uZXcgcihjKTpjfTtsLmNhbWVsVG9IdW5nYXJpYW49SjtvKFwiJCgpXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnJvd3MoYikubm9kZXMoKSxjPWgoYyk7cmV0dXJuIGgoW10uY29uY2F0KGMuZmlsdGVyKGEpLnRvQXJyYXkoKSxjLmZpbmQoYSkudG9BcnJheSgpKSl9KTtoLmVhY2goW1wib25cIixcIm9uZVwiLFwib2ZmXCJdLGZ1bmN0aW9uKGEsYil7byhiK1wiKClcIixmdW5jdGlvbigpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7YVswXT1cclxuaC5tYXAoYVswXS5zcGxpdCgvXFxzLyksZnVuY3Rpb24oYSl7cmV0dXJuIWEubWF0Y2goL1xcLmR0XFxiLyk/YStcIi5kdFwiOmF9KS5qb2luKFwiIFwiKTt2YXIgZD1oKHRoaXMudGFibGVzKCkubm9kZXMoKSk7ZFtiXS5hcHBseShkLGEpO3JldHVybiB0aGlzfSl9KTtvKFwiY2xlYXIoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGEpe3BhKGEpfSl9KTtvKFwic2V0dGluZ3MoKVwiLGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMuY29udGV4dCx0aGlzLmNvbnRleHQpfSk7byhcImluaXQoKVwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jb250ZXh0O3JldHVybiBhLmxlbmd0aD9hWzBdLm9Jbml0Om51bGx9KTtvKFwiZGF0YSgpXCIsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRvcihcInRhYmxlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIEMoYS5hb0RhdGEsXCJfYURhdGFcIil9KS5mbGF0dGVuKCl9KTtvKFwiZGVzdHJveSgpXCIsZnVuY3Rpb24oYSl7YT1hfHxmYWxzZTtcclxucmV0dXJuIHRoaXMuaXRlcmF0b3IoXCJ0YWJsZVwiLGZ1bmN0aW9uKGIpe3ZhciBjPWIublRhYmxlV3JhcHBlci5wYXJlbnROb2RlLGQ9Yi5vQ2xhc3NlcyxlPWIublRhYmxlLGY9Yi5uVEJvZHksZz1iLm5USGVhZCxqPWIublRGb290LGk9aChlKSxmPWgoZiksaz1oKGIublRhYmxlV3JhcHBlciksbT1oLm1hcChiLmFvRGF0YSxmdW5jdGlvbihhKXtyZXR1cm4gYS5uVHJ9KSxvO2IuYkRlc3Ryb3lpbmc9dHJ1ZTt0KGIsXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLFwiZGVzdHJveVwiLFtiXSk7YXx8KG5ldyByKGIpKS5jb2x1bW5zKCkudmlzaWJsZSh0cnVlKTtrLm9mZihcIi5EVFwiKS5maW5kKFwiOm5vdCh0Ym9keSAqKVwiKS5vZmYoXCIuRFRcIik7aChFKS5vZmYoXCIuRFQtXCIrYi5zSW5zdGFuY2UpO2lmKGUhPWcucGFyZW50Tm9kZSl7aS5jaGlsZHJlbihcInRoZWFkXCIpLmRldGFjaCgpO2kuYXBwZW5kKGcpfWlmKGomJmUhPWoucGFyZW50Tm9kZSl7aS5jaGlsZHJlbihcInRmb290XCIpLmRldGFjaCgpO2kuYXBwZW5kKGopfWIuYWFTb3J0aW5nPVxyXG5bXTtiLmFhU29ydGluZ0ZpeGVkPVtdO3lhKGIpO2gobSkucmVtb3ZlQ2xhc3MoYi5hc1N0cmlwZUNsYXNzZXMuam9pbihcIiBcIikpO2goXCJ0aCwgdGRcIixnKS5yZW1vdmVDbGFzcyhkLnNTb3J0YWJsZStcIiBcIitkLnNTb3J0YWJsZUFzYytcIiBcIitkLnNTb3J0YWJsZURlc2MrXCIgXCIrZC5zU29ydGFibGVOb25lKTtmLmNoaWxkcmVuKCkuZGV0YWNoKCk7Zi5hcHBlbmQobSk7Zz1hP1wicmVtb3ZlXCI6XCJkZXRhY2hcIjtpW2ddKCk7a1tnXSgpO2lmKCFhJiZjKXtjLmluc2VydEJlZm9yZShlLGIublRhYmxlUmVpbnNlcnRCZWZvcmUpO2kuY3NzKFwid2lkdGhcIixiLnNEZXN0cm95V2lkdGgpLnJlbW92ZUNsYXNzKGQuc1RhYmxlKTsobz1iLmFzRGVzdHJveVN0cmlwZXMubGVuZ3RoKSYmZi5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oYSl7aCh0aGlzKS5hZGRDbGFzcyhiLmFzRGVzdHJveVN0cmlwZXNbYSVvXSl9KX1jPWguaW5BcnJheShiLGwuc2V0dGluZ3MpO2MhPT0tMSYmbC5zZXR0aW5ncy5zcGxpY2UoYyxcclxuMSl9KX0pO2guZWFjaChbXCJjb2x1bW5cIixcInJvd1wiLFwiY2VsbFwiXSxmdW5jdGlvbihhLGIpe28oYitcInMoKS5ldmVyeSgpXCIsZnVuY3Rpb24oYSl7dmFyIGQ9dGhpcy5zZWxlY3Rvci5vcHRzLGU9dGhpcztyZXR1cm4gdGhpcy5pdGVyYXRvcihiLGZ1bmN0aW9uKGYsZyxoLGksbCl7YS5jYWxsKGVbYl0oZyxiPT09XCJjZWxsXCI/aDpkLGI9PT1cImNlbGxcIj9kOmspLGcsaCxpLGwpfSl9KX0pO28oXCJpMThuKClcIixmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5jb250ZXh0WzBdLGE9UyhhKShkLm9MYW5ndWFnZSk7YT09PWsmJihhPWIpO2MhPT1rJiZoLmlzUGxhaW5PYmplY3QoYSkmJihhPWFbY10hPT1rP2FbY106YS5fKTtyZXR1cm4gYS5yZXBsYWNlKFwiJWRcIixjKX0pO2wudmVyc2lvbj1cIjEuMTAuMjRcIjtsLnNldHRpbmdzPVtdO2wubW9kZWxzPXt9O2wubW9kZWxzLm9TZWFyY2g9e2JDYXNlSW5zZW5zaXRpdmU6ITAsc1NlYXJjaDpcIlwiLGJSZWdleDohMSxiU21hcnQ6ITB9O2wubW9kZWxzLm9Sb3c9XHJcbntuVHI6bnVsbCxhbkNlbGxzOm51bGwsX2FEYXRhOltdLF9hU29ydERhdGE6bnVsbCxfYUZpbHRlckRhdGE6bnVsbCxfc0ZpbHRlclJvdzpudWxsLF9zUm93U3RyaXBlOlwiXCIsc3JjOm51bGwsaWR4Oi0xfTtsLm1vZGVscy5vQ29sdW1uPXtpZHg6bnVsbCxhRGF0YVNvcnQ6bnVsbCxhc1NvcnRpbmc6bnVsbCxiU2VhcmNoYWJsZTpudWxsLGJTb3J0YWJsZTpudWxsLGJWaXNpYmxlOm51bGwsX3NNYW51YWxUeXBlOm51bGwsX2JBdHRyU3JjOiExLGZuQ3JlYXRlZENlbGw6bnVsbCxmbkdldERhdGE6bnVsbCxmblNldERhdGE6bnVsbCxtRGF0YTpudWxsLG1SZW5kZXI6bnVsbCxuVGg6bnVsbCxuVGY6bnVsbCxzQ2xhc3M6bnVsbCxzQ29udGVudFBhZGRpbmc6bnVsbCxzRGVmYXVsdENvbnRlbnQ6bnVsbCxzTmFtZTpudWxsLHNTb3J0RGF0YVR5cGU6XCJzdGRcIixzU29ydGluZ0NsYXNzOm51bGwsc1NvcnRpbmdDbGFzc0pVSTpudWxsLHNUaXRsZTpudWxsLHNUeXBlOm51bGwsc1dpZHRoOm51bGwsXHJcbnNXaWR0aE9yaWc6bnVsbH07bC5kZWZhdWx0cz17YWFEYXRhOm51bGwsYWFTb3J0aW5nOltbMCxcImFzY1wiXV0sYWFTb3J0aW5nRml4ZWQ6W10sYWpheDpudWxsLGFMZW5ndGhNZW51OlsxMCwyNSw1MCwxMDBdLGFvQ29sdW1uczpudWxsLGFvQ29sdW1uRGVmczpudWxsLGFvU2VhcmNoQ29sczpbXSxhc1N0cmlwZUNsYXNzZXM6bnVsbCxiQXV0b1dpZHRoOiEwLGJEZWZlclJlbmRlcjohMSxiRGVzdHJveTohMSxiRmlsdGVyOiEwLGJJbmZvOiEwLGJMZW5ndGhDaGFuZ2U6ITAsYlBhZ2luYXRlOiEwLGJQcm9jZXNzaW5nOiExLGJSZXRyaWV2ZTohMSxiU2Nyb2xsQ29sbGFwc2U6ITEsYlNlcnZlclNpZGU6ITEsYlNvcnQ6ITAsYlNvcnRNdWx0aTohMCxiU29ydENlbGxzVG9wOiExLGJTb3J0Q2xhc3NlczohMCxiU3RhdGVTYXZlOiExLGZuQ3JlYXRlZFJvdzpudWxsLGZuRHJhd0NhbGxiYWNrOm51bGwsZm5Gb290ZXJDYWxsYmFjazpudWxsLGZuRm9ybWF0TnVtYmVyOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcclxudGhpcy5vTGFuZ3VhZ2Uuc1Rob3VzYW5kcyl9LGZuSGVhZGVyQ2FsbGJhY2s6bnVsbCxmbkluZm9DYWxsYmFjazpudWxsLGZuSW5pdENvbXBsZXRlOm51bGwsZm5QcmVEcmF3Q2FsbGJhY2s6bnVsbCxmblJvd0NhbGxiYWNrOm51bGwsZm5TZXJ2ZXJEYXRhOm51bGwsZm5TZXJ2ZXJQYXJhbXM6bnVsbCxmblN0YXRlTG9hZENhbGxiYWNrOmZ1bmN0aW9uKGEpe3RyeXtyZXR1cm4gSlNPTi5wYXJzZSgoYS5pU3RhdGVEdXJhdGlvbj09PS0xP3Nlc3Npb25TdG9yYWdlOmxvY2FsU3RvcmFnZSkuZ2V0SXRlbShcIkRhdGFUYWJsZXNfXCIrYS5zSW5zdGFuY2UrXCJfXCIrbG9jYXRpb24ucGF0aG5hbWUpKX1jYXRjaChiKXtyZXR1cm57fX19LGZuU3RhdGVMb2FkUGFyYW1zOm51bGwsZm5TdGF0ZUxvYWRlZDpudWxsLGZuU3RhdGVTYXZlQ2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0cnl7KGEuaVN0YXRlRHVyYXRpb249PT0tMT9zZXNzaW9uU3RvcmFnZTpsb2NhbFN0b3JhZ2UpLnNldEl0ZW0oXCJEYXRhVGFibGVzX1wiK1xyXG5hLnNJbnN0YW5jZStcIl9cIitsb2NhdGlvbi5wYXRobmFtZSxKU09OLnN0cmluZ2lmeShiKSl9Y2F0Y2goYyl7fX0sZm5TdGF0ZVNhdmVQYXJhbXM6bnVsbCxpU3RhdGVEdXJhdGlvbjo3MjAwLGlEZWZlckxvYWRpbmc6bnVsbCxpRGlzcGxheUxlbmd0aDoxMCxpRGlzcGxheVN0YXJ0OjAsaVRhYkluZGV4OjAsb0NsYXNzZXM6e30sb0xhbmd1YWdlOntvQXJpYTp7c1NvcnRBc2NlbmRpbmc6XCI6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1wiLHNTb3J0RGVzY2VuZGluZzpcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gZGVzY2VuZGluZ1wifSxvUGFnaW5hdGU6e3NGaXJzdDpcIkZpcnN0XCIsc0xhc3Q6XCJMYXN0XCIsc05leHQ6XCJOZXh0XCIsc1ByZXZpb3VzOlwiUHJldmlvdXNcIn0sc0VtcHR5VGFibGU6XCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiLHNJbmZvOlwiU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1wiLHNJbmZvRW1wdHk6XCJTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcIixcclxuc0luZm9GaWx0ZXJlZDpcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXCIsc0luZm9Qb3N0Rml4OlwiXCIsc0RlY2ltYWw6XCJcIixzVGhvdXNhbmRzOlwiLFwiLHNMZW5ndGhNZW51OlwiU2hvdyBfTUVOVV8gZW50cmllc1wiLHNMb2FkaW5nUmVjb3JkczpcIkxvYWRpbmcuLi5cIixzUHJvY2Vzc2luZzpcIlByb2Nlc3NpbmcuLi5cIixzU2VhcmNoOlwiU2VhcmNoOlwiLHNTZWFyY2hQbGFjZWhvbGRlcjpcIlwiLHNVcmw6XCJcIixzWmVyb1JlY29yZHM6XCJObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXCJ9LG9TZWFyY2g6aC5leHRlbmQoe30sbC5tb2RlbHMub1NlYXJjaCksc0FqYXhEYXRhUHJvcDpcImRhdGFcIixzQWpheFNvdXJjZTpudWxsLHNEb206XCJsZnJ0aXBcIixzZWFyY2hEZWxheTpudWxsLHNQYWdpbmF0aW9uVHlwZTpcInNpbXBsZV9udW1iZXJzXCIsc1Njcm9sbFg6XCJcIixzU2Nyb2xsWElubmVyOlwiXCIsc1Njcm9sbFk6XCJcIixzU2VydmVyTWV0aG9kOlwiR0VUXCIscmVuZGVyZXI6bnVsbCxyb3dJZDpcIkRUX1Jvd0lkXCJ9O1xyXG4kKGwuZGVmYXVsdHMpO2wuZGVmYXVsdHMuY29sdW1uPXthRGF0YVNvcnQ6bnVsbCxpRGF0YVNvcnQ6LTEsYXNTb3J0aW5nOltcImFzY1wiLFwiZGVzY1wiXSxiU2VhcmNoYWJsZTohMCxiU29ydGFibGU6ITAsYlZpc2libGU6ITAsZm5DcmVhdGVkQ2VsbDpudWxsLG1EYXRhOm51bGwsbVJlbmRlcjpudWxsLHNDZWxsVHlwZTpcInRkXCIsc0NsYXNzOlwiXCIsc0NvbnRlbnRQYWRkaW5nOlwiXCIsc0RlZmF1bHRDb250ZW50Om51bGwsc05hbWU6XCJcIixzU29ydERhdGFUeXBlOlwic3RkXCIsc1RpdGxlOm51bGwsc1R5cGU6bnVsbCxzV2lkdGg6bnVsbH07JChsLmRlZmF1bHRzLmNvbHVtbik7bC5tb2RlbHMub1NldHRpbmdzPXtvRmVhdHVyZXM6e2JBdXRvV2lkdGg6bnVsbCxiRGVmZXJSZW5kZXI6bnVsbCxiRmlsdGVyOm51bGwsYkluZm86bnVsbCxiTGVuZ3RoQ2hhbmdlOm51bGwsYlBhZ2luYXRlOm51bGwsYlByb2Nlc3Npbmc6bnVsbCxiU2VydmVyU2lkZTpudWxsLGJTb3J0Om51bGwsYlNvcnRNdWx0aTpudWxsLFxyXG5iU29ydENsYXNzZXM6bnVsbCxiU3RhdGVTYXZlOm51bGx9LG9TY3JvbGw6e2JDb2xsYXBzZTpudWxsLGlCYXJXaWR0aDowLHNYOm51bGwsc1hJbm5lcjpudWxsLHNZOm51bGx9LG9MYW5ndWFnZTp7Zm5JbmZvQ2FsbGJhY2s6bnVsbH0sb0Jyb3dzZXI6e2JTY3JvbGxPdmVyc2l6ZTohMSxiU2Nyb2xsYmFyTGVmdDohMSxiQm91bmRpbmc6ITEsYmFyV2lkdGg6MH0sYWpheDpudWxsLGFhbkZlYXR1cmVzOltdLGFvRGF0YTpbXSxhaURpc3BsYXk6W10sYWlEaXNwbGF5TWFzdGVyOltdLGFJZHM6e30sYW9Db2x1bW5zOltdLGFvSGVhZGVyOltdLGFvRm9vdGVyOltdLG9QcmV2aW91c1NlYXJjaDp7fSxhb1ByZVNlYXJjaENvbHM6W10sYWFTb3J0aW5nOm51bGwsYWFTb3J0aW5nRml4ZWQ6W10sYXNTdHJpcGVDbGFzc2VzOm51bGwsYXNEZXN0cm95U3RyaXBlczpbXSxzRGVzdHJveVdpZHRoOjAsYW9Sb3dDYWxsYmFjazpbXSxhb0hlYWRlckNhbGxiYWNrOltdLGFvRm9vdGVyQ2FsbGJhY2s6W10sXHJcbmFvRHJhd0NhbGxiYWNrOltdLGFvUm93Q3JlYXRlZENhbGxiYWNrOltdLGFvUHJlRHJhd0NhbGxiYWNrOltdLGFvSW5pdENvbXBsZXRlOltdLGFvU3RhdGVTYXZlUGFyYW1zOltdLGFvU3RhdGVMb2FkUGFyYW1zOltdLGFvU3RhdGVMb2FkZWQ6W10sc1RhYmxlSWQ6XCJcIixuVGFibGU6bnVsbCxuVEhlYWQ6bnVsbCxuVEZvb3Q6bnVsbCxuVEJvZHk6bnVsbCxuVGFibGVXcmFwcGVyOm51bGwsYkRlZmVyTG9hZGluZzohMSxiSW5pdGlhbGlzZWQ6ITEsYW9PcGVuUm93czpbXSxzRG9tOm51bGwsc2VhcmNoRGVsYXk6bnVsbCxzUGFnaW5hdGlvblR5cGU6XCJ0d29fYnV0dG9uXCIsaVN0YXRlRHVyYXRpb246MCxhb1N0YXRlU2F2ZTpbXSxhb1N0YXRlTG9hZDpbXSxvU2F2ZWRTdGF0ZTpudWxsLG9Mb2FkZWRTdGF0ZTpudWxsLHNBamF4U291cmNlOm51bGwsc0FqYXhEYXRhUHJvcDpudWxsLGJBamF4RGF0YUdldDohMCxqcVhIUjpudWxsLGpzb246ayxvQWpheERhdGE6ayxmblNlcnZlckRhdGE6bnVsbCxcclxuYW9TZXJ2ZXJQYXJhbXM6W10sc1NlcnZlck1ldGhvZDpudWxsLGZuRm9ybWF0TnVtYmVyOm51bGwsYUxlbmd0aE1lbnU6bnVsbCxpRHJhdzowLGJEcmF3aW5nOiExLGlEcmF3RXJyb3I6LTEsX2lEaXNwbGF5TGVuZ3RoOjEwLF9pRGlzcGxheVN0YXJ0OjAsX2lSZWNvcmRzVG90YWw6MCxfaVJlY29yZHNEaXNwbGF5OjAsb0NsYXNzZXM6e30sYkZpbHRlcmVkOiExLGJTb3J0ZWQ6ITEsYlNvcnRDZWxsc1RvcDpudWxsLG9Jbml0Om51bGwsYW9EZXN0cm95Q2FsbGJhY2s6W10sZm5SZWNvcmRzVG90YWw6ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzKT09XCJzc3BcIj90aGlzLl9pUmVjb3Jkc1RvdGFsKjE6dGhpcy5haURpc3BsYXlNYXN0ZXIubGVuZ3RofSxmblJlY29yZHNEaXNwbGF5OmZ1bmN0aW9uKCl7cmV0dXJuIHkodGhpcyk9PVwic3NwXCI/dGhpcy5faVJlY29yZHNEaXNwbGF5KjE6dGhpcy5haURpc3BsYXkubGVuZ3RofSxmbkRpc3BsYXlFbmQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9pRGlzcGxheUxlbmd0aCxcclxuYj10aGlzLl9pRGlzcGxheVN0YXJ0LGM9YithLGQ9dGhpcy5haURpc3BsYXkubGVuZ3RoLGU9dGhpcy5vRmVhdHVyZXMsZj1lLmJQYWdpbmF0ZTtyZXR1cm4gZS5iU2VydmVyU2lkZT9mPT09ZmFsc2V8fGE9PT0tMT9iK2Q6TWF0aC5taW4oYithLHRoaXMuX2lSZWNvcmRzRGlzcGxheSk6IWZ8fGM+ZHx8YT09PS0xP2Q6Y30sb0luc3RhbmNlOm51bGwsc0luc3RhbmNlOm51bGwsaVRhYkluZGV4OjAsblNjcm9sbEhlYWQ6bnVsbCxuU2Nyb2xsRm9vdDpudWxsLGFMYXN0U29ydDpbXSxvUGx1Z2luczp7fSxyb3dJZEZuOm51bGwscm93SWQ6bnVsbH07bC5leHQ9dj17YnV0dG9uczp7fSxjbGFzc2VzOnt9LGJ1aWxkZXI6XCItc291cmNlLVwiLGVyck1vZGU6XCJhbGVydFwiLGZlYXR1cmU6W10sc2VhcmNoOltdLHNlbGVjdG9yOntjZWxsOltdLGNvbHVtbjpbXSxyb3c6W119LGludGVybmFsOnt9LGxlZ2FjeTp7YWpheDpudWxsfSxwYWdlcjp7fSxyZW5kZXJlcjp7cGFnZUJ1dHRvbjp7fSxoZWFkZXI6e319LFxyXG5vcmRlcjp7fSx0eXBlOntkZXRlY3Q6W10sc2VhcmNoOnt9LG9yZGVyOnt9fSxfdW5pcXVlOjAsZm5WZXJzaW9uQ2hlY2s6bC5mblZlcnNpb25DaGVjayxpQXBpSW5kZXg6MCxvSlVJQ2xhc3Nlczp7fSxzVmVyc2lvbjpsLnZlcnNpb259O2guZXh0ZW5kKHYse2FmbkZpbHRlcmluZzp2LnNlYXJjaCxhVHlwZXM6di50eXBlLmRldGVjdCxvZm5TZWFyY2g6di50eXBlLnNlYXJjaCxvU29ydDp2LnR5cGUub3JkZXIsYWZuU29ydERhdGE6di5vcmRlcixhb0ZlYXR1cmVzOnYuZmVhdHVyZSxvQXBpOnYuaW50ZXJuYWwsb1N0ZENsYXNzZXM6di5jbGFzc2VzLG9QYWdpbmF0aW9uOnYucGFnZXJ9KTtoLmV4dGVuZChsLmV4dC5jbGFzc2VzLHtzVGFibGU6XCJkYXRhVGFibGVcIixzTm9Gb290ZXI6XCJuby1mb290ZXJcIixzUGFnZUJ1dHRvbjpcInBhZ2luYXRlX2J1dHRvblwiLHNQYWdlQnV0dG9uQWN0aXZlOlwiY3VycmVudFwiLHNQYWdlQnV0dG9uRGlzYWJsZWQ6XCJkaXNhYmxlZFwiLHNTdHJpcGVPZGQ6XCJvZGRcIixcclxuc1N0cmlwZUV2ZW46XCJldmVuXCIsc1Jvd0VtcHR5OlwiZGF0YVRhYmxlc19lbXB0eVwiLHNXcmFwcGVyOlwiZGF0YVRhYmxlc193cmFwcGVyXCIsc0ZpbHRlcjpcImRhdGFUYWJsZXNfZmlsdGVyXCIsc0luZm86XCJkYXRhVGFibGVzX2luZm9cIixzUGFnaW5nOlwiZGF0YVRhYmxlc19wYWdpbmF0ZSBwYWdpbmdfXCIsc0xlbmd0aDpcImRhdGFUYWJsZXNfbGVuZ3RoXCIsc1Byb2Nlc3Npbmc6XCJkYXRhVGFibGVzX3Byb2Nlc3NpbmdcIixzU29ydEFzYzpcInNvcnRpbmdfYXNjXCIsc1NvcnREZXNjOlwic29ydGluZ19kZXNjXCIsc1NvcnRhYmxlOlwic29ydGluZ1wiLHNTb3J0YWJsZUFzYzpcInNvcnRpbmdfZGVzY19kaXNhYmxlZFwiLHNTb3J0YWJsZURlc2M6XCJzb3J0aW5nX2FzY19kaXNhYmxlZFwiLHNTb3J0YWJsZU5vbmU6XCJzb3J0aW5nX2Rpc2FibGVkXCIsc1NvcnRDb2x1bW46XCJzb3J0aW5nX1wiLHNGaWx0ZXJJbnB1dDpcIlwiLHNMZW5ndGhTZWxlY3Q6XCJcIixzU2Nyb2xsV3JhcHBlcjpcImRhdGFUYWJsZXNfc2Nyb2xsXCIsc1Njcm9sbEhlYWQ6XCJkYXRhVGFibGVzX3Njcm9sbEhlYWRcIixcclxuc1Njcm9sbEhlYWRJbm5lcjpcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZElubmVyXCIsc1Njcm9sbEJvZHk6XCJkYXRhVGFibGVzX3Njcm9sbEJvZHlcIixzU2Nyb2xsRm9vdDpcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdFwiLHNTY3JvbGxGb290SW5uZXI6XCJkYXRhVGFibGVzX3Njcm9sbEZvb3RJbm5lclwiLHNIZWFkZXJUSDpcIlwiLHNGb290ZXJUSDpcIlwiLHNTb3J0SlVJQXNjOlwiXCIsc1NvcnRKVUlEZXNjOlwiXCIsc1NvcnRKVUk6XCJcIixzU29ydEpVSUFzY0FsbG93ZWQ6XCJcIixzU29ydEpVSURlc2NBbGxvd2VkOlwiXCIsc1NvcnRKVUlXcmFwcGVyOlwiXCIsc1NvcnRJY29uOlwiXCIsc0pVSUhlYWRlcjpcIlwiLHNKVUlGb290ZXI6XCJcIn0pO3ZhciBNYj1sLmV4dC5wYWdlcjtoLmV4dGVuZChNYix7c2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuW1wicHJldmlvdXNcIixcIm5leHRcIl19LGZ1bGw6ZnVuY3Rpb24oKXtyZXR1cm5bXCJmaXJzdFwiLFwicHJldmlvdXNcIixcIm5leHRcIixcImxhc3RcIl19LG51bWJlcnM6ZnVuY3Rpb24oYSxiKXtyZXR1cm5bamEoYSxcclxuYildfSxzaW1wbGVfbnVtYmVyczpmdW5jdGlvbihhLGIpe3JldHVybltcInByZXZpb3VzXCIsamEoYSxiKSxcIm5leHRcIl19LGZ1bGxfbnVtYmVyczpmdW5jdGlvbihhLGIpe3JldHVybltcImZpcnN0XCIsXCJwcmV2aW91c1wiLGphKGEsYiksXCJuZXh0XCIsXCJsYXN0XCJdfSxmaXJzdF9sYXN0X251bWJlcnM6ZnVuY3Rpb24oYSxiKXtyZXR1cm5bXCJmaXJzdFwiLGphKGEsYiksXCJsYXN0XCJdfSxfbnVtYmVyczpqYSxudW1iZXJzX2xlbmd0aDo3fSk7aC5leHRlbmQoITAsbC5leHQucmVuZGVyZXIse3BhZ2VCdXR0b246e186ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPWEub0NsYXNzZXMsaj1hLm9MYW5ndWFnZS5vUGFnaW5hdGUsaT1hLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZXx8e30sbCxtLG89MCxzPWZ1bmN0aW9uKGIsZCl7dmFyIGssdSx0LHIsdj1nLnNQYWdlQnV0dG9uRGlzYWJsZWQsdz1mdW5jdGlvbihiKXtWYShhLGIuZGF0YS5hY3Rpb24sdHJ1ZSl9O2s9MDtmb3IodT1kLmxlbmd0aDtrPFxyXG51O2srKyl7cj1kW2tdO2lmKEFycmF5LmlzQXJyYXkocikpe3Q9aChcIjxcIisoci5EVF9lbHx8XCJkaXZcIikrXCIvPlwiKS5hcHBlbmRUbyhiKTtzKHQscil9ZWxzZXtsPW51bGw7bT1yO3Q9YS5pVGFiSW5kZXg7c3dpdGNoKHIpe2Nhc2UgXCJlbGxpcHNpc1wiOmIuYXBwZW5kKCc8c3BhbiBjbGFzcz1cImVsbGlwc2lzXCI+JiN4MjAyNjs8L3NwYW4+Jyk7YnJlYWs7Y2FzZSBcImZpcnN0XCI6bD1qLnNGaXJzdDtpZihlPT09MCl7dD0tMTttPW0rKFwiIFwiK3YpfWJyZWFrO2Nhc2UgXCJwcmV2aW91c1wiOmw9ai5zUHJldmlvdXM7aWYoZT09PTApe3Q9LTE7bT1tKyhcIiBcIit2KX1icmVhaztjYXNlIFwibmV4dFwiOmw9ai5zTmV4dDtpZihmPT09MHx8ZT09PWYtMSl7dD0tMTttPW0rKFwiIFwiK3YpfWJyZWFrO2Nhc2UgXCJsYXN0XCI6bD1qLnNMYXN0O2lmKGY9PT0wfHxlPT09Zi0xKXt0PS0xO209bSsoXCIgXCIrdil9YnJlYWs7ZGVmYXVsdDpsPWEuZm5Gb3JtYXROdW1iZXIocisxKTttPWU9PT1yP2cuc1BhZ2VCdXR0b25BY3RpdmU6XHJcblwiXCJ9aWYobCE9PW51bGwpe3Q9aChcIjxhPlwiLHtcImNsYXNzXCI6Zy5zUGFnZUJ1dHRvbitcIiBcIittLFwiYXJpYS1jb250cm9sc1wiOmEuc1RhYmxlSWQsXCJhcmlhLWxhYmVsXCI6aVtyXSxcImRhdGEtZHQtaWR4XCI6byx0YWJpbmRleDp0LGlkOmM9PT0wJiZ0eXBlb2Ygcj09PVwic3RyaW5nXCI/YS5zVGFibGVJZCtcIl9cIityOm51bGx9KS5odG1sKGwpLmFwcGVuZFRvKGIpO1hhKHQse2FjdGlvbjpyfSx3KTtvKyt9fX19LHU7dHJ5e3U9aChiKS5maW5kKEguYWN0aXZlRWxlbWVudCkuZGF0YShcImR0LWlkeFwiKX1jYXRjaCh0KXt9cyhoKGIpLmVtcHR5KCksZCk7dSE9PWsmJmgoYikuZmluZChcIltkYXRhLWR0LWlkeD1cIit1K1wiXVwiKS50cmlnZ2VyKFwiZm9jdXNcIil9fX0pO2guZXh0ZW5kKGwuZXh0LnR5cGUuZGV0ZWN0LFtmdW5jdGlvbihhLGIpe3ZhciBjPWIub0xhbmd1YWdlLnNEZWNpbWFsO3JldHVybiBhYihhLGMpP1wibnVtXCIrYzpudWxsfSxmdW5jdGlvbihhKXtpZihhJiYhKGEgaW5zdGFuY2VvZiBEYXRlKSYmXHJcbiFiYy50ZXN0KGEpKXJldHVybiBudWxsO3ZhciBiPURhdGUucGFyc2UoYSk7cmV0dXJuIGIhPT1udWxsJiYhaXNOYU4oYil8fE0oYSk/XCJkYXRlXCI6bnVsbH0sZnVuY3Rpb24oYSxiKXt2YXIgYz1iLm9MYW5ndWFnZS5zRGVjaW1hbDtyZXR1cm4gYWIoYSxjLHRydWUpP1wibnVtLWZtdFwiK2M6bnVsbH0sZnVuY3Rpb24oYSxiKXt2YXIgYz1iLm9MYW5ndWFnZS5zRGVjaW1hbDtyZXR1cm4gUmIoYSxjKT9cImh0bWwtbnVtXCIrYzpudWxsfSxmdW5jdGlvbihhLGIpe3ZhciBjPWIub0xhbmd1YWdlLnNEZWNpbWFsO3JldHVybiBSYihhLGMsdHJ1ZSk/XCJodG1sLW51bS1mbXRcIitjOm51bGx9LGZ1bmN0aW9uKGEpe3JldHVybiBNKGEpfHx0eXBlb2YgYT09PVwic3RyaW5nXCImJmEuaW5kZXhPZihcIjxcIikhPT0tMT9cImh0bWxcIjpudWxsfV0pO2guZXh0ZW5kKGwuZXh0LnR5cGUuc2VhcmNoLHtodG1sOmZ1bmN0aW9uKGEpe3JldHVybiBNKGEpP2E6dHlwZW9mIGE9PT1cInN0cmluZ1wiP2EucmVwbGFjZShPYixcclxuXCIgXCIpLnJlcGxhY2UoQ2EsXCJcIik6XCJcIn0sc3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybiBNKGEpP2E6dHlwZW9mIGE9PT1cInN0cmluZ1wiP2EucmVwbGFjZShPYixcIiBcIik6YX19KTt2YXIgQmE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYSE9PTAmJighYXx8YT09PVwiLVwiKSlyZXR1cm4tSW5maW5pdHk7YiYmKGE9UWIoYSxiKSk7aWYoYS5yZXBsYWNlKXtjJiYoYT1hLnJlcGxhY2UoYyxcIlwiKSk7ZCYmKGE9YS5yZXBsYWNlKGQsXCJcIikpfXJldHVybiBhKjF9O2guZXh0ZW5kKHYudHlwZS5vcmRlcix7XCJkYXRlLXByZVwiOmZ1bmN0aW9uKGEpe2E9RGF0ZS5wYXJzZShhKTtyZXR1cm4gaXNOYU4oYSk/LUluZmluaXR5OmF9LFwiaHRtbC1wcmVcIjpmdW5jdGlvbihhKXtyZXR1cm4gTShhKT9cIlwiOmEucmVwbGFjZT9hLnJlcGxhY2UoLzwuKj8+L2csXCJcIikudG9Mb3dlckNhc2UoKTphK1wiXCJ9LFwic3RyaW5nLXByZVwiOmZ1bmN0aW9uKGEpe3JldHVybiBNKGEpP1wiXCI6dHlwZW9mIGE9PT1cInN0cmluZ1wiP2EudG9Mb3dlckNhc2UoKTpcclxuIWEudG9TdHJpbmc/XCJcIjphLnRvU3RyaW5nKCl9LFwic3RyaW5nLWFzY1wiOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGE8Yj8tMTphPmI/MTowfSxcInN0cmluZy1kZXNjXCI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYTxiPzE6YT5iPy0xOjB9fSk7RmEoXCJcIik7aC5leHRlbmQoITAsbC5leHQucmVuZGVyZXIse2hlYWRlcjp7XzpmdW5jdGlvbihhLGIsYyxkKXtoKGEublRhYmxlKS5vbihcIm9yZGVyLmR0LkRUXCIsZnVuY3Rpb24oZSxmLGcsaCl7aWYoYT09PWYpe2U9Yy5pZHg7Yi5yZW1vdmVDbGFzcyhkLnNTb3J0QXNjK1wiIFwiK2Quc1NvcnREZXNjKS5hZGRDbGFzcyhoW2VdPT1cImFzY1wiP2Quc1NvcnRBc2M6aFtlXT09XCJkZXNjXCI/ZC5zU29ydERlc2M6Yy5zU29ydGluZ0NsYXNzKX19KX0sanF1ZXJ5dWk6ZnVuY3Rpb24oYSxiLGMsZCl7aChcIjxkaXYvPlwiKS5hZGRDbGFzcyhkLnNTb3J0SlVJV3JhcHBlcikuYXBwZW5kKGIuY29udGVudHMoKSkuYXBwZW5kKGgoXCI8c3Bhbi8+XCIpLmFkZENsYXNzKGQuc1NvcnRJY29uK1xyXG5cIiBcIitjLnNTb3J0aW5nQ2xhc3NKVUkpKS5hcHBlbmRUbyhiKTtoKGEublRhYmxlKS5vbihcIm9yZGVyLmR0LkRUXCIsZnVuY3Rpb24oZSxmLGcsaCl7aWYoYT09PWYpe2U9Yy5pZHg7Yi5yZW1vdmVDbGFzcyhkLnNTb3J0QXNjK1wiIFwiK2Quc1NvcnREZXNjKS5hZGRDbGFzcyhoW2VdPT1cImFzY1wiP2Quc1NvcnRBc2M6aFtlXT09XCJkZXNjXCI/ZC5zU29ydERlc2M6Yy5zU29ydGluZ0NsYXNzKTtiLmZpbmQoXCJzcGFuLlwiK2Quc1NvcnRJY29uKS5yZW1vdmVDbGFzcyhkLnNTb3J0SlVJQXNjK1wiIFwiK2Quc1NvcnRKVUlEZXNjK1wiIFwiK2Quc1NvcnRKVUkrXCIgXCIrZC5zU29ydEpVSUFzY0FsbG93ZWQrXCIgXCIrZC5zU29ydEpVSURlc2NBbGxvd2VkKS5hZGRDbGFzcyhoW2VdPT1cImFzY1wiP2Quc1NvcnRKVUlBc2M6aFtlXT09XCJkZXNjXCI/ZC5zU29ydEpVSURlc2M6Yy5zU29ydGluZ0NsYXNzSlVJKX19KX19fSk7dmFyIGZiPWZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgYT09PVwic3RyaW5nXCI/YS5yZXBsYWNlKC8mL2csXHJcblwiJmFtcDtcIikucmVwbGFjZSgvPC9nLFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csXCImZ3Q7XCIpLnJlcGxhY2UoL1wiL2csXCImcXVvdDtcIik6YX07bC5yZW5kZXI9e251bWJlcjpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybntkaXNwbGF5OmZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBmIT09XCJudW1iZXJcIiYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXJldHVybiBmO3ZhciBnPWY8MD9cIi1cIjpcIlwiLGg9cGFyc2VGbG9hdChmKTtpZihpc05hTihoKSlyZXR1cm4gZmIoZik7aD1oLnRvRml4ZWQoYyk7Zj1NYXRoLmFicyhoKTtoPXBhcnNlSW50KGYsMTApO2Y9Yz9iKyhmLWgpLnRvRml4ZWQoYykuc3Vic3RyaW5nKDIpOlwiXCI7cmV0dXJuIGcrKGR8fFwiXCIpK2gudG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLGEpK2YrKGV8fFwiXCIpfX19LHRleHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZGlzcGxheTpmYixmaWx0ZXI6ZmJ9fX07aC5leHRlbmQobC5leHQuaW50ZXJuYWwse19mbkV4dGVybkFwaUZ1bmM6TmIsXHJcbl9mbkJ1aWxkQWpheDp0YSxfZm5BamF4VXBkYXRlOm5iLF9mbkFqYXhQYXJhbWV0ZXJzOndiLF9mbkFqYXhVcGRhdGVEcmF3OnhiLF9mbkFqYXhEYXRhU3JjOnVhLF9mbkFkZENvbHVtbjpHYSxfZm5Db2x1bW5PcHRpb25zOmxhLF9mbkFkanVzdENvbHVtblNpemluZzphYSxfZm5WaXNpYmxlVG9Db2x1bW5JbmRleDpiYSxfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTpjYSxfZm5WaXNibGVDb2x1bW5zOlcsX2ZuR2V0Q29sdW1uczpuYSxfZm5Db2x1bW5UeXBlczpJYSxfZm5BcHBseUNvbHVtbkRlZnM6a2IsX2ZuSHVuZ2FyaWFuTWFwOiQsX2ZuQ2FtZWxUb0h1bmdhcmlhbjpKLF9mbkxhbmd1YWdlQ29tcGF0OkVhLF9mbkJyb3dzZXJEZXRlY3Q6aWIsX2ZuQWRkRGF0YTpPLF9mbkFkZFRyOm9hLF9mbk5vZGVUb0RhdGFJbmRleDpmdW5jdGlvbihhLGIpe3JldHVybiBiLl9EVF9Sb3dJbmRleCE9PWs/Yi5fRFRfUm93SW5kZXg6bnVsbH0sX2ZuTm9kZVRvQ29sdW1uSW5kZXg6ZnVuY3Rpb24oYSxcclxuYixjKXtyZXR1cm4gaC5pbkFycmF5KGMsYS5hb0RhdGFbYl0uYW5DZWxscyl9LF9mbkdldENlbGxEYXRhOkIsX2ZuU2V0Q2VsbERhdGE6bGIsX2ZuU3BsaXRPYmpOb3RhdGlvbjpMYSxfZm5HZXRPYmplY3REYXRhRm46UyxfZm5TZXRPYmplY3REYXRhRm46TixfZm5HZXREYXRhTWFzdGVyOk1hLF9mbkNsZWFyVGFibGU6cGEsX2ZuRGVsZXRlSW5kZXg6cWEsX2ZuSW52YWxpZGF0ZTplYSxfZm5HZXRSb3dFbGVtZW50czpLYSxfZm5DcmVhdGVUcjpKYSxfZm5CdWlsZEhlYWQ6bWIsX2ZuRHJhd0hlYWQ6Z2EsX2ZuRHJhdzpQLF9mblJlRHJhdzpULF9mbkFkZE9wdGlvbnNIdG1sOnBiLF9mbkRldGVjdEhlYWRlcjpmYSxfZm5HZXRVbmlxdWVUaHM6c2EsX2ZuRmVhdHVyZUh0bWxGaWx0ZXI6cmIsX2ZuRmlsdGVyQ29tcGxldGU6aGEsX2ZuRmlsdGVyQ3VzdG9tOkFiLF9mbkZpbHRlckNvbHVtbjp6YixfZm5GaWx0ZXI6eWIsX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOlJhLF9mbkVzY2FwZVJlZ2V4OlNhLFxyXG5fZm5GaWx0ZXJEYXRhOkJiLF9mbkZlYXR1cmVIdG1sSW5mbzp1YixfZm5VcGRhdGVJbmZvOkViLF9mbkluZm9NYWNyb3M6RmIsX2ZuSW5pdGlhbGlzZTppYSxfZm5Jbml0Q29tcGxldGU6dmEsX2ZuTGVuZ3RoQ2hhbmdlOlRhLF9mbkZlYXR1cmVIdG1sTGVuZ3RoOnFiLF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6dmIsX2ZuUGFnZUNoYW5nZTpWYSxfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6c2IsX2ZuUHJvY2Vzc2luZ0Rpc3BsYXk6RCxfZm5GZWF0dXJlSHRtbFRhYmxlOnRiLF9mblNjcm9sbERyYXc6bWEsX2ZuQXBwbHlUb0NoaWxkcmVuOkksX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzOkhhLF9mblRocm90dGxlOlFhLF9mbkNvbnZlcnRUb1dpZHRoOkdiLF9mbkdldFdpZGVzdE5vZGU6SGIsX2ZuR2V0TWF4TGVuU3RyaW5nOkliLF9mblN0cmluZ1RvQ3NzOncsX2ZuU29ydEZsYXR0ZW46WSxfZm5Tb3J0Om9iLF9mblNvcnRBcmlhOktiLF9mblNvcnRMaXN0ZW5lcjpXYSxfZm5Tb3J0QXR0YWNoTGlzdGVuZXI6T2EsXHJcbl9mblNvcnRpbmdDbGFzc2VzOnlhLF9mblNvcnREYXRhOkpiLF9mblNhdmVTdGF0ZTp6YSxfZm5Mb2FkU3RhdGU6TGIsX2ZuU2V0dGluZ3NGcm9tTm9kZTpBYSxfZm5Mb2c6SyxfZm5NYXA6RixfZm5CaW5kQWN0aW9uOlhhLF9mbkNhbGxiYWNrUmVnOnosX2ZuQ2FsbGJhY2tGaXJlOnQsX2ZuTGVuZ3RoT3ZlcmZsb3c6VWEsX2ZuUmVuZGVyZXI6UGEsX2ZuRGF0YVNvdXJjZTp5LF9mblJvd0F0dHJpYnV0ZXM6TmEsX2ZuRXh0ZW5kOllhLF9mbkNhbGN1bGF0ZUVuZDpmdW5jdGlvbigpe319KTtoLmZuLmRhdGFUYWJsZT1sO2wuJD1oO2guZm4uZGF0YVRhYmxlU2V0dGluZ3M9bC5zZXR0aW5ncztoLmZuLmRhdGFUYWJsZUV4dD1sLmV4dDtoLmZuLkRhdGFUYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gaCh0aGlzKS5kYXRhVGFibGUoYSkuYXBpKCl9O2guZWFjaChsLGZ1bmN0aW9uKGEsYil7aC5mbi5EYXRhVGFibGVbYV09Yn0pO3JldHVybiBoLmZuLmRhdGFUYWJsZX0pO1xyXG4iXSwibmFtZXMiOlsiaCIsImRlZmluZSIsImFtZCIsIkUiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImV4cG9ydHMiLCJtb2R1bGUiLCJIIiwicmVxdWlyZSIsImpRdWVyeSIsImsiLCIkIiwiYSIsImIiLCJjIiwiZCIsImVhY2giLCJlIiwibWF0Y2giLCJpbmRleE9mIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiX2h1bmdhcmlhbk1hcCIsIkoiLCJjaGFyQXQiLCJleHRlbmQiLCJFYSIsImwiLCJkZWZhdWx0cyIsIm9MYW5ndWFnZSIsInNEZWNpbWFsIiwiRmEiLCJzWmVyb1JlY29yZHMiLCJzRW1wdHlUYWJsZSIsIkYiLCJzTG9hZGluZ1JlY29yZHMiLCJzSW5mb1Rob3VzYW5kcyIsInNUaG91c2FuZHMiLCJnYiIsIkEiLCJzU2Nyb2xsWCIsInNjcm9sbFgiLCJhb1NlYXJjaENvbHMiLCJsZW5ndGgiLCJtb2RlbHMiLCJvU2VhcmNoIiwiaGIiLCJhRGF0YVNvcnQiLCJBcnJheSIsImlzQXJyYXkiLCJpYiIsIl9fYnJvd3NlciIsImNzcyIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInNjcm9sbExlZnQiLCJoZWlnaHQiLCJ3aWR0aCIsIm92ZXJmbG93IiwiYXBwZW5kIiwiYXBwZW5kVG8iLCJjaGlsZHJlbiIsImJhcldpZHRoIiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsImJTY3JvbGxPdmVyc2l6ZSIsImJTY3JvbGxiYXJMZWZ0IiwiTWF0aCIsInJvdW5kIiwib2Zmc2V0IiwiYkJvdW5kaW5nIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVtb3ZlIiwib0Jyb3dzZXIiLCJvU2Nyb2xsIiwiaUJhcldpZHRoIiwiamIiLCJmIiwiZyIsImoiLCJoYXNPd25Qcm9wZXJ0eSIsIkdhIiwiY29sdW1uIiwiYW9Db2x1bW5zIiwib0NvbHVtbiIsIm5UaCIsImNyZWF0ZUVsZW1lbnQiLCJzVGl0bGUiLCJpbm5lckhUTUwiLCJtRGF0YSIsImlkeCIsInB1c2giLCJhb1ByZVNlYXJjaENvbHMiLCJsYSIsImRhdGEiLCJvQ2xhc3NlcyIsInNXaWR0aE9yaWciLCJhdHRyIiwibURhdGFQcm9wIiwic1R5cGUiLCJfc01hbnVhbFR5cGUiLCJjbGFzc05hbWUiLCJzQ2xhc3MiLCJhZGRDbGFzcyIsImlEYXRhU29ydCIsIlMiLCJpIiwibVJlbmRlciIsIl9iQXR0clNyYyIsImlzUGxhaW5PYmplY3QiLCJzb3J0IiwidHlwZSIsImZpbHRlciIsIl9zZXR0ZXIiLCJmbkdldERhdGEiLCJmblNldERhdGEiLCJOIiwiX3Jvd1JlYWRPYmplY3QiLCJvRmVhdHVyZXMiLCJiU29ydCIsImJTb3J0YWJsZSIsInNTb3J0YWJsZU5vbmUiLCJpbkFycmF5IiwiYXNTb3J0aW5nIiwic1NvcnRpbmdDbGFzcyIsInNTb3J0aW5nQ2xhc3NKVUkiLCJzU29ydGFibGVBc2MiLCJzU29ydEpVSUFzY0FsbG93ZWQiLCJzU29ydGFibGVEZXNjIiwic1NvcnRKVUlEZXNjQWxsb3dlZCIsInNTb3J0YWJsZSIsInNTb3J0SlVJIiwiYWEiLCJiQXV0b1dpZHRoIiwiSGEiLCJzdHlsZSIsInNXaWR0aCIsInNZIiwic1giLCJtYSIsInQiLCJiYSIsIm5hIiwiY2EiLCJXIiwiYlZpc2libGUiLCJtYXAiLCJJYSIsImFvRGF0YSIsImV4dCIsImRldGVjdCIsIm0iLCJxIiwicyIsIkIiLCJrYiIsIm4iLCJ0YXJnZXRzIiwiYVRhcmdldHMiLCJoYXNDbGFzcyIsIk8iLCJvUm93Iiwic3JjIiwiX2FEYXRhIiwiYWlEaXNwbGF5TWFzdGVyIiwicm93SWRGbiIsImFJZHMiLCJiRGVmZXJSZW5kZXIiLCJKYSIsIm9hIiwiS2EiLCJjZWxscyIsImlEcmF3Iiwic0RlZmF1bHRDb250ZW50Iiwic2V0dGluZ3MiLCJyb3ciLCJjb2wiLCJpRHJhd0Vycm9yIiwiSyIsImNhbGwiLCJsYiIsIkxhIiwiXyIsImRhIiwiWCIsInNwbGljZSIsImpvaW4iLCJzdWJzdHJpbmciLCJFcnJvciIsInNsaWNlIiwiTWEiLCJDIiwicGEiLCJhaURpc3BsYXkiLCJxYSIsImVhIiwiY2hpbGROb2RlcyIsInJlbW92ZUNoaWxkIiwiZmlyc3RDaGlsZCIsImFuQ2VsbHMiLCJfYVNvcnREYXRhIiwiX2FGaWx0ZXJEYXRhIiwiTmEiLCJnZXRBdHRyaWJ1dGUiLCJHIiwidHJpbSIsIm5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJuZXh0U2libGluZyIsIm5UciIsInJvd0lkIiwiX0RUX1Jvd0luZGV4Iiwic0NlbGxUeXBlIiwiX0RUX0NlbGxJbmRleCIsImFwcGVuZENoaWxkIiwicGFyZW50Tm9kZSIsImZuQ3JlYXRlZENlbGwiLCJvSW5zdGFuY2UiLCJpZCIsIkRUX1Jvd0NsYXNzIiwic3BsaXQiLCJfX3Jvd2MiLCJyYSIsImNvbmNhdCIsInJlbW92ZUNsYXNzIiwiRFRfUm93QXR0ciIsIkRUX1Jvd0RhdGEiLCJtYiIsIm5USGVhZCIsIm5URm9vdCIsImlUYWJJbmRleCIsInNUYWJsZUlkIiwiT2EiLCJodG1sIiwiUGEiLCJmYSIsImFvSGVhZGVyIiwic0hlYWRlclRIIiwic0Zvb3RlclRIIiwiYW9Gb290ZXIiLCJuVGYiLCJjZWxsIiwiZ2EiLCJQIiwiRCIsImFzU3RyaXBlQ2xhc3NlcyIsImlJbml0RGlzcGxheVN0YXJ0IiwieSIsImJEcmF3aW5nIiwiX2lEaXNwbGF5U3RhcnQiLCJmblJlY29yZHNEaXNwbGF5IiwiZm5EaXNwbGF5RW5kIiwiYkRlZmVyTG9hZGluZyIsImJEZXN0cm95aW5nIiwibmIiLCJfc1Jvd1N0cmlwZSIsImZuUmVjb3Jkc1RvdGFsIiwidmFsaWduIiwiY29sU3BhbiIsInNSb3dFbXB0eSIsIm5UQm9keSIsImRldGFjaCIsImJTb3J0ZWQiLCJiRmlsdGVyZWQiLCJUIiwiYkZpbHRlciIsIm9iIiwiaGEiLCJvUHJldmlvdXNTZWFyY2giLCJfZHJhd0hvbGQiLCJwYiIsIm5UYWJsZSIsImluc2VydEJlZm9yZSIsInNXcmFwcGVyIiwic05vRm9vdGVyIiwibkhvbGRpbmciLCJuVGFibGVXcmFwcGVyIiwiblRhYmxlUmVpbnNlcnRCZWZvcmUiLCJzRG9tIiwic0pVSUhlYWRlciIsInNKVUlGb290ZXIiLCJzdWJzdHIiLCJwYXJlbnQiLCJiUGFnaW5hdGUiLCJiTGVuZ3RoQ2hhbmdlIiwicWIiLCJyYiIsImJQcm9jZXNzaW5nIiwic2IiLCJ0YiIsImJJbmZvIiwidWIiLCJ2YiIsImZlYXR1cmUiLCJjRmVhdHVyZSIsImZuSW5pdCIsImFhbkZlYXR1cmVzIiwicmVwbGFjZVdpdGgiLCJ1bmlxdWUiLCJzYSIsImJTb3J0Q2VsbHNUb3AiLCJ0YSIsIm5hbWUiLCJ2YWx1ZSIsImFqYXgiLCJqcVhIUiIsInN1Y2Nlc3MiLCJlcnJvciIsInNFcnJvciIsImpzb24iLCJkYXRhVHlwZSIsImNhY2hlIiwic1NlcnZlck1ldGhvZCIsInJlYWR5U3RhdGUiLCJvQWpheERhdGEiLCJmblNlcnZlckRhdGEiLCJzQWpheFNvdXJjZSIsInVybCIsImJBamF4RGF0YUdldCIsIndiIiwieGIiLCJZIiwiX2lEaXNwbGF5TGVuZ3RoIiwiZHJhdyIsImNvbHVtbnMiLCJvcmRlciIsInN0YXJ0Iiwic2VhcmNoIiwic1NlYXJjaCIsInJlZ2V4IiwiYlJlZ2V4Iiwic05hbWUiLCJzZWFyY2hhYmxlIiwiYlNlYXJjaGFibGUiLCJvcmRlcmFibGUiLCJkaXIiLCJsZWdhY3kiLCJ1YSIsInNFY2hvIiwiaVRvdGFsUmVjb3JkcyIsInJlY29yZHNUb3RhbCIsImlUb3RhbERpc3BsYXlSZWNvcmRzIiwicmVjb3Jkc0ZpbHRlcmVkIiwiX2lSZWNvcmRzVG90YWwiLCJwYXJzZUludCIsIl9pUmVjb3Jkc0Rpc3BsYXkiLCJfYkluaXRDb21wbGV0ZSIsInZhIiwiZGF0YVNyYyIsInNBamF4RGF0YVByb3AiLCJhYURhdGEiLCJzRmlsdGVySW5wdXQiLCJzRmlsdGVyIiwiYlNtYXJ0IiwiYkNhc2VJbnNlbnNpdGl2ZSIsInNlYXJjaERlbGF5IiwidmFsIiwic1NlYXJjaFBsYWNlaG9sZGVyIiwib24iLCJRYSIsInNldFRpbWVvdXQiLCJrZXlDb2RlIiwiYWN0aXZlRWxlbWVudCIsInliIiwiYkVzY2FwZVJlZ2V4IiwiemIiLCJBYiIsIm1lcmdlIiwiUmEiLCJ0ZXN0IiwiQmIiLCJfc0ZpbHRlclJvdyIsIlNhIiwiUmVnRXhwIiwidG9TdHJpbmciLCJ3YSIsIlpiIiwidGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJDYiIsInNtYXJ0IiwiY2FzZUluc2Vuc2l0aXZlIiwiRGIiLCJzSW5mbyIsImFvRHJhd0NhbGxiYWNrIiwiZm4iLCJFYiIsInNJbmZvRW1wdHkiLCJzSW5mb0ZpbHRlcmVkIiwic0luZm9Qb3N0Rml4IiwiRmIiLCJmbkluZm9DYWxsYmFjayIsImZuRm9ybWF0TnVtYmVyIiwiY2VpbCIsImlhIiwiYkluaXRpYWxpc2VkIiwidyIsIm9Jbml0IiwiVGEiLCJVYSIsImFMZW5ndGhNZW51Iiwic0xlbmd0aFNlbGVjdCIsIk9wdGlvbiIsInNMZW5ndGgiLCJzTGVuZ3RoTWVudSIsIm91dGVySFRNTCIsInNQYWdpbmF0aW9uVHlwZSIsInBhZ2VyIiwic1BhZ2luZyIsInAiLCJmblVwZGF0ZSIsIlZhIiwiZmxvb3IiLCJyIiwic1Byb2Nlc3NpbmciLCJfY2FwdGlvblNpZGUiLCJjbG9uZU5vZGUiLCJzU2Nyb2xsV3JhcHBlciIsInNTY3JvbGxIZWFkIiwiYm9yZGVyIiwic1Njcm9sbEhlYWRJbm5lciIsInNYSW5uZXIiLCJyZW1vdmVBdHRyIiwic1Njcm9sbEJvZHkiLCJzU2Nyb2xsRm9vdCIsInNTY3JvbGxGb290SW5uZXIiLCJiQ29sbGFwc2UiLCJuU2Nyb2xsSGVhZCIsIm5TY3JvbGxCb2R5IiwiblNjcm9sbEZvb3QiLCJvIiwidSIsIlUiLCJWIiwiJGIiLCJRIiwiTCIsIlIiLCJ4YSIsInYiLCJ4IiwieiIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsInNjcm9sbEJhclZpcyIsImNsb25lIiwicHJlcGVuZFRvIiwiZmluZCIsIkkiLCJvdXRlcldpZHRoIiwib2Zmc2V0SGVpZ2h0IiwidHJpZ2dlciIsInNjcm9sbFRvcCIsIm5vZGVUeXBlIiwiR2IiLCJlcSIsIm1hcmdpbiIsInBhZGRpbmciLCJIYiIsInNDb250ZW50UGFkZGluZyIsInJpZ2h0IiwiX3Jlc3pFdnQiLCJzSW5zdGFuY2UiLCJib2R5IiwiSWIiLCJhYyIsImFhU29ydGluZ0ZpeGVkIiwicHJlIiwiYWFTb3J0aW5nIiwicG9zdCIsIl9pZHgiLCJpbmRleCIsImZvcm1hdHRlciIsIkpiIiwiS2IiLCJvQXJpYSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInNTb3J0QXNjZW5kaW5nIiwic1NvcnREZXNjZW5kaW5nIiwiV2EiLCJiU29ydE11bHRpIiwiWGEiLCJzaGlmdEtleSIsInlhIiwiYUxhc3RTb3J0Iiwic1NvcnRDb2x1bW4iLCJiU29ydENsYXNzZXMiLCJzU29ydERhdGFUeXBlIiwiemEiLCJiU3RhdGVTYXZlIiwidGltZSIsIkRhdGUiLCJ2aXNpYmxlIiwib1NhdmVkU3RhdGUiLCJmblN0YXRlU2F2ZUNhbGxiYWNrIiwiTGIiLCJpU3RhdGVEdXJhdGlvbiIsIm9Mb2FkZWRTdGF0ZSIsImZuU3RhdGVMb2FkQ2FsbGJhY2siLCJBYSIsImNvbnNvbGUiLCJsb2ciLCJzRXJyTW9kZSIsImVyck1vZGUiLCJhbGVydCIsIllhIiwid2hpY2giLCJwcmV2ZW50RGVmYXVsdCIsInJldmVyc2UiLCJhcHBseSIsIkV2ZW50IiwicmVzdWx0IiwicmVuZGVyZXIiLCJiU2VydmVyU2lkZSIsImphIiwiTWIiLCJudW1iZXJzX2xlbmd0aCIsIloiLCJEVF9lbCIsIm51bSIsIkJhIiwiWmEiLCJDYSIsIk5iIiwiaUFwaUluZGV4IiwicHJvdG90eXBlIiwiYXJndW1lbnRzIiwiaW50ZXJuYWwiLCJhcGkiLCJyb3dzIiwiZm5BZGREYXRhIiwiYWRkIiwiZmxhdHRlbiIsInRvQXJyYXkiLCJmbkFkanVzdENvbHVtblNpemluZyIsImFkanVzdCIsImZuQ2xlYXJUYWJsZSIsImNsZWFyIiwiZm5DbG9zZSIsImNoaWxkIiwiaGlkZSIsImZuRGVsZXRlUm93IiwiZm5EZXN0cm95IiwiZGVzdHJveSIsImZuRHJhdyIsImZuRmlsdGVyIiwiZm5HZXROb2RlcyIsIm5vZGUiLCJub2RlcyIsImZuR2V0UG9zaXRpb24iLCJjb2x1bW5WaXNpYmxlIiwiZm5Jc09wZW4iLCJpc1Nob3duIiwiZm5PcGVuIiwic2hvdyIsImZuUGFnZUNoYW5nZSIsInBhZ2UiLCJmblNldENvbHVtblZpcyIsImZuU2V0dGluZ3MiLCJmblNvcnQiLCJmblNvcnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiZm5WZXJzaW9uQ2hlY2siLCJvQXBpIiwiYlJldHJpZXZlIiwiYkRlc3Ryb3kiLCJfdW5pcXVlIiwib1NldHRpbmdzIiwic0Rlc3Ryb3lXaWR0aCIsImRhdGFUYWJsZSIsImlEaXNwbGF5TGVuZ3RoIiwiZm5EcmF3Q2FsbGJhY2siLCJmblNlcnZlclBhcmFtcyIsImZuU3RhdGVTYXZlUGFyYW1zIiwiZm5TdGF0ZUxvYWRQYXJhbXMiLCJmblN0YXRlTG9hZGVkIiwiZm5Sb3dDYWxsYmFjayIsImZuQ3JlYXRlZFJvdyIsImZuSGVhZGVyQ2FsbGJhY2siLCJmbkZvb3RlckNhbGxiYWNrIiwiZm5Jbml0Q29tcGxldGUiLCJmblByZURyYXdDYWxsYmFjayIsImNsYXNzZXMiLCJzVGFibGUiLCJpRGlzcGxheVN0YXJ0IiwiaURlZmVyTG9hZGluZyIsInNVcmwiLCJzU3RyaXBlT2RkIiwic1N0cmlwZUV2ZW4iLCJhc0Rlc3Ryb3lTdHJpcGVzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhb0NvbHVtbkRlZnMiLCIkYSIsIk9iIiwiYmMiLCJjYyIsIk0iLCJQYiIsImlzTmFOIiwiaXNGaW5pdGUiLCJRYiIsImFiIiwicGFyc2VGbG9hdCIsIlJiIiwia2EiLCJTYiIsIlRiIiwiT2JqZWN0IiwiU3RyaW5nIiwidXRpbCIsInRocm90dGxlIiwiY2xlYXJUaW1lb3V0IiwiZXNjYXBlUmVnZXgiLCJVYiIsImRjIiwiY29udGV4dCIsInNlbGVjdG9yIiwiY29scyIsIm9wdHMiLCJBcGkiLCJhbnkiLCJjb3VudCIsIml0ZXJhdG9yIiwiRGEiLCJsYXN0SW5kZXhPZiIsInBsdWNrIiwicG9wIiwicmVkdWNlIiwicmVkdWNlUmlnaHQiLCJzaGlmdCIsInRvJCIsInRvSlF1ZXJ5IiwidW5zaGlmdCIsIl9fZHRfd3JhcHBlciIsIm1ldGhvZEV4dCIsInByb3BFeHQiLCJyZWdpc3RlciIsInJlZ2lzdGVyUGx1cmFsIiwiVmIiLCJ0YWJsZXMiLCJpbmZvIiwicGFnZXMiLCJlbmQiLCJyZWNvcmRzRGlzcGxheSIsInNlcnZlclNpZGUiLCJXYiIsIm9uZSIsImFib3J0IiwiYmIiLCJjYiIsImRiIiwiY2xvc2VzdCIsImViIiwiX2RldGFpbHMiLCJfZGV0YWlsc1Nob3ciLCJYYiIsImluc2VydEFmdGVyIiwib2ZmIiwiZWMiLCJZYiIsInNlbGVjdGVkIiwidmVyc2lvbkNoZWNrIiwidmVyc2lvbiIsImlzRGF0YVRhYmxlIiwiZm5Jc0RhdGFUYWJsZSIsImdldCIsImZuVGFibGVzIiwiaXMiLCJjYW1lbFRvSHVuZ2FyaWFuIiwiYlNjcm9sbENvbGxhcHNlIiwiSlNPTiIsInBhcnNlIiwic2Vzc2lvblN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwibG9jYXRpb24iLCJwYXRobmFtZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJvUGFnaW5hdGUiLCJzRmlyc3QiLCJzTGFzdCIsInNOZXh0Iiwic1ByZXZpb3VzIiwic1Njcm9sbFhJbm5lciIsInNTY3JvbGxZIiwiYW9Sb3dDYWxsYmFjayIsImFvSGVhZGVyQ2FsbGJhY2siLCJhb0Zvb3RlckNhbGxiYWNrIiwiYW9Sb3dDcmVhdGVkQ2FsbGJhY2siLCJhb1ByZURyYXdDYWxsYmFjayIsImFvSW5pdENvbXBsZXRlIiwiYW9TdGF0ZVNhdmVQYXJhbXMiLCJhb1N0YXRlTG9hZFBhcmFtcyIsImFvU3RhdGVMb2FkZWQiLCJhb09wZW5Sb3dzIiwiYW9TdGF0ZVNhdmUiLCJhb1N0YXRlTG9hZCIsImFvU2VydmVyUGFyYW1zIiwiYW9EZXN0cm95Q2FsbGJhY2siLCJtaW4iLCJvUGx1Z2lucyIsImJ1dHRvbnMiLCJidWlsZGVyIiwicGFnZUJ1dHRvbiIsImhlYWRlciIsIm9KVUlDbGFzc2VzIiwic1ZlcnNpb24iLCJhZm5GaWx0ZXJpbmciLCJhVHlwZXMiLCJvZm5TZWFyY2giLCJvU29ydCIsImFmblNvcnREYXRhIiwiYW9GZWF0dXJlcyIsIm9TdGRDbGFzc2VzIiwib1BhZ2luYXRpb24iLCJzUGFnZUJ1dHRvbiIsInNQYWdlQnV0dG9uQWN0aXZlIiwic1BhZ2VCdXR0b25EaXNhYmxlZCIsInNTb3J0QXNjIiwic1NvcnREZXNjIiwic1NvcnRKVUlBc2MiLCJzU29ydEpVSURlc2MiLCJzU29ydEpVSVdyYXBwZXIiLCJzU29ydEljb24iLCJzaW1wbGUiLCJmdWxsIiwibnVtYmVycyIsInNpbXBsZV9udW1iZXJzIiwiZnVsbF9udW1iZXJzIiwiZmlyc3RfbGFzdF9udW1iZXJzIiwiX251bWJlcnMiLCJwYWdpbmF0ZSIsImFjdGlvbiIsInRhYmluZGV4IiwiZW1wdHkiLCJzdHJpbmciLCJJbmZpbml0eSIsImpxdWVyeXVpIiwiY29udGVudHMiLCJmYiIsInJlbmRlciIsIm51bWJlciIsImRpc3BsYXkiLCJ0b0ZpeGVkIiwiYWJzIiwidGV4dCIsIl9mbkV4dGVybkFwaUZ1bmMiLCJfZm5CdWlsZEFqYXgiLCJfZm5BamF4VXBkYXRlIiwiX2ZuQWpheFBhcmFtZXRlcnMiLCJfZm5BamF4VXBkYXRlRHJhdyIsIl9mbkFqYXhEYXRhU3JjIiwiX2ZuQWRkQ29sdW1uIiwiX2ZuQ29sdW1uT3B0aW9ucyIsIl9mbkFkanVzdENvbHVtblNpemluZyIsIl9mblZpc2libGVUb0NvbHVtbkluZGV4IiwiX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUiLCJfZm5WaXNibGVDb2x1bW5zIiwiX2ZuR2V0Q29sdW1ucyIsIl9mbkNvbHVtblR5cGVzIiwiX2ZuQXBwbHlDb2x1bW5EZWZzIiwiX2ZuSHVuZ2FyaWFuTWFwIiwiX2ZuQ2FtZWxUb0h1bmdhcmlhbiIsIl9mbkxhbmd1YWdlQ29tcGF0IiwiX2ZuQnJvd3NlckRldGVjdCIsIl9mbkFkZERhdGEiLCJfZm5BZGRUciIsIl9mbk5vZGVUb0RhdGFJbmRleCIsIl9mbk5vZGVUb0NvbHVtbkluZGV4IiwiX2ZuR2V0Q2VsbERhdGEiLCJfZm5TZXRDZWxsRGF0YSIsIl9mblNwbGl0T2JqTm90YXRpb24iLCJfZm5HZXRPYmplY3REYXRhRm4iLCJfZm5TZXRPYmplY3REYXRhRm4iLCJfZm5HZXREYXRhTWFzdGVyIiwiX2ZuQ2xlYXJUYWJsZSIsIl9mbkRlbGV0ZUluZGV4IiwiX2ZuSW52YWxpZGF0ZSIsIl9mbkdldFJvd0VsZW1lbnRzIiwiX2ZuQ3JlYXRlVHIiLCJfZm5CdWlsZEhlYWQiLCJfZm5EcmF3SGVhZCIsIl9mbkRyYXciLCJfZm5SZURyYXciLCJfZm5BZGRPcHRpb25zSHRtbCIsIl9mbkRldGVjdEhlYWRlciIsIl9mbkdldFVuaXF1ZVRocyIsIl9mbkZlYXR1cmVIdG1sRmlsdGVyIiwiX2ZuRmlsdGVyQ29tcGxldGUiLCJfZm5GaWx0ZXJDdXN0b20iLCJfZm5GaWx0ZXJDb2x1bW4iLCJfZm5GaWx0ZXIiLCJfZm5GaWx0ZXJDcmVhdGVTZWFyY2giLCJfZm5Fc2NhcGVSZWdleCIsIl9mbkZpbHRlckRhdGEiLCJfZm5GZWF0dXJlSHRtbEluZm8iLCJfZm5VcGRhdGVJbmZvIiwiX2ZuSW5mb01hY3JvcyIsIl9mbkluaXRpYWxpc2UiLCJfZm5Jbml0Q29tcGxldGUiLCJfZm5MZW5ndGhDaGFuZ2UiLCJfZm5GZWF0dXJlSHRtbExlbmd0aCIsIl9mbkZlYXR1cmVIdG1sUGFnaW5hdGUiLCJfZm5QYWdlQ2hhbmdlIiwiX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nIiwiX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkiLCJfZm5GZWF0dXJlSHRtbFRhYmxlIiwiX2ZuU2Nyb2xsRHJhdyIsIl9mbkFwcGx5VG9DaGlsZHJlbiIsIl9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyIsIl9mblRocm90dGxlIiwiX2ZuQ29udmVydFRvV2lkdGgiLCJfZm5HZXRXaWRlc3ROb2RlIiwiX2ZuR2V0TWF4TGVuU3RyaW5nIiwiX2ZuU3RyaW5nVG9Dc3MiLCJfZm5Tb3J0RmxhdHRlbiIsIl9mblNvcnQiLCJfZm5Tb3J0QXJpYSIsIl9mblNvcnRMaXN0ZW5lciIsIl9mblNvcnRBdHRhY2hMaXN0ZW5lciIsIl9mblNvcnRpbmdDbGFzc2VzIiwiX2ZuU29ydERhdGEiLCJfZm5TYXZlU3RhdGUiLCJfZm5Mb2FkU3RhdGUiLCJfZm5TZXR0aW5nc0Zyb21Ob2RlIiwiX2ZuTG9nIiwiX2ZuTWFwIiwiX2ZuQmluZEFjdGlvbiIsIl9mbkNhbGxiYWNrUmVnIiwiX2ZuQ2FsbGJhY2tGaXJlIiwiX2ZuTGVuZ3RoT3ZlcmZsb3ciLCJfZm5SZW5kZXJlciIsIl9mbkRhdGFTb3VyY2UiLCJfZm5Sb3dBdHRyaWJ1dGVzIiwiX2ZuRXh0ZW5kIiwiX2ZuQ2FsY3VsYXRlRW5kIiwiZGF0YVRhYmxlU2V0dGluZ3MiLCJkYXRhVGFibGVFeHQiLCJEYXRhVGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/datatables/jquery.dataTables.min.js\n");

/***/ }),

/***/ "./resources/vendor/slider-range/js/draggable-0.1.js":
/*!***********************************************************!*\
  !*** ./resources/vendor/slider-range/js/draggable-0.1.js ***!
  \***********************************************************/
/***/ (() => {

eval("/**\n * draggable - Class allows to make any element draggable\n * \n * Written by\n * Egor Khmelev (hmelyoff@gmail.com)\n *\n * Licensed under the MIT (MIT-LICENSE.txt).\n *\n * @author Egor Khmelev\n * @version 0.1.0-BETA ($Id$)\n * \n **/\n(function ($) {\n  function Draggable() {\n    this._init.apply(this, arguments);\n  }\n\n  ;\n\n  Draggable.prototype.oninit = function () {};\n\n  Draggable.prototype.events = function () {};\n\n  Draggable.prototype.onmousedown = function () {\n    this.ptr.css({\n      position: \"absolute\"\n    });\n  };\n\n  Draggable.prototype.onmousemove = function (evt, x, y) {\n    this.ptr.css({\n      left: x,\n      top: y\n    });\n  };\n\n  Draggable.prototype.onmouseup = function () {};\n\n  Draggable.prototype.isDefault = {\n    drag: false,\n    clicked: false,\n    toclick: true,\n    mouseup: false\n  };\n\n  Draggable.prototype._init = function () {\n    if (arguments.length > 0) {\n      this.ptr = $(arguments[0]);\n      this.outer = $(\".draggable-outer\");\n      this.is = {};\n      $.extend(this.is, this.isDefault);\n\n      var _offset = this.ptr.offset();\n\n      this.d = {\n        left: _offset.left,\n        top: _offset.top,\n        width: this.ptr.width(),\n        height: this.ptr.height()\n      };\n      this.oninit.apply(this, arguments);\n\n      this._events();\n    }\n  };\n\n  Draggable.prototype._getPageCoords = function (event) {\n    if (event.targetTouches && event.targetTouches[0]) {\n      return {\n        x: event.targetTouches[0].pageX,\n        y: event.targetTouches[0].pageY\n      };\n    } else return {\n      x: event.pageX,\n      y: event.pageY\n    };\n  };\n\n  Draggable.prototype._bindEvent = function (ptr, eventType, handler) {\n    var self = this;\n    if (this.supportTouches_) ptr.get(0).addEventListener(this.events_[eventType], handler, false);else ptr.bind(this.events_[eventType], handler);\n  };\n\n  Draggable.prototype._events = function () {\n    var self = this;\n    this.supportTouches_ = 'ontouchend' in document;\n    this.events_ = {\n      \"click\": this.supportTouches_ ? \"touchstart\" : \"click\",\n      \"down\": this.supportTouches_ ? \"touchstart\" : \"mousedown\",\n      \"move\": this.supportTouches_ ? \"touchmove\" : \"mousemove\",\n      \"up\": this.supportTouches_ ? \"touchend\" : \"mouseup\"\n    };\n\n    this._bindEvent($(document), \"move\", function (event) {\n      if (self.is.drag) {\n        event.stopPropagation();\n        event.preventDefault();\n\n        self._mousemove(event);\n      }\n    });\n\n    this._bindEvent($(document), \"down\", function (event) {\n      if (self.is.drag) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    });\n\n    this._bindEvent($(document), \"up\", function (event) {\n      self._mouseup(event);\n    });\n\n    this._bindEvent(this.ptr, \"down\", function (event) {\n      self._mousedown(event);\n\n      return false;\n    });\n\n    this._bindEvent(this.ptr, \"up\", function (event) {\n      self._mouseup(event);\n    });\n\n    this.ptr.find(\"a\").click(function () {\n      self.is.clicked = true;\n\n      if (!self.is.toclick) {\n        self.is.toclick = true;\n        return false;\n      }\n    }).mousedown(function (event) {\n      self._mousedown(event);\n\n      return false;\n    });\n    this.events();\n  };\n\n  Draggable.prototype._mousedown = function (evt) {\n    this.is.drag = true;\n    this.is.clicked = false;\n    this.is.mouseup = false;\n\n    var _offset = this.ptr.offset();\n\n    var coords = this._getPageCoords(evt);\n\n    this.cx = coords.x - _offset.left;\n    this.cy = coords.y - _offset.top;\n    $.extend(this.d, {\n      left: _offset.left,\n      top: _offset.top,\n      width: this.ptr.width(),\n      height: this.ptr.height()\n    });\n\n    if (this.outer && this.outer.get(0)) {\n      this.outer.css({\n        height: Math.max(this.outer.height(), $(document.body).height()),\n        overflow: \"hidden\"\n      });\n    }\n\n    this.onmousedown(evt);\n  };\n\n  Draggable.prototype._mousemove = function (evt) {\n    this.is.toclick = false;\n\n    var coords = this._getPageCoords(evt);\n\n    this.onmousemove(evt, coords.x - this.cx, coords.y - this.cy);\n  };\n\n  Draggable.prototype._mouseup = function (evt) {\n    var oThis = this;\n\n    if (this.is.drag) {\n      this.is.drag = false;\n\n      if (this.outer && this.outer.get(0)) {\n        if ($.browser.mozilla) {\n          this.outer.css({\n            overflow: \"hidden\"\n          });\n        } else {\n          this.outer.css({\n            overflow: \"visible\"\n          });\n        }\n\n        if ($.browser.msie && $.browser.version == '6.0') {\n          this.outer.css({\n            height: \"100%\"\n          });\n        } else {\n          this.outer.css({\n            height: \"auto\"\n          });\n        }\n      }\n\n      this.onmouseup(evt);\n    }\n  };\n\n  window.Draggable = Draggable;\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL3NsaWRlci1yYW5nZS9qcy9kcmFnZ2FibGUtMC4xLmpzPzM3YTYiXSwibmFtZXMiOlsiJCIsIkRyYWdnYWJsZSIsIl9pbml0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwcm90b3R5cGUiLCJvbmluaXQiLCJldmVudHMiLCJvbm1vdXNlZG93biIsInB0ciIsImNzcyIsInBvc2l0aW9uIiwib25tb3VzZW1vdmUiLCJldnQiLCJ4IiwieSIsImxlZnQiLCJ0b3AiLCJvbm1vdXNldXAiLCJpc0RlZmF1bHQiLCJkcmFnIiwiY2xpY2tlZCIsInRvY2xpY2siLCJtb3VzZXVwIiwibGVuZ3RoIiwib3V0ZXIiLCJpcyIsImV4dGVuZCIsIl9vZmZzZXQiLCJvZmZzZXQiLCJkIiwid2lkdGgiLCJoZWlnaHQiLCJfZXZlbnRzIiwiX2dldFBhZ2VDb29yZHMiLCJldmVudCIsInRhcmdldFRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiX2JpbmRFdmVudCIsImV2ZW50VHlwZSIsImhhbmRsZXIiLCJzZWxmIiwic3VwcG9ydFRvdWNoZXNfIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50c18iLCJiaW5kIiwiZG9jdW1lbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIl9tb3VzZW1vdmUiLCJfbW91c2V1cCIsIl9tb3VzZWRvd24iLCJmaW5kIiwiY2xpY2siLCJtb3VzZWRvd24iLCJjb29yZHMiLCJjeCIsImN5IiwiTWF0aCIsIm1heCIsImJvZHkiLCJvdmVyZmxvdyIsIm9UaGlzIiwiYnJvd3NlciIsIm1vemlsbGEiLCJtc2llIiwidmVyc2lvbiIsIndpbmRvdyIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFVQSxDQUFWLEVBQWE7QUFFWixXQUFTQyxTQUFULEdBQW9C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LFlBQUkvRCxDQUFDLENBQUNpRSxPQUFGLENBQVVFLElBQVYsSUFBa0JuRSxDQUFDLENBQUNpRSxPQUFGLENBQVVHLE9BQVYsSUFBcUIsS0FBM0MsRUFBa0Q7QUFDakQsZUFBSzNDLEtBQUwsQ0FBV2YsR0FBWCxDQUFlO0FBQUVzQixZQUFBQSxNQUFNLEVBQUU7QUFBVixXQUFmO0FBQ0EsU0FGRCxNQUVPO0FBQ04sZUFBS1AsS0FBTCxDQUFXZixHQUFYLENBQWU7QUFBRXNCLFlBQUFBLE1BQU0sRUFBRTtBQUFWLFdBQWY7QUFDQTtBQUNMOztBQUVELFdBQUtkLFNBQUwsQ0FBZ0JMLEdBQWhCO0FBQ0E7QUFDRCxHQXZCRDs7QUF5QkF3RCxFQUFBQSxNQUFNLENBQUNwRSxTQUFQLEdBQW1CQSxTQUFuQjtBQUVBLENBdExELEVBc0xJcUUsTUF0TEoiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRyYWdnYWJsZSAtIENsYXNzIGFsbG93cyB0byBtYWtlIGFueSBlbGVtZW50IGRyYWdnYWJsZVxuICogXG4gKiBXcml0dGVuIGJ5XG4gKiBFZ29yIEtobWVsZXYgKGhtZWx5b2ZmQGdtYWlsLmNvbSlcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIChNSVQtTElDRU5TRS50eHQpLlxuICpcbiAqIEBhdXRob3IgRWdvciBLaG1lbGV2XG4gKiBAdmVyc2lvbiAwLjEuMC1CRVRBICgkSWQkKVxuICogXG4gKiovXG5cbihmdW5jdGlvbiggJCApe1xuXG4gIGZ1bmN0aW9uIERyYWdnYWJsZSgpe1xuICBcdHRoaXMuX2luaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICB9O1xuXG5cdERyYWdnYWJsZS5wcm90b3R5cGUub25pbml0ID0gZnVuY3Rpb24oKXtcblx0ICBcblx0fTtcblx0XG5cdERyYWdnYWJsZS5wcm90b3R5cGUuZXZlbnRzID0gZnVuY3Rpb24oKXtcblx0ICBcblx0fTtcblx0XG5cdERyYWdnYWJsZS5wcm90b3R5cGUub25tb3VzZWRvd24gPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMucHRyLmNzcyh7IHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSk7XG5cdH07XG5cdFxuXHREcmFnZ2FibGUucHJvdG90eXBlLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2dCwgeCwgeSApe1xuXHRcdHRoaXMucHRyLmNzcyh7IGxlZnQ6IHgsIHRvcDogeSB9KTtcblx0fTtcblx0XG5cdERyYWdnYWJsZS5wcm90b3R5cGUub25tb3VzZXVwID0gZnVuY3Rpb24oKXtcblx0ICBcblx0fTtcblxuXHREcmFnZ2FibGUucHJvdG90eXBlLmlzRGVmYXVsdCA9IHtcblx0XHRkcmFnOiBmYWxzZSxcblx0XHRjbGlja2VkOiBmYWxzZSxcblx0XHR0b2NsaWNrOiB0cnVlLFxuXHRcdG1vdXNldXA6IGZhbHNlXG5cdH07XG5cblx0RHJhZ2dhYmxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCl7XG5cdFx0aWYoIGFyZ3VtZW50cy5sZW5ndGggPiAwICl7XG5cdFx0XHR0aGlzLnB0ciA9ICQoYXJndW1lbnRzWzBdKTtcblx0XHRcdHRoaXMub3V0ZXIgPSAkKFwiLmRyYWdnYWJsZS1vdXRlclwiKTtcblxuXHRcdFx0dGhpcy5pcyA9IHt9O1xuXHRcdFx0JC5leHRlbmQoIHRoaXMuaXMsIHRoaXMuaXNEZWZhdWx0ICk7XG5cblx0XHRcdHZhciBfb2Zmc2V0ID0gdGhpcy5wdHIub2Zmc2V0KCk7XG5cdFx0XHR0aGlzLmQgPSB7XG5cdFx0XHRcdGxlZnQ6IF9vZmZzZXQubGVmdCxcblx0XHRcdFx0dG9wOiBfb2Zmc2V0LnRvcCxcblx0XHRcdFx0d2lkdGg6IHRoaXMucHRyLndpZHRoKCksXG5cdFx0XHRcdGhlaWdodDogdGhpcy5wdHIuaGVpZ2h0KClcblx0XHRcdH07XG5cblx0XHRcdHRoaXMub25pbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0dGhpcy5fZXZlbnRzKCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0RHJhZ2dhYmxlLnByb3RvdHlwZS5fZ2V0UGFnZUNvb3JkcyA9IGZ1bmN0aW9uKCBldmVudCApe1xuXHQgIGlmKCBldmVudC50YXJnZXRUb3VjaGVzICYmIGV2ZW50LnRhcmdldFRvdWNoZXNbMF0gKXtcblx0ICAgIHJldHVybiB7IHg6IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsIHk6IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgfTtcblx0ICB9IGVsc2Vcblx0ICAgIHJldHVybiB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xuXHR9O1xuXHRcblx0RHJhZ2dhYmxlLnByb3RvdHlwZS5fYmluZEV2ZW50ID0gZnVuY3Rpb24oIHB0ciwgZXZlbnRUeXBlLCBoYW5kbGVyICl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgaWYoIHRoaXMuc3VwcG9ydFRvdWNoZXNfIClcbiAgICAgIHB0ci5nZXQoMCkuYWRkRXZlbnRMaXN0ZW5lciggdGhpcy5ldmVudHNfWyBldmVudFR5cGUgXSwgaGFuZGxlciwgZmFsc2UgKTtcblx0ICBcblx0ICBlbHNlXG5cdCAgICBwdHIuYmluZCggdGhpcy5ldmVudHNfWyBldmVudFR5cGUgXSwgaGFuZGxlciApO1xuXHR9O1xuXHRcblx0RHJhZ2dhYmxlLnByb3RvdHlwZS5fZXZlbnRzID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnN1cHBvcnRUb3VjaGVzXyA9ICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudDtcbiAgICB0aGlzLmV2ZW50c18gPSB7XG4gICAgICBcImNsaWNrXCI6IHRoaXMuc3VwcG9ydFRvdWNoZXNfID8gXCJ0b3VjaHN0YXJ0XCIgOiBcImNsaWNrXCIsXG4gICAgICBcImRvd25cIjogdGhpcy5zdXBwb3J0VG91Y2hlc18gPyBcInRvdWNoc3RhcnRcIiA6IFwibW91c2Vkb3duXCIsXG4gICAgICBcIm1vdmVcIjogdGhpcy5zdXBwb3J0VG91Y2hlc18gPyBcInRvdWNobW92ZVwiIDogXCJtb3VzZW1vdmVcIixcbiAgICAgIFwidXBcIiAgOiB0aGlzLnN1cHBvcnRUb3VjaGVzXyA/IFwidG91Y2hlbmRcIiA6IFwibW91c2V1cFwiXG4gICAgfTtcblxuICAgIHRoaXMuX2JpbmRFdmVudCggJCggZG9jdW1lbnQgKSwgXCJtb3ZlXCIsIGZ1bmN0aW9uKCBldmVudCApe1xuXHRcdFx0aWYoIHNlbGYuaXMuZHJhZyApe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0c2VsZi5fbW91c2Vtb3ZlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuICAgIHRoaXMuX2JpbmRFdmVudCggJCggZG9jdW1lbnQgKSwgXCJkb3duXCIsIGZ1bmN0aW9uKCBldmVudCApe1xuXHRcdFx0aWYoIHNlbGYuaXMuZHJhZyApe1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9KTtcbiAgICB0aGlzLl9iaW5kRXZlbnQoICQoIGRvY3VtZW50ICksIFwidXBcIiwgZnVuY3Rpb24oIGV2ZW50ICl7XG5cdFx0XHRzZWxmLl9tb3VzZXVwKCBldmVudCApO1xuXHRcdH0pO1xuXHRcdFxuICAgIHRoaXMuX2JpbmRFdmVudCggdGhpcy5wdHIsIFwiZG93blwiLCBmdW5jdGlvbiggZXZlbnQgKXtcblx0XHRcdHNlbGYuX21vdXNlZG93biggZXZlbnQgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9KTtcbiAgICB0aGlzLl9iaW5kRXZlbnQoIHRoaXMucHRyLCBcInVwXCIsIGZ1bmN0aW9uKCBldmVudCApe1xuXHRcdFx0c2VsZi5fbW91c2V1cCggZXZlbnQgKTtcblx0XHR9KTtcblx0XHRcblx0XHR0aGlzLnB0ci5maW5kKFwiYVwiKVxuXHRcdFx0LmNsaWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHNlbGYuaXMuY2xpY2tlZCA9IHRydWU7XG5cblx0XHRcdFx0aWYoICFzZWxmLmlzLnRvY2xpY2sgKXtcblx0XHRcdFx0XHRzZWxmLmlzLnRvY2xpY2sgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5tb3VzZWRvd24oZnVuY3Rpb24oIGV2ZW50ICl7XG5cdFx0XHRcdHNlbGYuX21vdXNlZG93biggZXZlbnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSk7XG5cblx0XHR0aGlzLmV2ZW50cygpO1xuXHR9O1xuXHRcblx0RHJhZ2dhYmxlLnByb3RvdHlwZS5fbW91c2Vkb3duID0gZnVuY3Rpb24oIGV2dCApe1xuXHRcdHRoaXMuaXMuZHJhZyA9IHRydWU7XG5cdFx0dGhpcy5pcy5jbGlja2VkID0gZmFsc2U7XG5cdFx0dGhpcy5pcy5tb3VzZXVwID0gZmFsc2U7XG5cblx0XHR2YXIgX29mZnNldCA9IHRoaXMucHRyLm9mZnNldCgpO1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl9nZXRQYWdlQ29vcmRzKCBldnQgKTtcblx0XHR0aGlzLmN4ID0gY29vcmRzLnggLSBfb2Zmc2V0LmxlZnQ7XG5cdFx0dGhpcy5jeSA9IGNvb3Jkcy55IC0gX29mZnNldC50b3A7XG5cblx0XHQkLmV4dGVuZCh0aGlzLmQsIHtcblx0XHRcdGxlZnQ6IF9vZmZzZXQubGVmdCxcblx0XHRcdHRvcDogX29mZnNldC50b3AsXG5cdFx0XHR3aWR0aDogdGhpcy5wdHIud2lkdGgoKSxcblx0XHRcdGhlaWdodDogdGhpcy5wdHIuaGVpZ2h0KClcblx0XHR9KTtcblxuXHRcdGlmKCB0aGlzLm91dGVyICYmIHRoaXMub3V0ZXIuZ2V0KDApICl7XG5cdFx0XHR0aGlzLm91dGVyLmNzcyh7IGhlaWdodDogTWF0aC5tYXgodGhpcy5vdXRlci5oZWlnaHQoKSwgJChkb2N1bWVudC5ib2R5KS5oZWlnaHQoKSksIG92ZXJmbG93OiBcImhpZGRlblwiIH0pO1xuXHRcdH1cblxuXHRcdHRoaXMub25tb3VzZWRvd24oIGV2dCApO1xuXHR9O1xuXHRcblx0RHJhZ2dhYmxlLnByb3RvdHlwZS5fbW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2dCApe1xuXHRcdHRoaXMuaXMudG9jbGljayA9IGZhbHNlO1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl9nZXRQYWdlQ29vcmRzKCBldnQgKTtcblx0XHR0aGlzLm9ubW91c2Vtb3ZlKCBldnQsIGNvb3Jkcy54IC0gdGhpcy5jeCwgY29vcmRzLnkgLSB0aGlzLmN5ICk7XG5cdH07XG5cdFxuXHREcmFnZ2FibGUucHJvdG90eXBlLl9tb3VzZXVwID0gZnVuY3Rpb24oIGV2dCApe1xuXHRcdHZhciBvVGhpcyA9IHRoaXM7XG5cblx0XHRpZiggdGhpcy5pcy5kcmFnICl7XG5cdFx0XHR0aGlzLmlzLmRyYWcgPSBmYWxzZTtcblxuXHRcdFx0aWYoIHRoaXMub3V0ZXIgJiYgdGhpcy5vdXRlci5nZXQoMCkgKXtcblxuXHRcdFx0XHRpZiggJC5icm93c2VyLm1vemlsbGEgKXtcblx0XHRcdFx0XHR0aGlzLm91dGVyLmNzcyh7IG92ZXJmbG93OiBcImhpZGRlblwiIH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMub3V0ZXIuY3NzKHsgb3ZlcmZsb3c6IFwidmlzaWJsZVwiIH0pO1xuXHRcdFx0XHR9XG5cbiAgICAgICAgaWYoICQuYnJvd3Nlci5tc2llICYmICQuYnJvd3Nlci52ZXJzaW9uID09ICc2LjAnICl7XG4gICAgICAgICB0aGlzLm91dGVyLmNzcyh7IGhlaWdodDogXCIxMDAlXCIgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aGlzLm91dGVyLmNzcyh7IGhlaWdodDogXCJhdXRvXCIgfSk7XG4gICAgICAgIH0gIFxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9ubW91c2V1cCggZXZ0ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0d2luZG93LkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcblxufSkoIGpRdWVyeSApO1xuIl0sImZpbGUiOiIuL3Jlc291cmNlcy92ZW5kb3Ivc2xpZGVyLXJhbmdlL2pzL2RyYWdnYWJsZS0wLjEuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/vendor/slider-range/js/draggable-0.1.js\n");

/***/ }),

/***/ "./resources/vendor/slider-range/js/jquery.dependClass-0.1.js":
/*!********************************************************************!*\
  !*** ./resources/vendor/slider-range/js/jquery.dependClass-0.1.js ***!
  \********************************************************************/
/***/ (() => {

eval("/**\n * jquery.dependClass - Attach class based on first class in list of current element\n * \n * Written by\n * Egor Khmelev (hmelyoff@gmail.com)\n *\n * Licensed under the MIT (MIT-LICENSE.txt).\n *\n * @author Egor Khmelev\n * @version 0.1.0-BETA ($Id$)\n * \n **/\n(function ($) {\n  $.baseClass = function (obj) {\n    obj = $(obj);\n    return obj.get(0).className.match(/([^ ]+)/)[1];\n  };\n\n  $.fn.addDependClass = function (className, delimiter) {\n    var options = {\n      delimiter: delimiter ? delimiter : '-'\n    };\n    return this.each(function () {\n      var baseClass = $.baseClass(this);\n      if (baseClass) $(this).addClass(baseClass + options.delimiter + className);\n    });\n  };\n\n  $.fn.removeDependClass = function (className, delimiter) {\n    var options = {\n      delimiter: delimiter ? delimiter : '-'\n    };\n    return this.each(function () {\n      var baseClass = $.baseClass(this);\n      if (baseClass) $(this).removeClass(baseClass + options.delimiter + className);\n    });\n  };\n\n  $.fn.toggleDependClass = function (className, delimiter) {\n    var options = {\n      delimiter: delimiter ? delimiter : '-'\n    };\n    return this.each(function () {\n      var baseClass = $.baseClass(this);\n      if (baseClass) if ($(this).is(\".\" + baseClass + options.delimiter + className)) $(this).removeClass(baseClass + options.delimiter + className);else $(this).addClass(baseClass + options.delimiter + className);\n    });\n  };\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL3NsaWRlci1yYW5nZS9qcy9qcXVlcnkuZGVwZW5kQ2xhc3MtMC4xLmpzP2M4YmEiXSwibmFtZXMiOlsiJCIsImJhc2VDbGFzcyIsIm9iaiIsImdldCIsImNsYXNzTmFtZSIsIm1hdGNoIiwiZm4iLCJhZGREZXBlbmRDbGFzcyIsImRlbGltaXRlciIsIm9wdGlvbnMiLCJlYWNoIiwiYWRkQ2xhc3MiLCJyZW1vdmVEZXBlbmRDbGFzcyIsInJlbW92ZUNsYXNzIiwidG9nZ2xlRGVwZW5kQ2xhc3MiLCJpcyIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVk7QUFDWkEsRUFBQUEsQ0FBQyxDQUFDQyxTQUFGLEdBQWMsVUFBU0MsR0FBVCxFQUFhO0FBQ3pCQSxJQUFBQSxHQUFHLEdBQUdGLENBQUMsQ0FBQ0UsR0FBRCxDQUFQO0FBQ0EsV0FBT0EsR0FBRyxDQUFDQyxHQUFKLENBQVEsQ0FBUixFQUFXQyxTQUFYLENBQXFCQyxLQUFyQixDQUEyQixTQUEzQixFQUFzQyxDQUF0QyxDQUFQO0FBQ0QsR0FIRDs7QUFLQUwsRUFBQUEsQ0FBQyxDQUFDTSxFQUFGLENBQUtDLGNBQUwsR0FBc0IsVUFBU0gsU0FBVCxFQUFvQkksU0FBcEIsRUFBOEI7QUFDbkQsUUFBSUMsT0FBTyxHQUFHO0FBQ1pELE1BQUFBLFNBQVMsRUFBRUEsU0FBUyxHQUFHQSxTQUFILEdBQWU7QUFEdkIsS0FBZDtBQUdBLFdBQU8sS0FBS0UsSUFBTCxDQUFVLFlBQVU7QUFDekIsVUFBSVQsU0FBUyxHQUFHRCxDQUFDLENBQUNDLFNBQUYsQ0FBWSxJQUFaLENBQWhCO0FBQ0EsVUFBR0EsU0FBSCxFQUNFRCxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFXLFFBQVIsQ0FBaUJWLFNBQVMsR0FBR1EsT0FBTyxDQUFDRCxTQUFwQixHQUFnQ0osU0FBakQ7QUFDSCxLQUpNLENBQVA7QUFLQSxHQVREOztBQVdBSixFQUFBQSxDQUFDLENBQUNNLEVBQUYsQ0FBS00saUJBQUwsR0FBeUIsVUFBU1IsU0FBVCxFQUFvQkksU0FBcEIsRUFBOEI7QUFDdEQsUUFBSUMsT0FBTyxHQUFHO0FBQ1pELE1BQUFBLFNBQVMsRUFBRUEsU0FBUyxHQUFHQSxTQUFILEdBQWU7QUFEdkIsS0FBZDtBQUdBLFdBQU8sS0FBS0UsSUFBTCxDQUFVLFlBQVU7QUFDekIsVUFBSVQsU0FBUyxHQUFHRCxDQUFDLENBQUNDLFNBQUYsQ0FBWSxJQUFaLENBQWhCO0FBQ0EsVUFBR0EsU0FBSCxFQUNFRCxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFhLFdBQVIsQ0FBb0JaLFNBQVMsR0FBR1EsT0FBTyxDQUFDRCxTQUFwQixHQUFnQ0osU0FBcEQ7QUFDSCxLQUpNLENBQVA7QUFLQSxHQVREOztBQVdBSixFQUFBQSxDQUFDLENBQUNNLEVBQUYsQ0FBS1EsaUJBQUwsR0FBeUIsVUFBU1YsU0FBVCxFQUFvQkksU0FBcEIsRUFBOEI7QUFDdEQsUUFBSUMsT0FBTyxHQUFHO0FBQ1pELE1BQUFBLFNBQVMsRUFBRUEsU0FBUyxHQUFHQSxTQUFILEdBQWU7QUFEdkIsS0FBZDtBQUdBLFdBQU8sS0FBS0UsSUFBTCxDQUFVLFlBQVU7QUFDekIsVUFBSVQsU0FBUyxHQUFHRCxDQUFDLENBQUNDLFNBQUYsQ0FBWSxJQUFaLENBQWhCO0FBQ0EsVUFBR0EsU0FBSCxFQUNFLElBQUdELENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWUsRUFBUixDQUFXLE1BQU1kLFNBQU4sR0FBa0JRLE9BQU8sQ0FBQ0QsU0FBMUIsR0FBc0NKLFNBQWpELENBQUgsRUFDRUosQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRYSxXQUFSLENBQW9CWixTQUFTLEdBQUdRLE9BQU8sQ0FBQ0QsU0FBcEIsR0FBZ0NKLFNBQXBELEVBREYsS0FHRUosQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRVyxRQUFSLENBQWlCVixTQUFTLEdBQUdRLE9BQU8sQ0FBQ0QsU0FBcEIsR0FBZ0NKLFNBQWpEO0FBQ0wsS0FQTSxDQUFQO0FBUUEsR0FaRDtBQWNBLENBMUNELEVBMENHWSxNQTFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICoganF1ZXJ5LmRlcGVuZENsYXNzIC0gQXR0YWNoIGNsYXNzIGJhc2VkIG9uIGZpcnN0IGNsYXNzIGluIGxpc3Qgb2YgY3VycmVudCBlbGVtZW50XG4gKiBcbiAqIFdyaXR0ZW4gYnlcbiAqIEVnb3IgS2htZWxldiAoaG1lbHlvZmZAZ21haWwuY29tKVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKE1JVC1MSUNFTlNFLnR4dCkuXG4gKlxuICogQGF1dGhvciBFZ29yIEtobWVsZXZcbiAqIEB2ZXJzaW9uIDAuMS4wLUJFVEEgKCRJZCQpXG4gKiBcbiAqKi9cblxuKGZ1bmN0aW9uKCQpIHtcblx0JC5iYXNlQ2xhc3MgPSBmdW5jdGlvbihvYmope1xuXHQgIG9iaiA9ICQob2JqKTtcblx0ICByZXR1cm4gb2JqLmdldCgwKS5jbGFzc05hbWUubWF0Y2goLyhbXiBdKykvKVsxXTtcblx0fTtcblx0XG5cdCQuZm4uYWRkRGVwZW5kQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUsIGRlbGltaXRlcil7XG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0ICBkZWxpbWl0ZXI6IGRlbGltaXRlciA/IGRlbGltaXRlciA6ICctJ1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0ICB2YXIgYmFzZUNsYXNzID0gJC5iYXNlQ2xhc3ModGhpcyk7XG5cdFx0ICBpZihiYXNlQ2xhc3MpXG4gICAgXHRcdCQodGhpcykuYWRkQ2xhc3MoYmFzZUNsYXNzICsgb3B0aW9ucy5kZWxpbWl0ZXIgKyBjbGFzc05hbWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdCQuZm4ucmVtb3ZlRGVwZW5kQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUsIGRlbGltaXRlcil7XG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0ICBkZWxpbWl0ZXI6IGRlbGltaXRlciA/IGRlbGltaXRlciA6ICctJ1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0ICB2YXIgYmFzZUNsYXNzID0gJC5iYXNlQ2xhc3ModGhpcyk7XG5cdFx0ICBpZihiYXNlQ2xhc3MpXG4gICAgXHRcdCQodGhpcykucmVtb3ZlQ2xhc3MoYmFzZUNsYXNzICsgb3B0aW9ucy5kZWxpbWl0ZXIgKyBjbGFzc05hbWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdCQuZm4udG9nZ2xlRGVwZW5kQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUsIGRlbGltaXRlcil7XG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0ICBkZWxpbWl0ZXI6IGRlbGltaXRlciA/IGRlbGltaXRlciA6ICctJ1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0ICB2YXIgYmFzZUNsYXNzID0gJC5iYXNlQ2xhc3ModGhpcyk7XG5cdFx0ICBpZihiYXNlQ2xhc3MpXG5cdFx0ICAgIGlmKCQodGhpcykuaXMoXCIuXCIgKyBiYXNlQ2xhc3MgKyBvcHRpb25zLmRlbGltaXRlciArIGNsYXNzTmFtZSkpXG4gICAgXHRcdCAgJCh0aGlzKS5yZW1vdmVDbGFzcyhiYXNlQ2xhc3MgKyBvcHRpb25zLmRlbGltaXRlciArIGNsYXNzTmFtZSk7XG4gICAgXHRcdGVsc2VcbiAgICBcdFx0ICAkKHRoaXMpLmFkZENsYXNzKGJhc2VDbGFzcyArIG9wdGlvbnMuZGVsaW1pdGVyICsgY2xhc3NOYW1lKTtcblx0XHR9KTtcblx0fTtcblxufSkoalF1ZXJ5KTsiXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3ZlbmRvci9zbGlkZXItcmFuZ2UvanMvanF1ZXJ5LmRlcGVuZENsYXNzLTAuMS5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/slider-range/js/jquery.dependClass-0.1.js\n");

/***/ }),

/***/ "./resources/vendor/slider-range/js/jquery.slider.js":
/*!***********************************************************!*\
  !*** ./resources/vendor/slider-range/js/jquery.slider.js ***!
  \***********************************************************/
/***/ (() => {

eval("/**\n * jquery.slider - Slider ui control in jQuery\n * \n * Written by\n * Egor Khmelev (hmelyoff@gmail.com)\n *\n * Licensed under the MIT (MIT-LICENSE.txt).\n *\n * @author Egor Khmelev\n * @version 1.1.0-RELEASE ($Id$)\n * \n * Dependencies\n * \n * jQuery (http://jquery.com)\n * jquery.numberformatter (http://code.google.com/p/jquery-numberformatter/)\n * tmpl (http://ejohn.org/blog/javascript-micro-templating/)\n * jquery.dependClass\n * draggable\n * \n **/\n(function ($) {\n  function isArray(value) {\n    if (typeof value == \"undefined\") return false;\n\n    if (value instanceof Array || !(value instanceof Object) && Object.prototype.toString.call(value) == '[object Array]' || typeof value.length == 'number' && typeof value.splice != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  $.slider = function (node, settings) {\n    var jNode = $(node);\n    if (!jNode.data(\"jslider\")) jNode.data(\"jslider\", new jSlider(node, settings));\n    return jNode.data(\"jslider\");\n  };\n\n  $.fn.slider = function (action, opt_value) {\n    var returnValue,\n        args = arguments;\n\n    function isDef(val) {\n      return val !== undefined;\n    }\n\n    ;\n\n    function isDefAndNotNull(val) {\n      return val != null;\n    }\n\n    ;\n    this.each(function () {\n      var self = $.slider(this, action); // do actions\n\n      if (typeof action == \"string\") {\n        switch (action) {\n          case \"value\":\n            if (isDef(args[1]) && isDef(args[2])) {\n              var pointers = self.getPointers();\n\n              if (isDefAndNotNull(pointers[0]) && isDefAndNotNull(args[1])) {\n                pointers[0].set(args[1]);\n                pointers[0].setIndexOver();\n              }\n\n              if (isDefAndNotNull(pointers[1]) && isDefAndNotNull(args[2])) {\n                pointers[1].set(args[2]);\n                pointers[1].setIndexOver();\n              }\n            } else if (isDef(args[1])) {\n              var pointers = self.getPointers();\n\n              if (isDefAndNotNull(pointers[0]) && isDefAndNotNull(args[1])) {\n                pointers[0].set(args[1]);\n                pointers[0].setIndexOver();\n              }\n            } else returnValue = self.getValue();\n\n            break;\n\n          case \"prc\":\n            if (isDef(args[1]) && isDef(args[2])) {\n              var pointers = self.getPointers();\n\n              if (isDefAndNotNull(pointers[0]) && isDefAndNotNull(args[1])) {\n                pointers[0]._set(args[1]);\n\n                pointers[0].setIndexOver();\n              }\n\n              if (isDefAndNotNull(pointers[1]) && isDefAndNotNull(args[2])) {\n                pointers[1]._set(args[2]);\n\n                pointers[1].setIndexOver();\n              }\n            } else if (isDef(args[1])) {\n              var pointers = self.getPointers();\n\n              if (isDefAndNotNull(pointers[0]) && isDefAndNotNull(args[1])) {\n                pointers[0]._set(args[1]);\n\n                pointers[0].setIndexOver();\n              }\n            } else returnValue = self.getPrcValue();\n\n            break;\n\n          case \"calculatedValue\":\n            var value = self.getValue().split(\";\");\n            returnValue = \"\";\n\n            for (var i = 0; i < value.length; i++) {\n              returnValue += (i > 0 ? \";\" : \"\") + self.nice(value[i]);\n            }\n\n            ;\n            break;\n\n          case \"skin\":\n            self.setSkin(args[1]);\n            break;\n        }\n\n        ;\n      } // return actual object\n      else if (!action && !opt_value) {\n        if (!isArray(returnValue)) returnValue = [];\n        returnValue.push(self);\n      }\n    }); // flatten array just with one slider\n\n    if (isArray(returnValue) && returnValue.length == 1) returnValue = returnValue[0];\n    return returnValue || this;\n  };\n\n  var OPTIONS = {\n    settings: {\n      from: 1,\n      to: 10,\n      step: 1,\n      smooth: true,\n      limits: true,\n      round: 0,\n      format: {\n        format: \"#,##0.##\"\n      },\n      value: \"5;7\",\n      dimension: \"\"\n    },\n    className: \"jslider\",\n    selector: \".jslider-\",\n    template: tmpl('<span class=\"<%=className%>\">' + '<table><tr><td>' + '<div class=\"<%=className%>-bg\">' + '<i class=\"l\"></i><i class=\"f\"></i><i class=\"r\"></i>' + '<i class=\"v\"></i>' + '</div>' + '<div class=\"<%=className%>-pointer\"></div>' + '<div class=\"<%=className%>-pointer <%=className%>-pointer-to\"></div>' + '<div class=\"<%=className%>-label\"><span><%=settings.from%></span></div>' + '<div class=\"<%=className%>-label <%=className%>-label-to\"><span><%=settings.to%></span><%=settings.dimension%></div>' + '<div class=\"<%=className%>-value\"><span></span><%=settings.dimension%></div>' + '<div class=\"<%=className%>-value <%=className%>-value-to\"><span></span><%=settings.dimension%></div>' + '<div class=\"<%=className%>-scale\"><%=scale%></div>' + '</td></tr></table>' + '</span>')\n  };\n\n  function jSlider() {\n    return this.init.apply(this, arguments);\n  }\n\n  ;\n\n  jSlider.prototype.init = function (node, settings) {\n    this.settings = $.extend(true, {}, OPTIONS.settings, settings ? settings : {}); // obj.sliderHandler = this;\n\n    this.inputNode = $(node).hide();\n    this.settings.interval = this.settings.to - this.settings.from;\n    this.settings.value = this.inputNode.attr(\"value\");\n    if (this.settings.calculate && $.isFunction(this.settings.calculate)) this.nice = this.settings.calculate;\n    if (this.settings.onstatechange && $.isFunction(this.settings.onstatechange)) this.onstatechange = this.settings.onstatechange;\n    this.is = {\n      init: false\n    };\n    this.o = {};\n    this.create();\n  };\n\n  jSlider.prototype.onstatechange = function () {};\n\n  jSlider.prototype.create = function () {\n    var $this = this;\n    this.domNode = $(OPTIONS.template({\n      className: OPTIONS.className,\n      settings: {\n        from: this.nice(this.settings.from),\n        to: this.nice(this.settings.to),\n        dimension: this.settings.dimension\n      },\n      scale: this.generateScale()\n    }));\n    this.inputNode.after(this.domNode);\n    this.drawScale(); // set skin class\n\n    if (this.settings.skin && this.settings.skin.length > 0) this.setSkin(this.settings.skin);\n    this.sizes = {\n      domWidth: this.domNode.width(),\n      domOffset: this.domNode.offset()\n    }; // find some objects\n\n    $.extend(this.o, {\n      pointers: {},\n      labels: {\n        0: {\n          o: this.domNode.find(OPTIONS.selector + \"value\").not(OPTIONS.selector + \"value-to\")\n        },\n        1: {\n          o: this.domNode.find(OPTIONS.selector + \"value\").filter(OPTIONS.selector + \"value-to\")\n        }\n      },\n      limits: {\n        0: this.domNode.find(OPTIONS.selector + \"label\").not(OPTIONS.selector + \"label-to\"),\n        1: this.domNode.find(OPTIONS.selector + \"label\").filter(OPTIONS.selector + \"label-to\")\n      }\n    });\n    $.extend(this.o.labels[0], {\n      value: this.o.labels[0].o.find(\"span\")\n    });\n    $.extend(this.o.labels[1], {\n      value: this.o.labels[1].o.find(\"span\")\n    });\n\n    if (!$this.settings.value.split(\";\")[1]) {\n      this.settings.single = true;\n      this.domNode.addDependClass(\"single\");\n    }\n\n    if (!$this.settings.limits) this.domNode.addDependClass(\"limitless\");\n    this.domNode.find(OPTIONS.selector + \"pointer\").each(function (i) {\n      var value = $this.settings.value.split(\";\")[i];\n\n      if (value) {\n        $this.o.pointers[i] = new jSliderPointer(this, i, $this);\n        var prev = $this.settings.value.split(\";\")[i - 1];\n        if (prev && new Number(value) < new Number(prev)) value = prev;\n        value = value < $this.settings.from ? $this.settings.from : value;\n        value = value > $this.settings.to ? $this.settings.to : value;\n        $this.o.pointers[i].set(value, true);\n      }\n    });\n    this.o.value = this.domNode.find(\".v\");\n    this.is.init = true;\n    $.each(this.o.pointers, function (i) {\n      $this.redraw(this);\n    });\n\n    (function (self) {\n      $(window).resize(function () {\n        self.onresize();\n      });\n    })(this);\n  };\n\n  jSlider.prototype.setSkin = function (skin) {\n    if (this.skin_) this.domNode.removeDependClass(this.skin_, \"_\");\n    this.domNode.addDependClass(this.skin_ = skin, \"_\");\n  };\n\n  jSlider.prototype.setPointersIndex = function (i) {\n    $.each(this.getPointers(), function (i) {\n      this.index(i);\n    });\n  };\n\n  jSlider.prototype.getPointers = function () {\n    return this.o.pointers;\n  };\n\n  jSlider.prototype.generateScale = function () {\n    if (this.settings.scale && this.settings.scale.length > 0) {\n      var str = \"\";\n      var s = this.settings.scale;\n      var prc = Math.round(100 / (s.length - 1) * 10) / 10;\n\n      for (var i = 0; i < s.length; i++) {\n        str += '<span style=\"left: ' + i * prc + '%\">' + (s[i] != '|' ? '<ins>' + s[i] + '</ins>' : '') + '</span>';\n      }\n\n      ;\n      return str;\n    } else return \"\";\n\n    return \"\";\n  };\n\n  jSlider.prototype.drawScale = function () {\n    this.domNode.find(OPTIONS.selector + \"scale span ins\").each(function () {\n      $(this).css({\n        marginLeft: -$(this).outerWidth() / 2\n      });\n    });\n  };\n\n  jSlider.prototype.onresize = function () {\n    var self = this;\n    this.sizes = {\n      domWidth: this.domNode.width(),\n      domOffset: this.domNode.offset()\n    };\n    $.each(this.o.pointers, function (i) {\n      self.redraw(this);\n    });\n  };\n\n  jSlider.prototype.update = function () {\n    this.onresize();\n    this.drawScale();\n  };\n\n  jSlider.prototype.limits = function (x, pointer) {\n    // smooth\n    if (!this.settings.smooth) {\n      var step = this.settings.step * 100 / this.settings.interval;\n      x = Math.round(x / step) * step;\n    }\n\n    var another = this.o.pointers[1 - pointer.uid];\n    if (another && pointer.uid && x < another.value.prc) x = another.value.prc;\n    if (another && !pointer.uid && x > another.value.prc) x = another.value.prc; // base limit\n\n    if (x < 0) x = 0;\n    if (x > 100) x = 100;\n    return Math.round(x * 10) / 10;\n  };\n\n  jSlider.prototype.redraw = function (pointer) {\n    if (!this.is.init) return false;\n    this.setValue(); // redraw range line\n\n    if (this.o.pointers[0] && this.o.pointers[1]) this.o.value.css({\n      left: this.o.pointers[0].value.prc + \"%\",\n      width: this.o.pointers[1].value.prc - this.o.pointers[0].value.prc + \"%\"\n    });\n    this.o.labels[pointer.uid].value.html(this.nice(pointer.value.origin)); // redraw position of labels\n\n    this.redrawLabels(pointer);\n  };\n\n  jSlider.prototype.redrawLabels = function (pointer) {\n    function setPosition(label, sizes, prc) {\n      sizes.margin = -sizes.label / 2; // left limit\n\n      label_left = sizes.border + sizes.margin;\n      if (label_left < 0) sizes.margin -= label_left; // right limit\n\n      if (sizes.border + sizes.label / 2 > self.sizes.domWidth) {\n        sizes.margin = 0;\n        sizes.right = true;\n      } else sizes.right = false;\n\n      label.o.css({\n        left: prc + \"%\",\n        marginLeft: sizes.margin,\n        right: \"auto\"\n      });\n      if (sizes.right) label.o.css({\n        left: \"auto\",\n        right: 0\n      });\n      return sizes;\n    }\n\n    var self = this;\n    var label = this.o.labels[pointer.uid];\n    var prc = pointer.value.prc;\n    var sizes = {\n      label: label.o.outerWidth(),\n      right: false,\n      border: prc * this.sizes.domWidth / 100\n    };\n\n    if (!this.settings.single) {\n      // glue if near;\n      var another = this.o.pointers[1 - pointer.uid];\n      var another_label = this.o.labels[another.uid];\n\n      switch (pointer.uid) {\n        case 0:\n          if (sizes.border + sizes.label / 2 > another_label.o.offset().left - this.sizes.domOffset.left) {\n            another_label.o.css({\n              visibility: \"hidden\"\n            });\n            another_label.value.html(this.nice(another.value.origin));\n            label.o.css({\n              visibility: \"visible\"\n            });\n            prc = (another.value.prc - prc) / 2 + prc;\n\n            if (another.value.prc != pointer.value.prc) {\n              label.value.html(this.nice(pointer.value.origin) + \"&nbsp;&ndash;&nbsp;\" + this.nice(another.value.origin));\n              sizes.label = label.o.outerWidth();\n              sizes.border = prc * this.sizes.domWidth / 100;\n            }\n          } else {\n            another_label.o.css({\n              visibility: \"visible\"\n            });\n          }\n\n          break;\n\n        case 1:\n          if (sizes.border - sizes.label / 2 < another_label.o.offset().left - this.sizes.domOffset.left + another_label.o.outerWidth()) {\n            another_label.o.css({\n              visibility: \"hidden\"\n            });\n            another_label.value.html(this.nice(another.value.origin));\n            label.o.css({\n              visibility: \"visible\"\n            });\n            prc = (prc - another.value.prc) / 2 + another.value.prc;\n\n            if (another.value.prc != pointer.value.prc) {\n              label.value.html(this.nice(another.value.origin) + \"&nbsp;&ndash;&nbsp;\" + this.nice(pointer.value.origin));\n              sizes.label = label.o.outerWidth();\n              sizes.border = prc * this.sizes.domWidth / 100;\n            }\n          } else {\n            another_label.o.css({\n              visibility: \"visible\"\n            });\n          }\n\n          break;\n      }\n    }\n\n    sizes = setPosition(label, sizes, prc);\n    /* draw second label */\n\n    if (another_label) {\n      var sizes = {\n        label: another_label.o.outerWidth(),\n        right: false,\n        border: another.value.prc * this.sizes.domWidth / 100\n      };\n      sizes = setPosition(another_label, sizes, another.value.prc);\n    }\n\n    this.redrawLimits();\n  };\n\n  jSlider.prototype.redrawLimits = function () {\n    if (this.settings.limits) {\n      var limits = [true, true];\n\n      for (key in this.o.pointers) {\n        if (!this.settings.single || key == 0) {\n          var pointer = this.o.pointers[key];\n          var label = this.o.labels[pointer.uid];\n          var label_left = label.o.offset().left - this.sizes.domOffset.left;\n          var limit = this.o.limits[0];\n          if (label_left < limit.outerWidth()) limits[0] = false;\n          var limit = this.o.limits[1];\n          if (label_left + label.o.outerWidth() > this.sizes.domWidth - limit.outerWidth()) limits[1] = false;\n        }\n      }\n\n      ;\n\n      for (var i = 0; i < limits.length; i++) {\n        if (limits[i]) this.o.limits[i].fadeIn(\"fast\");else this.o.limits[i].fadeOut(\"fast\");\n      }\n\n      ;\n    }\n  };\n\n  jSlider.prototype.setValue = function () {\n    var value = this.getValue();\n    this.inputNode.attr(\"value\", value);\n    this.onstatechange.call(this, value);\n  };\n\n  jSlider.prototype.getValue = function () {\n    if (!this.is.init) return false;\n    var $this = this;\n    var value = \"\";\n    $.each(this.o.pointers, function (i) {\n      if (this.value.prc != undefined && !isNaN(this.value.prc)) value += (i > 0 ? \";\" : \"\") + $this.prcToValue(this.value.prc);\n    });\n    return value;\n  };\n\n  jSlider.prototype.getPrcValue = function () {\n    if (!this.is.init) return false;\n    var $this = this;\n    var value = \"\";\n    $.each(this.o.pointers, function (i) {\n      if (this.value.prc != undefined && !isNaN(this.value.prc)) value += (i > 0 ? \";\" : \"\") + this.value.prc;\n    });\n    return value;\n  };\n\n  jSlider.prototype.prcToValue = function (prc) {\n    if (this.settings.heterogeneity && this.settings.heterogeneity.length > 0) {\n      var h = this.settings.heterogeneity;\n      var _start = 0;\n      var _from = this.settings.from;\n\n      for (var i = 0; i <= h.length; i++) {\n        if (h[i]) var v = h[i].split(\"/\");else var v = [100, this.settings.to];\n        v[0] = new Number(v[0]);\n        v[1] = new Number(v[1]);\n\n        if (prc >= _start && prc <= v[0]) {\n          var value = _from + (prc - _start) * (v[1] - _from) / (v[0] - _start);\n        }\n\n        _start = v[0];\n        _from = v[1];\n      }\n\n      ;\n    } else {\n      var value = this.settings.from + prc * this.settings.interval / 100;\n    }\n\n    return this.round(value);\n  };\n\n  jSlider.prototype.valueToPrc = function (value, pointer) {\n    if (this.settings.heterogeneity && this.settings.heterogeneity.length > 0) {\n      var h = this.settings.heterogeneity;\n      var _start = 0;\n      var _from = this.settings.from;\n\n      for (var i = 0; i <= h.length; i++) {\n        if (h[i]) var v = h[i].split(\"/\");else var v = [100, this.settings.to];\n        v[0] = new Number(v[0]);\n        v[1] = new Number(v[1]);\n\n        if (value >= _from && value <= v[1]) {\n          var prc = pointer.limits(_start + (value - _from) * (v[0] - _start) / (v[1] - _from));\n        }\n\n        _start = v[0];\n        _from = v[1];\n      }\n\n      ;\n    } else {\n      var prc = pointer.limits((value - this.settings.from) * 100 / this.settings.interval);\n    }\n\n    return prc;\n  };\n\n  jSlider.prototype.round = function (value) {\n    value = Math.round(value / this.settings.step) * this.settings.step;\n    if (this.settings.round) value = Math.round(value * Math.pow(10, this.settings.round)) / Math.pow(10, this.settings.round);else value = Math.round(value);\n    return value;\n  };\n\n  jSlider.prototype.nice = function (value) {\n    value = value.toString().replace(/,/gi, \".\").replace(/ /gi, \"\");\n    ;\n\n    if ($.formatNumber) {\n      return $.formatNumber(new Number(value), this.settings.format || {}).replace(/-/gi, \"&minus;\");\n    } else {\n      return new Number(value);\n    }\n  };\n\n  function jSliderPointer() {\n    Draggable.apply(this, arguments);\n  }\n\n  jSliderPointer.prototype = new Draggable();\n\n  jSliderPointer.prototype.oninit = function (ptr, id, _constructor) {\n    this.uid = id;\n    this.parent = _constructor;\n    this.value = {};\n    this.settings = this.parent.settings;\n  };\n\n  jSliderPointer.prototype.onmousedown = function (evt) {\n    this._parent = {\n      offset: this.parent.domNode.offset(),\n      width: this.parent.domNode.width()\n    };\n    this.ptr.addDependClass(\"hover\");\n    this.setIndexOver();\n  };\n\n  jSliderPointer.prototype.onmousemove = function (evt, x) {\n    var coords = this._getPageCoords(evt);\n\n    this._set(this.calc(coords.x));\n  };\n\n  jSliderPointer.prototype.onmouseup = function (evt) {\n    if (this.parent.settings.callback && $.isFunction(this.parent.settings.callback)) this.parent.settings.callback.call(this.parent, this.parent.getValue());\n    this.ptr.removeDependClass(\"hover\");\n  };\n\n  jSliderPointer.prototype.setIndexOver = function () {\n    this.parent.setPointersIndex(1);\n    this.index(2);\n  };\n\n  jSliderPointer.prototype.index = function (i) {\n    this.ptr.css({\n      zIndex: i\n    });\n  };\n\n  jSliderPointer.prototype.limits = function (x) {\n    return this.parent.limits(x, this);\n  };\n\n  jSliderPointer.prototype.calc = function (coords) {\n    var x = this.limits((coords - this._parent.offset.left) * 100 / this._parent.width);\n    return x;\n  };\n\n  jSliderPointer.prototype.set = function (value, opt_origin) {\n    this.value.origin = this.parent.round(value);\n\n    this._set(this.parent.valueToPrc(value, this), opt_origin);\n  };\n\n  jSliderPointer.prototype._set = function (prc, opt_origin) {\n    if (!opt_origin) this.value.origin = this.parent.prcToValue(prc);\n    this.value.prc = prc;\n    this.ptr.css({\n      left: prc + \"%\"\n    });\n    this.parent.redraw(this);\n  };\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL3NsaWRlci1yYW5nZS9qcy9qcXVlcnkuc2xpZGVyLmpzPzgzY2IiXSwibmFtZXMiOlsiJCIsImlzQXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibGVuZ3RoIiwic3BsaWNlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzbGlkZXIiLCJub2RlIiwic2V0dGluZ3MiLCJqTm9kZSIsImRhdGEiLCJqU2xpZGVyIiwiZm4iLCJhY3Rpb24iLCJvcHRfdmFsdWUiLCJyZXR1cm5WYWx1ZSIsImFyZ3MiLCJhcmd1bWVudHMiLCJpc0RlZiIsInZhbCIsInVuZGVmaW5lZCIsImlzRGVmQW5kTm90TnVsbCIsImVhY2giLCJzZWxmIiwicG9pbnRlcnMiLCJnZXRQb2ludGVycyIsInNldCIsInNldEluZGV4T3ZlciIsImdldFZhbHVlIiwiX3NldCIsImdldFByY1ZhbHVlIiwic3BsaXQiLCJpIiwibmljZSIsInNldFNraW4iLCJwdXNoIiwiT1BUSU9OUyIsImZyb20iLCJ0byIsInN0ZXAiLCJzbW9vdGgiLCJsaW1pdHMiLCJyb3VuZCIsImZvcm1hdCIsImRpbWVuc2lvbiIsImNsYXNzTmFtZSIsInNlbGVjdG9yIiwidGVtcGxhdGUiLCJ0bXBsIiwiaW5pdCIsImFwcGx5IiwiZXh0ZW5kIiwiaW5wdXROb2RlIiwiaGlkZSIsImludGVydmFsIiwiYXR0ciIsImNhbGN1bGF0ZSIsImlzRnVuY3Rpb24iLCJvbnN0YXRlY2hhbmdlIiwiaXMiLCJvIiwiY3JlYXRlIiwiJHRoaXMiLCJkb21Ob2RlIiwic2NhbGUiLCJnZW5lcmF0ZVNjYWxlIiwiYWZ0ZXIiLCJkcmF3U2NhbGUiLCJza2luIiwic2l6ZXMiLCJkb21XaWR0aCIsIndpZHRoIiwiZG9tT2Zmc2V0Iiwib2Zmc2V0IiwibGFiZWxzIiwiZmluZCIsIm5vdCIsImZpbHRlciIsInNpbmdsZSIsImFkZERlcGVuZENsYXNzIiwialNsaWRlclBvaW50ZXIiLCJwcmV2IiwiTnVtYmVyIiwicmVkcmF3Iiwid2luZG93IiwicmVzaXplIiwib25yZXNpemUiLCJza2luXyIsInJlbW92ZURlcGVuZENsYXNzIiwic2V0UG9pbnRlcnNJbmRleCIsImluZGV4Iiwic3RyIiwicyIsInByYyIsIk1hdGgiLCJjc3MiLCJtYXJnaW5MZWZ0Iiwib3V0ZXJXaWR0aCIsInVwZGF0ZSIsIngiLCJwb2ludGVyIiwiYW5vdGhlciIsInVpZCIsInNldFZhbHVlIiwibGVmdCIsImh0bWwiLCJvcmlnaW4iLCJyZWRyYXdMYWJlbHMiLCJzZXRQb3NpdGlvbiIsImxhYmVsIiwibWFyZ2luIiwibGFiZWxfbGVmdCIsImJvcmRlciIsInJpZ2h0IiwiYW5vdGhlcl9sYWJlbCIsInZpc2liaWxpdHkiLCJyZWRyYXdMaW1pdHMiLCJrZXkiLCJsaW1pdCIsImZhZGVJbiIsImZhZGVPdXQiLCJpc05hTiIsInByY1RvVmFsdWUiLCJoZXRlcm9nZW5laXR5IiwiaCIsIl9zdGFydCIsIl9mcm9tIiwidiIsInZhbHVlVG9QcmMiLCJwb3ciLCJyZXBsYWNlIiwiZm9ybWF0TnVtYmVyIiwiRHJhZ2dhYmxlIiwib25pbml0IiwicHRyIiwiaWQiLCJfY29uc3RydWN0b3IiLCJwYXJlbnQiLCJvbm1vdXNlZG93biIsImV2dCIsIl9wYXJlbnQiLCJvbm1vdXNlbW92ZSIsImNvb3JkcyIsIl9nZXRQYWdlQ29vcmRzIiwiY2FsYyIsIm9ubW91c2V1cCIsImNhbGxiYWNrIiwiekluZGV4Iiwib3B0X29yaWdpbiIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLENBQUMsVUFBVUEsQ0FBVixFQUFjO0FBRWIsV0FBU0MsT0FBVCxDQUFrQkMsS0FBbEIsRUFBeUI7QUFDdkIsUUFBSSxPQUFPQSxL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VUFBVTdCLEtBQVYsRUFBaUJ1SixVQUFqQixFQUE2QjtBQUMxRCxTQUFLdkosS0FBTCxDQUFXNkcsTUFBWCxHQUFvQixLQUFLK0IsTUFBTCxDQUFZL0YsS0FBWixDQUFrQjdDLEtBQWxCLENBQXBCOztBQUNBLFNBQUtnQyxJQUFMLENBQVcsS0FBSzRHLE1BQUwsQ0FBWVQsVUFBWixDQUF3Qm5JLEtBQXhCLEVBQStCLElBQS9CLENBQVgsRUFBa0R1SixVQUFsRDtBQUNELEdBSEQ7O0FBS0FwRSxFQUFBQSxjQUFjLENBQUNoRixTQUFmLENBQXlCNkIsSUFBekIsR0FBZ0MsVUFBVWdFLEdBQVYsRUFBZXVELFVBQWYsRUFBMkI7QUFDekQsUUFBSSxDQUFDQSxVQUFMLEVBQ0UsS0FBS3ZKLEtBQUwsQ0FBVzZHLE1BQVgsR0FBb0IsS0FBSytCLE1BQUwsQ0FBWWYsVUFBWixDQUF1QjdCLEdBQXZCLENBQXBCO0FBRUYsU0FBS2hHLEtBQUwsQ0FBV2dHLEdBQVgsR0FBaUJBLEdBQWpCO0FBQ0QsU0FBS3lDLEdBQUwsQ0FBU3ZDLEdBQVQsQ0FBYTtBQUFFUyxNQUFBQSxJQUFJLEVBQUVYLEdBQUcsR0FBRztBQUFkLEtBQWI7QUFDQyxTQUFLNEMsTUFBTCxDQUFZdEQsTUFBWixDQUFtQixJQUFuQjtBQUNELEdBUEQ7QUFTQSxDQXRxQkQsRUFzcUJHa0UsTUF0cUJIIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBqcXVlcnkuc2xpZGVyIC0gU2xpZGVyIHVpIGNvbnRyb2wgaW4galF1ZXJ5XG4gKiBcbiAqIFdyaXR0ZW4gYnlcbiAqIEVnb3IgS2htZWxldiAoaG1lbHlvZmZAZ21haWwuY29tKVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKE1JVC1MSUNFTlNFLnR4dCkuXG4gKlxuICogQGF1dGhvciBFZ29yIEtobWVsZXZcbiAqIEB2ZXJzaW9uIDEuMS4wLVJFTEVBU0UgKCRJZCQpXG4gKiBcbiAqIERlcGVuZGVuY2llc1xuICogXG4gKiBqUXVlcnkgKGh0dHA6Ly9qcXVlcnkuY29tKVxuICoganF1ZXJ5Lm51bWJlcmZvcm1hdHRlciAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS1udW1iZXJmb3JtYXR0ZXIvKVxuICogdG1wbCAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gKiBqcXVlcnkuZGVwZW5kQ2xhc3NcbiAqIGRyYWdnYWJsZVxuICogXG4gKiovXG5cbihmdW5jdGlvbiggJCApIHtcbiAgXG4gIGZ1bmN0aW9uIGlzQXJyYXkoIHZhbHVlICl7XG4gICAgaWYoIHR5cGVvZiB2YWx1ZSA9PSBcInVuZGVmaW5lZFwiICkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8ICghKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSAmJlxuICAgICAgICAgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgodmFsdWUpKSA9PSAnW29iamVjdCBBcnJheV0nKSB8fFxuICAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICAgdHlwZW9mIHZhbHVlLnNwbGljZSAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgdHlwZW9mIHZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAhdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUoJ3NwbGljZScpXG4gICAgICAgICkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXHQkLnNsaWRlciA9IGZ1bmN0aW9uKCBub2RlLCBzZXR0aW5ncyApe1xuXHQgIHZhciBqTm9kZSA9ICQobm9kZSk7XG5cdCAgaWYoICFqTm9kZS5kYXRhKCBcImpzbGlkZXJcIiApIClcblx0ICAgIGpOb2RlLmRhdGEoIFwianNsaWRlclwiLCBuZXcgalNsaWRlciggbm9kZSwgc2V0dGluZ3MgKSApO1xuXHQgIFxuXHQgIHJldHVybiBqTm9kZS5kYXRhKCBcImpzbGlkZXJcIiApO1xuXHR9O1xuXHRcblx0JC5mbi5zbGlkZXIgPSBmdW5jdGlvbiggYWN0aW9uLCBvcHRfdmFsdWUgKXtcblx0ICB2YXIgcmV0dXJuVmFsdWUsIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgXG5cdCAgZnVuY3Rpb24gaXNEZWYoIHZhbCApe1xuXHQgICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwoIHZhbCApe1xuICAgICAgcmV0dXJuIHZhbCAhPSBudWxsO1xuXHQgIH07XG5cdCAgXG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0ICB2YXIgc2VsZiA9ICQuc2xpZGVyKCB0aGlzLCBhY3Rpb24gKTtcblx0XHQgIFxuXHRcdCAgLy8gZG8gYWN0aW9uc1xuXHRcdCAgaWYoIHR5cGVvZiBhY3Rpb24gPT0gXCJzdHJpbmdcIiApe1xuXHRcdCAgICBzd2l0Y2goIGFjdGlvbiApe1xuXHRcdCAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuXHRcdCAgICAgICAgaWYoIGlzRGVmKCBhcmdzWyAxIF0gKSAmJiBpc0RlZiggYXJnc1sgMiBdICkgKXtcblx0XHQgICAgICAgICAgdmFyIHBvaW50ZXJzID0gc2VsZi5nZXRQb2ludGVycygpO1xuXHRcdCAgICAgICAgICBpZiggaXNEZWZBbmROb3ROdWxsKCBwb2ludGVyc1swXSApICYmIGlzRGVmQW5kTm90TnVsbCggYXJnc1sxXSApICl7XG5cdFx0ICAgICAgICAgICAgcG9pbnRlcnNbMF0uc2V0KCBhcmdzWyAxIF0gKTtcblx0XHQgICAgICAgICAgICBwb2ludGVyc1swXS5zZXRJbmRleE92ZXIoKTtcblx0XHQgICAgICAgICAgfVxuXHRcdCAgICAgICAgICBcblx0XHQgICAgICAgICAgaWYoIGlzRGVmQW5kTm90TnVsbCggcG9pbnRlcnNbMV0gKSAmJiBpc0RlZkFuZE5vdE51bGwoIGFyZ3NbMl0gKSApe1xuXHRcdCAgICAgICAgICAgIHBvaW50ZXJzWzFdLnNldCggYXJnc1sgMiBdICk7XG5cdFx0ICAgICAgICAgICAgcG9pbnRlcnNbMV0uc2V0SW5kZXhPdmVyKCk7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFxuXHRcdCAgICAgICAgZWxzZSBpZiggaXNEZWYoIGFyZ3NbIDEgXSApICl7XG5cdFx0ICAgICAgICAgIHZhciBwb2ludGVycyA9IHNlbGYuZ2V0UG9pbnRlcnMoKTtcblx0XHQgICAgICAgICAgaWYoIGlzRGVmQW5kTm90TnVsbCggcG9pbnRlcnNbMF0gKSAmJiBpc0RlZkFuZE5vdE51bGwoIGFyZ3NbMV0gKSApe1xuXHRcdCAgICAgICAgICAgIHBvaW50ZXJzWzBdLnNldCggYXJnc1sgMSBdICk7XG5cdFx0ICAgICAgICAgICAgcG9pbnRlcnNbMF0uc2V0SW5kZXhPdmVyKCk7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIFxuXHRcdCAgICAgICAgZWxzZVxuICBcdFx0ICAgICAgICByZXR1cm5WYWx1ZSA9IHNlbGYuZ2V0VmFsdWUoKTtcblxuXHRcdCAgICAgICAgYnJlYWs7XG5cblx0XHQgICAgICBjYXNlIFwicHJjXCI6XG5cdFx0ICAgICAgICBpZiggaXNEZWYoIGFyZ3NbIDEgXSApICYmIGlzRGVmKCBhcmdzWyAyIF0gKSApe1xuXHRcdCAgICAgICAgICB2YXIgcG9pbnRlcnMgPSBzZWxmLmdldFBvaW50ZXJzKCk7XG5cdFx0ICAgICAgICAgIGlmKCBpc0RlZkFuZE5vdE51bGwoIHBvaW50ZXJzWzBdICkgJiYgaXNEZWZBbmROb3ROdWxsKCBhcmdzWzFdICkgKXtcblx0XHQgICAgICAgICAgICBwb2ludGVyc1swXS5fc2V0KCBhcmdzWyAxIF0gKTtcblx0XHQgICAgICAgICAgICBwb2ludGVyc1swXS5zZXRJbmRleE92ZXIoKTtcblx0XHQgICAgICAgICAgfVxuXG5cdFx0ICAgICAgICAgIGlmKCBpc0RlZkFuZE5vdE51bGwoIHBvaW50ZXJzWzFdICkgJiYgaXNEZWZBbmROb3ROdWxsKCBhcmdzWzJdICkgKXtcblx0XHQgICAgICAgICAgICBwb2ludGVyc1sxXS5fc2V0KCBhcmdzWyAyIF0gKTtcblx0XHQgICAgICAgICAgICBwb2ludGVyc1sxXS5zZXRJbmRleE92ZXIoKTtcblx0XHQgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgICAgICBlbHNlIGlmKCBpc0RlZiggYXJnc1sgMSBdICkgKXtcblx0XHQgICAgICAgICAgdmFyIHBvaW50ZXJzID0gc2VsZi5nZXRQb2ludGVycygpO1xuXHRcdCAgICAgICAgICBpZiggaXNEZWZBbmROb3ROdWxsKCBwb2ludGVyc1swXSApICYmIGlzRGVmQW5kTm90TnVsbCggYXJnc1sxXSApICl7XG5cdFx0ICAgICAgICAgICAgcG9pbnRlcnNbMF0uX3NldCggYXJnc1sgMSBdICk7XG5cdFx0ICAgICAgICAgICAgcG9pbnRlcnNbMF0uc2V0SW5kZXhPdmVyKCk7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblxuXHRcdCAgICAgICAgZWxzZVxuICBcdFx0ICAgICAgICByZXR1cm5WYWx1ZSA9IHNlbGYuZ2V0UHJjVmFsdWUoKTtcblxuXHRcdCAgICAgICAgYnJlYWs7XG5cbiAgXHRcdCAgICBjYXNlIFwiY2FsY3VsYXRlZFZhbHVlXCI6XG4gIFx0XHQgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldFZhbHVlKCkuc3BsaXQoXCI7XCIpO1xuICBcdFx0ICAgICAgcmV0dXJuVmFsdWUgPSBcIlwiO1xuICBcdFx0ICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgXHRcdCAgICAgICAgcmV0dXJuVmFsdWUgKz0gKGkgPiAwID8gXCI7XCIgOiBcIlwiKSArIHNlbGYubmljZSggdmFsdWVbaV0gKTtcbiAgXHRcdCAgICAgIH07XG4gIFx0XHQgICAgICBcbiAgXHRcdCAgICAgIGJyZWFrO1xuICBcdFx0ICAgICAgXG4gIFx0XHQgICAgY2FzZSBcInNraW5cIjpcblx0XHQgICAgICAgIHNlbGYuc2V0U2tpbiggYXJnc1sxXSApO1xuXG4gIFx0XHQgICAgICBicmVhaztcblx0XHQgICAgfTtcblx0XHQgIFxuXHRcdCAgfVxuXHRcdCAgXG5cdFx0ICAvLyByZXR1cm4gYWN0dWFsIG9iamVjdFxuXHRcdCAgZWxzZSBpZiggIWFjdGlvbiAmJiAhb3B0X3ZhbHVlICl7XG5cdFx0ICAgIGlmKCAhaXNBcnJheSggcmV0dXJuVmFsdWUgKSApXG5cdFx0ICAgICAgcmV0dXJuVmFsdWUgPSBbXTtcblxuXHRcdCAgICByZXR1cm5WYWx1ZS5wdXNoKCBzZWxmICk7XG5cdFx0ICB9XG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gZmxhdHRlbiBhcnJheSBqdXN0IHdpdGggb25lIHNsaWRlclxuXHRcdGlmKCBpc0FycmF5KCByZXR1cm5WYWx1ZSApICYmIHJldHVyblZhbHVlLmxlbmd0aCA9PSAxIClcblx0XHQgIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWVbIDAgXTtcblx0XHRcblx0XHRyZXR1cm4gcmV0dXJuVmFsdWUgfHwgdGhpcztcblx0fTtcbiAgXG4gIHZhciBPUFRJT05TID0ge1xuXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIGZyb206IDEsXG4gICAgICB0bzogMTAsXG4gICAgICBzdGVwOiAxLFxuICAgICAgc21vb3RoOiB0cnVlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcm91bmQ6IDAsXG4gICAgICBmb3JtYXQ6IHsgZm9ybWF0OiBcIiMsIyMwLiMjXCIgfSxcbiAgICAgIHZhbHVlOiBcIjU7N1wiLFxuICAgICAgZGltZW5zaW9uOiBcIlwiXG4gICAgfSxcbiAgICBcbiAgICBjbGFzc05hbWU6IFwianNsaWRlclwiLFxuICAgIHNlbGVjdG9yOiBcIi5qc2xpZGVyLVwiLFxuXG4gICAgdGVtcGxhdGU6IHRtcGwoXG4gICAgICAnPHNwYW4gY2xhc3M9XCI8JT1jbGFzc05hbWUlPlwiPicgK1xuICAgICAgICAnPHRhYmxlPjx0cj48dGQ+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCI8JT1jbGFzc05hbWUlPi1iZ1wiPicgK1xuICAgICAgICAgICAgJzxpIGNsYXNzPVwibFwiPjwvaT48aSBjbGFzcz1cImZcIj48L2k+PGkgY2xhc3M9XCJyXCI+PC9pPicgK1xuICAgICAgICAgICAgJzxpIGNsYXNzPVwidlwiPjwvaT4nICtcbiAgICAgICAgICAnPC9kaXY+JyArXG5cbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIjwlPWNsYXNzTmFtZSU+LXBvaW50ZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIjwlPWNsYXNzTmFtZSU+LXBvaW50ZXIgPCU9Y2xhc3NOYW1lJT4tcG9pbnRlci10b1wiPjwvZGl2PicgK1xuICAgICAgICBcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIjwlPWNsYXNzTmFtZSU+LWxhYmVsXCI+PHNwYW4+PCU9c2V0dGluZ3MuZnJvbSU+PC9zcGFuPjwvZGl2PicgK1xuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiPCU9Y2xhc3NOYW1lJT4tbGFiZWwgPCU9Y2xhc3NOYW1lJT4tbGFiZWwtdG9cIj48c3Bhbj48JT1zZXR0aW5ncy50byU+PC9zcGFuPjwlPXNldHRpbmdzLmRpbWVuc2lvbiU+PC9kaXY+JyArXG5cbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIjwlPWNsYXNzTmFtZSU+LXZhbHVlXCI+PHNwYW4+PC9zcGFuPjwlPXNldHRpbmdzLmRpbWVuc2lvbiU+PC9kaXY+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCI8JT1jbGFzc05hbWUlPi12YWx1ZSA8JT1jbGFzc05hbWUlPi12YWx1ZS10b1wiPjxzcGFuPjwvc3Bhbj48JT1zZXR0aW5ncy5kaW1lbnNpb24lPjwvZGl2PicgK1xuICAgICAgICAgIFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiPCU9Y2xhc3NOYW1lJT4tc2NhbGVcIj48JT1zY2FsZSU+PC9kaXY+JytcblxuICAgICAgICAnPC90ZD48L3RyPjwvdGFibGU+JyArXG4gICAgICAnPC9zcGFuPidcbiAgICApXG4gICAgXG4gIH07XG5cbiAgZnVuY3Rpb24galNsaWRlcigpe1xuICBcdHJldHVybiB0aGlzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICB9O1xuXG4gIGpTbGlkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiggbm9kZSwgc2V0dGluZ3MgKXtcbiAgICB0aGlzLnNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIE9QVElPTlMuc2V0dGluZ3MsIHNldHRpbmdzID8gc2V0dGluZ3MgOiB7fSk7XG4gICAgXG4gICAgLy8gb2JqLnNsaWRlckhhbmRsZXIgPSB0aGlzO1xuICAgIHRoaXMuaW5wdXROb2RlID0gJCggbm9kZSApLmhpZGUoKTtcbiAgICBcdFx0XHRcdFx0XHRcblx0XHR0aGlzLnNldHRpbmdzLmludGVydmFsID0gdGhpcy5zZXR0aW5ncy50by10aGlzLnNldHRpbmdzLmZyb207XG5cdFx0dGhpcy5zZXR0aW5ncy52YWx1ZSA9IHRoaXMuaW5wdXROb2RlLmF0dHIoXCJ2YWx1ZVwiKTtcblx0XHRcblx0XHRpZiggdGhpcy5zZXR0aW5ncy5jYWxjdWxhdGUgJiYgJC5pc0Z1bmN0aW9uKCB0aGlzLnNldHRpbmdzLmNhbGN1bGF0ZSApIClcblx0XHQgIHRoaXMubmljZSA9IHRoaXMuc2V0dGluZ3MuY2FsY3VsYXRlO1xuXG5cdFx0aWYoIHRoaXMuc2V0dGluZ3Mub25zdGF0ZWNoYW5nZSAmJiAkLmlzRnVuY3Rpb24oIHRoaXMuc2V0dGluZ3Mub25zdGF0ZWNoYW5nZSApIClcblx0XHQgIHRoaXMub25zdGF0ZWNoYW5nZSA9IHRoaXMuc2V0dGluZ3Mub25zdGF0ZWNoYW5nZTtcblxuICAgIHRoaXMuaXMgPSB7XG4gICAgICBpbml0OiBmYWxzZVxuICAgIH07XG5cdFx0dGhpcy5vID0ge307XG5cbiAgICB0aGlzLmNyZWF0ZSgpO1xuICB9O1xuICBcbiAgalNsaWRlci5wcm90b3R5cGUub25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgXG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgXG4gICAgdGhpcy5kb21Ob2RlID0gJCggT1BUSU9OUy50ZW1wbGF0ZSh7XG4gICAgICBjbGFzc05hbWU6IE9QVElPTlMuY2xhc3NOYW1lLFxuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgZnJvbTogdGhpcy5uaWNlKCB0aGlzLnNldHRpbmdzLmZyb20gKSxcbiAgICAgICAgdG86IHRoaXMubmljZSggdGhpcy5zZXR0aW5ncy50byApLFxuICAgICAgICBkaW1lbnNpb246IHRoaXMuc2V0dGluZ3MuZGltZW5zaW9uXG4gICAgICB9LFxuICAgICAgc2NhbGU6IHRoaXMuZ2VuZXJhdGVTY2FsZSgpXG4gICAgfSkgKTtcbiAgICBcbiAgICB0aGlzLmlucHV0Tm9kZS5hZnRlciggdGhpcy5kb21Ob2RlICk7XG4gICAgdGhpcy5kcmF3U2NhbGUoKTtcbiAgICBcbiAgICAvLyBzZXQgc2tpbiBjbGFzc1xuICAgIGlmKCB0aGlzLnNldHRpbmdzLnNraW4gJiYgdGhpcy5zZXR0aW5ncy5za2luLmxlbmd0aCA+IDAgKVxuICAgICAgdGhpcy5zZXRTa2luKCB0aGlzLnNldHRpbmdzLnNraW4gKTtcblxuXHRcdHRoaXMuc2l6ZXMgPSB7XG5cdFx0ICBkb21XaWR0aDogdGhpcy5kb21Ob2RlLndpZHRoKCksXG5cdFx0ICBkb21PZmZzZXQ6IHRoaXMuZG9tTm9kZS5vZmZzZXQoKVxuXHRcdH07XG5cbiAgICAvLyBmaW5kIHNvbWUgb2JqZWN0c1xuICAgICQuZXh0ZW5kKHRoaXMubywge1xuICAgICAgcG9pbnRlcnM6IHt9LFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIDA6IHtcbiAgICAgICAgICBvOiB0aGlzLmRvbU5vZGUuZmluZChPUFRJT05TLnNlbGVjdG9yICsgXCJ2YWx1ZVwiKS5ub3QoT1BUSU9OUy5zZWxlY3RvciArIFwidmFsdWUtdG9cIilcbiAgICAgICAgfSxcbiAgICAgICAgMToge1xuICAgICAgICAgIG86IHRoaXMuZG9tTm9kZS5maW5kKE9QVElPTlMuc2VsZWN0b3IgKyBcInZhbHVlXCIpLmZpbHRlcihPUFRJT05TLnNlbGVjdG9yICsgXCJ2YWx1ZS10b1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGltaXRzOiB7XG4gICAgICAgIDA6IHRoaXMuZG9tTm9kZS5maW5kKE9QVElPTlMuc2VsZWN0b3IgKyBcImxhYmVsXCIpLm5vdChPUFRJT05TLnNlbGVjdG9yICsgXCJsYWJlbC10b1wiKSxcbiAgICAgICAgMTogdGhpcy5kb21Ob2RlLmZpbmQoT1BUSU9OUy5zZWxlY3RvciArIFwibGFiZWxcIikuZmlsdGVyKE9QVElPTlMuc2VsZWN0b3IgKyBcImxhYmVsLXRvXCIpXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkLmV4dGVuZCh0aGlzLm8ubGFiZWxzWzBdLCB7XG4gICAgICB2YWx1ZTogdGhpcy5vLmxhYmVsc1swXS5vLmZpbmQoXCJzcGFuXCIpXG4gICAgfSk7XG5cbiAgICAkLmV4dGVuZCh0aGlzLm8ubGFiZWxzWzFdLCB7XG4gICAgICB2YWx1ZTogdGhpcy5vLmxhYmVsc1sxXS5vLmZpbmQoXCJzcGFuXCIpXG4gICAgfSk7XG5cbiAgICBcbiAgICBpZiggISR0aGlzLnNldHRpbmdzLnZhbHVlLnNwbGl0KFwiO1wiKVsxXSApe1xuICAgICAgdGhpcy5zZXR0aW5ncy5zaW5nbGUgPSB0cnVlO1xuICAgICAgdGhpcy5kb21Ob2RlLmFkZERlcGVuZENsYXNzKFwic2luZ2xlXCIpO1xuICAgIH1cblxuICAgIGlmKCAhJHRoaXMuc2V0dGluZ3MubGltaXRzIClcbiAgICAgIHRoaXMuZG9tTm9kZS5hZGREZXBlbmRDbGFzcyhcImxpbWl0bGVzc1wiKTtcblxuICAgIHRoaXMuZG9tTm9kZS5maW5kKE9QVElPTlMuc2VsZWN0b3IgKyBcInBvaW50ZXJcIikuZWFjaChmdW5jdGlvbiggaSApe1xuICAgICAgdmFyIHZhbHVlID0gJHRoaXMuc2V0dGluZ3MudmFsdWUuc3BsaXQoXCI7XCIpW2ldO1xuICAgICAgaWYoIHZhbHVlICl7XG4gICAgICAgICR0aGlzLm8ucG9pbnRlcnNbaV0gPSBuZXcgalNsaWRlclBvaW50ZXIoIHRoaXMsIGksICR0aGlzICk7XG5cbiAgICAgICAgdmFyIHByZXYgPSAkdGhpcy5zZXR0aW5ncy52YWx1ZS5zcGxpdChcIjtcIilbaS0xXTtcbiAgICAgICAgaWYoIHByZXYgJiYgbmV3IE51bWJlcih2YWx1ZSkgPCBuZXcgTnVtYmVyKHByZXYpICkgdmFsdWUgPSBwcmV2O1xuXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPCAkdGhpcy5zZXR0aW5ncy5mcm9tID8gJHRoaXMuc2V0dGluZ3MuZnJvbSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4gJHRoaXMuc2V0dGluZ3MudG8gPyAkdGhpcy5zZXR0aW5ncy50byA6IHZhbHVlO1xuICAgICAgXG4gICAgICAgICR0aGlzLm8ucG9pbnRlcnNbaV0uc2V0KCB2YWx1ZSwgdHJ1ZSApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuby52YWx1ZSA9IHRoaXMuZG9tTm9kZS5maW5kKFwiLnZcIik7XG4gICAgdGhpcy5pcy5pbml0ID0gdHJ1ZTtcbiAgICBcbiAgICAkLmVhY2godGhpcy5vLnBvaW50ZXJzLCBmdW5jdGlvbihpKXtcbiAgICAgICR0aGlzLnJlZHJhdyh0aGlzKTtcbiAgICB9KTtcbiAgICBcbiAgICAoZnVuY3Rpb24oc2VsZil7XG4gICAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25yZXNpemUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHRoaXMpO1xuXG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5zZXRTa2luID0gZnVuY3Rpb24oIHNraW4gKXtcbiAgICBpZiggdGhpcy5za2luXyApXG4gICAgICB0aGlzLmRvbU5vZGUucmVtb3ZlRGVwZW5kQ2xhc3MoIHRoaXMuc2tpbl8sIFwiX1wiICk7XG5cbiAgICB0aGlzLmRvbU5vZGUuYWRkRGVwZW5kQ2xhc3MoIHRoaXMuc2tpbl8gPSBza2luLCBcIl9cIiApO1xuICB9O1xuICBcbiAgalNsaWRlci5wcm90b3R5cGUuc2V0UG9pbnRlcnNJbmRleCA9IGZ1bmN0aW9uKCBpICl7XG4gICAgJC5lYWNoKHRoaXMuZ2V0UG9pbnRlcnMoKSwgZnVuY3Rpb24oaSl7XG4gICAgICB0aGlzLmluZGV4KCBpICk7XG4gICAgfSk7XG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5nZXRQb2ludGVycyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuby5wb2ludGVycztcbiAgfTtcbiAgXG4gIGpTbGlkZXIucHJvdG90eXBlLmdlbmVyYXRlU2NhbGUgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLnNldHRpbmdzLnNjYWxlICYmIHRoaXMuc2V0dGluZ3Muc2NhbGUubGVuZ3RoID4gMCApe1xuICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICB2YXIgcyA9IHRoaXMuc2V0dGluZ3Muc2NhbGU7XG4gICAgICB2YXIgcHJjID0gTWF0aC5yb3VuZCgoMTAwLyhzLmxlbmd0aC0xKSkqMTApLzEwO1xuICAgICAgZm9yKCB2YXIgaT0wOyBpIDwgcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBzdHIgKz0gJzxzcGFuIHN0eWxlPVwibGVmdDogJyArIGkqcHJjICsgJyVcIj4nICsgKCBzW2ldICE9ICd8JyA/ICc8aW5zPicgKyBzW2ldICsgJzwvaW5zPicgOiAnJyApICsgJzwvc3Bhbj4nO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSBlbHNlIHJldHVybiBcIlwiO1xuXG4gICAgcmV0dXJuIFwiXCI7XG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5kcmF3U2NhbGUgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZG9tTm9kZS5maW5kKE9QVElPTlMuc2VsZWN0b3IgKyBcInNjYWxlIHNwYW4gaW5zXCIpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICQodGhpcykuY3NzKHsgbWFyZ2luTGVmdDogLSQodGhpcykub3V0ZXJXaWR0aCgpLzIgfSk7XG4gICAgfSk7XG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuc2l6ZXMgPSB7XG5cdFx0ICBkb21XaWR0aDogdGhpcy5kb21Ob2RlLndpZHRoKCksXG5cdFx0ICBkb21PZmZzZXQ6IHRoaXMuZG9tTm9kZS5vZmZzZXQoKVxuXHRcdH07XG5cbiAgICAkLmVhY2godGhpcy5vLnBvaW50ZXJzLCBmdW5jdGlvbihpKXtcbiAgICAgIHNlbGYucmVkcmF3KHRoaXMpO1xuICAgIH0pO1xuICB9O1xuICBcbiAgalNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm9ucmVzaXplKCk7XG4gICAgdGhpcy5kcmF3U2NhbGUoKTtcbiAgfTtcbiAgXG4gIGpTbGlkZXIucHJvdG90eXBlLmxpbWl0cyA9IGZ1bmN0aW9uKCB4LCBwb2ludGVyICl7XG5cdCAgLy8gc21vb3RoXG5cdCAgaWYoICF0aGlzLnNldHRpbmdzLnNtb290aCApe1xuXHQgICAgdmFyIHN0ZXAgPSB0aGlzLnNldHRpbmdzLnN0ZXAqMTAwIC8gKCB0aGlzLnNldHRpbmdzLmludGVydmFsICk7XG5cdCAgICB4ID0gTWF0aC5yb3VuZCggeC9zdGVwICkgKiBzdGVwO1xuXHQgIH1cblx0ICBcblx0ICB2YXIgYW5vdGhlciA9IHRoaXMuby5wb2ludGVyc1sxLXBvaW50ZXIudWlkXTtcblx0ICBpZiggYW5vdGhlciAmJiBwb2ludGVyLnVpZCAmJiB4IDwgYW5vdGhlci52YWx1ZS5wcmMgKSB4ID0gYW5vdGhlci52YWx1ZS5wcmM7XG5cdCAgaWYoIGFub3RoZXIgJiYgIXBvaW50ZXIudWlkICYmIHggPiBhbm90aGVyLnZhbHVlLnByYyApIHggPSBhbm90aGVyLnZhbHVlLnByYztcblxuICAgIC8vIGJhc2UgbGltaXRcblx0ICBpZiggeCA8IDAgKSB4ID0gMDtcblx0ICBpZiggeCA+IDEwMCApIHggPSAxMDA7XG5cdCAgXG4gICAgcmV0dXJuIE1hdGgucm91bmQoIHgqMTAgKSAvIDEwO1xuICB9O1xuICBcbiAgalNsaWRlci5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oIHBvaW50ZXIgKXtcbiAgICBpZiggIXRoaXMuaXMuaW5pdCApIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICB0aGlzLnNldFZhbHVlKCk7XG4gICAgXG4gICAgLy8gcmVkcmF3IHJhbmdlIGxpbmVcbiAgICBpZiggdGhpcy5vLnBvaW50ZXJzWzBdICYmIHRoaXMuby5wb2ludGVyc1sxXSApXG4gICAgICB0aGlzLm8udmFsdWUuY3NzKHsgbGVmdDogdGhpcy5vLnBvaW50ZXJzWzBdLnZhbHVlLnByYyArIFwiJVwiLCB3aWR0aDogKCB0aGlzLm8ucG9pbnRlcnNbMV0udmFsdWUucHJjIC0gdGhpcy5vLnBvaW50ZXJzWzBdLnZhbHVlLnByYyApICsgXCIlXCIgfSk7XG5cbiAgICB0aGlzLm8ubGFiZWxzW3BvaW50ZXIudWlkXS52YWx1ZS5odG1sKFxuICAgICAgdGhpcy5uaWNlKFxuICAgICAgICBwb2ludGVyLnZhbHVlLm9yaWdpblxuICAgICAgKVxuICAgICk7XG4gICAgXG4gICAgLy8gcmVkcmF3IHBvc2l0aW9uIG9mIGxhYmVsc1xuICAgIHRoaXMucmVkcmF3TGFiZWxzKCBwb2ludGVyICk7XG5cbiAgfTtcbiAgXG4gIGpTbGlkZXIucHJvdG90eXBlLnJlZHJhd0xhYmVscyA9IGZ1bmN0aW9uKCBwb2ludGVyICl7XG5cbiAgICBmdW5jdGlvbiBzZXRQb3NpdGlvbiggbGFiZWwsIHNpemVzLCBwcmMgKXtcbiAgXHQgIHNpemVzLm1hcmdpbiA9IC1zaXplcy5sYWJlbC8yO1xuXG4gICAgICAvLyBsZWZ0IGxpbWl0XG4gICAgICBsYWJlbF9sZWZ0ID0gc2l6ZXMuYm9yZGVyICsgc2l6ZXMubWFyZ2luO1xuICAgICAgaWYoIGxhYmVsX2xlZnQgPCAwIClcbiAgICAgICAgc2l6ZXMubWFyZ2luIC09IGxhYmVsX2xlZnQ7XG5cbiAgICAgIC8vIHJpZ2h0IGxpbWl0XG4gICAgICBpZiggc2l6ZXMuYm9yZGVyK3NpemVzLmxhYmVsIC8gMiA+IHNlbGYuc2l6ZXMuZG9tV2lkdGggKXtcbiAgICAgICAgc2l6ZXMubWFyZ2luID0gMDtcbiAgICAgICAgc2l6ZXMucmlnaHQgPSB0cnVlO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHNpemVzLnJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgbGFiZWwuby5jc3MoeyBsZWZ0OiBwcmMgKyBcIiVcIiwgbWFyZ2luTGVmdDogc2l6ZXMubWFyZ2luLCByaWdodDogXCJhdXRvXCIgfSk7XG4gICAgICBpZiggc2l6ZXMucmlnaHQgKSBsYWJlbC5vLmNzcyh7IGxlZnQ6IFwiYXV0b1wiLCByaWdodDogMCB9KTtcbiAgICAgIHJldHVybiBzaXplcztcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIGxhYmVsID0gdGhpcy5vLmxhYmVsc1twb2ludGVyLnVpZF07XG5cdCAgdmFyIHByYyA9IHBvaW50ZXIudmFsdWUucHJjO1xuXG5cdCAgdmFyIHNpemVzID0ge1xuXHQgICAgbGFiZWw6IGxhYmVsLm8ub3V0ZXJXaWR0aCgpLFxuXHQgICAgcmlnaHQ6IGZhbHNlLFxuXHQgICAgYm9yZGVyOiAoIHByYyAqIHRoaXMuc2l6ZXMuZG9tV2lkdGggKSAvIDEwMFxuXHQgIH07XG5cbiAgICBpZiggIXRoaXMuc2V0dGluZ3Muc2luZ2xlICl7XG4gICAgICAvLyBnbHVlIGlmIG5lYXI7XG4gICAgICB2YXIgYW5vdGhlciA9IHRoaXMuby5wb2ludGVyc1sxLXBvaW50ZXIudWlkXTtcbiAgICBcdHZhciBhbm90aGVyX2xhYmVsID0gdGhpcy5vLmxhYmVsc1thbm90aGVyLnVpZF07XG5cbiAgICAgIHN3aXRjaCggcG9pbnRlci51aWQgKXtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlmKCBzaXplcy5ib3JkZXIrc2l6ZXMubGFiZWwgLyAyID4gYW5vdGhlcl9sYWJlbC5vLm9mZnNldCgpLmxlZnQtdGhpcy5zaXplcy5kb21PZmZzZXQubGVmdCApe1xuICAgICAgICAgICAgYW5vdGhlcl9sYWJlbC5vLmNzcyh7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG4gICAgICAgIFx0ICBhbm90aGVyX2xhYmVsLnZhbHVlLmh0bWwoIHRoaXMubmljZSggYW5vdGhlci52YWx1ZS5vcmlnaW4gKSApO1xuXG4gICAgICAgICAgXHRsYWJlbC5vLmNzcyh7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuXG4gICAgICAgICAgXHRwcmMgPSAoIGFub3RoZXIudmFsdWUucHJjIC0gcHJjICkgLyAyICsgcHJjO1xuICAgICAgICAgIFx0aWYoIGFub3RoZXIudmFsdWUucHJjICE9IHBvaW50ZXIudmFsdWUucHJjICl7XG4gICAgICAgICAgXHQgIGxhYmVsLnZhbHVlLmh0bWwoIHRoaXMubmljZShwb2ludGVyLnZhbHVlLm9yaWdpbikgKyBcIiZuYnNwOyZuZGFzaDsmbmJzcDtcIiArIHRoaXMubmljZShhbm90aGVyLnZhbHVlLm9yaWdpbikgKTtcbiAgICAgICAgICAgIFx0c2l6ZXMubGFiZWwgPSBsYWJlbC5vLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgIFx0c2l6ZXMuYm9yZGVyID0gKCBwcmMgKiB0aGlzLnNpemVzLmRvbVdpZHRoICkgLyAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBcdGFub3RoZXJfbGFiZWwuby5jc3MoeyB2aXNpYmlsaXR5OiBcInZpc2libGVcIiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmKCBzaXplcy5ib3JkZXIgLSBzaXplcy5sYWJlbCAvIDIgPCBhbm90aGVyX2xhYmVsLm8ub2Zmc2V0KCkubGVmdCAtIHRoaXMuc2l6ZXMuZG9tT2Zmc2V0LmxlZnQgKyBhbm90aGVyX2xhYmVsLm8ub3V0ZXJXaWR0aCgpICl7XG4gICAgICAgICAgICBhbm90aGVyX2xhYmVsLm8uY3NzKHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9KTtcbiAgICAgICAgXHQgIGFub3RoZXJfbGFiZWwudmFsdWUuaHRtbCggdGhpcy5uaWNlKGFub3RoZXIudmFsdWUub3JpZ2luKSApO1xuXG4gICAgICAgICAgXHRsYWJlbC5vLmNzcyh7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuXG4gICAgICAgICAgXHRwcmMgPSAoIHByYyAtIGFub3RoZXIudmFsdWUucHJjICkgLyAyICsgYW5vdGhlci52YWx1ZS5wcmM7XG4gICAgICAgICAgXHRpZiggYW5vdGhlci52YWx1ZS5wcmMgIT0gcG9pbnRlci52YWx1ZS5wcmMgKXtcbiAgICAgICAgICBcdCAgbGFiZWwudmFsdWUuaHRtbCggdGhpcy5uaWNlKGFub3RoZXIudmFsdWUub3JpZ2luKSArIFwiJm5ic3A7Jm5kYXNoOyZuYnNwO1wiICsgdGhpcy5uaWNlKHBvaW50ZXIudmFsdWUub3JpZ2luKSApO1xuICAgICAgICAgICAgXHRzaXplcy5sYWJlbCA9IGxhYmVsLm8ub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgXHRzaXplcy5ib3JkZXIgPSAoIHByYyAqIHRoaXMuc2l6ZXMuZG9tV2lkdGggKSAvIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5vdGhlcl9sYWJlbC5vLmNzcyh7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaXplcyA9IHNldFBvc2l0aW9uKCBsYWJlbCwgc2l6ZXMsIHByYyApO1xuICAgIFxuICAgIC8qIGRyYXcgc2Vjb25kIGxhYmVsICovXG4gICAgaWYoIGFub3RoZXJfbGFiZWwgKXtcbiAgICAgIHZhciBzaXplcyA9IHtcbiAgXHQgICAgbGFiZWw6IGFub3RoZXJfbGFiZWwuby5vdXRlcldpZHRoKCksXG4gIFx0ICAgIHJpZ2h0OiBmYWxzZSxcbiAgXHQgICAgYm9yZGVyOiAoIGFub3RoZXIudmFsdWUucHJjICogdGhpcy5zaXplcy5kb21XaWR0aCApIC8gMTAwXG4gIFx0ICB9O1xuICAgICAgc2l6ZXMgPSBzZXRQb3NpdGlvbiggYW5vdGhlcl9sYWJlbCwgc2l6ZXMsIGFub3RoZXIudmFsdWUucHJjICk7XG4gICAgfVxuXHQgIFxuICAgIHRoaXMucmVkcmF3TGltaXRzKCk7XG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5yZWRyYXdMaW1pdHMgPSBmdW5jdGlvbigpe1xuXHQgIGlmKCB0aGlzLnNldHRpbmdzLmxpbWl0cyApe1xuXG4gICAgICB2YXIgbGltaXRzID0gWyB0cnVlLCB0cnVlIF07XG5cbiAgICAgIGZvcigga2V5IGluIHRoaXMuby5wb2ludGVycyApe1xuXG4gICAgICAgIGlmKCAhdGhpcy5zZXR0aW5ncy5zaW5nbGUgfHwga2V5ID09IDAgKXtcbiAgICAgICAgXG4gICAgICBcdCAgdmFyIHBvaW50ZXIgPSB0aGlzLm8ucG9pbnRlcnNba2V5XTtcbiAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLm8ubGFiZWxzW3BvaW50ZXIudWlkXTtcbiAgICAgICAgICB2YXIgbGFiZWxfbGVmdCA9IGxhYmVsLm8ub2Zmc2V0KCkubGVmdCAtIHRoaXMuc2l6ZXMuZG9tT2Zmc2V0LmxlZnQ7XG5cbiAgICAgIFx0ICB2YXIgbGltaXQgPSB0aGlzLm8ubGltaXRzWzBdO1xuICAgICAgICAgIGlmKCBsYWJlbF9sZWZ0IDwgbGltaXQub3V0ZXJXaWR0aCgpIClcbiAgICAgICAgICAgIGxpbWl0c1swXSA9IGZhbHNlO1xuXG4gICAgICBcdCAgdmFyIGxpbWl0ID0gdGhpcy5vLmxpbWl0c1sxXTtcbiAgICAgIFx0ICBpZiggbGFiZWxfbGVmdCArIGxhYmVsLm8ub3V0ZXJXaWR0aCgpID4gdGhpcy5zaXplcy5kb21XaWR0aCAtIGxpbWl0Lm91dGVyV2lkdGgoKSApXG4gICAgICBcdCAgICBsaW1pdHNbMV0gPSBmYWxzZTtcbiAgICAgIFx0fVxuXG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBpPTA7IGkgPCBsaW1pdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIGxpbWl0c1tpXSApXG4gICAgICAgICAgdGhpcy5vLmxpbWl0c1tpXS5mYWRlSW4oXCJmYXN0XCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5vLmxpbWl0c1tpXS5mYWRlT3V0KFwiZmFzdFwiKTtcbiAgICAgIH07XG5cblx0ICB9XG4gIH07XG4gIFxuICBqU2xpZGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuaW5wdXROb2RlLmF0dHIoIFwidmFsdWVcIiwgdmFsdWUgKTtcbiAgICB0aGlzLm9uc3RhdGVjaGFuZ2UuY2FsbCggdGhpcywgdmFsdWUgKTtcbiAgfTtcblxuICBqU2xpZGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMuaXMuaW5pdCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgXG4gICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAkLmVhY2goIHRoaXMuby5wb2ludGVycywgZnVuY3Rpb24oaSl7XG4gICAgICBpZiggdGhpcy52YWx1ZS5wcmMgIT0gdW5kZWZpbmVkICYmICFpc05hTih0aGlzLnZhbHVlLnByYykgKSB2YWx1ZSArPSAoaSA+IDAgPyBcIjtcIiA6IFwiXCIpICsgJHRoaXMucHJjVG9WYWx1ZSggdGhpcy52YWx1ZS5wcmMgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgalNsaWRlci5wcm90b3R5cGUuZ2V0UHJjVmFsdWUgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLmlzLmluaXQpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgIFxuICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgJC5lYWNoKCB0aGlzLm8ucG9pbnRlcnMsIGZ1bmN0aW9uKGkpe1xuICAgICAgaWYoIHRoaXMudmFsdWUucHJjICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4odGhpcy52YWx1ZS5wcmMpICkgdmFsdWUgKz0gKGkgPiAwID8gXCI7XCIgOiBcIlwiKSArIHRoaXMudmFsdWUucHJjO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgXG4gIGpTbGlkZXIucHJvdG90eXBlLnByY1RvVmFsdWUgPSBmdW5jdGlvbiggcHJjICl7XG5cblx0ICBpZiggdGhpcy5zZXR0aW5ncy5oZXRlcm9nZW5laXR5ICYmIHRoaXMuc2V0dGluZ3MuaGV0ZXJvZ2VuZWl0eS5sZW5ndGggPiAwICl7XG4gIFx0ICB2YXIgaCA9IHRoaXMuc2V0dGluZ3MuaGV0ZXJvZ2VuZWl0eTtcblxuICBcdCAgdmFyIF9zdGFydCA9IDA7XG4gIFx0ICB2YXIgX2Zyb20gPSB0aGlzLnNldHRpbmdzLmZyb207XG5cbiAgXHQgIGZvciggdmFyIGk9MDsgaSA8PSBoLmxlbmd0aDsgaSsrICl7XG4gIFx0ICAgIGlmKCBoW2ldICkgdmFyIHYgPSBoW2ldLnNwbGl0KFwiL1wiKTtcbiAgXHQgICAgZWxzZSAgICAgICB2YXIgdiA9IFsxMDAsIHRoaXMuc2V0dGluZ3MudG9dO1xuICBcdCAgICBcbiAgXHQgICAgdlswXSA9IG5ldyBOdW1iZXIodlswXSk7XG4gIFx0ICAgIHZbMV0gPSBuZXcgTnVtYmVyKHZbMV0pO1xuICBcdCAgICAgIFxuICBcdCAgICBpZiggcHJjID49IF9zdGFydCAmJiBwcmMgPD0gdlswXSApIHtcbiAgXHQgICAgICB2YXIgdmFsdWUgPSBfZnJvbSArICggKHByYy1fc3RhcnQpICogKHZbMV0tX2Zyb20pICkgLyAodlswXS1fc3RhcnQpO1xuICBcdCAgICB9XG5cbiAgXHQgICAgX3N0YXJ0ID0gdlswXTtcbiAgXHQgICAgX2Zyb20gPSB2WzFdO1xuICBcdCAgfTtcblxuXHQgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnNldHRpbmdzLmZyb20gKyAoIHByYyAqIHRoaXMuc2V0dGluZ3MuaW50ZXJ2YWwgKSAvIDEwMDtcblx0ICB9XG5cbiAgICByZXR1cm4gdGhpcy5yb3VuZCggdmFsdWUgKTtcbiAgfTtcbiAgXG5cdGpTbGlkZXIucHJvdG90eXBlLnZhbHVlVG9QcmMgPSBmdW5jdGlvbiggdmFsdWUsIHBvaW50ZXIgKXsgIFx0ICBcblx0ICBpZiggdGhpcy5zZXR0aW5ncy5oZXRlcm9nZW5laXR5ICYmIHRoaXMuc2V0dGluZ3MuaGV0ZXJvZ2VuZWl0eS5sZW5ndGggPiAwICl7XG4gIFx0ICB2YXIgaCA9IHRoaXMuc2V0dGluZ3MuaGV0ZXJvZ2VuZWl0eTtcblxuICBcdCAgdmFyIF9zdGFydCA9IDA7XG4gIFx0ICB2YXIgX2Zyb20gPSB0aGlzLnNldHRpbmdzLmZyb207XG5cbiAgXHQgIGZvciAodmFyIGk9MDsgaSA8PSBoLmxlbmd0aDsgaSsrKSB7XG4gIFx0ICAgIGlmKGhbaV0pIHZhciB2ID0gaFtpXS5zcGxpdChcIi9cIik7XG4gIFx0ICAgIGVsc2UgICAgIHZhciB2ID0gWzEwMCwgdGhpcy5zZXR0aW5ncy50b107XG4gIFx0ICAgIHZbMF0gPSBuZXcgTnVtYmVyKHZbMF0pOyB2WzFdID0gbmV3IE51bWJlcih2WzFdKTtcbiAgXHQgICAgICBcbiAgXHQgICAgaWYodmFsdWUgPj0gX2Zyb20gJiYgdmFsdWUgPD0gdlsxXSl7XG4gIFx0ICAgICAgdmFyIHByYyA9IHBvaW50ZXIubGltaXRzKF9zdGFydCArICh2YWx1ZS1fZnJvbSkqKHZbMF0tX3N0YXJ0KS8odlsxXS1fZnJvbSkpO1xuICBcdCAgICB9XG5cbiAgXHQgICAgX3N0YXJ0ID0gdlswXTsgX2Zyb20gPSB2WzFdO1xuICBcdCAgfTtcblxuXHQgIH0gZWxzZSB7XG4gIFx0ICB2YXIgcHJjID0gcG9pbnRlci5saW1pdHMoKHZhbHVlLXRoaXMuc2V0dGluZ3MuZnJvbSkqMTAwL3RoaXMuc2V0dGluZ3MuaW50ZXJ2YWwpO1xuXHQgIH1cblxuXHQgIHJldHVybiBwcmM7XG5cdH07XG4gIFxuXHRqU2xpZGVyLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCB2YWx1ZSApe1xuICAgIHZhbHVlID0gTWF0aC5yb3VuZCggdmFsdWUgLyB0aGlzLnNldHRpbmdzLnN0ZXAgKSAqIHRoaXMuc2V0dGluZ3Muc3RlcDtcblx0XHRpZiggdGhpcy5zZXR0aW5ncy5yb3VuZCApIHZhbHVlID0gTWF0aC5yb3VuZCggdmFsdWUgKiBNYXRoLnBvdygxMCwgdGhpcy5zZXR0aW5ncy5yb3VuZCkgKSAvIE1hdGgucG93KDEwLCB0aGlzLnNldHRpbmdzLnJvdW5kKTtcblx0XHRlbHNlIHZhbHVlID0gTWF0aC5yb3VuZCggdmFsdWUgKTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cdFxuXHRqU2xpZGVyLnByb3RvdHlwZS5uaWNlID0gZnVuY3Rpb24oIHZhbHVlICl7XG5cdFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoLywvZ2ksIFwiLlwiKS5yZXBsYWNlKC8gL2dpLCBcIlwiKTs7XG5cblx0XHRpZiggJC5mb3JtYXROdW1iZXIgKXtcblx0XHQgIHJldHVybiAkLmZvcm1hdE51bWJlciggbmV3IE51bWJlcih2YWx1ZSksIHRoaXMuc2V0dGluZ3MuZm9ybWF0IHx8IHt9ICkucmVwbGFjZSggLy0vZ2ksIFwiJm1pbnVzO1wiICk7XG5cdFx0fVxuXHRcdCAgXG5cdFx0ZWxzZSB7XG5cdFx0ICByZXR1cm4gbmV3IE51bWJlcih2YWx1ZSk7XG5cdFx0fVxuXHR9O1xuXG4gIFxuICBmdW5jdGlvbiBqU2xpZGVyUG9pbnRlcigpe1xuICBcdERyYWdnYWJsZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gIH1cbiAgalNsaWRlclBvaW50ZXIucHJvdG90eXBlID0gbmV3IERyYWdnYWJsZSgpO1xuICBcbiAgalNsaWRlclBvaW50ZXIucHJvdG90eXBlLm9uaW5pdCA9IGZ1bmN0aW9uKCBwdHIsIGlkLCBfY29uc3RydWN0b3IgKXtcbiAgICB0aGlzLnVpZCA9IGlkO1xuICAgIHRoaXMucGFyZW50ID0gX2NvbnN0cnVjdG9yO1xuICAgIHRoaXMudmFsdWUgPSB7fTtcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5wYXJlbnQuc2V0dGluZ3M7XG4gIH07XG4gIFxuICBqU2xpZGVyUG9pbnRlci5wcm90b3R5cGUub25tb3VzZWRvd24gPSBmdW5jdGlvbihldnQpe1xuXHQgIHRoaXMuX3BhcmVudCA9IHtcblx0ICAgIG9mZnNldDogdGhpcy5wYXJlbnQuZG9tTm9kZS5vZmZzZXQoKSxcblx0ICAgIHdpZHRoOiB0aGlzLnBhcmVudC5kb21Ob2RlLndpZHRoKClcblx0ICB9O1xuXHQgIHRoaXMucHRyLmFkZERlcGVuZENsYXNzKFwiaG92ZXJcIik7XG5cdCAgdGhpcy5zZXRJbmRleE92ZXIoKTtcblx0fTtcblxuXHRqU2xpZGVyUG9pbnRlci5wcm90b3R5cGUub25tb3VzZW1vdmUgPSBmdW5jdGlvbiggZXZ0LCB4ICl7XG5cdCAgdmFyIGNvb3JkcyA9IHRoaXMuX2dldFBhZ2VDb29yZHMoIGV2dCApO1xuXHQgIHRoaXMuX3NldCggdGhpcy5jYWxjKCBjb29yZHMueCApICk7XG5cdH07XG5cdFxuXHRqU2xpZGVyUG9pbnRlci5wcm90b3R5cGUub25tb3VzZXVwID0gZnVuY3Rpb24oIGV2dCApe1xuXHQgIGlmKCB0aGlzLnBhcmVudC5zZXR0aW5ncy5jYWxsYmFjayAmJiAkLmlzRnVuY3Rpb24odGhpcy5wYXJlbnQuc2V0dGluZ3MuY2FsbGJhY2spIClcblx0ICAgIHRoaXMucGFyZW50LnNldHRpbmdzLmNhbGxiYWNrLmNhbGwoIHRoaXMucGFyZW50LCB0aGlzLnBhcmVudC5nZXRWYWx1ZSgpICk7XG5cdCAgICBcblx0ICB0aGlzLnB0ci5yZW1vdmVEZXBlbmRDbGFzcyhcImhvdmVyXCIpO1xuXHR9O1xuXHRcblx0alNsaWRlclBvaW50ZXIucHJvdG90eXBlLnNldEluZGV4T3ZlciA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5wYXJlbnQuc2V0UG9pbnRlcnNJbmRleCggMSApO1xuXHQgIHRoaXMuaW5kZXgoIDIgKTtcblx0fTtcblx0XG5cdGpTbGlkZXJQb2ludGVyLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCBpICl7XG5cdCAgdGhpcy5wdHIuY3NzKHsgekluZGV4OiBpIH0pO1xuXHR9O1xuXHRcblx0alNsaWRlclBvaW50ZXIucHJvdG90eXBlLmxpbWl0cyA9IGZ1bmN0aW9uKCB4ICl7XG5cdCAgcmV0dXJuIHRoaXMucGFyZW50LmxpbWl0cyggeCwgdGhpcyApO1xuXHR9O1xuXHRcblx0alNsaWRlclBvaW50ZXIucHJvdG90eXBlLmNhbGMgPSBmdW5jdGlvbihjb29yZHMpe1xuXHQgIHZhciB4ID0gdGhpcy5saW1pdHMoKChjb29yZHMtdGhpcy5fcGFyZW50Lm9mZnNldC5sZWZ0KSoxMDApL3RoaXMuX3BhcmVudC53aWR0aCk7XG5cdCAgcmV0dXJuIHg7XG5cdH07XG5cblx0alNsaWRlclBvaW50ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0X29yaWdpbiApe1xuXHQgIHRoaXMudmFsdWUub3JpZ2luID0gdGhpcy5wYXJlbnQucm91bmQodmFsdWUpO1xuXHQgIHRoaXMuX3NldCggdGhpcy5wYXJlbnQudmFsdWVUb1ByYyggdmFsdWUsIHRoaXMgKSwgb3B0X29yaWdpbiApO1xuXHR9O1xuXHRcblx0alNsaWRlclBvaW50ZXIucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiggcHJjLCBvcHRfb3JpZ2luICl7XG5cdCAgaWYoICFvcHRfb3JpZ2luIClcblx0ICAgIHRoaXMudmFsdWUub3JpZ2luID0gdGhpcy5wYXJlbnQucHJjVG9WYWx1ZShwcmMpO1xuXG5cdCAgdGhpcy52YWx1ZS5wcmMgPSBwcmM7XG5cdFx0dGhpcy5wdHIuY3NzKHsgbGVmdDogcHJjICsgXCIlXCIgfSk7XG5cdCAgdGhpcy5wYXJlbnQucmVkcmF3KHRoaXMpO1xuXHR9O1xuICBcbn0pKGpRdWVyeSk7XG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3ZlbmRvci9zbGlkZXItcmFuZ2UvanMvanF1ZXJ5LnNsaWRlci5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/slider-range/js/jquery.slider.js\n");

/***/ }),

/***/ "./resources/vendor/slider-range/js/tmpl.js":
/*!**************************************************!*\
  !*** ./resources/vendor/slider-range/js/tmpl.js ***!
  \**************************************************/
/***/ (() => {

eval("// Simple JavaScript Templating\n// John Resig - http://ejohn.org/ - MIT Licensed\n(function () {\n  var cache = {};\n\n  this.tmpl = function tmpl(str, data) {\n    // Figure out if we're getting a template, or if we need to\n    // load the template - and be sure to cache the result.\n    var fn = !/\\W/.test(str) ? cache[str] = cache[str] || tmpl(document.getElementById(str).innerHTML) : // Generate a reusable function that will serve as a template\n    // generator (and which will be cached).\n    new Function(\"obj\", \"var p=[],print=function(){p.push.apply(p,arguments);};\" + // Introduce the data as local variables using with(){}\n    \"with(obj){p.push('\" + // Convert the template into pure JavaScript\n    str.replace(/[\\r\\t\\n]/g, \" \").split(\"<%\").join(\"\\t\").replace(/((^|%>)[^\\t]*)'/g, \"$1\\r\").replace(/\\t=(.*?)%>/g, \"',$1,'\").split(\"\\t\").join(\"');\").split(\"%>\").join(\"p.push('\").split(\"\\r\").join(\"\\\\'\") + \"');}return p.join('');\"); // Provide some basic currying to the user\n\n    return data ? fn(data) : fn;\n  };\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL3NsaWRlci1yYW5nZS9qcy90bXBsLmpzPzZjNmEiXSwibmFtZXMiOlsiY2FjaGUiLCJ0bXBsIiwic3RyIiwiZGF0YSIsImZuIiwidGVzdCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhUTUwiLCJGdW5jdGlvbiIsInJlcGxhY2UiLCJzcGxpdCIsImpvaW4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxDQUFDLFlBQVU7QUFDVCxNQUFJQSxLQUFLLEdBQUcsRUFBWjs7QUFFQSxPQUFLQyxJQUFMLEdBQVksU0FBU0EsSUFBVCxDQUFjQyxHQUFkLEVBQW1CQyxJQUFuQixFQUF3QjtBQUNsQztBQUNBO0FBQ0EsUUFBSUMsRUFBRSxHQUFHLENBQUMsS0FBS0MsSUFBTCxDQUFVSCxHQUFWLENBQUQsR0FDUEYsS0FBSyxDQUFDRSxHQUFELENBQUwsR0FBYUYsS0FBSyxDQUFDRSxHQUFELENBQUwsSUFDWEQsSUFBSSxDQUFDSyxRQUFRLENBQUNDLGNBQVQsQ0FBd0JMLEdBQXhCLEVBQTZCTSxTQUE5QixDQUZDLEdBSVA7QUFDQTtBQUNBLFFBQUlDLFFBQUosQ0FBYSxLQUFiLEVBQ0UsMkRBRUE7QUFDQSx3QkFIQSxHQUtBO0FBQ0FQLElBQUFBLEdBQUcsQ0FDQVEsT0FESCxDQUNXLFdBRFgsRUFDd0IsR0FEeEIsRUFFR0MsS0FGSCxDQUVTLElBRlQsRUFFZUMsSUFGZixDQUVvQixJQUZwQixFQUdHRixPQUhILENBR1csa0JBSFgsRUFHK0IsTUFIL0IsRUFJR0EsT0FKSCxDQUlXLGFBSlgsRUFJMEIsUUFKMUIsRUFLR0MsS0FMSCxDQUtTLElBTFQsRUFLZUMsSUFMZixDQUtvQixLQUxwQixFQU1HRCxLQU5ILENBTVMsSUFOVCxFQU1lQyxJQU5mLENBTW9CLFVBTnBCLEVBT0dELEtBUEgsQ0FPUyxJQVBULEVBT2VDLElBUGYsQ0FPb0IsS0FQcEIsQ0FOQSxHQWNBLHdCQWZGLENBTkYsQ0FIa0MsQ0EwQmxDOztBQUNBLFdBQU9ULElBQUksR0FBR0MsRUFBRSxDQUFFRCxJQUFGLENBQUwsR0FBZ0JDLEVBQTNCO0FBQ0QsR0E1QkQ7QUE2QkQsQ0FoQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGUgSmF2YVNjcmlwdCBUZW1wbGF0aW5nXG4vLyBKb2huIFJlc2lnIC0gaHR0cDovL2Vqb2huLm9yZy8gLSBNSVQgTGljZW5zZWRcbihmdW5jdGlvbigpe1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgXG4gIHRoaXMudG1wbCA9IGZ1bmN0aW9uIHRtcGwoc3RyLCBkYXRhKXtcbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlJ3JlIGdldHRpbmcgYSB0ZW1wbGF0ZSwgb3IgaWYgd2UgbmVlZCB0b1xuICAgIC8vIGxvYWQgdGhlIHRlbXBsYXRlIC0gYW5kIGJlIHN1cmUgdG8gY2FjaGUgdGhlIHJlc3VsdC5cbiAgICB2YXIgZm4gPSAhL1xcVy8udGVzdChzdHIpID9cbiAgICAgIGNhY2hlW3N0cl0gPSBjYWNoZVtzdHJdIHx8XG4gICAgICAgIHRtcGwoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3RyKS5pbm5lckhUTUwpIDpcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgYSByZXVzYWJsZSBmdW5jdGlvbiB0aGF0IHdpbGwgc2VydmUgYXMgYSB0ZW1wbGF0ZVxuICAgICAgLy8gZ2VuZXJhdG9yIChhbmQgd2hpY2ggd2lsbCBiZSBjYWNoZWQpLlxuICAgICAgbmV3IEZ1bmN0aW9uKFwib2JqXCIsXG4gICAgICAgIFwidmFyIHA9W10scHJpbnQ9ZnVuY3Rpb24oKXtwLnB1c2guYXBwbHkocCxhcmd1bWVudHMpO307XCIgK1xuICAgICAgICBcbiAgICAgICAgLy8gSW50cm9kdWNlIHRoZSBkYXRhIGFzIGxvY2FsIHZhcmlhYmxlcyB1c2luZyB3aXRoKCl7fVxuICAgICAgICBcIndpdGgob2JqKXtwLnB1c2goJ1wiICtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHRlbXBsYXRlIGludG8gcHVyZSBKYXZhU2NyaXB0XG4gICAgICAgIHN0clxuICAgICAgICAgIC5yZXBsYWNlKC9bXFxyXFx0XFxuXS9nLCBcIiBcIilcbiAgICAgICAgICAuc3BsaXQoXCI8JVwiKS5qb2luKFwiXFx0XCIpXG4gICAgICAgICAgLnJlcGxhY2UoLygoXnwlPilbXlxcdF0qKScvZywgXCIkMVxcclwiKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHQ9KC4qPyklPi9nLCBcIicsJDEsJ1wiKVxuICAgICAgICAgIC5zcGxpdChcIlxcdFwiKS5qb2luKFwiJyk7XCIpXG4gICAgICAgICAgLnNwbGl0KFwiJT5cIikuam9pbihcInAucHVzaCgnXCIpXG4gICAgICAgICAgLnNwbGl0KFwiXFxyXCIpLmpvaW4oXCJcXFxcJ1wiKVxuICAgICAgKyBcIicpO31yZXR1cm4gcC5qb2luKCcnKTtcIik7XG4gICAgXG4gICAgLy8gUHJvdmlkZSBzb21lIGJhc2ljIGN1cnJ5aW5nIHRvIHRoZSB1c2VyXG4gICAgcmV0dXJuIGRhdGEgPyBmbiggZGF0YSApIDogZm47XG4gIH07XG59KSgpOyJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL3NsaWRlci1yYW5nZS9qcy90bXBsLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/slider-range/js/tmpl.js\n");

/***/ }),

/***/ "./node_modules/imask/dist/imask.js":
/*!******************************************!*\
  !*** ./node_modules/imask/dist/imask.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  // 7.2.1 RequireObjectCoercible(argument)\n  var _defined = function (it) {\n    if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n    return it;\n  };\n\n  // 7.1.13 ToObject(argument)\n\n  var _toObject = function (it) {\n    return Object(_defined(it));\n  };\n\n  var hasOwnProperty = {}.hasOwnProperty;\n  var _has = function (it, key) {\n    return hasOwnProperty.call(it, key);\n  };\n\n  var toString = {}.toString;\n\n  var _cof = function (it) {\n    return toString.call(it).slice(8, -1);\n  };\n\n  // fallback for non-array-like ES3 and non-enumerable old V8 strings\n\n  // eslint-disable-next-line no-prototype-builtins\n  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n    return _cof(it) == 'String' ? it.split('') : Object(it);\n  };\n\n  // to indexed object, toObject with fallback for non-array-like ES3 strings\n\n\n  var _toIobject = function (it) {\n    return _iobject(_defined(it));\n  };\n\n  // 7.1.4 ToInteger\n  var ceil = Math.ceil;\n  var floor = Math.floor;\n  var _toInteger = function (it) {\n    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n  };\n\n  // 7.1.15 ToLength\n\n  var min = Math.min;\n  var _toLength = function (it) {\n    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n  };\n\n  var max = Math.max;\n  var min$1 = Math.min;\n  var _toAbsoluteIndex = function (index, length) {\n    index = _toInteger(index);\n    return index < 0 ? max(index + length, 0) : min$1(index, length);\n  };\n\n  // false -> Array#indexOf\n  // true  -> Array#includes\n\n\n\n  var _arrayIncludes = function (IS_INCLUDES) {\n    return function ($this, el, fromIndex) {\n      var O = _toIobject($this);\n      var length = _toLength(O.length);\n      var index = _toAbsoluteIndex(fromIndex, length);\n      var value;\n      // Array#includes uses SameValueZero equality algorithm\n      // eslint-disable-next-line no-self-compare\n      if (IS_INCLUDES && el != el) while (length > index) {\n        value = O[index++];\n        // eslint-disable-next-line no-self-compare\n        if (value != value) return true;\n      // Array#indexOf ignores holes, Array#includes - not\n      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n        if (O[index] === el) return IS_INCLUDES || index || 0;\n      } return !IS_INCLUDES && -1;\n    };\n  };\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var _global = createCommonjsModule(function (module) {\n  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n  var global = module.exports = typeof window != 'undefined' && window.Math == Math\n    ? window : typeof self != 'undefined' && self.Math == Math ? self\n    // eslint-disable-next-line no-new-func\n    : Function('return this')();\n  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n  });\n\n  var SHARED = '__core-js_shared__';\n  var store = _global[SHARED] || (_global[SHARED] = {});\n  var _shared = function (key) {\n    return store[key] || (store[key] = {});\n  };\n\n  var id = 0;\n  var px = Math.random();\n  var _uid = function (key) {\n    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n  };\n\n  var shared = _shared('keys');\n\n  var _sharedKey = function (key) {\n    return shared[key] || (shared[key] = _uid(key));\n  };\n\n  var arrayIndexOf = _arrayIncludes(false);\n  var IE_PROTO = _sharedKey('IE_PROTO');\n\n  var _objectKeysInternal = function (object, names) {\n    var O = _toIobject(object);\n    var i = 0;\n    var result = [];\n    var key;\n    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);\n    // Don't enum bug & hidden keys\n    while (names.length > i) if (_has(O, key = names[i++])) {\n      ~arrayIndexOf(result, key) || result.push(key);\n    }\n    return result;\n  };\n\n  // IE 8- don't enum bug keys\n  var _enumBugKeys = (\n    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n  ).split(',');\n\n  // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\n\n  var _objectKeys = Object.keys || function keys(O) {\n    return _objectKeysInternal(O, _enumBugKeys);\n  };\n\n  var _core = createCommonjsModule(function (module) {\n  var core = module.exports = { version: '2.5.5' };\n  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n  });\n  var _core_1 = _core.version;\n\n  var _isObject = function (it) {\n    return typeof it === 'object' ? it !== null : typeof it === 'function';\n  };\n\n  var _anObject = function (it) {\n    if (!_isObject(it)) throw TypeError(it + ' is not an object!');\n    return it;\n  };\n\n  var _fails = function (exec) {\n    try {\n      return !!exec();\n    } catch (e) {\n      return true;\n    }\n  };\n\n  // Thank's IE8 for his funny defineProperty\n  var _descriptors = !_fails(function () {\n    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n  });\n\n  var document$1 = _global.document;\n  // typeof document.createElement is 'object' in old IE\n  var is = _isObject(document$1) && _isObject(document$1.createElement);\n  var _domCreate = function (it) {\n    return is ? document$1.createElement(it) : {};\n  };\n\n  var _ie8DomDefine = !_descriptors && !_fails(function () {\n    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;\n  });\n\n  // 7.1.1 ToPrimitive(input [, PreferredType])\n\n  // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n  // and the second argument - flag - preferred type is a string\n  var _toPrimitive = function (it, S) {\n    if (!_isObject(it)) return it;\n    var fn, val;\n    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;\n    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n    throw TypeError(\"Can't convert object to primitive value\");\n  };\n\n  var dP = Object.defineProperty;\n\n  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n    _anObject(O);\n    P = _toPrimitive(P, true);\n    _anObject(Attributes);\n    if (_ie8DomDefine) try {\n      return dP(O, P, Attributes);\n    } catch (e) { /* empty */ }\n    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n    if ('value' in Attributes) O[P] = Attributes.value;\n    return O;\n  };\n\n  var _objectDp = {\n  \tf: f\n  };\n\n  var _propertyDesc = function (bitmap, value) {\n    return {\n      enumerable: !(bitmap & 1),\n      configurable: !(bitmap & 2),\n      writable: !(bitmap & 4),\n      value: value\n    };\n  };\n\n  var _hide = _descriptors ? function (object, key, value) {\n    return _objectDp.f(object, key, _propertyDesc(1, value));\n  } : function (object, key, value) {\n    object[key] = value;\n    return object;\n  };\n\n  var _redefine = createCommonjsModule(function (module) {\n  var SRC = _uid('src');\n  var TO_STRING = 'toString';\n  var $toString = Function[TO_STRING];\n  var TPL = ('' + $toString).split(TO_STRING);\n\n  _core.inspectSource = function (it) {\n    return $toString.call(it);\n  };\n\n  (module.exports = function (O, key, val, safe) {\n    var isFunction = typeof val == 'function';\n    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);\n    if (O[key] === val) return;\n    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n    if (O === _global) {\n      O[key] = val;\n    } else if (!safe) {\n      delete O[key];\n      _hide(O, key, val);\n    } else if (O[key]) {\n      O[key] = val;\n    } else {\n      _hide(O, key, val);\n    }\n  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n  })(Function.prototype, TO_STRING, function toString() {\n    return typeof this == 'function' && this[SRC] || $toString.call(this);\n  });\n  });\n\n  var _aFunction = function (it) {\n    if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n    return it;\n  };\n\n  // optional / simple context binding\n\n  var _ctx = function (fn, that, length) {\n    _aFunction(fn);\n    if (that === undefined) return fn;\n    switch (length) {\n      case 1: return function (a) {\n        return fn.call(that, a);\n      };\n      case 2: return function (a, b) {\n        return fn.call(that, a, b);\n      };\n      case 3: return function (a, b, c) {\n        return fn.call(that, a, b, c);\n      };\n    }\n    return function (/* ...args */) {\n      return fn.apply(that, arguments);\n    };\n  };\n\n  var PROTOTYPE = 'prototype';\n\n  var $export = function (type, name, source) {\n    var IS_FORCED = type & $export.F;\n    var IS_GLOBAL = type & $export.G;\n    var IS_STATIC = type & $export.S;\n    var IS_PROTO = type & $export.P;\n    var IS_BIND = type & $export.B;\n    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n    var key, own, out, exp;\n    if (IS_GLOBAL) source = name;\n    for (key in source) {\n      // contains in native\n      own = !IS_FORCED && target && target[key] !== undefined;\n      // export native or passed\n      out = (own ? target : source)[key];\n      // bind timers to global for call from export context\n      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n      // extend global\n      if (target) _redefine(target, key, out, type & $export.U);\n      // export\n      if (exports[key] != out) _hide(exports, key, exp);\n      if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n    }\n  };\n  _global.core = _core;\n  // type bitmap\n  $export.F = 1;   // forced\n  $export.G = 2;   // global\n  $export.S = 4;   // static\n  $export.P = 8;   // proto\n  $export.B = 16;  // bind\n  $export.W = 32;  // wrap\n  $export.U = 64;  // safe\n  $export.R = 128; // real proto method for `library`\n  var _export = $export;\n\n  // most Object methods by ES6 should accept primitives\n\n\n\n  var _objectSap = function (KEY, exec) {\n    var fn = (_core.Object || {})[KEY] || Object[KEY];\n    var exp = {};\n    exp[KEY] = exec(fn);\n    _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);\n  };\n\n  // 19.1.2.14 Object.keys(O)\n\n\n\n  _objectSap('keys', function () {\n    return function keys(it) {\n      return _objectKeys(_toObject(it));\n    };\n  });\n\n  var keys = _core.Object.keys;\n\n  var _stringRepeat = function repeat(count) {\n    var str = String(_defined(this));\n    var res = '';\n    var n = _toInteger(count);\n    if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n    for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n    return res;\n  };\n\n  _export(_export.P, 'String', {\n    // 21.1.3.13 String.prototype.repeat(count)\n    repeat: _stringRepeat\n  });\n\n  var repeat = _core.String.repeat;\n\n  // https://github.com/tc39/proposal-string-pad-start-end\n\n\n\n\n  var _stringPad = function (that, maxLength, fillString, left) {\n    var S = String(_defined(that));\n    var stringLength = S.length;\n    var fillStr = fillString === undefined ? ' ' : String(fillString);\n    var intMaxLength = _toLength(maxLength);\n    if (intMaxLength <= stringLength || fillStr == '') return S;\n    var fillLen = intMaxLength - stringLength;\n    var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n    return left ? stringFiller + S : S + stringFiller;\n  };\n\n  var navigator = _global.navigator;\n\n  var _userAgent = navigator && navigator.userAgent || '';\n\n  // https://github.com/tc39/proposal-string-pad-start-end\n\n\n\n\n  // https://github.com/zloirock/core-js/issues/280\n  _export(_export.P + _export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(_userAgent), 'String', {\n    padStart: function padStart(maxLength /* , fillString = ' ' */) {\n      return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n    }\n  });\n\n  var padStart = _core.String.padStart;\n\n  // https://github.com/tc39/proposal-string-pad-start-end\n\n\n\n\n  // https://github.com/zloirock/core-js/issues/280\n  _export(_export.P + _export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(_userAgent), 'String', {\n    padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n      return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n    }\n  });\n\n  var padEnd = _core.String.padEnd;\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var get = function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  };\n\n  var inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var possibleConstructorReturn = function (self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  var set = function set(object, property, value, receiver) {\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent !== null) {\n        set(parent, property, value, receiver);\n      }\n    } else if (\"value\" in desc && desc.writable) {\n      desc.value = value;\n    } else {\n      var setter = desc.set;\n\n      if (setter !== undefined) {\n        setter.call(receiver, value);\n      }\n    }\n\n    return value;\n  };\n\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  /** Checks if value is string */\n  function isString(str) {\n    return typeof str === 'string' || str instanceof String;\n  }\n\n  /** Conforms string with fallback */\n  function conform(res, str) {\n    var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    return isString(res) ? res : res ? str : fallback;\n  }\n\n  /**\r\n    Direction\r\n    @prop {number} NONE\r\n    @prop {number} LEFT\r\n    @prop {number} RIGHT\r\n  */\n  var DIRECTION = {\n    NONE: 0,\n    LEFT: -1,\n    RIGHT: 1\n    /**\r\n      Direction\r\n      @enum {number}\r\n    */\n  };\n\n  /** Returns next char position in direction */\n  function indexInDirection(pos, direction) {\n    if (direction === DIRECTION.LEFT) --pos;\n    return pos;\n  }\n\n  /** Escapes regular expression control chars */\n  function escapeRegExp(str) {\n    return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1');\n  }\n\n  // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes\n  function objectIncludes(b, a) {\n    if (a === b) return true;\n\n    var arrA = Array.isArray(a),\n        arrB = Array.isArray(b),\n        i;\n\n    if (arrA && arrB) {\n      if (a.length != b.length) return false;\n      for (i = 0; i < a.length; i++) {\n        if (!objectIncludes(a[i], b[i])) return false;\n      }return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    if (a && b && (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {\n      var keys = Object.keys(a);\n      // if (keys.length !== Object.keys(b).length) return false;\n\n      var dateA = a instanceof Date,\n          dateB = b instanceof Date;\n      if (dateA && dateB) return a.getTime() == b.getTime();\n      if (dateA != dateB) return false;\n\n      var regexpA = a instanceof RegExp,\n          regexpB = b instanceof RegExp;\n      if (regexpA && regexpB) return a.toString() == b.toString();\n      if (regexpA != regexpB) return false;\n\n      for (i = 0; i < keys.length; i++) {\n        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n      }for (i = 0; i < keys.length; i++) {\n        if (!objectIncludes(a[keys[i]], b[keys[i]])) return false;\n      }return true;\n    }\n\n    return false;\n  }\n\n  /* eslint-disable no-undef */\n  var g = typeof window !== 'undefined' && window || typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g || typeof self !== 'undefined' && self.self === self && self || {};\n\n  /** Provides details of changing input */\n\n  var ActionDetails = function () {\n    /** Old input value */\n\n    /** Current input value */\n    function ActionDetails(value, cursorPos, oldValue, oldSelection) {\n      classCallCheck(this, ActionDetails);\n\n      this.value = value;\n      this.cursorPos = cursorPos;\n      this.oldValue = oldValue;\n      this.oldSelection = oldSelection;\n\n      // double check if left part was changed (autofilling, other non-standard input triggers)\n      while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {\n        --this.oldSelection.start;\n      }\n    }\n\n    /**\r\n      Start changing position\r\n      @readonly\r\n    */\n\n    /** Old selection */\n\n    /** Current cursor position */\n\n\n    createClass(ActionDetails, [{\n      key: 'startChangePos',\n      get: function get$$1() {\n        return Math.min(this.cursorPos, this.oldSelection.start);\n      }\n\n      /**\r\n        Inserted symbols count\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'insertedCount',\n      get: function get$$1() {\n        return this.cursorPos - this.startChangePos;\n      }\n\n      /**\r\n        Inserted symbols\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'inserted',\n      get: function get$$1() {\n        return this.value.substr(this.startChangePos, this.insertedCount);\n      }\n\n      /**\r\n        Removed symbols count\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'removedCount',\n      get: function get$$1() {\n        // Math.max for opposite operation\n        return Math.max(this.oldSelection.end - this.startChangePos ||\n        // for Delete\n        this.oldValue.length - this.value.length, 0);\n      }\n\n      /**\r\n        Removed symbols\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'removed',\n      get: function get$$1() {\n        return this.oldValue.substr(this.startChangePos, this.removedCount);\n      }\n\n      /**\r\n        Unchanged head symbols\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'head',\n      get: function get$$1() {\n        return this.value.substring(0, this.startChangePos);\n      }\n\n      /**\r\n        Unchanged tail symbols\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'tail',\n      get: function get$$1() {\n        return this.value.substring(this.startChangePos + this.insertedCount);\n      }\n\n      /**\r\n        Remove direction\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'removeDirection',\n      get: function get$$1() {\n        if (!this.removedCount || this.insertedCount) return DIRECTION.NONE;\n\n        // align right if delete at right or if range removed (event with backspace)\n        return this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? DIRECTION.RIGHT : DIRECTION.LEFT;\n      }\n    }]);\n    return ActionDetails;\n  }();\n\n  /**\r\n    Provides details of changing model value\r\n    @param {Object} [details]\r\n    @param {string} [details.inserted] - Inserted symbols\r\n    @param {boolean} [details.overflow] - Is overflowed\r\n    @param {number} [details.removeCount] - Removed symbols count\r\n    @param {number} [details.shift] - Additional offset if any changes occurred before current position\r\n  */\n  var ChangeDetails = function () {\n    /** Additional offset if any changes occurred before current position */\n\n    /** Inserted symbols */\n    function ChangeDetails(details) {\n      classCallCheck(this, ChangeDetails);\n\n      _extends(this, {\n        inserted: '',\n        overflow: false,\n        shift: 0\n      }, details);\n    }\n\n    /**\r\n      Aggregate changes\r\n      @returns {ChangeDetails} `this`\r\n    */\n\n    /** Is overflowed */\n\n\n    createClass(ChangeDetails, [{\n      key: 'aggregate',\n      value: function aggregate(details) {\n        if (details.rawInserted) this.rawInserted += details.rawInserted;\n        this.inserted += details.inserted;\n        this.shift += details.shift;\n        this.overflow = this.overflow || details.overflow;\n        return this;\n      }\n\n      /** Total offset considering all changes */\n\n    }, {\n      key: 'offset',\n      get: function get$$1() {\n        return this.shift + this.inserted.length;\n      }\n\n      /** Raw inserted is used by dynamic mask */\n\n    }, {\n      key: 'rawInserted',\n      get: function get$$1() {\n        return this._rawInserted != null ? this._rawInserted : this.inserted;\n      },\n      set: function set$$1(rawInserted) {\n        this._rawInserted = rawInserted;\n      }\n    }]);\n    return ChangeDetails;\n  }();\n\n  /** Supported mask type */\n\n\n  /** Append flags */\n\n\n  /** Extract flags */\n\n  /** Provides common masking stuff */\n  var Masked = function () {\n    /** Does additional processing in the end of editing */\n\n    /** Transforms value before mask processing */\n    function Masked(opts) {\n      classCallCheck(this, Masked);\n\n      this._value = '';\n      this._update(opts);\n      this.isInitialized = true;\n    }\n\n    /** Sets and applies new options */\n\n    /** */\n\n    /** Validates if value is acceptable */\n    // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n    /** @type {Mask} */\n\n\n    createClass(Masked, [{\n      key: 'updateOptions',\n      value: function updateOptions(opts) {\n        this.withValueRefresh(this._update.bind(this, opts));\n      }\n\n      /**\r\n        Sets new options\r\n        @protected\r\n      */\n\n    }, {\n      key: '_update',\n      value: function _update(opts) {\n        _extends(this, opts);\n      }\n\n      /** Clones masked with options and value */\n\n    }, {\n      key: 'clone',\n      value: function clone() {\n        var m = new Masked(this);\n        m._value = this.value.slice();\n        return m;\n      }\n\n      /** */\n\n    }, {\n      key: 'assign',\n      value: function assign(source) {\n        // $FlowFixMe\n        return _extends(this, source);\n      }\n\n      /** Resets value */\n\n    }, {\n      key: 'reset',\n      value: function reset() {\n        this._value = '';\n      }\n\n      /** */\n\n    }, {\n      key: 'resolve',\n\n\n      /** Resolve new value */\n      value: function resolve(value) {\n        this.reset();\n        this._append(value, { input: true });\n        this._appendTail();\n        this.doCommit();\n        return this.value;\n      }\n\n      /** */\n\n    }, {\n      key: 'nearestInputPos',\n\n\n      /** Finds nearest input position in direction */\n      value: function nearestInputPos(cursorPos, direction) {\n        return cursorPos;\n      }\n\n      /** Extracts value in range considering flags */\n\n    }, {\n      key: 'extractInput',\n      value: function extractInput() {\n        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n        return this.value.slice(fromPos, toPos);\n      }\n\n      /** Extracts tail in range */\n\n    }, {\n      key: '_extractTail',\n      value: function _extractTail() {\n        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n        return {\n          value: this.extractInput(fromPos, toPos),\n          fromPos: fromPos,\n          toPos: toPos\n        };\n      }\n\n      /** Appends tail */\n\n    }, {\n      key: '_appendTail',\n      value: function _appendTail(tail) {\n        return this._append(tail ? tail.value : '', { tail: true });\n      }\n\n      /** Appends symbols considering flags */\n\n    }, {\n      key: '_append',\n      value: function _append(str) {\n        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var oldValueLength = this.value.length;\n        var consistentValue = this.clone();\n        var overflow = false;\n\n        str = this.doPrepare(str, flags);\n\n        for (var ci = 0; ci < str.length; ++ci) {\n          this._value += str[ci];\n          if (this.doValidate(flags) === false) {\n            this.assign(consistentValue);\n            if (!flags.input) {\n              // in `input` mode dont skip invalid chars\n              overflow = true;\n              break;\n            }\n          }\n\n          consistentValue = this.clone();\n        }\n\n        return new ChangeDetails({\n          inserted: this.value.slice(oldValueLength),\n          overflow: overflow\n        });\n      }\n\n      /** Appends symbols considering tail */\n\n    }, {\n      key: 'appendWithTail',\n      value: function appendWithTail(str, tail) {\n        // TODO refactor\n        var aggregateDetails = new ChangeDetails();\n        var consistentValue = this.clone();\n        var consistentAppended = void 0;\n\n        for (var ci = 0; ci < str.length; ++ci) {\n          var ch = str[ci];\n\n          var appendDetails = this._append(ch, { input: true });\n          consistentAppended = this.clone();\n          var tailAppended = !appendDetails.overflow && !this._appendTail(tail).overflow;\n          if (!tailAppended || this.doValidate({ tail: true }) === false) {\n            this.assign(consistentValue);\n            break;\n          }\n\n          this.assign(consistentAppended);\n          consistentValue = this.clone();\n          aggregateDetails.aggregate(appendDetails);\n        }\n\n        // TODO needed for cases when\n        // 1) REMOVE ONLY AND NO LOOP AT ALL\n        // 2) last loop iteration removes tail\n        // 3) when breaks on tail insert\n\n        // aggregate only shift from tail\n        aggregateDetails.shift += this._appendTail(tail).shift;\n\n        return aggregateDetails;\n      }\n\n      /** */\n\n    }, {\n      key: 'remove',\n      value: function remove() {\n        var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length - from;\n\n        this._value = this.value.slice(0, from) + this.value.slice(from + count);\n        return new ChangeDetails();\n      }\n\n      /** Calls function and reapplies current value */\n\n    }, {\n      key: 'withValueRefresh',\n      value: function withValueRefresh(fn) {\n        if (this._refreshing || !this.isInitialized) return fn();\n        this._refreshing = true;\n\n        var unmasked = this.unmaskedValue;\n        var value = this.value;\n\n        var ret = fn();\n\n        // try to update with raw value first to keep fixed chars\n        if (this.resolve(value) !== value) {\n          // or fallback to unmasked\n          this.unmaskedValue = unmasked;\n        }\n\n        delete this._refreshing;\n        return ret;\n      }\n\n      /**\r\n        Prepares string before mask processing\r\n        @protected\r\n      */\n\n    }, {\n      key: 'doPrepare',\n      value: function doPrepare(str) {\n        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        return this.prepare ? this.prepare(str, this, flags) : str;\n      }\n\n      /**\r\n        Validates if value is acceptable\r\n        @protected\r\n      */\n\n    }, {\n      key: 'doValidate',\n      value: function doValidate(flags) {\n        return !this.validate || this.validate(this.value, this, flags);\n      }\n\n      /**\r\n        Does additional processing in the end of editing\r\n        @protected\r\n      */\n\n    }, {\n      key: 'doCommit',\n      value: function doCommit() {\n        if (this.commit) this.commit(this.value, this);\n      }\n\n      // TODO\n      // insert (str, fromPos, flags)\n\n      /** */\n\n    }, {\n      key: 'splice',\n      value: function splice(start, deleteCount, inserted, removeDirection) {\n        var tailPos = start + deleteCount;\n        var tail = this._extractTail(tailPos);\n\n        var startChangePos = this.nearestInputPos(start, removeDirection);\n        var changeDetails = new ChangeDetails({\n          shift: startChangePos - start // adjust shift if start was aligned\n        }).aggregate(this.remove(startChangePos)).aggregate(this.appendWithTail(inserted, tail));\n\n        return changeDetails;\n      }\n    }, {\n      key: 'value',\n      get: function get$$1() {\n        return this._value;\n      },\n      set: function set$$1(value) {\n        this.resolve(value);\n      }\n    }, {\n      key: 'unmaskedValue',\n      get: function get$$1() {\n        return this.value;\n      },\n      set: function set$$1(value) {\n        this.reset();\n        this._append(value);\n        this._appendTail();\n        this.doCommit();\n      }\n\n      /** */\n\n    }, {\n      key: 'typedValue',\n      get: function get$$1() {\n        return this.unmaskedValue;\n      },\n      set: function set$$1(value) {\n        this.unmaskedValue = value;\n      }\n\n      /** Value that includes raw user input */\n\n    }, {\n      key: 'rawInputValue',\n      get: function get$$1() {\n        return this.extractInput(0, this.value.length, { raw: true });\n      },\n      set: function set$$1(value) {\n        this.reset();\n        this._append(value, { raw: true });\n        this._appendTail();\n        this.doCommit();\n      }\n\n      /** */\n\n    }, {\n      key: 'isComplete',\n      get: function get$$1() {\n        return true;\n      }\n    }]);\n    return Masked;\n  }();\n\n  /** Get Masked class by mask type */\n  function maskedClass(mask) {\n    if (mask == null) {\n      throw new Error('mask property should be defined');\n    }\n\n    if (mask instanceof RegExp) return g.IMask.MaskedRegExp;\n    if (isString(mask)) return g.IMask.MaskedPattern;\n    if (mask instanceof Date || mask === Date) return g.IMask.MaskedDate;\n    if (mask instanceof Number || typeof mask === 'number' || mask === Number) return g.IMask.MaskedNumber;\n    if (Array.isArray(mask) || mask === Array) return g.IMask.MaskedDynamic;\n    // $FlowFixMe\n    if (mask.prototype instanceof g.IMask.Masked) return mask;\n    // $FlowFixMe\n    if (mask instanceof Function) return g.IMask.MaskedFunction;\n\n    console.warn('Mask not found for mask', mask); // eslint-disable-line no-console\n    return g.IMask.Masked;\n  }\n\n  /** Creates new {@link Masked} depending on mask type */\n  function createMask(opts) {\n    opts = _extends({}, opts); // clone\n    var mask = opts.mask;\n\n    if (mask instanceof g.IMask.Masked) return mask;\n\n    var MaskedClass = maskedClass(mask);\n    return new MaskedClass(opts);\n  }\n\n  /** */\n\n  /** */\n  var PatternDefinition = function () {\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n    function PatternDefinition(opts) {\n      classCallCheck(this, PatternDefinition);\n      // TODO flow\n      _extends(this, opts);\n\n      if (this.mask) {\n        this._masked = createMask(opts);\n      }\n    }\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n\n    /** */\n\n\n    createClass(PatternDefinition, [{\n      key: 'reset',\n      value: function reset() {\n        this.isHollow = false;\n        this.isRawInput = false;\n        if (this._masked) this._masked.reset();\n      }\n\n      /** */\n\n    }, {\n      key: 'resolve',\n\n\n      /** */\n      value: function resolve(ch) {\n        if (!this._masked) return false;\n        return this._masked.resolve(ch);\n      }\n    }, {\n      key: 'isInput',\n      get: function get$$1() {\n        return this.type === PatternDefinition.TYPES.INPUT;\n      }\n\n      /** */\n\n    }, {\n      key: 'isHiddenHollow',\n      get: function get$$1() {\n        return this.isHollow && this.optional;\n      }\n    }]);\n    return PatternDefinition;\n  }();\n\n  PatternDefinition.DEFAULTS = {\n    '0': /\\d/,\n    'a': /[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/, // http://stackoverflow.com/a/22075070\n    '*': /./\n  };\n  /**\r\n    @prop {string} INPUT\r\n    @prop {string} FIXED\r\n  */\n  PatternDefinition.TYPES = {\n    INPUT: 'input',\n    FIXED: 'fixed'\n  };\n\n  /** */\n\n\n  /** */\n\n  /**\r\n    Pattern group symbols from parent\r\n    @param {MaskedPattern} masked - Internal {@link masked} model\r\n    @param {Object} opts\r\n    @param {string} opts.name - Group name\r\n    @param {number} opts.offset - Group offset in masked definitions array\r\n    @param {string} opts.mask - Group mask\r\n    @param {Function} [opts.validate] - Custom group validator\r\n  */\n  var PatternGroup = function () {\n    /** Group mask */\n\n    /** Group name */\n\n    /** */\n    function PatternGroup(masked, _ref) {\n      var name = _ref.name,\n          offset = _ref.offset,\n          mask = _ref.mask,\n          validate = _ref.validate;\n      classCallCheck(this, PatternGroup);\n\n      this.masked = masked;\n      this.name = name;\n      this.offset = offset;\n      this.mask = mask;\n      this.validate = validate || function () {\n        return true;\n      };\n    }\n\n    /** Slice of internal {@link masked} value */\n\n    /** Custom group validator */\n\n    /** Group offset in masked definitions array */\n\n\n    /** Internal {@link masked} model */\n\n    /** */\n\n\n    createClass(PatternGroup, [{\n      key: 'doValidate',\n\n\n      /** Validates if current value is acceptable */\n      value: function doValidate(flags) {\n        return this.validate(this.value, this, flags);\n      }\n    }, {\n      key: 'value',\n      get: function get$$1() {\n        return this.masked.value.slice(this.masked.mapDefIndexToPos(this.offset), this.masked.mapDefIndexToPos(this.offset + this.mask.length));\n      }\n\n      /** Unmasked slice of internal {@link masked} value */\n\n    }, {\n      key: 'unmaskedValue',\n      get: function get$$1() {\n        return this.masked.extractInput(this.masked.mapDefIndexToPos(this.offset), this.masked.mapDefIndexToPos(this.offset + this.mask.length));\n      }\n    }]);\n    return PatternGroup;\n  }();\n  var RangeGroup = function () {\n    /** @type {Function} */\n    function RangeGroup(_ref2) {\n      var _ref3 = slicedToArray(_ref2, 2),\n          from = _ref3[0],\n          to = _ref3[1];\n\n      var maxlen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(to).length;\n      classCallCheck(this, RangeGroup);\n\n      this._from = from;\n      this._to = to;\n      this._maxLength = maxlen;\n      this.validate = this.validate.bind(this);\n\n      this._update();\n    }\n    /** @type {string} */\n\n\n    createClass(RangeGroup, [{\n      key: '_update',\n      value: function _update() {\n        this._maxLength = Math.max(this._maxLength, String(this.to).length);\n        this.mask = '0'.repeat(this._maxLength);\n      }\n    }, {\n      key: 'validate',\n      value: function validate(str) {\n        var minstr = '';\n        var maxstr = '';\n\n        var _ref4 = str.match(/^(\\D*)(\\d*)(\\D*)/) || [],\n            _ref5 = slicedToArray(_ref4, 3),\n            placeholder = _ref5[1],\n            num = _ref5[2];\n\n        if (num) {\n          minstr = '0'.repeat(placeholder.length) + num;\n          maxstr = '9'.repeat(placeholder.length) + num;\n        }\n\n        var firstNonZero = str.search(/[^0]/);\n        if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n\n        minstr = minstr.padEnd(this._maxLength, '0');\n        maxstr = maxstr.padEnd(this._maxLength, '9');\n\n        return this.from <= Number(maxstr) && Number(minstr) <= this.to;\n      }\n    }, {\n      key: 'to',\n      get: function get$$1() {\n        return this._to;\n      },\n      set: function set$$1(to) {\n        this._to = to;\n        this._update();\n      }\n    }, {\n      key: 'from',\n      get: function get$$1() {\n        return this._from;\n      },\n      set: function set$$1(from) {\n        this._from = from;\n        this._update();\n      }\n    }, {\n      key: 'maxLength',\n      get: function get$$1() {\n        return this._maxLength;\n      },\n      set: function set$$1(maxLength) {\n        this._maxLength = maxLength;\n        this._update();\n      }\n    }, {\n      key: '_matchFrom',\n      get: function get$$1() {\n        return this.maxLength - String(this.from).length;\n      }\n    }]);\n    return RangeGroup;\n  }();\n\n  /** Pattern group that validates enum values */\n  function EnumGroup(enums) {\n    return {\n      mask: '*'.repeat(enums[0].length),\n      validate: function validate(value, group, flags) {\n        return enums.some(function (e) {\n          return e.indexOf(group.unmaskedValue) >= 0;\n        });\n      }\n    };\n  }\n\n  PatternGroup.Range = RangeGroup;\n  PatternGroup.Enum = EnumGroup;\n\n  var ChunksTailDetails = function () {\n    function ChunksTailDetails(chunks) {\n      classCallCheck(this, ChunksTailDetails);\n\n      this.chunks = chunks;\n    }\n\n    createClass(ChunksTailDetails, [{\n      key: 'value',\n      get: function get$$1() {\n        return this.chunks.map(function (c) {\n          return c.value;\n        }).join('');\n      }\n    }, {\n      key: 'fromPos',\n      get: function get$$1() {\n        var firstChunk = this.chunks[0];\n        return firstChunk && firstChunk.stop;\n      }\n    }, {\n      key: 'toPos',\n      get: function get$$1() {\n        var lastChunk = this.chunks[this.chunks.length - 1];\n        return lastChunk && lastChunk.stop;\n      }\n    }]);\n    return ChunksTailDetails;\n  }();\n\n  /**\r\n    Pattern mask\r\n    @param {Object} opts\r\n    @param {Object} opts.groups\r\n    @param {Object} opts.definitions\r\n    @param {string} opts.placeholderChar\r\n    @param {boolean} opts.lazy\r\n  */\n  var MaskedPattern = function (_Masked) {\n    inherits(MaskedPattern, _Masked);\n\n    // TODO mask type\n    /** Single char for empty input */\n\n\n    /** */\n    function MaskedPattern() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      classCallCheck(this, MaskedPattern);\n      // TODO type $Shape<MaskedPatternOptions>={} does not work\n      opts.definitions = _extends({}, PatternDefinition.DEFAULTS, opts.definitions);\n      return possibleConstructorReturn(this, (MaskedPattern.__proto__ || Object.getPrototypeOf(MaskedPattern)).call(this, _extends({}, MaskedPattern.DEFAULTS, opts)));\n    }\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n\n    /** Show placeholder only when needed */\n\n    /** */\n\n\n    createClass(MaskedPattern, [{\n      key: '_update',\n      value: function _update() {\n        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        opts.definitions = _extends({}, this.definitions, opts.definitions);\n        get(MaskedPattern.prototype.__proto__ || Object.getPrototypeOf(MaskedPattern.prototype), '_update', this).call(this, opts);\n        this._rebuildMask();\n      }\n\n      /** */\n\n    }, {\n      key: '_rebuildMask',\n      value: function _rebuildMask() {\n        var _this2 = this;\n\n        var defs = this.definitions;\n        this._charDefs = [];\n        this._groupDefs = [];\n\n        var pattern = this.mask;\n        if (!pattern || !defs) return;\n\n        var unmaskingBlock = false;\n        var optionalBlock = false;\n        var stopAlign = false;\n\n        var _loop = function _loop(_i) {\n          if (_this2.groups) {\n            var p = pattern.slice(_i);\n            var gNames = Object.keys(_this2.groups).filter(function (gName) {\n              return p.indexOf(gName) === 0;\n            });\n            // order by key length\n            gNames.sort(function (a, b) {\n              return b.length - a.length;\n            });\n            // use group name with max length\n            var gName = gNames[0];\n            if (gName) {\n              var group = _this2.groups[gName];\n              _this2._groupDefs.push(new PatternGroup(_this2, {\n                name: gName,\n                offset: _this2._charDefs.length,\n                mask: group.mask,\n                validate: group.validate\n              }));\n              pattern = pattern.replace(gName, group.mask);\n            }\n          }\n\n          var char = pattern[_i];\n          var type = char in defs ? PatternDefinition.TYPES.INPUT : PatternDefinition.TYPES.FIXED;\n          var unmasking = type === PatternDefinition.TYPES.INPUT || unmaskingBlock;\n          var optional = type === PatternDefinition.TYPES.INPUT && optionalBlock;\n\n          if (char === MaskedPattern.STOP_CHAR) {\n            stopAlign = true;\n            return 'continue';\n          }\n\n          if (char === '{' || char === '}') {\n            unmaskingBlock = !unmaskingBlock;\n            return 'continue';\n          }\n\n          if (char === '[' || char === ']') {\n            optionalBlock = !optionalBlock;\n            return 'continue';\n          }\n\n          if (char === MaskedPattern.ESCAPE_CHAR) {\n            ++_i;\n            char = pattern[_i];\n            if (!char) return 'break';\n            type = PatternDefinition.TYPES.FIXED;\n          }\n\n          _this2._charDefs.push(new PatternDefinition({\n            char: char,\n            type: type,\n            optional: optional,\n            stopAlign: stopAlign,\n            unmasking: unmasking,\n            mask: type === PatternDefinition.TYPES.INPUT ? defs[char] : function (value) {\n              return value === char;\n            }\n          }));\n\n          stopAlign = false;\n          i = _i;\n        };\n\n        _loop2: for (var i = 0; i < pattern.length; ++i) {\n          var _ret = _loop(i);\n\n          switch (_ret) {\n            case 'continue':\n              continue;\n\n            case 'break':\n              break _loop2;}\n        }\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doValidate',\n      value: function doValidate() {\n        var _babelHelpers$get;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return this._groupDefs.every(function (g$$1) {\n          return g$$1.doValidate.apply(g$$1, toConsumableArray(args));\n        }) && (_babelHelpers$get = get(MaskedPattern.prototype.__proto__ || Object.getPrototypeOf(MaskedPattern.prototype), 'doValidate', this)).call.apply(_babelHelpers$get, [this].concat(toConsumableArray(args)));\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'clone',\n      value: function clone() {\n        var _this3 = this;\n\n        var m = new MaskedPattern(this);\n        m._value = this.value;\n        // $FlowFixMe\n        m._charDefs.forEach(function (d, i) {\n          return _extends(d, _this3._charDefs[i]);\n        });\n        // $FlowFixMe\n        m._groupDefs.forEach(function (d, i) {\n          return _extends(d, _this3._groupDefs[i]);\n        });\n        return m;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'reset',\n      value: function reset() {\n        get(MaskedPattern.prototype.__proto__ || Object.getPrototypeOf(MaskedPattern.prototype), 'reset', this).call(this);\n        this._charDefs.forEach(function (d) {\n          delete d.isHollow;\n        });\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'hiddenHollowsBefore',\n\n\n      /** */\n      value: function hiddenHollowsBefore(defIndex) {\n        return this._charDefs.slice(0, defIndex).filter(function (d) {\n          return d.isHiddenHollow;\n        }).length;\n      }\n\n      /** Map definition index to position on view */\n\n    }, {\n      key: 'mapDefIndexToPos',\n      value: function mapDefIndexToPos(defIndex) {\n        return defIndex - this.hiddenHollowsBefore(defIndex);\n      }\n\n      /** Map position on view to definition index */\n\n    }, {\n      key: 'mapPosToDefIndex',\n      value: function mapPosToDefIndex(pos) {\n        var defIndex = pos;\n        for (var di = 0; di < this._charDefs.length; ++di) {\n          var def = this._charDefs[di];\n          if (di >= defIndex) break;\n          if (def.isHiddenHollow) ++defIndex;\n        }\n        return defIndex;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_appendTail',\n\n\n      /**\r\n        @override\r\n      */\n      value: function _appendTail(tail) {\n        var details = new ChangeDetails();\n        if (tail) {\n          details.aggregate(tail instanceof ChunksTailDetails ? this._appendChunks(tail.chunks, { tail: true }) : get(MaskedPattern.prototype.__proto__ || Object.getPrototypeOf(MaskedPattern.prototype), '_appendTail', this).call(this, tail));\n        }\n        return details.aggregate(this._appendPlaceholder());\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_append',\n      value: function _append(str) {\n        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var oldValueLength = this.value.length;\n        var rawInserted = '';\n        var overflow = false;\n\n        str = this.doPrepare(str, flags);\n\n        for (var ci = 0, di = this.mapPosToDefIndex(this.value.length); ci < str.length;) {\n          var ch = str[ci];\n          var def = this._charDefs[di];\n\n          // check overflow\n          if (def == null) {\n            overflow = true;\n            break;\n          }\n\n          // reset\n          def.isHollow = false;\n\n          var resolved = void 0,\n              skipped = void 0;\n          var chres = conform(def.resolve(ch), ch);\n\n          if (def.type === PatternDefinition.TYPES.INPUT) {\n            if (chres) {\n              this._value += chres;\n              if (!this.doValidate()) {\n                chres = '';\n                this._value = this.value.slice(0, -1);\n              }\n            }\n\n            resolved = !!chres;\n            skipped = !chres && !def.optional;\n\n            if (!chres) {\n              if (!def.optional && !flags.input && !this.lazy) {\n                this._value += this.placeholderChar;\n                skipped = false;\n              }\n              if (!skipped) def.isHollow = true;\n            } else {\n              rawInserted += chres;\n            }\n          } else {\n            this._value += def.char;\n            resolved = chres && (def.unmasking || flags.input || flags.raw) && !flags.tail;\n            def.isRawInput = resolved && (flags.raw || flags.input);\n            if (def.isRawInput) rawInserted += def.char;\n          }\n\n          if (!skipped) ++di;\n          if (resolved || skipped) ++ci;\n        }\n\n        return new ChangeDetails({\n          inserted: this.value.slice(oldValueLength),\n          rawInserted: rawInserted,\n          overflow: overflow\n        });\n      }\n\n      /** Appends chunks splitted by stop chars */\n\n    }, {\n      key: '_appendChunks',\n      value: function _appendChunks(chunks) {\n        var details = new ChangeDetails();\n\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        for (var ci = 0; ci < chunks.length; ++ci) {\n          var _chunks$ci = chunks[ci],\n              stop = _chunks$ci.stop,\n              value = _chunks$ci.value;\n\n          var fromDef = stop != null && this._charDefs[stop];\n          // lets double check if stopAlign is here\n          if (fromDef && fromDef.stopAlign) details.aggregate(this._appendPlaceholder(stop));\n          if (details.aggregate(this._append.apply(this, [value].concat(toConsumableArray(args)))).overflow) break;\n        }\n        return details;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_extractTail',\n      value: function _extractTail() {\n        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n        return new ChunksTailDetails(this._extractInputChunks(fromPos, toPos));\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'extractInput',\n      value: function extractInput() {\n        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n        var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (fromPos === toPos) return '';\n\n        var str = this.value;\n        var input = '';\n\n        var toDefIndex = this.mapPosToDefIndex(toPos);\n        for (var ci = fromPos, di = this.mapPosToDefIndex(fromPos); ci < toPos && ci < str.length && di < toDefIndex; ++di) {\n          var ch = str[ci];\n          var def = this._charDefs[di];\n\n          if (!def) break;\n          if (def.isHiddenHollow) continue;\n\n          if (def.isInput && !def.isHollow || flags.raw && !def.isInput && def.isRawInput) input += ch;\n          ++ci;\n        }\n        return input;\n      }\n\n      /** Extracts chunks from input splitted by stop chars */\n\n    }, {\n      key: '_extractInputChunks',\n      value: function _extractInputChunks() {\n        var _this4 = this;\n\n        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n        if (fromPos === toPos) return [];\n\n        var fromDefIndex = this.mapPosToDefIndex(fromPos);\n        var toDefIndex = this.mapPosToDefIndex(toPos);\n        var stopDefIndices = this._charDefs.map(function (d, i) {\n          return [d, i];\n        }).slice(fromDefIndex, toDefIndex).filter(function (_ref) {\n          var _ref2 = slicedToArray(_ref, 1),\n              d = _ref2[0];\n\n          return d.stopAlign;\n        }).map(function (_ref3) {\n          var _ref4 = slicedToArray(_ref3, 2),\n              i = _ref4[1];\n\n          return i;\n        });\n\n        var stops = [fromDefIndex].concat(toConsumableArray(stopDefIndices), [toDefIndex]);\n\n        return stops.map(function (s, i) {\n          return {\n            stop: stopDefIndices.indexOf(s) >= 0 ? s : null,\n\n            value: _this4.extractInput(_this4.mapDefIndexToPos(s), _this4.mapDefIndexToPos(stops[++i]))\n          };\n        }).filter(function (_ref5) {\n          var stop = _ref5.stop,\n              value = _ref5.value;\n          return stop != null || value;\n        });\n      }\n\n      /** Appends placeholder depending on laziness */\n\n    }, {\n      key: '_appendPlaceholder',\n      value: function _appendPlaceholder(toDefIndex) {\n        var oldValueLength = this.value.length;\n        var maxDefIndex = toDefIndex || this._charDefs.length;\n        for (var di = this.mapPosToDefIndex(this.value.length); di < maxDefIndex; ++di) {\n          var def = this._charDefs[di];\n          if (def.isInput) def.isHollow = true;\n\n          if (!this.lazy || toDefIndex) {\n            this._value += !def.isInput && def.char != null ? def.char : !def.optional ? this.placeholderChar : '';\n          }\n        }\n        return new ChangeDetails({\n          inserted: this.value.slice(oldValueLength)\n        });\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'remove',\n      value: function remove() {\n        var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length - from;\n\n        var fromDefIndex = this.mapPosToDefIndex(from);\n        var toDefIndex = this.mapPosToDefIndex(from + count);\n        this._charDefs.slice(fromDefIndex, toDefIndex).forEach(function (d) {\n          return d.reset();\n        });\n\n        return get(MaskedPattern.prototype.__proto__ || Object.getPrototypeOf(MaskedPattern.prototype), 'remove', this).call(this, from, count);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'nearestInputPos',\n      value: function nearestInputPos(cursorPos) {\n        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n\n        var step = direction || DIRECTION.RIGHT;\n\n        var initialDefIndex = this.mapPosToDefIndex(cursorPos);\n        var initialDef = this._charDefs[initialDefIndex];\n        var di = initialDefIndex;\n\n        var firstInputIndex = void 0,\n            firstFilledInputIndex = void 0,\n            firstVisibleHollowIndex = void 0,\n            nextdi = void 0;\n\n        // check if chars at right is acceptable for LEFT and NONE directions\n        if (direction !== DIRECTION.RIGHT && (initialDef && initialDef.isInput ||\n        // in none direction latest position is acceptable also\n        direction === DIRECTION.NONE && cursorPos === this.value.length)) {\n          firstInputIndex = initialDefIndex;\n          if (initialDef && !initialDef.isHollow) firstFilledInputIndex = initialDefIndex;\n        }\n\n        if (firstFilledInputIndex == null && direction == DIRECTION.LEFT || firstInputIndex == null) {\n          // search forward\n          for (nextdi = indexInDirection(di, step); 0 <= nextdi && nextdi < this._charDefs.length; di += step, nextdi += step) {\n            var nextDef = this._charDefs[nextdi];\n            if (firstInputIndex == null && nextDef.isInput) {\n              firstInputIndex = di;\n              if (direction === DIRECTION.NONE) break;\n            }\n            if (firstVisibleHollowIndex == null && nextDef.isHollow && !nextDef.isHiddenHollow) firstVisibleHollowIndex = di;\n            if (nextDef.isInput && !nextDef.isHollow) {\n              firstFilledInputIndex = di;\n              break;\n            }\n          }\n        }\n\n        // for lazy if has aligned left inside fixed and has came to the start - use start position\n        if (direction === DIRECTION.LEFT && di === 0 && this.lazy && !this.extractInput() && (!initialDef || !initialDef.isInput)) firstInputIndex = 0;\n\n        if (direction === DIRECTION.LEFT || firstInputIndex == null) {\n          // search backward\n          step = -step;\n          var overflow = false;\n\n          // find hollows only before initial pos\n          for (nextdi = indexInDirection(di, step); 0 <= nextdi && nextdi < this._charDefs.length; di += step, nextdi += step) {\n            var _nextDef = this._charDefs[nextdi];\n            if (_nextDef.isInput) {\n              firstInputIndex = di;\n              if (_nextDef.isHollow && !_nextDef.isHiddenHollow) break;\n            }\n\n            // if hollow not found before start position - set `overflow`\n            // and try to find just any input\n            if (di === initialDefIndex) overflow = true;\n\n            // first input found\n            if (overflow && firstInputIndex != null) break;\n          }\n\n          // process overflow\n          overflow = overflow || nextdi >= this._charDefs.length;\n          if (overflow && firstInputIndex != null) di = firstInputIndex;\n        } else if (firstFilledInputIndex == null) {\n          // adjust index if delete at right and filled input not found at right\n          di = firstVisibleHollowIndex != null ? firstVisibleHollowIndex : firstInputIndex;\n        }\n\n        return this.mapDefIndexToPos(di);\n      }\n\n      /** Get group by name */\n\n    }, {\n      key: 'group',\n      value: function group(name) {\n        return this.groupsByName(name)[0];\n      }\n\n      /** Get all groups by name */\n\n    }, {\n      key: 'groupsByName',\n      value: function groupsByName(name) {\n        return this._groupDefs.filter(function (g$$1) {\n          return g$$1.name === name;\n        });\n      }\n    }, {\n      key: 'isComplete',\n      get: function get$$1() {\n        var _this5 = this;\n\n        return !this._charDefs.some(function (d, i) {\n          return d.isInput && !d.optional && (d.isHollow || !_this5.extractInput(i, i + 1));\n        });\n      }\n    }, {\n      key: 'unmaskedValue',\n      get: function get$$1() {\n        var str = this.value;\n        var unmasked = '';\n\n        for (var ci = 0, di = 0; ci < str.length && di < this._charDefs.length; ++di) {\n          var ch = str[ci];\n          var def = this._charDefs[di];\n\n          if (def.isHiddenHollow) continue;\n          if (def.unmasking && !def.isHollow) unmasked += ch;\n          ++ci;\n        }\n\n        return unmasked;\n      },\n      set: function set$$1(unmaskedValue) {\n        set(MaskedPattern.prototype.__proto__ || Object.getPrototypeOf(MaskedPattern.prototype), 'unmaskedValue', unmaskedValue, this);\n      }\n    }]);\n    return MaskedPattern;\n  }(Masked);\n\n  MaskedPattern.DEFAULTS = {\n    lazy: true,\n    placeholderChar: '_'\n  };\n  MaskedPattern.STOP_CHAR = '`';\n  MaskedPattern.ESCAPE_CHAR = '\\\\';\n  MaskedPattern.Definition = PatternDefinition;\n  MaskedPattern.Group = PatternGroup;\n\n  /** Date mask */\n\n  var MaskedDate = function (_MaskedPattern) {\n    inherits(MaskedDate, _MaskedPattern);\n\n    /**\r\n      @param {Object} opts\r\n    */\n\n    /** Start date */\n\n    /** Format Date to string */\n    function MaskedDate(opts) {\n      classCallCheck(this, MaskedDate);\n      return possibleConstructorReturn(this, (MaskedDate.__proto__ || Object.getPrototypeOf(MaskedDate)).call(this, _extends({}, MaskedDate.DEFAULTS, opts)));\n    }\n\n    /**\r\n      @override\r\n    */\n\n    /** End date */\n\n    /** Pattern mask for date according to {@link MaskedDate#format} */\n\n\n    /** Parse string to Date */\n\n\n    createClass(MaskedDate, [{\n      key: '_update',\n      value: function _update(opts) {\n        if (opts.mask === Date) delete opts.mask;\n        if (opts.pattern) {\n          opts.mask = opts.pattern;\n          delete opts.pattern;\n        }\n\n        var groups = opts.groups;\n        opts.groups = _extends({}, MaskedDate.GET_DEFAULT_GROUPS());\n        // adjust year group\n        if (opts.min) opts.groups.Y.from = opts.min.getFullYear();\n        if (opts.max) opts.groups.Y.to = opts.max.getFullYear();\n        _extends(opts.groups, groups);\n\n        get(MaskedDate.prototype.__proto__ || Object.getPrototypeOf(MaskedDate.prototype), '_update', this).call(this, opts);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doValidate',\n      value: function doValidate() {\n        var _babelHelpers$get;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var valid = (_babelHelpers$get = get(MaskedDate.prototype.__proto__ || Object.getPrototypeOf(MaskedDate.prototype), 'doValidate', this)).call.apply(_babelHelpers$get, [this].concat(toConsumableArray(args)));\n        var date = this.date;\n\n        return valid && (!this.isComplete || this.isDateExist(this.value) && date && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n      }\n\n      /** Checks if date is exists */\n\n    }, {\n      key: 'isDateExist',\n      value: function isDateExist(str) {\n        return this.format(this.parse(str)) === str;\n      }\n\n      /** Parsed Date */\n\n    }, {\n      key: 'date',\n      get: function get$$1() {\n        return this.isComplete ? this.parse(this.value) : null;\n      },\n      set: function set$$1(date) {\n        this.value = this.format(date);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'typedValue',\n      get: function get$$1() {\n        return this.date;\n      },\n      set: function set$$1(value) {\n        this.date = value;\n      }\n    }]);\n    return MaskedDate;\n  }(MaskedPattern);\n\n  MaskedDate.DEFAULTS = {\n    pattern: 'd{.}`m{.}`Y',\n    format: function format(date) {\n      var day = String(date.getDate()).padStart(2, '0');\n      var month = String(date.getMonth() + 1).padStart(2, '0');\n      var year = date.getFullYear();\n\n      return [day, month, year].join('.');\n    },\n    parse: function parse(str) {\n      var _str$split = str.split('.'),\n          _str$split2 = slicedToArray(_str$split, 3),\n          day = _str$split2[0],\n          month = _str$split2[1],\n          year = _str$split2[2];\n\n      return new Date(year, month - 1, day);\n    }\n  };\n  MaskedDate.GET_DEFAULT_GROUPS = function () {\n    return {\n      d: new PatternGroup.Range([1, 31]),\n      m: new PatternGroup.Range([1, 12]),\n      Y: new PatternGroup.Range([1900, 9999])\n    };\n  };\n\n  /**\r\n    Generic element API to use with mask\r\n    @interface\r\n  */\n  var MaskElement = function () {\n    function MaskElement() {\n      classCallCheck(this, MaskElement);\n    }\n\n    createClass(MaskElement, [{\n      key: 'select',\n      value: function select(start, end) {\n        if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;\n\n        try {\n          this._unsafeSelect(start, end);\n        } catch (e) {}\n      }\n    }, {\n      key: '_unsafeSelect',\n      value: function _unsafeSelect(start, end) {}\n    }, {\n      key: 'isActive',\n      value: function isActive() {\n        return false;\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents(handlers) {}\n    }, {\n      key: 'unbindEvents',\n      value: function unbindEvents() {}\n    }, {\n      key: 'selectionStart',\n      get: function get$$1() {\n        var start = void 0;\n        try {\n          start = this._unsafeSelectionStart;\n        } catch (e) {}\n\n        return start != null ? start : this.value.length;\n      }\n    }, {\n      key: 'selectionEnd',\n      get: function get$$1() {\n        var end = void 0;\n        try {\n          end = this._unsafeSelectionEnd;\n        } catch (e) {}\n\n        return end != null ? end : this.value.length;\n      }\n    }]);\n    return MaskElement;\n  }();\n\n  var HTMLMaskElement = function (_MaskElement) {\n    inherits(HTMLMaskElement, _MaskElement);\n\n    function HTMLMaskElement(input) {\n      classCallCheck(this, HTMLMaskElement);\n\n      var _this = possibleConstructorReturn(this, (HTMLMaskElement.__proto__ || Object.getPrototypeOf(HTMLMaskElement)).call(this));\n\n      _this.input = input;\n      _this._handlers = {};\n      return _this;\n    }\n\n    createClass(HTMLMaskElement, [{\n      key: 'isActive',\n      value: function isActive() {\n        return this.input === document.activeElement;\n      }\n    }, {\n      key: '_unsafeSelect',\n      value: function _unsafeSelect(start, end) {\n        this.input.setSelectionRange(start, end);\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents(handlers) {\n        var _this2 = this;\n\n        Object.keys(handlers).forEach(function (event) {\n          return _this2._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]);\n        });\n      }\n    }, {\n      key: 'unbindEvents',\n      value: function unbindEvents() {\n        var _this3 = this;\n\n        Object.keys(this._handlers).forEach(function (event) {\n          return _this3._toggleEventHandler(event);\n        });\n      }\n    }, {\n      key: '_toggleEventHandler',\n      value: function _toggleEventHandler(event, handler) {\n        if (this._handlers[event]) {\n          this.input.removeEventListener(event, this._handlers[event]);\n          delete this._handlers[event];\n        }\n\n        if (handler) {\n          this.input.addEventListener(event, handler);\n          this._handlers[event] = handler;\n        }\n      }\n    }, {\n      key: '_unsafeSelectionStart',\n      get: function get$$1() {\n        return this.input.selectionStart;\n      }\n    }, {\n      key: '_unsafeSelectionEnd',\n      get: function get$$1() {\n        return this.input.selectionEnd;\n      }\n    }, {\n      key: 'value',\n      get: function get$$1() {\n        return this.input.value;\n      },\n      set: function set$$1(value) {\n        this.input.value = value;\n      }\n    }]);\n    return HTMLMaskElement;\n  }(MaskElement);\n\n  HTMLMaskElement.EVENTS_MAP = {\n    selectionChange: 'keydown',\n    input: 'input',\n    drop: 'drop',\n    click: 'click',\n    focus: 'focus',\n    commit: 'change'\n  };\n\n  /** Listens to element events and controls changes between element and {@link Masked} */\n\n  var InputMask = function () {\n\n    /**\r\n      @param {MaskElement|HTMLInputElement|HTMLTextAreaElement} el\r\n      @param {Object} opts\r\n    */\n\n    /**\r\n      View element\r\n      @readonly\r\n    */\n    function InputMask(el, opts) {\n      classCallCheck(this, InputMask);\n\n      this.el = el instanceof MaskElement ? el : new HTMLMaskElement(el);\n      this.masked = createMask(opts);\n\n      this._listeners = {};\n      this._value = '';\n      this._unmaskedValue = '';\n\n      this._saveSelection = this._saveSelection.bind(this);\n      this._onInput = this._onInput.bind(this);\n      this._onChange = this._onChange.bind(this);\n      this._onDrop = this._onDrop.bind(this);\n      this.alignCursor = this.alignCursor.bind(this);\n      this.alignCursorFriendly = this.alignCursorFriendly.bind(this);\n\n      this._bindEvents();\n\n      // refresh\n      this.updateValue();\n      this._onChange();\n    }\n\n    /** Read or update mask */\n\n\n    /**\r\n      Internal {@link Masked} model\r\n      @readonly\r\n    */\n\n\n    createClass(InputMask, [{\n      key: '_bindEvents',\n\n\n      /**\r\n        Starts listening to element events\r\n        @protected\r\n      */\n      value: function _bindEvents() {\n        this.el.bindEvents({\n          selectionChange: this._saveSelection,\n          input: this._onInput,\n          drop: this._onDrop,\n          click: this.alignCursorFriendly,\n          focus: this.alignCursorFriendly,\n          commit: this._onChange\n        });\n      }\n\n      /**\r\n        Stops listening to element events\r\n        @protected\r\n       */\n\n    }, {\n      key: '_unbindEvents',\n      value: function _unbindEvents() {\n        this.el.unbindEvents();\n      }\n\n      /**\r\n        Fires custom event\r\n        @protected\r\n       */\n\n    }, {\n      key: '_fireEvent',\n      value: function _fireEvent(ev) {\n        var listeners = this._listeners[ev];\n        if (!listeners) return;\n\n        listeners.forEach(function (l) {\n          return l();\n        });\n      }\n\n      /**\r\n        Current selection start\r\n        @readonly\r\n      */\n\n    }, {\n      key: '_saveSelection',\n\n\n      /**\r\n        Stores current selection\r\n        @protected\r\n      */\n      value: function _saveSelection() /* ev */{\n        if (this.value !== this.el.value) {\n          console.warn('Uncontrolled input change, refresh mask manually!'); // eslint-disable-line no-console\n        }\n        this._selection = {\n          start: this.selectionStart,\n          end: this.cursorPos\n        };\n      }\n\n      /** Syncronizes model value from view */\n\n    }, {\n      key: 'updateValue',\n      value: function updateValue() {\n        this.masked.value = this.el.value;\n      }\n\n      /** Syncronizes view from model value, fires change events */\n\n    }, {\n      key: 'updateControl',\n      value: function updateControl() {\n        var newUnmaskedValue = this.masked.unmaskedValue;\n        var newValue = this.masked.value;\n        var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;\n\n        this._unmaskedValue = newUnmaskedValue;\n        this._value = newValue;\n\n        if (this.el.value !== newValue) this.el.value = newValue;\n        if (isChanged) this._fireChangeEvents();\n      }\n\n      /** Updates options with deep equal check, recreates @{link Masked} model if mask type changes */\n\n    }, {\n      key: 'updateOptions',\n      value: function updateOptions(opts) {\n        opts = _extends({}, opts);\n\n        this.mask = opts.mask;\n        delete opts.mask;\n\n        // check if changed\n        if (objectIncludes(this.masked, opts)) return;\n\n        this.masked.updateOptions(opts);\n        this.updateControl();\n      }\n\n      /** Updates cursor */\n\n    }, {\n      key: 'updateCursor',\n      value: function updateCursor(cursorPos) {\n        if (cursorPos == null) return;\n        this.cursorPos = cursorPos;\n\n        // also queue change cursor for mobile browsers\n        this._delayUpdateCursor(cursorPos);\n      }\n\n      /**\r\n        Delays cursor update to support mobile browsers\r\n        @private\r\n      */\n\n    }, {\n      key: '_delayUpdateCursor',\n      value: function _delayUpdateCursor(cursorPos) {\n        var _this = this;\n\n        this._abortUpdateCursor();\n        this._changingCursorPos = cursorPos;\n        this._cursorChanging = setTimeout(function () {\n          if (!_this.el) return; // if was destroyed\n          _this.cursorPos = _this._changingCursorPos;\n          _this._abortUpdateCursor();\n        }, 10);\n      }\n\n      /**\r\n        Fires custom events\r\n        @protected\r\n      */\n\n    }, {\n      key: '_fireChangeEvents',\n      value: function _fireChangeEvents() {\n        this._fireEvent('accept');\n        if (this.masked.isComplete) this._fireEvent('complete');\n      }\n\n      /**\r\n        Aborts delayed cursor update\r\n        @private\r\n      */\n\n    }, {\n      key: '_abortUpdateCursor',\n      value: function _abortUpdateCursor() {\n        if (this._cursorChanging) {\n          clearTimeout(this._cursorChanging);\n          delete this._cursorChanging;\n        }\n      }\n\n      /** Aligns cursor to nearest available position */\n\n    }, {\n      key: 'alignCursor',\n      value: function alignCursor() {\n        this.cursorPos = this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT);\n      }\n\n      /** Aligns cursor only if selection is empty */\n\n    }, {\n      key: 'alignCursorFriendly',\n      value: function alignCursorFriendly() {\n        if (this.selectionStart !== this.cursorPos) return;\n        this.alignCursor();\n      }\n\n      /** Adds listener on custom event */\n\n    }, {\n      key: 'on',\n      value: function on(ev, handler) {\n        if (!this._listeners[ev]) this._listeners[ev] = [];\n        this._listeners[ev].push(handler);\n        return this;\n      }\n\n      /** Removes custom event listener */\n\n    }, {\n      key: 'off',\n      value: function off(ev, handler) {\n        if (!this._listeners[ev]) return;\n        if (!handler) {\n          delete this._listeners[ev];\n          return;\n        }\n        var hIndex = this._listeners[ev].indexOf(handler);\n        if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);\n        return this;\n      }\n\n      /** Handles view input event */\n\n    }, {\n      key: '_onInput',\n      value: function _onInput() {\n        this._abortUpdateCursor();\n\n        // fix strange IE behavior\n        if (!this._selection) return this.updateValue();\n\n        var details = new ActionDetails(\n        // new state\n        this.el.value, this.cursorPos,\n        // old state\n        this.value, this._selection);\n\n        var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset;\n\n        var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, details.removeDirection);\n\n        this.updateControl();\n        this.updateCursor(cursorPos);\n      }\n\n      /** Handles view change event and commits model value */\n\n    }, {\n      key: '_onChange',\n      value: function _onChange() {\n        if (this.value !== this.el.value) {\n          this.updateValue();\n        }\n        this.masked.doCommit();\n        this.updateControl();\n      }\n\n      /** Handles view drop event, prevents by default */\n\n    }, {\n      key: '_onDrop',\n      value: function _onDrop(ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      /** Unbind view events and removes element reference */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this._unbindEvents();\n        // $FlowFixMe why not do so?\n        this._listeners.length = 0;\n        delete this.el;\n      }\n    }, {\n      key: 'mask',\n      get: function get$$1() {\n        return this.masked.mask;\n      },\n      set: function set$$1(mask) {\n        if (mask == null || mask === this.masked.mask || mask === Date && this.masked instanceof MaskedDate) return;\n\n        if (this.masked.constructor === maskedClass(mask)) {\n          this.masked.mask = mask;\n          return;\n        }\n\n        var masked = createMask({ mask: mask });\n        masked.unmaskedValue = this.masked.unmaskedValue;\n        this.masked = masked;\n      }\n\n      /** Raw value */\n\n    }, {\n      key: 'value',\n      get: function get$$1() {\n        return this._value;\n      },\n      set: function set$$1(str) {\n        this.masked.value = str;\n        this.updateControl();\n        this.alignCursor();\n      }\n\n      /** Unmasked value */\n\n    }, {\n      key: 'unmaskedValue',\n      get: function get$$1() {\n        return this._unmaskedValue;\n      },\n      set: function set$$1(str) {\n        this.masked.unmaskedValue = str;\n        this.updateControl();\n        this.alignCursor();\n      }\n\n      /** Typed unmasked value */\n\n    }, {\n      key: 'typedValue',\n      get: function get$$1() {\n        return this.masked.typedValue;\n      },\n      set: function set$$1(val) {\n        this.masked.typedValue = val;\n        this.updateControl();\n        this.alignCursor();\n      }\n    }, {\n      key: 'selectionStart',\n      get: function get$$1() {\n        return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;\n      }\n\n      /** Current cursor position */\n\n    }, {\n      key: 'cursorPos',\n      get: function get$$1() {\n        return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;\n      },\n      set: function set$$1(pos) {\n        if (!this.el.isActive) return;\n\n        this.el.select(pos, pos);\n        this._saveSelection();\n      }\n    }]);\n    return InputMask;\n  }();\n\n  /**\r\n    Number mask\r\n    @param {Object} opts\r\n    @param {string} opts.radix - Single char\r\n    @param {string} opts.thousandsSeparator - Single char\r\n    @param {Array<string>} opts.mapToRadix - Array of single chars\r\n    @param {number} opts.min\r\n    @param {number} opts.max\r\n    @param {number} opts.scale - Digits after point\r\n    @param {boolean} opts.signed - Allow negative\r\n    @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing\r\n    @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing\r\n  */\n  var MaskedNumber = function (_Masked) {\n    inherits(MaskedNumber, _Masked);\n\n    /** Flag to remove leading and trailing zeros in the end of editing */\n\n    /** Digits after point */\n\n    /** */\n\n    /** Single char */\n    function MaskedNumber(opts) {\n      classCallCheck(this, MaskedNumber);\n      return possibleConstructorReturn(this, (MaskedNumber.__proto__ || Object.getPrototypeOf(MaskedNumber)).call(this, _extends({}, MaskedNumber.DEFAULTS, opts)));\n    }\n\n    /**\r\n      @override\r\n    */\n\n    /** Flag to pad trailing zeros after point in the end of editing */\n\n    /** */\n\n    /** */\n\n    /** Array of single chars */\n\n\n    /** Single char */\n\n\n    createClass(MaskedNumber, [{\n      key: '_update',\n      value: function _update(opts) {\n        get(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), '_update', this).call(this, opts);\n        this._updateRegExps();\n      }\n\n      /** */\n\n    }, {\n      key: '_updateRegExps',\n      value: function _updateRegExps() {\n        // use different regexp to process user input (more strict, input suffix) and tail shifting\n        var start = '^';\n\n        var midInput = '';\n        var mid = '';\n        if (this.allowNegative) {\n          midInput += '([+|\\\\-]?|([+|\\\\-]?(0|([1-9]+\\\\d*))))';\n          mid += '[+|\\\\-]?';\n        } else {\n          midInput += '(0|([1-9]+\\\\d*))';\n        }\n        mid += '\\\\d*';\n\n        var end = (this.scale ? '(' + this.radix + '\\\\d{0,' + this.scale + '})?' : '') + '$';\n\n        this._numberRegExpInput = new RegExp(start + midInput + end);\n        this._numberRegExp = new RegExp(start + mid + end);\n        this._mapToRadixRegExp = new RegExp('[' + this.mapToRadix.map(escapeRegExp).join('') + ']', 'g');\n        this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_extractTail',\n      value: function _extractTail() {\n        var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n        var tail = get(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), '_extractTail', this).call(this, fromPos, toPos);\n\n        return _extends({}, tail, {\n          value: this._removeThousandsSeparators(tail.value)\n        });\n      }\n\n      /** */\n\n    }, {\n      key: '_removeThousandsSeparators',\n      value: function _removeThousandsSeparators(value) {\n        return value.replace(this._thousandsSeparatorRegExp, '');\n      }\n\n      /** */\n\n    }, {\n      key: '_insertThousandsSeparators',\n      value: function _insertThousandsSeparators(value) {\n        // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n        var parts = value.split(this.radix);\n        parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n        return parts.join(this.radix);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doPrepare',\n      value: function doPrepare(str) {\n        var _babelHelpers$get;\n\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return (_babelHelpers$get = get(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), 'doPrepare', this)).call.apply(_babelHelpers$get, [this, this._removeThousandsSeparators(str.replace(this._mapToRadixRegExp, this.radix))].concat(toConsumableArray(args)));\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'appendWithTail',\n      value: function appendWithTail() {\n        var _babelHelpers$get2;\n\n        var previousValue = this.value;\n        this._value = this._removeThousandsSeparators(this.value);\n        var startChangePos = this.value.length;\n\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        var appendDetails = (_babelHelpers$get2 = get(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), 'appendWithTail', this)).call.apply(_babelHelpers$get2, [this].concat(toConsumableArray(args)));\n        this._value = this._insertThousandsSeparators(this.value);\n\n        // calculate offsets after insert separators\n        var beforeTailPos = startChangePos + appendDetails.inserted.length;\n        for (var pos = 0; pos <= beforeTailPos; ++pos) {\n          if (this.value[pos] === this.thousandsSeparator) {\n            if (pos < startChangePos ||\n            // check high bound\n            // if separator is still there - consider it also\n            pos === startChangePos && previousValue[pos] === this.thousandsSeparator) {\n              ++startChangePos;\n            }\n            if (pos < beforeTailPos) ++beforeTailPos;\n          }\n        }\n\n        // adjust details with separators\n        appendDetails.rawInserted = appendDetails.inserted;\n        appendDetails.inserted = this.value.slice(startChangePos, beforeTailPos);\n        appendDetails.shift += startChangePos - previousValue.length;\n\n        return appendDetails;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'nearestInputPos',\n      value: function nearestInputPos(cursorPos, direction) {\n        if (!direction) return cursorPos;\n\n        var nextPos = indexInDirection(cursorPos, direction);\n        if (this.value[nextPos] === this.thousandsSeparator) cursorPos += direction;\n        return cursorPos;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doValidate',\n      value: function doValidate(flags) {\n        var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp;\n\n        // validate as string\n        var valid = regexp.test(this._removeThousandsSeparators(this.value));\n\n        if (valid) {\n          // validate as number\n          var number = this.number;\n          valid = valid && !isNaN(number) && (\n          // check min bound for negative values\n          this.min == null || this.min >= 0 || this.min <= this.number) && (\n          // check max bound for positive values\n          this.max == null || this.max <= 0 || this.number <= this.max);\n        }\n\n        return valid && get(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), 'doValidate', this).call(this, flags);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doCommit',\n      value: function doCommit() {\n        var number = this.number;\n        var validnum = number;\n\n        // check bounds\n        if (this.min != null) validnum = Math.max(validnum, this.min);\n        if (this.max != null) validnum = Math.min(validnum, this.max);\n\n        if (validnum !== number) this.unmaskedValue = String(validnum);\n\n        var formatted = this.value;\n\n        if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n        if (this.padFractionalZeros) formatted = this._padFractionalZeros(formatted);\n\n        this._value = this._insertThousandsSeparators(formatted);\n        get(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), 'doCommit', this).call(this);\n      }\n\n      /** */\n\n    }, {\n      key: '_normalizeZeros',\n      value: function _normalizeZeros(value) {\n        var parts = this._removeThousandsSeparators(value).split(this.radix);\n\n        // remove leading zeros\n        parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, function (match, sign, zeros, num) {\n          return sign + num;\n        });\n        // add leading zero\n        if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n\n        if (parts.length > 1) {\n          parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n          if (!parts[1].length) parts.length = 1; // remove fractional\n        }\n\n        return this._insertThousandsSeparators(parts.join(this.radix));\n      }\n\n      /** */\n\n    }, {\n      key: '_padFractionalZeros',\n      value: function _padFractionalZeros(value) {\n        if (!value) return value;\n\n        var parts = value.split(this.radix);\n        if (parts.length < 2) parts.push('');\n        parts[1] = parts[1].padEnd(this.scale, '0');\n        return parts.join(this.radix);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'unmaskedValue',\n      get: function get$$1() {\n        return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, '.');\n      },\n      set: function set$$1(unmaskedValue) {\n        set(MaskedNumber.prototype.__proto__ || Object.getPrototypeOf(MaskedNumber.prototype), 'unmaskedValue', unmaskedValue.replace('.', this.radix), this);\n      }\n\n      /** Parsed Number */\n\n    }, {\n      key: 'number',\n      get: function get$$1() {\n        return Number(this.unmaskedValue);\n      },\n      set: function set$$1(number) {\n        this.unmaskedValue = String(number);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'typedValue',\n      get: function get$$1() {\n        return this.number;\n      },\n      set: function set$$1(value) {\n        this.number = value;\n      }\n\n      /**\r\n        Is negative allowed\r\n        @readonly\r\n      */\n\n    }, {\n      key: 'allowNegative',\n      get: function get$$1() {\n        return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;\n      }\n    }]);\n    return MaskedNumber;\n  }(Masked);\n\n  MaskedNumber.DEFAULTS = {\n    radix: ',',\n    thousandsSeparator: '',\n    mapToRadix: ['.'],\n    scale: 2,\n    signed: false,\n    normalizeZeros: true,\n    padFractionalZeros: false\n  };\n\n  /** Masking by RegExp */\n\n  var MaskedRegExp = function (_Masked) {\n    inherits(MaskedRegExp, _Masked);\n\n    function MaskedRegExp() {\n      classCallCheck(this, MaskedRegExp);\n      return possibleConstructorReturn(this, (MaskedRegExp.__proto__ || Object.getPrototypeOf(MaskedRegExp)).apply(this, arguments));\n    }\n\n    createClass(MaskedRegExp, [{\n      key: '_update',\n\n      /**\r\n        @override\r\n        @param {Object} opts\r\n      */\n      value: function _update(opts) {\n        opts.validate = function (value) {\n          return value.search(opts.mask) >= 0;\n        };\n        get(MaskedRegExp.prototype.__proto__ || Object.getPrototypeOf(MaskedRegExp.prototype), '_update', this).call(this, opts);\n      }\n    }]);\n    return MaskedRegExp;\n  }(Masked);\n\n  /** Masking by custom Function */\n\n  var MaskedFunction = function (_Masked) {\n    inherits(MaskedFunction, _Masked);\n\n    function MaskedFunction() {\n      classCallCheck(this, MaskedFunction);\n      return possibleConstructorReturn(this, (MaskedFunction.__proto__ || Object.getPrototypeOf(MaskedFunction)).apply(this, arguments));\n    }\n\n    createClass(MaskedFunction, [{\n      key: '_update',\n\n      /**\r\n        @override\r\n        @param {Object} opts\r\n      */\n      value: function _update(opts) {\n        opts.validate = opts.mask;\n        get(MaskedFunction.prototype.__proto__ || Object.getPrototypeOf(MaskedFunction.prototype), '_update', this).call(this, opts);\n      }\n    }]);\n    return MaskedFunction;\n  }(Masked);\n\n  /** Dynamic mask for choosing apropriate mask in run-time */\n  var MaskedDynamic = function (_Masked) {\n    inherits(MaskedDynamic, _Masked);\n\n    /**\r\n      @param {Object} opts\r\n    */\n\n    /** Compliled {@link Masked} options */\n    function MaskedDynamic(opts) {\n      classCallCheck(this, MaskedDynamic);\n\n      var _this = possibleConstructorReturn(this, (MaskedDynamic.__proto__ || Object.getPrototypeOf(MaskedDynamic)).call(this, _extends({}, MaskedDynamic.DEFAULTS, opts)));\n\n      _this.currentMask = null;\n      return _this;\n    }\n\n    /**\r\n      @override\r\n    */\n\n    /** Chooses {@link Masked} depending on input value */\n\n    /** Currently chosen mask */\n\n\n    createClass(MaskedDynamic, [{\n      key: '_update',\n      value: function _update(opts) {\n        get(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), '_update', this).call(this, opts);\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {\n          return createMask(m);\n        }) : [];\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_append',\n      value: function _append(str) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        str = this.doPrepare.apply(this, [str].concat(toConsumableArray(args)));\n\n        var details = this._applyDispatch.apply(this, [str].concat(toConsumableArray(args)));\n\n        if (this.currentMask) {\n          var _currentMask;\n\n          details.aggregate((_currentMask = this.currentMask)._append.apply(_currentMask, [str].concat(toConsumableArray(args))));\n        }\n\n        return details;\n      }\n    }, {\n      key: '_applyDispatch',\n      value: function _applyDispatch() {\n        var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n        var oldValueLength = this.value.length;\n        var inputValue = this.rawInputValue;\n        var oldMask = this.currentMask;\n        var details = new ChangeDetails();\n\n        // dispatch SHOULD NOT modify mask\n\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        this.currentMask = this.doDispatch.apply(this, [appended].concat(toConsumableArray(args)));\n\n        // restore state after dispatch\n        if (this.currentMask && this.currentMask !== oldMask) {\n          // if mask changed reapply input\n          this.currentMask.reset();\n          // $FlowFixMe - it's ok, we don't change current mask\n          this.currentMask._append(inputValue, { raw: true });\n          details.shift = this.value.length - oldValueLength;\n        }\n\n        return details;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doDispatch',\n      value: function doDispatch(appended) {\n        var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        return this.dispatch(appended, this, flags);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'clone',\n      value: function clone() {\n        var m = new MaskedDynamic(this);\n        m._value = this.value;\n\n        // try to keep reference to compiled masks\n        var currentMaskIndex = this.compiledMasks.indexOf(this.currentMask);\n        if (this.currentMask) {\n          m.currentMask = currentMaskIndex >= 0 ? m.compiledMasks[currentMaskIndex].assign(this.currentMask) : this.currentMask.clone();\n        }\n\n        return m;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'reset',\n      value: function reset() {\n        if (this.currentMask) this.currentMask.reset();\n        this.compiledMasks.forEach(function (cm) {\n          return cm.reset();\n        });\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'remove',\n\n\n      /**\r\n        @override\r\n      */\n      value: function remove() {\n        var details = new ChangeDetails();\n        if (this.currentMask) {\n          var _currentMask2;\n\n          details.aggregate((_currentMask2 = this.currentMask).remove.apply(_currentMask2, arguments))\n          // update with dispatch\n          .aggregate(this._applyDispatch());\n        }\n\n        return details;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'extractInput',\n      value: function extractInput() {\n        var _currentMask3;\n\n        return this.currentMask ? (_currentMask3 = this.currentMask).extractInput.apply(_currentMask3, arguments) : '';\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_extractTail',\n      value: function _extractTail() {\n        var _currentMask4, _babelHelpers$get;\n\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return this.currentMask ? (_currentMask4 = this.currentMask)._extractTail.apply(_currentMask4, toConsumableArray(args)) : (_babelHelpers$get = get(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), '_extractTail', this)).call.apply(_babelHelpers$get, [this].concat(toConsumableArray(args)));\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: '_appendTail',\n      value: function _appendTail(tail) {\n        var details = new ChangeDetails();\n        if (tail) details.aggregate(this._applyDispatch(tail.value));\n\n        return details.aggregate(this.currentMask ? this.currentMask._appendTail(tail) : get(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), '_appendTail', this).call(this, tail));\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'doCommit',\n      value: function doCommit() {\n        if (this.currentMask) this.currentMask.doCommit();\n        get(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), 'doCommit', this).call(this);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'nearestInputPos',\n      value: function nearestInputPos() {\n        var _currentMask5, _babelHelpers$get2;\n\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        return this.currentMask ? (_currentMask5 = this.currentMask).nearestInputPos.apply(_currentMask5, toConsumableArray(args)) : (_babelHelpers$get2 = get(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), 'nearestInputPos', this)).call.apply(_babelHelpers$get2, [this].concat(toConsumableArray(args)));\n      }\n    }, {\n      key: 'value',\n      get: function get$$1() {\n        return this.currentMask ? this.currentMask.value : '';\n      },\n      set: function set$$1(value) {\n        set(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), 'value', value, this);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'unmaskedValue',\n      get: function get$$1() {\n        return this.currentMask ? this.currentMask.unmaskedValue : '';\n      },\n      set: function set$$1(unmaskedValue) {\n        set(MaskedDynamic.prototype.__proto__ || Object.getPrototypeOf(MaskedDynamic.prototype), 'unmaskedValue', unmaskedValue, this);\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'typedValue',\n      get: function get$$1() {\n        return this.currentMask ? this.currentMask.typedValue : '';\n      },\n      set: function set$$1(value) {\n        var unmaskedValue = String(value);\n        if (this.currentMask) {\n          this.currentMask.typedValue = value;\n          unmaskedValue = this.currentMask.unmaskedValue;\n        }\n        this.unmaskedValue = unmaskedValue;\n      }\n\n      /**\r\n        @override\r\n      */\n\n    }, {\n      key: 'isComplete',\n      get: function get$$1() {\n        return !!this.currentMask && this.currentMask.isComplete;\n      }\n    }]);\n    return MaskedDynamic;\n  }(Masked);\n\n\n  MaskedDynamic.DEFAULTS = {\n    dispatch: function dispatch(appended, masked, flags) {\n      if (!masked.compiledMasks.length) return;\n\n      var inputValue = masked.rawInputValue;\n\n      // simulate input\n      var inputs = masked.compiledMasks.map(function (cm, index) {\n        var m = cm.clone();\n        m.rawInputValue = inputValue;\n        m._append(appended, flags);\n\n        return { value: m.rawInputValue.length, index: index };\n      });\n\n      // pop masks with longer values first\n      inputs.sort(function (i1, i2) {\n        return i2.value - i1.value;\n      });\n\n      return masked.compiledMasks[inputs[0].index];\n    }\n  };\n\n  /**\r\n   * Applies mask on element.\r\n   * @constructor\r\n   * @param {HTMLInputElement|HTMLTextAreaElement|MaskElement} el - Element to apply mask\r\n   * @param {Object} opts - Custom mask options\r\n   * @return {InputMask}\r\n   */\n  function IMask(el) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // currently available only for input-like elements\n    return new InputMask(el, opts);\n  }\n\n  /** {@link InputMask} */\n  IMask.InputMask = InputMask;\n\n  /** {@link Masked} */\n  IMask.Masked = Masked;\n  /** {@link MaskedPattern} */\n  IMask.MaskedPattern = MaskedPattern;\n  /** {@link MaskedNumber} */\n  IMask.MaskedNumber = MaskedNumber;\n  /** {@link MaskedDate} */\n  IMask.MaskedDate = MaskedDate;\n  /** {@link MaskedRegExp} */\n  IMask.MaskedRegExp = MaskedRegExp;\n  /** {@link MaskedFunction} */\n  IMask.MaskedFunction = MaskedFunction;\n  /** {@link MaskedDynamic} */\n  IMask.MaskedDynamic = MaskedDynamic;\n  /** {@link createMask} */\n  IMask.createMask = createMask;\n  /** {@link MaskElement} */\n  IMask.MaskElement = MaskElement;\n  /** {@link HTMLMaskElement} */\n  IMask.HTMLMaskElement = HTMLMaskElement;\n\n  g.IMask = IMask;\n\n  return IMask;\n\n})));\n//# sourceMappingURL=imask.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW1hc2svZGlzdC9pbWFzay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUMwQjtBQUM1QixDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVcsZ0JBQWdCO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsR0FBRzs7QUFFSDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQywwQ0FBMEM7QUFDMUMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUIsZUFBZSxNQUFNOzs7QUFHckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUEsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEUsT0FBTztBQUNQO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBLHNC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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEUsY0FBYzs7QUFFeEY7O0FBRUE7QUFDQSxjQUFjLGtEQUFrRDtBQUNoRSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZELGFBQWE7O0FBRTFFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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LE9BQU8sbUJBQW1CO0FBQzFCO0FBQ0EsT0FBTyx1QkFBdUI7QUFDOUI7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2Rpc3QvaW1hc2suanM/NWU2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwuSU1hc2sgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbiAgdmFyIF9kZWZpbmVkID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICAgIHJldHVybiBpdDtcbiAgfTtcblxuICAvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG5cbiAgdmFyIF90b09iamVjdCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBPYmplY3QoX2RlZmluZWQoaXQpKTtcbiAgfTtcblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIF9oYXMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xuICB9O1xuXG4gIHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG4gIHZhciBfY29mID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbiAgfTtcblxuICAvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgdmFyIF9pb2JqZWN0ID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gX2NvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xuICB9O1xuXG4gIC8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xuXG5cbiAgdmFyIF90b0lvYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gX2lvYmplY3QoX2RlZmluZWQoaXQpKTtcbiAgfTtcblxuICAvLyA3LjEuNCBUb0ludGVnZXJcbiAgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBfdG9JbnRlZ2VyID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG4gIH07XG5cbiAgLy8gNy4xLjE1IFRvTGVuZ3RoXG5cbiAgdmFyIG1pbiA9IE1hdGgubWluO1xuICB2YXIgX3RvTGVuZ3RoID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0ID4gMCA/IG1pbihfdG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG4gIH07XG5cbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuICB2YXIgbWluJDEgPSBNYXRoLm1pbjtcbiAgdmFyIF90b0Fic29sdXRlSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgIGluZGV4ID0gX3RvSW50ZWdlcihpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4kMShpbmRleCwgbGVuZ3RoKTtcbiAgfTtcblxuICAvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4gIC8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG5cblxuXG4gIHZhciBfYXJyYXlJbmNsdWRlcyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBPID0gX3RvSW9iamVjdCgkdGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gX3RvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIHZhciBpbmRleCA9IF90b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuICBcdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIHZhciBfZ2xvYmFsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuICB2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9KTtcblxuICB2YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG4gIHZhciBzdG9yZSA9IF9nbG9iYWxbU0hBUkVEXSB8fCAoX2dsb2JhbFtTSEFSRURdID0ge30pO1xuICB2YXIgX3NoYXJlZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbiAgfTtcblxuICB2YXIgaWQgPSAwO1xuICB2YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xuICB2YXIgX3VpZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xuICB9O1xuXG4gIHZhciBzaGFyZWQgPSBfc2hhcmVkKCdrZXlzJyk7XG5cbiAgdmFyIF9zaGFyZWRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IF91aWQoa2V5KSk7XG4gIH07XG5cbiAgdmFyIGFycmF5SW5kZXhPZiA9IF9hcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIElFX1BST1RPID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxuICB2YXIgX29iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gICAgdmFyIE8gPSBfdG9Jb2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIF9oYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAgIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKF9oYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xuICB2YXIgX2VudW1CdWdLZXlzID0gKFxuICAgICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4gICkuc3BsaXQoJywnKTtcblxuICAvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcblxuXG5cbiAgdmFyIF9vYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gICAgcmV0dXJuIF9vYmplY3RLZXlzSW50ZXJuYWwoTywgX2VudW1CdWdLZXlzKTtcbiAgfTtcblxuICB2YXIgX2NvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNScgfTtcbiAgaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfSk7XG4gIHZhciBfY29yZV8xID0gX2NvcmUudmVyc2lvbjtcblxuICB2YXIgX2lzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICB2YXIgX2FuT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKCFfaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gICAgcmV0dXJuIGl0O1xuICB9O1xuXG4gIHZhciBfZmFpbHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFleGVjKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbiAgdmFyIF9kZXNjcmlwdG9ycyA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xuICB9KTtcblxuICB2YXIgZG9jdW1lbnQkMSA9IF9nbG9iYWwuZG9jdW1lbnQ7XG4gIC8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxuICB2YXIgaXMgPSBfaXNPYmplY3QoZG9jdW1lbnQkMSkgJiYgX2lzT2JqZWN0KGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG4gIHZhciBfZG9tQ3JlYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGlzID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuICB9O1xuXG4gIHZhciBfaWU4RG9tRGVmaW5lID0gIV9kZXNjcmlwdG9ycyAmJiAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9kb21DcmVhdGUoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbiAgfSk7XG5cbiAgLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG5cbiAgLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2VcbiAgLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbiAgdmFyIF90b1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpdCwgUykge1xuICAgIGlmICghX2lzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICAgIHZhciBmbiwgdmFsO1xuICAgIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gICAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH07XG5cbiAgdmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4gIHZhciBmID0gX2Rlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICAgIF9hbk9iamVjdChPKTtcbiAgICBQID0gX3RvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIF9hbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgICBpZiAoX2llOERvbURlZmluZSkgdHJ5IHtcbiAgICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICAgIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgIHJldHVybiBPO1xuICB9O1xuXG4gIHZhciBfb2JqZWN0RHAgPSB7XG4gIFx0ZjogZlxuICB9O1xuXG4gIHZhciBfcHJvcGVydHlEZXNjID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfTtcblxuICB2YXIgX2hpZGUgPSBfZGVzY3JpcHRvcnMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9vYmplY3REcC5mKG9iamVjdCwga2V5LCBfcHJvcGVydHlEZXNjKDEsIHZhbHVlKSk7XG4gIH0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xuXG4gIHZhciBfcmVkZWZpbmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBTUkMgPSBfdWlkKCdzcmMnKTtcbiAgdmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG4gIHZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xuICB2YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG4gIF9jb3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xuXG4gIChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICAgIGlmIChpc0Z1bmN0aW9uKSBfaGFzKHZhbCwgJ25hbWUnKSB8fCBfaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgICBpZiAoaXNGdW5jdGlvbikgX2hhcyh2YWwsIFNSQykgfHwgX2hpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgICBpZiAoTyA9PT0gX2dsb2JhbCkge1xuICAgICAgT1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICAgIGRlbGV0ZSBPW2tleV07XG4gICAgICBfaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICAgIE9ba2V5XSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2hpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG4gIH0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xuICB9KTtcblxuICB2YXIgX2FGdW5jdGlvbiA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgICByZXR1cm4gaXQ7XG4gIH07XG5cbiAgLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cbiAgdmFyIF9jdHggPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICAgIF9hRnVuY3Rpb24oZm4pO1xuICAgIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4gIHZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICAgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICAgIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICAgIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICAgIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gICAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICAgIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBfZ2xvYmFsIDogSVNfU1RBVElDID8gX2dsb2JhbFtuYW1lXSB8fCAoX2dsb2JhbFtuYW1lXSA9IHt9KSA6IChfZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICAgIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gX2NvcmUgOiBfY29yZVtuYW1lXSB8fCAoX2NvcmVbbmFtZV0gPSB7fSk7XG4gICAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gICAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBfY3R4KG91dCwgX2dsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBfY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgICBpZiAodGFyZ2V0KSBfcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgICAvLyBleHBvcnRcbiAgICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBfaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gICAgfVxuICB9O1xuICBfZ2xvYmFsLmNvcmUgPSBfY29yZTtcbiAgLy8gdHlwZSBiaXRtYXBcbiAgJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiAgJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiAgJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiAgJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuICAkZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiAgJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4gICRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuICAkZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbiAgdmFyIF9leHBvcnQgPSAkZXhwb3J0O1xuXG4gIC8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xuXG5cblxuICB2YXIgX29iamVjdFNhcCA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgICB2YXIgZm4gPSAoX2NvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICAgIHZhciBleHAgPSB7fTtcbiAgICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAgIF9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogX2ZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbiAgfTtcblxuICAvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcblxuXG5cbiAgX29iamVjdFNhcCgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RLZXlzKF90b09iamVjdChpdCkpO1xuICAgIH07XG4gIH0pO1xuXG4gIHZhciBrZXlzID0gX2NvcmUuT2JqZWN0LmtleXM7XG5cbiAgdmFyIF9zdHJpbmdSZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgICB2YXIgc3RyID0gU3RyaW5nKF9kZWZpbmVkKHRoaXMpKTtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgdmFyIG4gPSBfdG9JbnRlZ2VyKGNvdW50KTtcbiAgICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICAgIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgX2V4cG9ydChfZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gICAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICAgIHJlcGVhdDogX3N0cmluZ1JlcGVhdFxuICB9KTtcblxuICB2YXIgcmVwZWF0ID0gX2NvcmUuU3RyaW5nLnJlcGVhdDtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxuXG5cblxuXG4gIHZhciBfc3RyaW5nUGFkID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICAgIHZhciBTID0gU3RyaW5nKF9kZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gICAgdmFyIGludE1heExlbmd0aCA9IF90b0xlbmd0aChtYXhMZW5ndGgpO1xuICAgIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICAgIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICAgIHZhciBzdHJpbmdGaWxsZXIgPSBfc3RyaW5nUmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICAgIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICAgIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG4gIH07XG5cbiAgdmFyIG5hdmlnYXRvciA9IF9nbG9iYWwubmF2aWdhdG9yO1xuXG4gIHZhciBfdXNlckFnZW50ID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcblxuXG5cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG4gIF9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdChfdXNlckFnZW50KSwgJ1N0cmluZycsIHtcbiAgICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgICAgcmV0dXJuIF9zdHJpbmdQYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGFkU3RhcnQgPSBfY29yZS5TdHJpbmcucGFkU3RhcnQ7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcblxuXG5cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG4gIF9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdChfdXNlckFnZW50KSwgJ1N0cmluZycsIHtcbiAgICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgICByZXR1cm4gX3N0cmluZ1BhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGFkRW5kID0gX2NvcmUuU3RyaW5nLnBhZEVuZDtcblxuICB2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9O1xuXG4gIHZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgdmFyIGdldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gIH07XG5cbiAgdmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICAgIGlmICghc2VsZikge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuICB9O1xuXG4gIHZhciBzZXQgPSBmdW5jdGlvbiBzZXQob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHNldChwYXJlbnQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSkge1xuICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2V0dGVyID0gZGVzYy5zZXQ7XG5cbiAgICAgIGlmIChzZXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0ZXIuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgICAgdmFyIF9hcnIgPSBbXTtcbiAgICAgIHZhciBfbiA9IHRydWU7XG4gICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKiogQ2hlY2tzIGlmIHZhbHVlIGlzIHN0cmluZyAqL1xuICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nO1xuICB9XG5cbiAgLyoqIENvbmZvcm1zIHN0cmluZyB3aXRoIGZhbGxiYWNrICovXG4gIGZ1bmN0aW9uIGNvbmZvcm0ocmVzLCBzdHIpIHtcbiAgICB2YXIgZmFsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuXG4gICAgcmV0dXJuIGlzU3RyaW5nKHJlcykgPyByZXMgOiByZXMgPyBzdHIgOiBmYWxsYmFjaztcbiAgfVxuXG4gIC8qKlxyXG4gICAgRGlyZWN0aW9uXHJcbiAgICBAcHJvcCB7bnVtYmVyfSBOT05FXHJcbiAgICBAcHJvcCB7bnVtYmVyfSBMRUZUXHJcbiAgICBAcHJvcCB7bnVtYmVyfSBSSUdIVFxyXG4gICovXG4gIHZhciBESVJFQ1RJT04gPSB7XG4gICAgTk9ORTogMCxcbiAgICBMRUZUOiAtMSxcbiAgICBSSUdIVDogMVxuICAgIC8qKlxyXG4gICAgICBEaXJlY3Rpb25cclxuICAgICAgQGVudW0ge251bWJlcn1cclxuICAgICovXG4gIH07XG5cbiAgLyoqIFJldHVybnMgbmV4dCBjaGFyIHBvc2l0aW9uIGluIGRpcmVjdGlvbiAqL1xuICBmdW5jdGlvbiBpbmRleEluRGlyZWN0aW9uKHBvcywgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkxFRlQpIC0tcG9zO1xuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICAvKiogRXNjYXBlcyByZWd1bGFyIGV4cHJlc3Npb24gY29udHJvbCBjaGFycyAqL1xuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXS9cXFxcXSkvZywgJ1xcXFwkMScpO1xuICB9XG5cbiAgLy8gY2xvbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbCB3aXRoIHNtYWxsIGNoYW5nZXNcbiAgZnVuY3Rpb24gb2JqZWN0SW5jbHVkZXMoYiwgYSkge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSxcbiAgICAgICAgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksXG4gICAgICAgIGk7XG5cbiAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb2JqZWN0SW5jbHVkZXMoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1yZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYXJyQSAhPSBhcnJCKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYSAmJiBiICYmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpID09PSAnb2JqZWN0JyAmJiAodHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAvLyBpZiAoa2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgZGF0ZUEgPSBhIGluc3RhbmNlb2YgRGF0ZSxcbiAgICAgICAgICBkYXRlQiA9IGIgaW5zdGFuY2VvZiBEYXRlO1xuICAgICAgaWYgKGRhdGVBICYmIGRhdGVCKSByZXR1cm4gYS5nZXRUaW1lKCkgPT0gYi5nZXRUaW1lKCk7XG4gICAgICBpZiAoZGF0ZUEgIT0gZGF0ZUIpIHJldHVybiBmYWxzZTtcblxuICAgICAgdmFyIHJlZ2V4cEEgPSBhIGluc3RhbmNlb2YgUmVnRXhwLFxuICAgICAgICAgIHJlZ2V4cEIgPSBiIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgICAgaWYgKHJlZ2V4cEEgJiYgcmVnZXhwQikgcmV0dXJuIGEudG9TdHJpbmcoKSA9PSBiLnRvU3RyaW5nKCk7XG4gICAgICBpZiAocmVnZXhwQSAhPSByZWdleHBCKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9Zm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmplY3RJbmNsdWRlcyhhW2tleXNbaV1dLCBiW2tleXNbaV1dKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfXJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gIHZhciBnID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93IHx8IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHwgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8IHt9O1xuXG4gIC8qKiBQcm92aWRlcyBkZXRhaWxzIG9mIGNoYW5naW5nIGlucHV0ICovXG5cbiAgdmFyIEFjdGlvbkRldGFpbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqIE9sZCBpbnB1dCB2YWx1ZSAqL1xuXG4gICAgLyoqIEN1cnJlbnQgaW5wdXQgdmFsdWUgKi9cbiAgICBmdW5jdGlvbiBBY3Rpb25EZXRhaWxzKHZhbHVlLCBjdXJzb3JQb3MsIG9sZFZhbHVlLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEFjdGlvbkRldGFpbHMpO1xuXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLmN1cnNvclBvcyA9IGN1cnNvclBvcztcbiAgICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgIHRoaXMub2xkU2VsZWN0aW9uID0gb2xkU2VsZWN0aW9uO1xuXG4gICAgICAvLyBkb3VibGUgY2hlY2sgaWYgbGVmdCBwYXJ0IHdhcyBjaGFuZ2VkIChhdXRvZmlsbGluZywgb3RoZXIgbm9uLXN0YW5kYXJkIGlucHV0IHRyaWdnZXJzKVxuICAgICAgd2hpbGUgKHRoaXMudmFsdWUuc2xpY2UoMCwgdGhpcy5zdGFydENoYW5nZVBvcykgIT09IHRoaXMub2xkVmFsdWUuc2xpY2UoMCwgdGhpcy5zdGFydENoYW5nZVBvcykpIHtcbiAgICAgICAgLS10aGlzLm9sZFNlbGVjdGlvbi5zdGFydDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcclxuICAgICAgU3RhcnQgY2hhbmdpbmcgcG9zaXRpb25cclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gICAgLyoqIE9sZCBzZWxlY3Rpb24gKi9cblxuICAgIC8qKiBDdXJyZW50IGN1cnNvciBwb3NpdGlvbiAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhBY3Rpb25EZXRhaWxzLCBbe1xuICAgICAga2V5OiAnc3RhcnRDaGFuZ2VQb3MnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmN1cnNvclBvcywgdGhpcy5vbGRTZWxlY3Rpb24uc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBJbnNlcnRlZCBzeW1ib2xzIGNvdW50XHJcbiAgICAgICAgQHJlYWRvbmx5XHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpbnNlcnRlZENvdW50JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0YXJ0Q2hhbmdlUG9zO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBJbnNlcnRlZCBzeW1ib2xzXHJcbiAgICAgICAgQHJlYWRvbmx5XHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdpbnNlcnRlZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyKHRoaXMuc3RhcnRDaGFuZ2VQb3MsIHRoaXMuaW5zZXJ0ZWRDb3VudCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIFJlbW92ZWQgc3ltYm9scyBjb3VudFxyXG4gICAgICAgIEByZWFkb25seVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlZENvdW50JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAvLyBNYXRoLm1heCBmb3Igb3Bwb3NpdGUgb3BlcmF0aW9uXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm9sZFNlbGVjdGlvbi5lbmQgLSB0aGlzLnN0YXJ0Q2hhbmdlUG9zIHx8XG4gICAgICAgIC8vIGZvciBEZWxldGVcbiAgICAgICAgdGhpcy5vbGRWYWx1ZS5sZW5ndGggLSB0aGlzLnZhbHVlLmxlbmd0aCwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIFJlbW92ZWQgc3ltYm9sc1xyXG4gICAgICAgIEByZWFkb25seVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2xkVmFsdWUuc3Vic3RyKHRoaXMuc3RhcnRDaGFuZ2VQb3MsIHRoaXMucmVtb3ZlZENvdW50KTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgVW5jaGFuZ2VkIGhlYWQgc3ltYm9sc1xyXG4gICAgICAgIEByZWFkb25seVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaGVhZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBVbmNoYW5nZWQgdGFpbCBzeW1ib2xzXHJcbiAgICAgICAgQHJlYWRvbmx5XHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0YWlsJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5zdGFydENoYW5nZVBvcyArIHRoaXMuaW5zZXJ0ZWRDb3VudCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIFJlbW92ZSBkaXJlY3Rpb25cclxuICAgICAgICBAcmVhZG9ubHlcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZURpcmVjdGlvbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbW92ZWRDb3VudCB8fCB0aGlzLmluc2VydGVkQ291bnQpIHJldHVybiBESVJFQ1RJT04uTk9ORTtcblxuICAgICAgICAvLyBhbGlnbiByaWdodCBpZiBkZWxldGUgYXQgcmlnaHQgb3IgaWYgcmFuZ2UgcmVtb3ZlZCAoZXZlbnQgd2l0aCBiYWNrc3BhY2UpXG4gICAgICAgIHJldHVybiB0aGlzLm9sZFNlbGVjdGlvbi5lbmQgPT09IHRoaXMuY3Vyc29yUG9zIHx8IHRoaXMub2xkU2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLmN1cnNvclBvcyA/IERJUkVDVElPTi5SSUdIVCA6IERJUkVDVElPTi5MRUZUO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQWN0aW9uRGV0YWlscztcbiAgfSgpO1xuXG4gIC8qKlxyXG4gICAgUHJvdmlkZXMgZGV0YWlscyBvZiBjaGFuZ2luZyBtb2RlbCB2YWx1ZVxyXG4gICAgQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzXVxyXG4gICAgQHBhcmFtIHtzdHJpbmd9IFtkZXRhaWxzLmluc2VydGVkXSAtIEluc2VydGVkIHN5bWJvbHNcclxuICAgIEBwYXJhbSB7Ym9vbGVhbn0gW2RldGFpbHMub3ZlcmZsb3ddIC0gSXMgb3ZlcmZsb3dlZFxyXG4gICAgQHBhcmFtIHtudW1iZXJ9IFtkZXRhaWxzLnJlbW92ZUNvdW50XSAtIFJlbW92ZWQgc3ltYm9scyBjb3VudFxyXG4gICAgQHBhcmFtIHtudW1iZXJ9IFtkZXRhaWxzLnNoaWZ0XSAtIEFkZGl0aW9uYWwgb2Zmc2V0IGlmIGFueSBjaGFuZ2VzIG9jY3VycmVkIGJlZm9yZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgKi9cbiAgdmFyIENoYW5nZURldGFpbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEFkZGl0aW9uYWwgb2Zmc2V0IGlmIGFueSBjaGFuZ2VzIG9jY3VycmVkIGJlZm9yZSBjdXJyZW50IHBvc2l0aW9uICovXG5cbiAgICAvKiogSW5zZXJ0ZWQgc3ltYm9scyAqL1xuICAgIGZ1bmN0aW9uIENoYW5nZURldGFpbHMoZGV0YWlscykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhbmdlRGV0YWlscyk7XG5cbiAgICAgIF9leHRlbmRzKHRoaXMsIHtcbiAgICAgICAgaW5zZXJ0ZWQ6ICcnLFxuICAgICAgICBvdmVyZmxvdzogZmFsc2UsXG4gICAgICAgIHNoaWZ0OiAwXG4gICAgICB9LCBkZXRhaWxzKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAgQWdncmVnYXRlIGNoYW5nZXNcclxuICAgICAgQHJldHVybnMge0NoYW5nZURldGFpbHN9IGB0aGlzYFxyXG4gICAgKi9cblxuICAgIC8qKiBJcyBvdmVyZmxvd2VkICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKENoYW5nZURldGFpbHMsIFt7XG4gICAgICBrZXk6ICdhZ2dyZWdhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFnZ3JlZ2F0ZShkZXRhaWxzKSB7XG4gICAgICAgIGlmIChkZXRhaWxzLnJhd0luc2VydGVkKSB0aGlzLnJhd0luc2VydGVkICs9IGRldGFpbHMucmF3SW5zZXJ0ZWQ7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgKz0gZGV0YWlscy5pbnNlcnRlZDtcbiAgICAgICAgdGhpcy5zaGlmdCArPSBkZXRhaWxzLnNoaWZ0O1xuICAgICAgICB0aGlzLm92ZXJmbG93ID0gdGhpcy5vdmVyZmxvdyB8fCBkZXRhaWxzLm92ZXJmbG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqIFRvdGFsIG9mZnNldCBjb25zaWRlcmluZyBhbGwgY2hhbmdlcyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb2Zmc2V0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdCArIHRoaXMuaW5zZXJ0ZWQubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvKiogUmF3IGluc2VydGVkIGlzIHVzZWQgYnkgZHluYW1pYyBtYXNrICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyYXdJbnNlcnRlZCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd0luc2VydGVkICE9IG51bGwgPyB0aGlzLl9yYXdJbnNlcnRlZCA6IHRoaXMuaW5zZXJ0ZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEocmF3SW5zZXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5fcmF3SW5zZXJ0ZWQgPSByYXdJbnNlcnRlZDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIENoYW5nZURldGFpbHM7XG4gIH0oKTtcblxuICAvKiogU3VwcG9ydGVkIG1hc2sgdHlwZSAqL1xuXG5cbiAgLyoqIEFwcGVuZCBmbGFncyAqL1xuXG5cbiAgLyoqIEV4dHJhY3QgZmxhZ3MgKi9cblxuICAvKiogUHJvdmlkZXMgY29tbW9uIG1hc2tpbmcgc3R1ZmYgKi9cbiAgdmFyIE1hc2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiogRG9lcyBhZGRpdGlvbmFsIHByb2Nlc3NpbmcgaW4gdGhlIGVuZCBvZiBlZGl0aW5nICovXG5cbiAgICAvKiogVHJhbnNmb3JtcyB2YWx1ZSBiZWZvcmUgbWFzayBwcm9jZXNzaW5nICovXG4gICAgZnVuY3Rpb24gTWFza2VkKG9wdHMpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZCk7XG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICB0aGlzLl91cGRhdGUob3B0cyk7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKiBTZXRzIGFuZCBhcHBsaWVzIG5ldyBvcHRpb25zICovXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiBWYWxpZGF0ZXMgaWYgdmFsdWUgaXMgYWNjZXB0YWJsZSAqL1xuICAgIC8vICRTaGFwZTxNYXNrZWRPcHRpb25zPjsgVE9ETyBhZnRlciBmaXggaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzQ3NzNcblxuICAgIC8qKiBAdHlwZSB7TWFza30gKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoTWFza2VkLCBbe1xuICAgICAga2V5OiAndXBkYXRlT3B0aW9ucycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIHRoaXMud2l0aFZhbHVlUmVmcmVzaCh0aGlzLl91cGRhdGUuYmluZCh0aGlzLCBvcHRzKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIFNldHMgbmV3IG9wdGlvbnNcclxuICAgICAgICBAcHJvdGVjdGVkXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgICAgX2V4dGVuZHModGhpcywgb3B0cyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBDbG9uZXMgbWFza2VkIHdpdGggb3B0aW9ucyBhbmQgdmFsdWUgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWFza2VkKHRoaXMpO1xuICAgICAgICBtLl92YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIC8qKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYXNzaWduJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NpZ24oc291cmNlKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHRoaXMsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBSZXNldHMgdmFsdWUgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgLyoqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZXNvbHZlJyxcblxuXG4gICAgICAvKiogUmVzb2x2ZSBuZXcgdmFsdWUgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fYXBwZW5kKHZhbHVlLCB7IGlucHV0OiB0cnVlIH0pO1xuICAgICAgICB0aGlzLl9hcHBlbmRUYWlsKCk7XG4gICAgICAgIHRoaXMuZG9Db21taXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbmVhcmVzdElucHV0UG9zJyxcblxuXG4gICAgICAvKiogRmluZHMgbmVhcmVzdCBpbnB1dCBwb3NpdGlvbiBpbiBkaXJlY3Rpb24gKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZWFyZXN0SW5wdXRQb3MoY3Vyc29yUG9zLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICAgIH1cblxuICAgICAgLyoqIEV4dHJhY3RzIHZhbHVlIGluIHJhbmdlIGNvbnNpZGVyaW5nIGZsYWdzICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdleHRyYWN0SW5wdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RJbnB1dCgpIHtcbiAgICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2xpY2UoZnJvbVBvcywgdG9Qb3MpO1xuICAgICAgfVxuXG4gICAgICAvKiogRXh0cmFjdHMgdGFpbCBpbiByYW5nZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V4dHJhY3RUYWlsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXh0cmFjdFRhaWwoKSB7XG4gICAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMuZXh0cmFjdElucHV0KGZyb21Qb3MsIHRvUG9zKSxcbiAgICAgICAgICBmcm9tUG9zOiBmcm9tUG9zLFxuICAgICAgICAgIHRvUG9zOiB0b1Bvc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKiogQXBwZW5kcyB0YWlsICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYXBwZW5kVGFpbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZFRhaWwodGFpbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwZW5kKHRhaWwgPyB0YWlsLnZhbHVlIDogJycsIHsgdGFpbDogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqIEFwcGVuZHMgc3ltYm9scyBjb25zaWRlcmluZyBmbGFncyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2FwcGVuZCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZChzdHIpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICB2YXIgb2xkVmFsdWVMZW5ndGggPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbnNpc3RlbnRWYWx1ZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFyIG92ZXJmbG93ID0gZmFsc2U7XG5cbiAgICAgICAgc3RyID0gdGhpcy5kb1ByZXBhcmUoc3RyLCBmbGFncyk7XG5cbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IHN0ci5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICB0aGlzLl92YWx1ZSArPSBzdHJbY2ldO1xuICAgICAgICAgIGlmICh0aGlzLmRvVmFsaWRhdGUoZmxhZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ24oY29uc2lzdGVudFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghZmxhZ3MuaW5wdXQpIHtcbiAgICAgICAgICAgICAgLy8gaW4gYGlucHV0YCBtb2RlIGRvbnQgc2tpcCBpbnZhbGlkIGNoYXJzXG4gICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc2lzdGVudFZhbHVlID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRhaWxzKHtcbiAgICAgICAgICBpbnNlcnRlZDogdGhpcy52YWx1ZS5zbGljZShvbGRWYWx1ZUxlbmd0aCksXG4gICAgICAgICAgb3ZlcmZsb3c6IG92ZXJmbG93XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKiogQXBwZW5kcyBzeW1ib2xzIGNvbnNpZGVyaW5nIHRhaWwgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FwcGVuZFdpdGhUYWlsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRXaXRoVGFpbChzdHIsIHRhaWwpIHtcbiAgICAgICAgLy8gVE9ETyByZWZhY3RvclxuICAgICAgICB2YXIgYWdncmVnYXRlRGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICAgIHZhciBjb25zaXN0ZW50VmFsdWUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhciBjb25zaXN0ZW50QXBwZW5kZWQgPSB2b2lkIDA7XG5cbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IHN0ci5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICB2YXIgY2ggPSBzdHJbY2ldO1xuXG4gICAgICAgICAgdmFyIGFwcGVuZERldGFpbHMgPSB0aGlzLl9hcHBlbmQoY2gsIHsgaW5wdXQ6IHRydWUgfSk7XG4gICAgICAgICAgY29uc2lzdGVudEFwcGVuZGVkID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgIHZhciB0YWlsQXBwZW5kZWQgPSAhYXBwZW5kRGV0YWlscy5vdmVyZmxvdyAmJiAhdGhpcy5fYXBwZW5kVGFpbCh0YWlsKS5vdmVyZmxvdztcbiAgICAgICAgICBpZiAoIXRhaWxBcHBlbmRlZCB8fCB0aGlzLmRvVmFsaWRhdGUoeyB0YWlsOiB0cnVlIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ24oY29uc2lzdGVudFZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXNzaWduKGNvbnNpc3RlbnRBcHBlbmRlZCk7XG4gICAgICAgICAgY29uc2lzdGVudFZhbHVlID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgIGFnZ3JlZ2F0ZURldGFpbHMuYWdncmVnYXRlKGFwcGVuZERldGFpbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBuZWVkZWQgZm9yIGNhc2VzIHdoZW5cbiAgICAgICAgLy8gMSkgUkVNT1ZFIE9OTFkgQU5EIE5PIExPT1AgQVQgQUxMXG4gICAgICAgIC8vIDIpIGxhc3QgbG9vcCBpdGVyYXRpb24gcmVtb3ZlcyB0YWlsXG4gICAgICAgIC8vIDMpIHdoZW4gYnJlYWtzIG9uIHRhaWwgaW5zZXJ0XG5cbiAgICAgICAgLy8gYWdncmVnYXRlIG9ubHkgc2hpZnQgZnJvbSB0YWlsXG4gICAgICAgIGFnZ3JlZ2F0ZURldGFpbHMuc2hpZnQgKz0gdGhpcy5fYXBwZW5kVGFpbCh0YWlsKS5zaGlmdDtcblxuICAgICAgICByZXR1cm4gYWdncmVnYXRlRGV0YWlscztcbiAgICAgIH1cblxuICAgICAgLyoqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGggLSBmcm9tO1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgwLCBmcm9tKSArIHRoaXMudmFsdWUuc2xpY2UoZnJvbSArIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBDYWxscyBmdW5jdGlvbiBhbmQgcmVhcHBsaWVzIGN1cnJlbnQgdmFsdWUgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3dpdGhWYWx1ZVJlZnJlc2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhWYWx1ZVJlZnJlc2goZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZnJlc2hpbmcgfHwgIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIGZuKCk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRoaXMudW5tYXNrZWRWYWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgICB2YXIgcmV0ID0gZm4oKTtcblxuICAgICAgICAvLyB0cnkgdG8gdXBkYXRlIHdpdGggcmF3IHZhbHVlIGZpcnN0IHRvIGtlZXAgZml4ZWQgY2hhcnNcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZSh2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgLy8gb3IgZmFsbGJhY2sgdG8gdW5tYXNrZWRcbiAgICAgICAgICB0aGlzLnVubWFza2VkVmFsdWUgPSB1bm1hc2tlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoaW5nO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBQcmVwYXJlcyBzdHJpbmcgYmVmb3JlIG1hc2sgcHJvY2Vzc2luZ1xyXG4gICAgICAgIEBwcm90ZWN0ZWRcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvUHJlcGFyZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9QcmVwYXJlKHN0cikge1xuICAgICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXBhcmUgPyB0aGlzLnByZXBhcmUoc3RyLCB0aGlzLCBmbGFncykgOiBzdHI7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIFZhbGlkYXRlcyBpZiB2YWx1ZSBpcyBhY2NlcHRhYmxlXHJcbiAgICAgICAgQHByb3RlY3RlZFxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZG9WYWxpZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9WYWxpZGF0ZShmbGFncykge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsaWRhdGUgfHwgdGhpcy52YWxpZGF0ZSh0aGlzLnZhbHVlLCB0aGlzLCBmbGFncyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIERvZXMgYWRkaXRpb25hbCBwcm9jZXNzaW5nIGluIHRoZSBlbmQgb2YgZWRpdGluZ1xyXG4gICAgICAgIEBwcm90ZWN0ZWRcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvQ29tbWl0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0KSB0aGlzLmNvbW1pdCh0aGlzLnZhbHVlLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gaW5zZXJ0IChzdHIsIGZyb21Qb3MsIGZsYWdzKVxuXG4gICAgICAvKiogKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NwbGljZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgaW5zZXJ0ZWQsIHJlbW92ZURpcmVjdGlvbikge1xuICAgICAgICB2YXIgdGFpbFBvcyA9IHN0YXJ0ICsgZGVsZXRlQ291bnQ7XG4gICAgICAgIHZhciB0YWlsID0gdGhpcy5fZXh0cmFjdFRhaWwodGFpbFBvcyk7XG5cbiAgICAgICAgdmFyIHN0YXJ0Q2hhbmdlUG9zID0gdGhpcy5uZWFyZXN0SW5wdXRQb3Moc3RhcnQsIHJlbW92ZURpcmVjdGlvbik7XG4gICAgICAgIHZhciBjaGFuZ2VEZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoe1xuICAgICAgICAgIHNoaWZ0OiBzdGFydENoYW5nZVBvcyAtIHN0YXJ0IC8vIGFkanVzdCBzaGlmdCBpZiBzdGFydCB3YXMgYWxpZ25lZFxuICAgICAgICB9KS5hZ2dyZWdhdGUodGhpcy5yZW1vdmUoc3RhcnRDaGFuZ2VQb3MpKS5hZ2dyZWdhdGUodGhpcy5hcHBlbmRXaXRoVGFpbChpbnNlcnRlZCwgdGFpbCkpO1xuXG4gICAgICAgIHJldHVybiBjaGFuZ2VEZXRhaWxzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bm1hc2tlZFZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2FwcGVuZCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2FwcGVuZFRhaWwoKTtcbiAgICAgICAgdGhpcy5kb0NvbW1pdCgpO1xuICAgICAgfVxuXG4gICAgICAvKiogKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3R5cGVkVmFsdWUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVubWFza2VkVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodmFsdWUpIHtcbiAgICAgICAgdGhpcy51bm1hc2tlZFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qKiBWYWx1ZSB0aGF0IGluY2x1ZGVzIHJhdyB1c2VyIGlucHV0ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyYXdJbnB1dFZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0SW5wdXQoMCwgdGhpcy52YWx1ZS5sZW5ndGgsIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fYXBwZW5kKHZhbHVlLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fYXBwZW5kVGFpbCgpO1xuICAgICAgICB0aGlzLmRvQ29tbWl0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNDb21wbGV0ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBNYXNrZWQ7XG4gIH0oKTtcblxuICAvKiogR2V0IE1hc2tlZCBjbGFzcyBieSBtYXNrIHR5cGUgKi9cbiAgZnVuY3Rpb24gbWFza2VkQ2xhc3MobWFzaykge1xuICAgIGlmIChtYXNrID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFzayBwcm9wZXJ0eSBzaG91bGQgYmUgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGlmIChtYXNrIGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gZy5JTWFzay5NYXNrZWRSZWdFeHA7XG4gICAgaWYgKGlzU3RyaW5nKG1hc2spKSByZXR1cm4gZy5JTWFzay5NYXNrZWRQYXR0ZXJuO1xuICAgIGlmIChtYXNrIGluc3RhbmNlb2YgRGF0ZSB8fCBtYXNrID09PSBEYXRlKSByZXR1cm4gZy5JTWFzay5NYXNrZWREYXRlO1xuICAgIGlmIChtYXNrIGluc3RhbmNlb2YgTnVtYmVyIHx8IHR5cGVvZiBtYXNrID09PSAnbnVtYmVyJyB8fCBtYXNrID09PSBOdW1iZXIpIHJldHVybiBnLklNYXNrLk1hc2tlZE51bWJlcjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXNrKSB8fCBtYXNrID09PSBBcnJheSkgcmV0dXJuIGcuSU1hc2suTWFza2VkRHluYW1pYztcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKG1hc2sucHJvdG90eXBlIGluc3RhbmNlb2YgZy5JTWFzay5NYXNrZWQpIHJldHVybiBtYXNrO1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBpZiAobWFzayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSByZXR1cm4gZy5JTWFzay5NYXNrZWRGdW5jdGlvbjtcblxuICAgIGNvbnNvbGUud2FybignTWFzayBub3QgZm91bmQgZm9yIG1hc2snLCBtYXNrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuIGcuSU1hc2suTWFza2VkO1xuICB9XG5cbiAgLyoqIENyZWF0ZXMgbmV3IHtAbGluayBNYXNrZWR9IGRlcGVuZGluZyBvbiBtYXNrIHR5cGUgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWFzayhvcHRzKSB7XG4gICAgb3B0cyA9IF9leHRlbmRzKHt9LCBvcHRzKTsgLy8gY2xvbmVcbiAgICB2YXIgbWFzayA9IG9wdHMubWFzaztcblxuICAgIGlmIChtYXNrIGluc3RhbmNlb2YgZy5JTWFzay5NYXNrZWQpIHJldHVybiBtYXNrO1xuXG4gICAgdmFyIE1hc2tlZENsYXNzID0gbWFza2VkQ2xhc3MobWFzayk7XG4gICAgcmV0dXJuIG5ldyBNYXNrZWRDbGFzcyhvcHRzKTtcbiAgfVxuXG4gIC8qKiAqL1xuXG4gIC8qKiAqL1xuICB2YXIgUGF0dGVybkRlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqICovXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiAqL1xuXG4gICAgLyoqICovXG4gICAgZnVuY3Rpb24gUGF0dGVybkRlZmluaXRpb24ob3B0cykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGF0dGVybkRlZmluaXRpb24pO1xuICAgICAgLy8gVE9ETyBmbG93XG4gICAgICBfZXh0ZW5kcyh0aGlzLCBvcHRzKTtcblxuICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICB0aGlzLl9tYXNrZWQgPSBjcmVhdGVNYXNrKG9wdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiAqL1xuXG4gICAgLyoqICovXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiAqL1xuXG4gICAgLyoqICovXG5cblxuICAgIC8qKiAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhQYXR0ZXJuRGVmaW5pdGlvbiwgW3tcbiAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pc0hvbGxvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmF3SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fbWFza2VkLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVzb2x2ZScsXG5cblxuICAgICAgLyoqICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShjaCkge1xuICAgICAgICBpZiAoIXRoaXMuX21hc2tlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFza2VkLnJlc29sdmUoY2gpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzSW5wdXQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFBhdHRlcm5EZWZpbml0aW9uLlRZUEVTLklOUFVUO1xuICAgICAgfVxuXG4gICAgICAvKiogKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzSGlkZGVuSG9sbG93JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0hvbGxvdyAmJiB0aGlzLm9wdGlvbmFsO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gUGF0dGVybkRlZmluaXRpb247XG4gIH0oKTtcblxuICBQYXR0ZXJuRGVmaW5pdGlvbi5ERUZBVUxUUyA9IHtcbiAgICAnMCc6IC9cXGQvLFxuICAgICdhJzogL1tcXHUwMDQxLVxcdTAwNUFcXHUwMDYxLVxcdTAwN0FcXHUwMEFBXFx1MDBCNVxcdTAwQkFcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjk3XFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE4MC1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdLywgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjIwNzUwNzBcbiAgICAnKic6IC8uL1xuICB9O1xuICAvKipcclxuICAgIEBwcm9wIHtzdHJpbmd9IElOUFVUXHJcbiAgICBAcHJvcCB7c3RyaW5nfSBGSVhFRFxyXG4gICovXG4gIFBhdHRlcm5EZWZpbml0aW9uLlRZUEVTID0ge1xuICAgIElOUFVUOiAnaW5wdXQnLFxuICAgIEZJWEVEOiAnZml4ZWQnXG4gIH07XG5cbiAgLyoqICovXG5cblxuICAvKiogKi9cblxuICAvKipcclxuICAgIFBhdHRlcm4gZ3JvdXAgc3ltYm9scyBmcm9tIHBhcmVudFxyXG4gICAgQHBhcmFtIHtNYXNrZWRQYXR0ZXJufSBtYXNrZWQgLSBJbnRlcm5hbCB7QGxpbmsgbWFza2VkfSBtb2RlbFxyXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm5hbWUgLSBHcm91cCBuYW1lXHJcbiAgICBAcGFyYW0ge251bWJlcn0gb3B0cy5vZmZzZXQgLSBHcm91cCBvZmZzZXQgaW4gbWFza2VkIGRlZmluaXRpb25zIGFycmF5XHJcbiAgICBAcGFyYW0ge3N0cmluZ30gb3B0cy5tYXNrIC0gR3JvdXAgbWFza1xyXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudmFsaWRhdGVdIC0gQ3VzdG9tIGdyb3VwIHZhbGlkYXRvclxyXG4gICovXG4gIHZhciBQYXR0ZXJuR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEdyb3VwIG1hc2sgKi9cblxuICAgIC8qKiBHcm91cCBuYW1lICovXG5cbiAgICAvKiogKi9cbiAgICBmdW5jdGlvbiBQYXR0ZXJuR3JvdXAobWFza2VkLCBfcmVmKSB7XG4gICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgICAgICBtYXNrID0gX3JlZi5tYXNrLFxuICAgICAgICAgIHZhbGlkYXRlID0gX3JlZi52YWxpZGF0ZTtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdHRlcm5Hcm91cCk7XG5cbiAgICAgIHRoaXMubWFza2VkID0gbWFza2VkO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgdGhpcy5tYXNrID0gbWFzaztcbiAgICAgIHRoaXMudmFsaWRhdGUgPSB2YWxpZGF0ZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogU2xpY2Ugb2YgaW50ZXJuYWwge0BsaW5rIG1hc2tlZH0gdmFsdWUgKi9cblxuICAgIC8qKiBDdXN0b20gZ3JvdXAgdmFsaWRhdG9yICovXG5cbiAgICAvKiogR3JvdXAgb2Zmc2V0IGluIG1hc2tlZCBkZWZpbml0aW9ucyBhcnJheSAqL1xuXG5cbiAgICAvKiogSW50ZXJuYWwge0BsaW5rIG1hc2tlZH0gbW9kZWwgKi9cblxuICAgIC8qKiAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhQYXR0ZXJuR3JvdXAsIFt7XG4gICAgICBrZXk6ICdkb1ZhbGlkYXRlJyxcblxuXG4gICAgICAvKiogVmFsaWRhdGVzIGlmIGN1cnJlbnQgdmFsdWUgaXMgYWNjZXB0YWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUodGhpcy52YWx1ZSwgdGhpcywgZmxhZ3MpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3ZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXNrZWQudmFsdWUuc2xpY2UodGhpcy5tYXNrZWQubWFwRGVmSW5kZXhUb1Bvcyh0aGlzLm9mZnNldCksIHRoaXMubWFza2VkLm1hcERlZkluZGV4VG9Qb3ModGhpcy5vZmZzZXQgKyB0aGlzLm1hc2subGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBVbm1hc2tlZCBzbGljZSBvZiBpbnRlcm5hbCB7QGxpbmsgbWFza2VkfSB2YWx1ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5tYXNrZWRWYWx1ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFza2VkLmV4dHJhY3RJbnB1dCh0aGlzLm1hc2tlZC5tYXBEZWZJbmRleFRvUG9zKHRoaXMub2Zmc2V0KSwgdGhpcy5tYXNrZWQubWFwRGVmSW5kZXhUb1Bvcyh0aGlzLm9mZnNldCArIHRoaXMubWFzay5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFBhdHRlcm5Hcm91cDtcbiAgfSgpO1xuICB2YXIgUmFuZ2VHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIGZ1bmN0aW9uIFJhbmdlR3JvdXAoX3JlZjIpIHtcbiAgICAgIHZhciBfcmVmMyA9IHNsaWNlZFRvQXJyYXkoX3JlZjIsIDIpLFxuICAgICAgICAgIGZyb20gPSBfcmVmM1swXSxcbiAgICAgICAgICB0byA9IF9yZWYzWzFdO1xuXG4gICAgICB2YXIgbWF4bGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTdHJpbmcodG8pLmxlbmd0aDtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlR3JvdXApO1xuXG4gICAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICAgIHRoaXMuX3RvID0gdG87XG4gICAgICB0aGlzLl9tYXhMZW5ndGggPSBtYXhsZW47XG4gICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy52YWxpZGF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKFJhbmdlR3JvdXAsIFt7XG4gICAgICBrZXk6ICdfdXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl9tYXhMZW5ndGggPSBNYXRoLm1heCh0aGlzLl9tYXhMZW5ndGgsIFN0cmluZyh0aGlzLnRvKS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hc2sgPSAnMCcucmVwZWF0KHRoaXMuX21heExlbmd0aCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndmFsaWRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKHN0cikge1xuICAgICAgICB2YXIgbWluc3RyID0gJyc7XG4gICAgICAgIHZhciBtYXhzdHIgPSAnJztcblxuICAgICAgICB2YXIgX3JlZjQgPSBzdHIubWF0Y2goL14oXFxEKikoXFxkKikoXFxEKikvKSB8fCBbXSxcbiAgICAgICAgICAgIF9yZWY1ID0gc2xpY2VkVG9BcnJheShfcmVmNCwgMyksXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IF9yZWY1WzFdLFxuICAgICAgICAgICAgbnVtID0gX3JlZjVbMl07XG5cbiAgICAgICAgaWYgKG51bSkge1xuICAgICAgICAgIG1pbnN0ciA9ICcwJy5yZXBlYXQocGxhY2Vob2xkZXIubGVuZ3RoKSArIG51bTtcbiAgICAgICAgICBtYXhzdHIgPSAnOScucmVwZWF0KHBsYWNlaG9sZGVyLmxlbmd0aCkgKyBudW07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3ROb25aZXJvID0gc3RyLnNlYXJjaCgvW14wXS8pO1xuICAgICAgICBpZiAoZmlyc3ROb25aZXJvID09PSAtMSAmJiBzdHIubGVuZ3RoIDw9IHRoaXMuX21hdGNoRnJvbSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgbWluc3RyID0gbWluc3RyLnBhZEVuZCh0aGlzLl9tYXhMZW5ndGgsICcwJyk7XG4gICAgICAgIG1heHN0ciA9IG1heHN0ci5wYWRFbmQodGhpcy5fbWF4TGVuZ3RoLCAnOScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gPD0gTnVtYmVyKG1heHN0cikgJiYgTnVtYmVyKG1pbnN0cikgPD0gdGhpcy50bztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0bycsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHRvKSB7XG4gICAgICAgIHRoaXMuX3RvID0gdG87XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Zyb20nLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcm9tO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGZyb20pIHtcbiAgICAgICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ21heExlbmd0aCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heExlbmd0aDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShtYXhMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWF0Y2hGcm9tJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhMZW5ndGggLSBTdHJpbmcodGhpcy5mcm9tKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBSYW5nZUdyb3VwO1xuICB9KCk7XG5cbiAgLyoqIFBhdHRlcm4gZ3JvdXAgdGhhdCB2YWxpZGF0ZXMgZW51bSB2YWx1ZXMgKi9cbiAgZnVuY3Rpb24gRW51bUdyb3VwKGVudW1zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hc2s6ICcqJy5yZXBlYXQoZW51bXNbMF0ubGVuZ3RoKSxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgZ3JvdXAsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBlbnVtcy5zb21lKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuaW5kZXhPZihncm91cC51bm1hc2tlZFZhbHVlKSA+PSAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUGF0dGVybkdyb3VwLlJhbmdlID0gUmFuZ2VHcm91cDtcbiAgUGF0dGVybkdyb3VwLkVudW0gPSBFbnVtR3JvdXA7XG5cbiAgdmFyIENodW5rc1RhaWxEZXRhaWxzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENodW5rc1RhaWxEZXRhaWxzKGNodW5rcykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2h1bmtzVGFpbERldGFpbHMpO1xuXG4gICAgICB0aGlzLmNodW5rcyA9IGNodW5rcztcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhDaHVua3NUYWlsRGV0YWlscywgW3tcbiAgICAgIGtleTogJ3ZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua3MubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Zyb21Qb3MnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHZhciBmaXJzdENodW5rID0gdGhpcy5jaHVua3NbMF07XG4gICAgICAgIHJldHVybiBmaXJzdENodW5rICYmIGZpcnN0Q2h1bmsuc3RvcDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b1BvcycsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgdmFyIGxhc3RDaHVuayA9IHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gbGFzdENodW5rICYmIGxhc3RDaHVuay5zdG9wO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ2h1bmtzVGFpbERldGFpbHM7XG4gIH0oKTtcblxuICAvKipcclxuICAgIFBhdHRlcm4gbWFza1xyXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmdyb3Vwc1xyXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHMuZGVmaW5pdGlvbnNcclxuICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnBsYWNlaG9sZGVyQ2hhclxyXG4gICAgQHBhcmFtIHtib29sZWFufSBvcHRzLmxhenlcclxuICAqL1xuICB2YXIgTWFza2VkUGF0dGVybiA9IGZ1bmN0aW9uIChfTWFza2VkKSB7XG4gICAgaW5oZXJpdHMoTWFza2VkUGF0dGVybiwgX01hc2tlZCk7XG5cbiAgICAvLyBUT0RPIG1hc2sgdHlwZVxuICAgIC8qKiBTaW5nbGUgY2hhciBmb3IgZW1wdHkgaW5wdXQgKi9cblxuXG4gICAgLyoqICovXG4gICAgZnVuY3Rpb24gTWFza2VkUGF0dGVybigpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFBhdHRlcm4pO1xuICAgICAgLy8gVE9ETyB0eXBlICRTaGFwZTxNYXNrZWRQYXR0ZXJuT3B0aW9ucz49e30gZG9lcyBub3Qgd29ya1xuICAgICAgb3B0cy5kZWZpbml0aW9ucyA9IF9leHRlbmRzKHt9LCBQYXR0ZXJuRGVmaW5pdGlvbi5ERUZBVUxUUywgb3B0cy5kZWZpbml0aW9ucyk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTWFza2VkUGF0dGVybi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4pKS5jYWxsKHRoaXMsIF9leHRlbmRzKHt9LCBNYXNrZWRQYXR0ZXJuLkRFRkFVTFRTLCBvcHRzKSkpO1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICovXG5cbiAgICAvKiogU2hvdyBwbGFjZWhvbGRlciBvbmx5IHdoZW4gbmVlZGVkICovXG5cbiAgICAvKiogKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoTWFza2VkUGF0dGVybiwgW3tcbiAgICAgIGtleTogJ191cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG4gICAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICBvcHRzLmRlZmluaXRpb25zID0gX2V4dGVuZHMoe30sIHRoaXMuZGVmaW5pdGlvbnMsIG9wdHMuZGVmaW5pdGlvbnMpO1xuICAgICAgICBnZXQoTWFza2VkUGF0dGVybi5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWRQYXR0ZXJuLnByb3RvdHlwZSksICdfdXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgdGhpcy5fcmVidWlsZE1hc2soKTtcbiAgICAgIH1cblxuICAgICAgLyoqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVidWlsZE1hc2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWJ1aWxkTWFzaygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGRlZnMgPSB0aGlzLmRlZmluaXRpb25zO1xuICAgICAgICB0aGlzLl9jaGFyRGVmcyA9IFtdO1xuICAgICAgICB0aGlzLl9ncm91cERlZnMgPSBbXTtcblxuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMubWFzaztcbiAgICAgICAgaWYgKCFwYXR0ZXJuIHx8ICFkZWZzKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHVubWFza2luZ0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIHZhciBvcHRpb25hbEJsb2NrID0gZmFsc2U7XG4gICAgICAgIHZhciBzdG9wQWxpZ24gPSBmYWxzZTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICAgIGlmIChfdGhpczIuZ3JvdXBzKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBhdHRlcm4uc2xpY2UoX2kpO1xuICAgICAgICAgICAgdmFyIGdOYW1lcyA9IE9iamVjdC5rZXlzKF90aGlzMi5ncm91cHMpLmZpbHRlcihmdW5jdGlvbiAoZ05hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHAuaW5kZXhPZihnTmFtZSkgPT09IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG9yZGVyIGJ5IGtleSBsZW5ndGhcbiAgICAgICAgICAgIGdOYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1c2UgZ3JvdXAgbmFtZSB3aXRoIG1heCBsZW5ndGhcbiAgICAgICAgICAgIHZhciBnTmFtZSA9IGdOYW1lc1swXTtcbiAgICAgICAgICAgIGlmIChnTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBfdGhpczIuZ3JvdXBzW2dOYW1lXTtcbiAgICAgICAgICAgICAgX3RoaXMyLl9ncm91cERlZnMucHVzaChuZXcgUGF0dGVybkdyb3VwKF90aGlzMiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IGdOYW1lLFxuICAgICAgICAgICAgICAgIG9mZnNldDogX3RoaXMyLl9jaGFyRGVmcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFzazogZ3JvdXAubWFzayxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZTogZ3JvdXAudmFsaWRhdGVcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKGdOYW1lLCBncm91cC5tYXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2hhciA9IHBhdHRlcm5bX2ldO1xuICAgICAgICAgIHZhciB0eXBlID0gY2hhciBpbiBkZWZzID8gUGF0dGVybkRlZmluaXRpb24uVFlQRVMuSU5QVVQgOiBQYXR0ZXJuRGVmaW5pdGlvbi5UWVBFUy5GSVhFRDtcbiAgICAgICAgICB2YXIgdW5tYXNraW5nID0gdHlwZSA9PT0gUGF0dGVybkRlZmluaXRpb24uVFlQRVMuSU5QVVQgfHwgdW5tYXNraW5nQmxvY2s7XG4gICAgICAgICAgdmFyIG9wdGlvbmFsID0gdHlwZSA9PT0gUGF0dGVybkRlZmluaXRpb24uVFlQRVMuSU5QVVQgJiYgb3B0aW9uYWxCbG9jaztcblxuICAgICAgICAgIGlmIChjaGFyID09PSBNYXNrZWRQYXR0ZXJuLlNUT1BfQ0hBUikge1xuICAgICAgICAgICAgc3RvcEFsaWduID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFyID09PSAneycgfHwgY2hhciA9PT0gJ30nKSB7XG4gICAgICAgICAgICB1bm1hc2tpbmdCbG9jayA9ICF1bm1hc2tpbmdCbG9jaztcbiAgICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFyID09PSAnWycgfHwgY2hhciA9PT0gJ10nKSB7XG4gICAgICAgICAgICBvcHRpb25hbEJsb2NrID0gIW9wdGlvbmFsQmxvY2s7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhciA9PT0gTWFza2VkUGF0dGVybi5FU0NBUEVfQ0hBUikge1xuICAgICAgICAgICAgKytfaTtcbiAgICAgICAgICAgIGNoYXIgPSBwYXR0ZXJuW19pXTtcbiAgICAgICAgICAgIGlmICghY2hhcikgcmV0dXJuICdicmVhayc7XG4gICAgICAgICAgICB0eXBlID0gUGF0dGVybkRlZmluaXRpb24uVFlQRVMuRklYRUQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMyLl9jaGFyRGVmcy5wdXNoKG5ldyBQYXR0ZXJuRGVmaW5pdGlvbih7XG4gICAgICAgICAgICBjaGFyOiBjaGFyLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgICAgICAgIHN0b3BBbGlnbjogc3RvcEFsaWduLFxuICAgICAgICAgICAgdW5tYXNraW5nOiB1bm1hc2tpbmcsXG4gICAgICAgICAgICBtYXNrOiB0eXBlID09PSBQYXR0ZXJuRGVmaW5pdGlvbi5UWVBFUy5JTlBVVCA/IGRlZnNbY2hhcl0gOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHN0b3BBbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIGkgPSBfaTtcbiAgICAgICAgfTtcblxuICAgICAgICBfbG9vcDI6IGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBfcmV0ID0gX2xvb3AoaSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKF9yZXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcbiAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcbiAgICAgICAgICAgICAgYnJlYWsgX2xvb3AyO31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvVmFsaWRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoKSB7XG4gICAgICAgIHZhciBfYmFiZWxIZWxwZXJzJGdldDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBEZWZzLmV2ZXJ5KGZ1bmN0aW9uIChnJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIGckJDEuZG9WYWxpZGF0ZS5hcHBseShnJCQxLCB0b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgICAgIH0pICYmIChfYmFiZWxIZWxwZXJzJGdldCA9IGdldChNYXNrZWRQYXR0ZXJuLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgJ2RvVmFsaWRhdGUnLCB0aGlzKSkuY2FsbC5hcHBseShfYmFiZWxIZWxwZXJzJGdldCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShhcmdzKSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG0gPSBuZXcgTWFza2VkUGF0dGVybih0aGlzKTtcbiAgICAgICAgbS5fdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG0uX2NoYXJEZWZzLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoZCwgX3RoaXMzLl9jaGFyRGVmc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIG0uX2dyb3VwRGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIF9leHRlbmRzKGQsIF90aGlzMy5fZ3JvdXBEZWZzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgZ2V0KE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCAncmVzZXQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9jaGFyRGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZGVsZXRlIGQuaXNIb2xsb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hpZGRlbkhvbGxvd3NCZWZvcmUnLFxuXG5cbiAgICAgIC8qKiAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGRlbkhvbGxvd3NCZWZvcmUoZGVmSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJEZWZzLnNsaWNlKDAsIGRlZkluZGV4KS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pc0hpZGRlbkhvbGxvdztcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvKiogTWFwIGRlZmluaXRpb24gaW5kZXggdG8gcG9zaXRpb24gb24gdmlldyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbWFwRGVmSW5kZXhUb1BvcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwRGVmSW5kZXhUb1BvcyhkZWZJbmRleCkge1xuICAgICAgICByZXR1cm4gZGVmSW5kZXggLSB0aGlzLmhpZGRlbkhvbGxvd3NCZWZvcmUoZGVmSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICAvKiogTWFwIHBvc2l0aW9uIG9uIHZpZXcgdG8gZGVmaW5pdGlvbiBpbmRleCAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbWFwUG9zVG9EZWZJbmRleCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwUG9zVG9EZWZJbmRleChwb3MpIHtcbiAgICAgICAgdmFyIGRlZkluZGV4ID0gcG9zO1xuICAgICAgICBmb3IgKHZhciBkaSA9IDA7IGRpIDwgdGhpcy5fY2hhckRlZnMubGVuZ3RoOyArK2RpKSB7XG4gICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2NoYXJEZWZzW2RpXTtcbiAgICAgICAgICBpZiAoZGkgPj0gZGVmSW5kZXgpIGJyZWFrO1xuICAgICAgICAgIGlmIChkZWYuaXNIaWRkZW5Ib2xsb3cpICsrZGVmSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZkluZGV4O1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hcHBlbmRUYWlsJyxcblxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kVGFpbCh0YWlsKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgICAgaWYgKHRhaWwpIHtcbiAgICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZSh0YWlsIGluc3RhbmNlb2YgQ2h1bmtzVGFpbERldGFpbHMgPyB0aGlzLl9hcHBlbmRDaHVua3ModGFpbC5jaHVua3MsIHsgdGFpbDogdHJ1ZSB9KSA6IGdldChNYXNrZWRQYXR0ZXJuLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgJ19hcHBlbmRUYWlsJywgdGhpcykuY2FsbCh0aGlzLCB0YWlsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRldGFpbHMuYWdncmVnYXRlKHRoaXMuX2FwcGVuZFBsYWNlaG9sZGVyKCkpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hcHBlbmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmQoc3RyKSB7XG4gICAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgdmFyIG9sZFZhbHVlTGVuZ3RoID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHZhciByYXdJbnNlcnRlZCA9ICcnO1xuICAgICAgICB2YXIgb3ZlcmZsb3cgPSBmYWxzZTtcblxuICAgICAgICBzdHIgPSB0aGlzLmRvUHJlcGFyZShzdHIsIGZsYWdzKTtcblxuICAgICAgICBmb3IgKHZhciBjaSA9IDAsIGRpID0gdGhpcy5tYXBQb3NUb0RlZkluZGV4KHRoaXMudmFsdWUubGVuZ3RoKTsgY2kgPCBzdHIubGVuZ3RoOykge1xuICAgICAgICAgIHZhciBjaCA9IHN0cltjaV07XG4gICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2NoYXJEZWZzW2RpXTtcblxuICAgICAgICAgIC8vIGNoZWNrIG92ZXJmbG93XG4gICAgICAgICAgaWYgKGRlZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXNldFxuICAgICAgICAgIGRlZi5pc0hvbGxvdyA9IGZhbHNlO1xuXG4gICAgICAgICAgdmFyIHJlc29sdmVkID0gdm9pZCAwLFxuICAgICAgICAgICAgICBza2lwcGVkID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBjaHJlcyA9IGNvbmZvcm0oZGVmLnJlc29sdmUoY2gpLCBjaCk7XG5cbiAgICAgICAgICBpZiAoZGVmLnR5cGUgPT09IFBhdHRlcm5EZWZpbml0aW9uLlRZUEVTLklOUFVUKSB7XG4gICAgICAgICAgICBpZiAoY2hyZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgKz0gY2hyZXM7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5kb1ZhbGlkYXRlKCkpIHtcbiAgICAgICAgICAgICAgICBjaHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZWQgPSAhIWNocmVzO1xuICAgICAgICAgICAgc2tpcHBlZCA9ICFjaHJlcyAmJiAhZGVmLm9wdGlvbmFsO1xuXG4gICAgICAgICAgICBpZiAoIWNocmVzKSB7XG4gICAgICAgICAgICAgIGlmICghZGVmLm9wdGlvbmFsICYmICFmbGFncy5pbnB1dCAmJiAhdGhpcy5sYXp5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgKz0gdGhpcy5wbGFjZWhvbGRlckNoYXI7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc2tpcHBlZCkgZGVmLmlzSG9sbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJhd0luc2VydGVkICs9IGNocmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSArPSBkZWYuY2hhcjtcbiAgICAgICAgICAgIHJlc29sdmVkID0gY2hyZXMgJiYgKGRlZi51bm1hc2tpbmcgfHwgZmxhZ3MuaW5wdXQgfHwgZmxhZ3MucmF3KSAmJiAhZmxhZ3MudGFpbDtcbiAgICAgICAgICAgIGRlZi5pc1Jhd0lucHV0ID0gcmVzb2x2ZWQgJiYgKGZsYWdzLnJhdyB8fCBmbGFncy5pbnB1dCk7XG4gICAgICAgICAgICBpZiAoZGVmLmlzUmF3SW5wdXQpIHJhd0luc2VydGVkICs9IGRlZi5jaGFyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc2tpcHBlZCkgKytkaTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQgfHwgc2tpcHBlZCkgKytjaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscyh7XG4gICAgICAgICAgaW5zZXJ0ZWQ6IHRoaXMudmFsdWUuc2xpY2Uob2xkVmFsdWVMZW5ndGgpLFxuICAgICAgICAgIHJhd0luc2VydGVkOiByYXdJbnNlcnRlZCxcbiAgICAgICAgICBvdmVyZmxvdzogb3ZlcmZsb3dcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBBcHBlbmRzIGNodW5rcyBzcGxpdHRlZCBieSBzdG9wIGNoYXJzICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYXBwZW5kQ2h1bmtzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2h1bmtzKGNodW5rcykge1xuICAgICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY2h1bmtzLmxlbmd0aDsgKytjaSkge1xuICAgICAgICAgIHZhciBfY2h1bmtzJGNpID0gY2h1bmtzW2NpXSxcbiAgICAgICAgICAgICAgc3RvcCA9IF9jaHVua3MkY2kuc3RvcCxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfY2h1bmtzJGNpLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGZyb21EZWYgPSBzdG9wICE9IG51bGwgJiYgdGhpcy5fY2hhckRlZnNbc3RvcF07XG4gICAgICAgICAgLy8gbGV0cyBkb3VibGUgY2hlY2sgaWYgc3RvcEFsaWduIGlzIGhlcmVcbiAgICAgICAgICBpZiAoZnJvbURlZiAmJiBmcm9tRGVmLnN0b3BBbGlnbikgZGV0YWlscy5hZ2dyZWdhdGUodGhpcy5fYXBwZW5kUGxhY2Vob2xkZXIoc3RvcCkpO1xuICAgICAgICAgIGlmIChkZXRhaWxzLmFnZ3JlZ2F0ZSh0aGlzLl9hcHBlbmQuYXBwbHkodGhpcywgW3ZhbHVlXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYXJncykpKSkub3ZlcmZsb3cpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19leHRyYWN0VGFpbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhY3RUYWlsKCkge1xuICAgICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcblxuICAgICAgICByZXR1cm4gbmV3IENodW5rc1RhaWxEZXRhaWxzKHRoaXMuX2V4dHJhY3RJbnB1dENodW5rcyhmcm9tUG9zLCB0b1BvcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2V4dHJhY3RJbnB1dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdElucHV0KCkge1xuICAgICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgICBpZiAoZnJvbVBvcyA9PT0gdG9Qb3MpIHJldHVybiAnJztcblxuICAgICAgICB2YXIgc3RyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIGlucHV0ID0gJyc7XG5cbiAgICAgICAgdmFyIHRvRGVmSW5kZXggPSB0aGlzLm1hcFBvc1RvRGVmSW5kZXgodG9Qb3MpO1xuICAgICAgICBmb3IgKHZhciBjaSA9IGZyb21Qb3MsIGRpID0gdGhpcy5tYXBQb3NUb0RlZkluZGV4KGZyb21Qb3MpOyBjaSA8IHRvUG9zICYmIGNpIDwgc3RyLmxlbmd0aCAmJiBkaSA8IHRvRGVmSW5kZXg7ICsrZGkpIHtcbiAgICAgICAgICB2YXIgY2ggPSBzdHJbY2ldO1xuICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9jaGFyRGVmc1tkaV07XG5cbiAgICAgICAgICBpZiAoIWRlZikgYnJlYWs7XG4gICAgICAgICAgaWYgKGRlZi5pc0hpZGRlbkhvbGxvdykgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoZGVmLmlzSW5wdXQgJiYgIWRlZi5pc0hvbGxvdyB8fCBmbGFncy5yYXcgJiYgIWRlZi5pc0lucHV0ICYmIGRlZi5pc1Jhd0lucHV0KSBpbnB1dCArPSBjaDtcbiAgICAgICAgICArK2NpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH1cblxuICAgICAgLyoqIEV4dHJhY3RzIGNodW5rcyBmcm9tIGlucHV0IHNwbGl0dGVkIGJ5IHN0b3AgY2hhcnMgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19leHRyYWN0SW5wdXRDaHVua3MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leHRyYWN0SW5wdXRDaHVua3MoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChmcm9tUG9zID09PSB0b1BvcykgcmV0dXJuIFtdO1xuXG4gICAgICAgIHZhciBmcm9tRGVmSW5kZXggPSB0aGlzLm1hcFBvc1RvRGVmSW5kZXgoZnJvbVBvcyk7XG4gICAgICAgIHZhciB0b0RlZkluZGV4ID0gdGhpcy5tYXBQb3NUb0RlZkluZGV4KHRvUG9zKTtcbiAgICAgICAgdmFyIHN0b3BEZWZJbmRpY2VzID0gdGhpcy5fY2hhckRlZnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIFtkLCBpXTtcbiAgICAgICAgfSkuc2xpY2UoZnJvbURlZkluZGV4LCB0b0RlZkluZGV4KS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBzbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgICAgICBkID0gX3JlZjJbMF07XG5cbiAgICAgICAgICByZXR1cm4gZC5zdG9wQWxpZ247XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSBzbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgICAgaSA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdG9wcyA9IFtmcm9tRGVmSW5kZXhdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShzdG9wRGVmSW5kaWNlcyksIFt0b0RlZkluZGV4XSk7XG5cbiAgICAgICAgcmV0dXJuIHN0b3BzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBzdG9wRGVmSW5kaWNlcy5pbmRleE9mKHMpID49IDAgPyBzIDogbnVsbCxcblxuICAgICAgICAgICAgdmFsdWU6IF90aGlzNC5leHRyYWN0SW5wdXQoX3RoaXM0Lm1hcERlZkluZGV4VG9Qb3MocyksIF90aGlzNC5tYXBEZWZJbmRleFRvUG9zKHN0b3BzWysraV0pKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICB2YXIgc3RvcCA9IF9yZWY1LnN0b3AsXG4gICAgICAgICAgICAgIHZhbHVlID0gX3JlZjUudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHN0b3AgIT0gbnVsbCB8fCB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBBcHBlbmRzIHBsYWNlaG9sZGVyIGRlcGVuZGluZyBvbiBsYXppbmVzcyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2FwcGVuZFBsYWNlaG9sZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kUGxhY2Vob2xkZXIodG9EZWZJbmRleCkge1xuICAgICAgICB2YXIgb2xkVmFsdWVMZW5ndGggPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heERlZkluZGV4ID0gdG9EZWZJbmRleCB8fCB0aGlzLl9jaGFyRGVmcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGRpID0gdGhpcy5tYXBQb3NUb0RlZkluZGV4KHRoaXMudmFsdWUubGVuZ3RoKTsgZGkgPCBtYXhEZWZJbmRleDsgKytkaSkge1xuICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9jaGFyRGVmc1tkaV07XG4gICAgICAgICAgaWYgKGRlZi5pc0lucHV0KSBkZWYuaXNIb2xsb3cgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxhenkgfHwgdG9EZWZJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgKz0gIWRlZi5pc0lucHV0ICYmIGRlZi5jaGFyICE9IG51bGwgPyBkZWYuY2hhciA6ICFkZWYub3B0aW9uYWwgPyB0aGlzLnBsYWNlaG9sZGVyQ2hhciA6ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoe1xuICAgICAgICAgIGluc2VydGVkOiB0aGlzLnZhbHVlLnNsaWNlKG9sZFZhbHVlTGVuZ3RoKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGggLSBmcm9tO1xuXG4gICAgICAgIHZhciBmcm9tRGVmSW5kZXggPSB0aGlzLm1hcFBvc1RvRGVmSW5kZXgoZnJvbSk7XG4gICAgICAgIHZhciB0b0RlZkluZGV4ID0gdGhpcy5tYXBQb3NUb0RlZkluZGV4KGZyb20gKyBjb3VudCk7XG4gICAgICAgIHRoaXMuX2NoYXJEZWZzLnNsaWNlKGZyb21EZWZJbmRleCwgdG9EZWZJbmRleCkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnJlc2V0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBnZXQoTWFza2VkUGF0dGVybi5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWRQYXR0ZXJuLnByb3RvdHlwZSksICdyZW1vdmUnLCB0aGlzKS5jYWxsKHRoaXMsIGZyb20sIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICduZWFyZXN0SW5wdXRQb3MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXJlc3RJbnB1dFBvcyhjdXJzb3JQb3MpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRElSRUNUSU9OLk5PTkU7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSBkaXJlY3Rpb24gfHwgRElSRUNUSU9OLlJJR0hUO1xuXG4gICAgICAgIHZhciBpbml0aWFsRGVmSW5kZXggPSB0aGlzLm1hcFBvc1RvRGVmSW5kZXgoY3Vyc29yUG9zKTtcbiAgICAgICAgdmFyIGluaXRpYWxEZWYgPSB0aGlzLl9jaGFyRGVmc1tpbml0aWFsRGVmSW5kZXhdO1xuICAgICAgICB2YXIgZGkgPSBpbml0aWFsRGVmSW5kZXg7XG5cbiAgICAgICAgdmFyIGZpcnN0SW5wdXRJbmRleCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGZpcnN0RmlsbGVkSW5wdXRJbmRleCA9IHZvaWQgMCxcbiAgICAgICAgICAgIGZpcnN0VmlzaWJsZUhvbGxvd0luZGV4ID0gdm9pZCAwLFxuICAgICAgICAgICAgbmV4dGRpID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGNoYXJzIGF0IHJpZ2h0IGlzIGFjY2VwdGFibGUgZm9yIExFRlQgYW5kIE5PTkUgZGlyZWN0aW9uc1xuICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSBESVJFQ1RJT04uUklHSFQgJiYgKGluaXRpYWxEZWYgJiYgaW5pdGlhbERlZi5pc0lucHV0IHx8XG4gICAgICAgIC8vIGluIG5vbmUgZGlyZWN0aW9uIGxhdGVzdCBwb3NpdGlvbiBpcyBhY2NlcHRhYmxlIGFsc29cbiAgICAgICAgZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTk9ORSAmJiBjdXJzb3JQb3MgPT09IHRoaXMudmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgIGZpcnN0SW5wdXRJbmRleCA9IGluaXRpYWxEZWZJbmRleDtcbiAgICAgICAgICBpZiAoaW5pdGlhbERlZiAmJiAhaW5pdGlhbERlZi5pc0hvbGxvdykgZmlyc3RGaWxsZWRJbnB1dEluZGV4ID0gaW5pdGlhbERlZkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0RmlsbGVkSW5wdXRJbmRleCA9PSBudWxsICYmIGRpcmVjdGlvbiA9PSBESVJFQ1RJT04uTEVGVCB8fCBmaXJzdElucHV0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkXG4gICAgICAgICAgZm9yIChuZXh0ZGkgPSBpbmRleEluRGlyZWN0aW9uKGRpLCBzdGVwKTsgMCA8PSBuZXh0ZGkgJiYgbmV4dGRpIDwgdGhpcy5fY2hhckRlZnMubGVuZ3RoOyBkaSArPSBzdGVwLCBuZXh0ZGkgKz0gc3RlcCkge1xuICAgICAgICAgICAgdmFyIG5leHREZWYgPSB0aGlzLl9jaGFyRGVmc1tuZXh0ZGldO1xuICAgICAgICAgICAgaWYgKGZpcnN0SW5wdXRJbmRleCA9PSBudWxsICYmIG5leHREZWYuaXNJbnB1dCkge1xuICAgICAgICAgICAgICBmaXJzdElucHV0SW5kZXggPSBkaTtcbiAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5PTkUpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VmlzaWJsZUhvbGxvd0luZGV4ID09IG51bGwgJiYgbmV4dERlZi5pc0hvbGxvdyAmJiAhbmV4dERlZi5pc0hpZGRlbkhvbGxvdykgZmlyc3RWaXNpYmxlSG9sbG93SW5kZXggPSBkaTtcbiAgICAgICAgICAgIGlmIChuZXh0RGVmLmlzSW5wdXQgJiYgIW5leHREZWYuaXNIb2xsb3cpIHtcbiAgICAgICAgICAgICAgZmlyc3RGaWxsZWRJbnB1dEluZGV4ID0gZGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBsYXp5IGlmIGhhcyBhbGlnbmVkIGxlZnQgaW5zaWRlIGZpeGVkIGFuZCBoYXMgY2FtZSB0byB0aGUgc3RhcnQgLSB1c2Ugc3RhcnQgcG9zaXRpb25cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkxFRlQgJiYgZGkgPT09IDAgJiYgdGhpcy5sYXp5ICYmICF0aGlzLmV4dHJhY3RJbnB1dCgpICYmICghaW5pdGlhbERlZiB8fCAhaW5pdGlhbERlZi5pc0lucHV0KSkgZmlyc3RJbnB1dEluZGV4ID0gMDtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTEVGVCB8fCBmaXJzdElucHV0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHNlYXJjaCBiYWNrd2FyZFxuICAgICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIGZpbmQgaG9sbG93cyBvbmx5IGJlZm9yZSBpbml0aWFsIHBvc1xuICAgICAgICAgIGZvciAobmV4dGRpID0gaW5kZXhJbkRpcmVjdGlvbihkaSwgc3RlcCk7IDAgPD0gbmV4dGRpICYmIG5leHRkaSA8IHRoaXMuX2NoYXJEZWZzLmxlbmd0aDsgZGkgKz0gc3RlcCwgbmV4dGRpICs9IHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBfbmV4dERlZiA9IHRoaXMuX2NoYXJEZWZzW25leHRkaV07XG4gICAgICAgICAgICBpZiAoX25leHREZWYuaXNJbnB1dCkge1xuICAgICAgICAgICAgICBmaXJzdElucHV0SW5kZXggPSBkaTtcbiAgICAgICAgICAgICAgaWYgKF9uZXh0RGVmLmlzSG9sbG93ICYmICFfbmV4dERlZi5pc0hpZGRlbkhvbGxvdykgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGhvbGxvdyBub3QgZm91bmQgYmVmb3JlIHN0YXJ0IHBvc2l0aW9uIC0gc2V0IGBvdmVyZmxvd2BcbiAgICAgICAgICAgIC8vIGFuZCB0cnkgdG8gZmluZCBqdXN0IGFueSBpbnB1dFxuICAgICAgICAgICAgaWYgKGRpID09PSBpbml0aWFsRGVmSW5kZXgpIG92ZXJmbG93ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gZmlyc3QgaW5wdXQgZm91bmRcbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyAmJiBmaXJzdElucHV0SW5kZXggIT0gbnVsbCkgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJvY2VzcyBvdmVyZmxvd1xuICAgICAgICAgIG92ZXJmbG93ID0gb3ZlcmZsb3cgfHwgbmV4dGRpID49IHRoaXMuX2NoYXJEZWZzLmxlbmd0aDtcbiAgICAgICAgICBpZiAob3ZlcmZsb3cgJiYgZmlyc3RJbnB1dEluZGV4ICE9IG51bGwpIGRpID0gZmlyc3RJbnB1dEluZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0RmlsbGVkSW5wdXRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gYWRqdXN0IGluZGV4IGlmIGRlbGV0ZSBhdCByaWdodCBhbmQgZmlsbGVkIGlucHV0IG5vdCBmb3VuZCBhdCByaWdodFxuICAgICAgICAgIGRpID0gZmlyc3RWaXNpYmxlSG9sbG93SW5kZXggIT0gbnVsbCA/IGZpcnN0VmlzaWJsZUhvbGxvd0luZGV4IDogZmlyc3RJbnB1dEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGVmSW5kZXhUb1BvcyhkaSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBHZXQgZ3JvdXAgYnkgbmFtZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ3JvdXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzQnlOYW1lKG5hbWUpWzBdO1xuICAgICAgfVxuXG4gICAgICAvKiogR2V0IGFsbCBncm91cHMgYnkgbmFtZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ3JvdXBzQnlOYW1lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cHNCeU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBEZWZzLmZpbHRlcihmdW5jdGlvbiAoZyQkMSkge1xuICAgICAgICAgIHJldHVybiBnJCQxLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzQ29tcGxldGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5fY2hhckRlZnMuc29tZShmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBkLmlzSW5wdXQgJiYgIWQub3B0aW9uYWwgJiYgKGQuaXNIb2xsb3cgfHwgIV90aGlzNS5leHRyYWN0SW5wdXQoaSwgaSArIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndW5tYXNrZWRWYWx1ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGNpID0gMCwgZGkgPSAwOyBjaSA8IHN0ci5sZW5ndGggJiYgZGkgPCB0aGlzLl9jaGFyRGVmcy5sZW5ndGg7ICsrZGkpIHtcbiAgICAgICAgICB2YXIgY2ggPSBzdHJbY2ldO1xuICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9jaGFyRGVmc1tkaV07XG5cbiAgICAgICAgICBpZiAoZGVmLmlzSGlkZGVuSG9sbG93KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoZGVmLnVubWFza2luZyAmJiAhZGVmLmlzSG9sbG93KSB1bm1hc2tlZCArPSBjaDtcbiAgICAgICAgICArK2NpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVubWFza2VkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHVubWFza2VkVmFsdWUpIHtcbiAgICAgICAgc2V0KE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCAndW5tYXNrZWRWYWx1ZScsIHVubWFza2VkVmFsdWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTWFza2VkUGF0dGVybjtcbiAgfShNYXNrZWQpO1xuXG4gIE1hc2tlZFBhdHRlcm4uREVGQVVMVFMgPSB7XG4gICAgbGF6eTogdHJ1ZSxcbiAgICBwbGFjZWhvbGRlckNoYXI6ICdfJ1xuICB9O1xuICBNYXNrZWRQYXR0ZXJuLlNUT1BfQ0hBUiA9ICdgJztcbiAgTWFza2VkUGF0dGVybi5FU0NBUEVfQ0hBUiA9ICdcXFxcJztcbiAgTWFza2VkUGF0dGVybi5EZWZpbml0aW9uID0gUGF0dGVybkRlZmluaXRpb247XG4gIE1hc2tlZFBhdHRlcm4uR3JvdXAgPSBQYXR0ZXJuR3JvdXA7XG5cbiAgLyoqIERhdGUgbWFzayAqL1xuXG4gIHZhciBNYXNrZWREYXRlID0gZnVuY3Rpb24gKF9NYXNrZWRQYXR0ZXJuKSB7XG4gICAgaW5oZXJpdHMoTWFza2VkRGF0ZSwgX01hc2tlZFBhdHRlcm4pO1xuXG4gICAgLyoqXHJcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAqL1xuXG4gICAgLyoqIFN0YXJ0IGRhdGUgKi9cblxuICAgIC8qKiBGb3JtYXQgRGF0ZSB0byBzdHJpbmcgKi9cbiAgICBmdW5jdGlvbiBNYXNrZWREYXRlKG9wdHMpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZERhdGUpO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE1hc2tlZERhdGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWREYXRlKSkuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgTWFza2VkRGF0ZS5ERUZBVUxUUywgb3B0cykpKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gICAgLyoqIEVuZCBkYXRlICovXG5cbiAgICAvKiogUGF0dGVybiBtYXNrIGZvciBkYXRlIGFjY29yZGluZyB0byB7QGxpbmsgTWFza2VkRGF0ZSNmb3JtYXR9ICovXG5cblxuICAgIC8qKiBQYXJzZSBzdHJpbmcgdG8gRGF0ZSAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhNYXNrZWREYXRlLCBbe1xuICAgICAga2V5OiAnX3VwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1hc2sgPT09IERhdGUpIGRlbGV0ZSBvcHRzLm1hc2s7XG4gICAgICAgIGlmIChvcHRzLnBhdHRlcm4pIHtcbiAgICAgICAgICBvcHRzLm1hc2sgPSBvcHRzLnBhdHRlcm47XG4gICAgICAgICAgZGVsZXRlIG9wdHMucGF0dGVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cHMgPSBvcHRzLmdyb3VwcztcbiAgICAgICAgb3B0cy5ncm91cHMgPSBfZXh0ZW5kcyh7fSwgTWFza2VkRGF0ZS5HRVRfREVGQVVMVF9HUk9VUFMoKSk7XG4gICAgICAgIC8vIGFkanVzdCB5ZWFyIGdyb3VwXG4gICAgICAgIGlmIChvcHRzLm1pbikgb3B0cy5ncm91cHMuWS5mcm9tID0gb3B0cy5taW4uZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgaWYgKG9wdHMubWF4KSBvcHRzLmdyb3Vwcy5ZLnRvID0gb3B0cy5tYXguZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgX2V4dGVuZHMob3B0cy5ncm91cHMsIGdyb3Vwcyk7XG5cbiAgICAgICAgZ2V0KE1hc2tlZERhdGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkRGF0ZS5wcm90b3R5cGUpLCAnX3VwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZG9WYWxpZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9WYWxpZGF0ZSgpIHtcbiAgICAgICAgdmFyIF9iYWJlbEhlbHBlcnMkZ2V0O1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZCA9IChfYmFiZWxIZWxwZXJzJGdldCA9IGdldChNYXNrZWREYXRlLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgJ2RvVmFsaWRhdGUnLCB0aGlzKSkuY2FsbC5hcHBseShfYmFiZWxIZWxwZXJzJGdldCwgW3RoaXNdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShhcmdzKSkpO1xuICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZGF0ZTtcblxuICAgICAgICByZXR1cm4gdmFsaWQgJiYgKCF0aGlzLmlzQ29tcGxldGUgfHwgdGhpcy5pc0RhdGVFeGlzdCh0aGlzLnZhbHVlKSAmJiBkYXRlICYmICh0aGlzLm1pbiA9PSBudWxsIHx8IHRoaXMubWluIDw9IGRhdGUpICYmICh0aGlzLm1heCA9PSBudWxsIHx8IGRhdGUgPD0gdGhpcy5tYXgpKTtcbiAgICAgIH1cblxuICAgICAgLyoqIENoZWNrcyBpZiBkYXRlIGlzIGV4aXN0cyAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaXNEYXRlRXhpc3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGF0ZUV4aXN0KHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5wYXJzZShzdHIpKSA9PT0gc3RyO1xuICAgICAgfVxuXG4gICAgICAvKiogUGFyc2VkIERhdGUgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RhdGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGUgPyB0aGlzLnBhcnNlKHRoaXMudmFsdWUpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShkYXRlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmZvcm1hdChkYXRlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0eXBlZFZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTWFza2VkRGF0ZTtcbiAgfShNYXNrZWRQYXR0ZXJuKTtcblxuICBNYXNrZWREYXRlLkRFRkFVTFRTID0ge1xuICAgIHBhdHRlcm46ICdkey59YG17Ln1gWScsXG4gICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgdmFyIGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgIHZhciBtb250aCA9IFN0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgdmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgIHJldHVybiBbZGF5LCBtb250aCwgeWVhcl0uam9pbignLicpO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgICAgdmFyIF9zdHIkc3BsaXQgPSBzdHIuc3BsaXQoJy4nKSxcbiAgICAgICAgICBfc3RyJHNwbGl0MiA9IHNsaWNlZFRvQXJyYXkoX3N0ciRzcGxpdCwgMyksXG4gICAgICAgICAgZGF5ID0gX3N0ciRzcGxpdDJbMF0sXG4gICAgICAgICAgbW9udGggPSBfc3RyJHNwbGl0MlsxXSxcbiAgICAgICAgICB5ZWFyID0gX3N0ciRzcGxpdDJbMl07XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSk7XG4gICAgfVxuICB9O1xuICBNYXNrZWREYXRlLkdFVF9ERUZBVUxUX0dST1VQUyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZDogbmV3IFBhdHRlcm5Hcm91cC5SYW5nZShbMSwgMzFdKSxcbiAgICAgIG06IG5ldyBQYXR0ZXJuR3JvdXAuUmFuZ2UoWzEsIDEyXSksXG4gICAgICBZOiBuZXcgUGF0dGVybkdyb3VwLlJhbmdlKFsxOTAwLCA5OTk5XSlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxyXG4gICAgR2VuZXJpYyBlbGVtZW50IEFQSSB0byB1c2Ugd2l0aCBtYXNrXHJcbiAgICBAaW50ZXJmYWNlXHJcbiAgKi9cbiAgdmFyIE1hc2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hc2tFbGVtZW50KCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza0VsZW1lbnQpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsYXNzKE1hc2tFbGVtZW50LCBbe1xuICAgICAga2V5OiAnc2VsZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3Qoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCB8fCBzdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25TdGFydCAmJiBlbmQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSByZXR1cm47XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl91bnNhZmVTZWxlY3Qoc3RhcnQsIGVuZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3Vuc2FmZVNlbGVjdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Vuc2FmZVNlbGVjdChzdGFydCwgZW5kKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzQWN0aXZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2JpbmRFdmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudHMoaGFuZGxlcnMpIHt9XG4gICAgfSwge1xuICAgICAga2V5OiAndW5iaW5kRXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRFdmVudHMoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdGlvblN0YXJ0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnQgPSB0aGlzLl91bnNhZmVTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICByZXR1cm4gc3RhcnQgIT0gbnVsbCA/IHN0YXJ0IDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0aW9uRW5kJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICB2YXIgZW5kID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVuZCA9IHRoaXMuX3Vuc2FmZVNlbGVjdGlvbkVuZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICByZXR1cm4gZW5kICE9IG51bGwgPyBlbmQgOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE1hc2tFbGVtZW50O1xuICB9KCk7XG5cbiAgdmFyIEhUTUxNYXNrRWxlbWVudCA9IGZ1bmN0aW9uIChfTWFza0VsZW1lbnQpIHtcbiAgICBpbmhlcml0cyhIVE1MTWFza0VsZW1lbnQsIF9NYXNrRWxlbWVudCk7XG5cbiAgICBmdW5jdGlvbiBIVE1MTWFza0VsZW1lbnQoaW5wdXQpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxNYXNrRWxlbWVudCk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEhUTUxNYXNrRWxlbWVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEhUTUxNYXNrRWxlbWVudCkpLmNhbGwodGhpcykpO1xuXG4gICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgX3RoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoSFRNTE1hc2tFbGVtZW50LCBbe1xuICAgICAga2V5OiAnaXNBY3RpdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5zYWZlU2VsZWN0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdiaW5kRXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKGhhbmRsZXJzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3RvZ2dsZUV2ZW50SGFuZGxlcihIVE1MTWFza0VsZW1lbnQuRVZFTlRTX01BUFtldmVudF0sIGhhbmRsZXJzW2V2ZW50XSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VuYmluZEV2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl90b2dnbGVFdmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdG9nZ2xlRXZlbnRIYW5kbGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICB0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3Vuc2FmZVNlbGVjdGlvblN0YXJ0JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdW5zYWZlU2VsZWN0aW9uRW5kJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndmFsdWUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEhUTUxNYXNrRWxlbWVudDtcbiAgfShNYXNrRWxlbWVudCk7XG5cbiAgSFRNTE1hc2tFbGVtZW50LkVWRU5UU19NQVAgPSB7XG4gICAgc2VsZWN0aW9uQ2hhbmdlOiAna2V5ZG93bicsXG4gICAgaW5wdXQ6ICdpbnB1dCcsXG4gICAgZHJvcDogJ2Ryb3AnLFxuICAgIGNsaWNrOiAnY2xpY2snLFxuICAgIGZvY3VzOiAnZm9jdXMnLFxuICAgIGNvbW1pdDogJ2NoYW5nZSdcbiAgfTtcblxuICAvKiogTGlzdGVucyB0byBlbGVtZW50IGV2ZW50cyBhbmQgY29udHJvbHMgY2hhbmdlcyBiZXR3ZWVuIGVsZW1lbnQgYW5kIHtAbGluayBNYXNrZWR9ICovXG5cbiAgdmFyIElucHV0TWFzayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxyXG4gICAgICBAcGFyYW0ge01hc2tFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR8SFRNTFRleHRBcmVhRWxlbWVudH0gZWxcclxuICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICovXG5cbiAgICAvKipcclxuICAgICAgVmlldyBlbGVtZW50XHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cbiAgICBmdW5jdGlvbiBJbnB1dE1hc2soZWwsIG9wdHMpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIElucHV0TWFzayk7XG5cbiAgICAgIHRoaXMuZWwgPSBlbCBpbnN0YW5jZW9mIE1hc2tFbGVtZW50ID8gZWwgOiBuZXcgSFRNTE1hc2tFbGVtZW50KGVsKTtcbiAgICAgIHRoaXMubWFza2VkID0gY3JlYXRlTWFzayhvcHRzKTtcblxuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICB0aGlzLl92YWx1ZSA9ICcnO1xuICAgICAgdGhpcy5fdW5tYXNrZWRWYWx1ZSA9ICcnO1xuXG4gICAgICB0aGlzLl9zYXZlU2VsZWN0aW9uID0gdGhpcy5fc2F2ZVNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJvcCA9IHRoaXMuX29uRHJvcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5hbGlnbkN1cnNvciA9IHRoaXMuYWxpZ25DdXJzb3IuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYWxpZ25DdXJzb3JGcmllbmRseSA9IHRoaXMuYWxpZ25DdXJzb3JGcmllbmRseS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG5cbiAgICAgIC8vIHJlZnJlc2hcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgLyoqIFJlYWQgb3IgdXBkYXRlIG1hc2sgKi9cblxuXG4gICAgLyoqXHJcbiAgICAgIEludGVybmFsIHtAbGluayBNYXNrZWR9IG1vZGVsXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoSW5wdXRNYXNrLCBbe1xuICAgICAga2V5OiAnX2JpbmRFdmVudHMnLFxuXG5cbiAgICAgIC8qKlxyXG4gICAgICAgIFN0YXJ0cyBsaXN0ZW5pbmcgdG8gZWxlbWVudCBldmVudHNcclxuICAgICAgICBAcHJvdGVjdGVkXHJcbiAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZWwuYmluZEV2ZW50cyh7XG4gICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlOiB0aGlzLl9zYXZlU2VsZWN0aW9uLFxuICAgICAgICAgIGlucHV0OiB0aGlzLl9vbklucHV0LFxuICAgICAgICAgIGRyb3A6IHRoaXMuX29uRHJvcCxcbiAgICAgICAgICBjbGljazogdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5LFxuICAgICAgICAgIGZvY3VzOiB0aGlzLmFsaWduQ3Vyc29yRnJpZW5kbHksXG4gICAgICAgICAgY29tbWl0OiB0aGlzLl9vbkNoYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgU3RvcHMgbGlzdGVuaW5nIHRvIGVsZW1lbnQgZXZlbnRzXHJcbiAgICAgICAgQHByb3RlY3RlZFxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bmJpbmRFdmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZWwudW5iaW5kRXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEZpcmVzIGN1c3RvbSBldmVudFxyXG4gICAgICAgIEBwcm90ZWN0ZWRcclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZmlyZUV2ZW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlyZUV2ZW50KGV2KSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgcmV0dXJuIGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEN1cnJlbnQgc2VsZWN0aW9uIHN0YXJ0XHJcbiAgICAgICAgQHJlYWRvbmx5XHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2F2ZVNlbGVjdGlvbicsXG5cblxuICAgICAgLyoqXHJcbiAgICAgICAgU3RvcmVzIGN1cnJlbnQgc2VsZWN0aW9uXHJcbiAgICAgICAgQHByb3RlY3RlZFxyXG4gICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlU2VsZWN0aW9uKCkgLyogZXYgKi97XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdVbmNvbnRyb2xsZWQgaW5wdXQgY2hhbmdlLCByZWZyZXNoIG1hc2sgbWFudWFsbHkhJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBlbmQ6IHRoaXMuY3Vyc29yUG9zXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKiBTeW5jcm9uaXplcyBtb2RlbCB2YWx1ZSBmcm9tIHZpZXcgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZVZhbHVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5tYXNrZWQudmFsdWUgPSB0aGlzLmVsLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKiogU3luY3Jvbml6ZXMgdmlldyBmcm9tIG1vZGVsIHZhbHVlLCBmaXJlcyBjaGFuZ2UgZXZlbnRzICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVDb250cm9sJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb250cm9sKCkge1xuICAgICAgICB2YXIgbmV3VW5tYXNrZWRWYWx1ZSA9IHRoaXMubWFza2VkLnVubWFza2VkVmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMubWFza2VkLnZhbHVlO1xuICAgICAgICB2YXIgaXNDaGFuZ2VkID0gdGhpcy51bm1hc2tlZFZhbHVlICE9PSBuZXdVbm1hc2tlZFZhbHVlIHx8IHRoaXMudmFsdWUgIT09IG5ld1ZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3VubWFza2VkVmFsdWUgPSBuZXdVbm1hc2tlZFZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmVsLnZhbHVlICE9PSBuZXdWYWx1ZSkgdGhpcy5lbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKSB0aGlzLl9maXJlQ2hhbmdlRXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBVcGRhdGVzIG9wdGlvbnMgd2l0aCBkZWVwIGVxdWFsIGNoZWNrLCByZWNyZWF0ZXMgQHtsaW5rIE1hc2tlZH0gbW9kZWwgaWYgbWFzayB0eXBlIGNoYW5nZXMgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VwZGF0ZU9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0cykge1xuICAgICAgICBvcHRzID0gX2V4dGVuZHMoe30sIG9wdHMpO1xuXG4gICAgICAgIHRoaXMubWFzayA9IG9wdHMubWFzaztcbiAgICAgICAgZGVsZXRlIG9wdHMubWFzaztcblxuICAgICAgICAvLyBjaGVjayBpZiBjaGFuZ2VkXG4gICAgICAgIGlmIChvYmplY3RJbmNsdWRlcyh0aGlzLm1hc2tlZCwgb3B0cykpIHJldHVybjtcblxuICAgICAgICB0aGlzLm1hc2tlZC51cGRhdGVPcHRpb25zKG9wdHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRyb2woKTtcbiAgICAgIH1cblxuICAgICAgLyoqIFVwZGF0ZXMgY3Vyc29yICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGVDdXJzb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcihjdXJzb3JQb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gY3Vyc29yUG9zO1xuXG4gICAgICAgIC8vIGFsc28gcXVldWUgY2hhbmdlIGN1cnNvciBmb3IgbW9iaWxlIGJyb3dzZXJzXG4gICAgICAgIHRoaXMuX2RlbGF5VXBkYXRlQ3Vyc29yKGN1cnNvclBvcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIERlbGF5cyBjdXJzb3IgdXBkYXRlIHRvIHN1cHBvcnQgbW9iaWxlIGJyb3dzZXJzXHJcbiAgICAgICAgQHByaXZhdGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19kZWxheVVwZGF0ZUN1cnNvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGF5VXBkYXRlQ3Vyc29yKGN1cnNvclBvcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2Fib3J0VXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMuX2NoYW5naW5nQ3Vyc29yUG9zID0gY3Vyc29yUG9zO1xuICAgICAgICB0aGlzLl9jdXJzb3JDaGFuZ2luZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghX3RoaXMuZWwpIHJldHVybjsgLy8gaWYgd2FzIGRlc3Ryb3llZFxuICAgICAgICAgIF90aGlzLmN1cnNvclBvcyA9IF90aGlzLl9jaGFuZ2luZ0N1cnNvclBvcztcbiAgICAgICAgICBfdGhpcy5fYWJvcnRVcGRhdGVDdXJzb3IoKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBGaXJlcyBjdXN0b20gZXZlbnRzXHJcbiAgICAgICAgQHByb3RlY3RlZFxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2ZpcmVDaGFuZ2VFdmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maXJlQ2hhbmdlRXZlbnRzKCkge1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2FjY2VwdCcpO1xuICAgICAgICBpZiAodGhpcy5tYXNrZWQuaXNDb21wbGV0ZSkgdGhpcy5fZmlyZUV2ZW50KCdjb21wbGV0ZScpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBBYm9ydHMgZGVsYXllZCBjdXJzb3IgdXBkYXRlXHJcbiAgICAgICAgQHByaXZhdGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hYm9ydFVwZGF0ZUN1cnNvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fib3J0VXBkYXRlQ3Vyc29yKCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yQ2hhbmdpbmcpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yQ2hhbmdpbmcpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJzb3JDaGFuZ2luZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQWxpZ25zIGN1cnNvciB0byBuZWFyZXN0IGF2YWlsYWJsZSBwb3NpdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWxpZ25DdXJzb3InLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsaWduQ3Vyc29yKCkge1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHRoaXMubWFza2VkLm5lYXJlc3RJbnB1dFBvcyh0aGlzLmN1cnNvclBvcywgRElSRUNUSU9OLkxFRlQpO1xuICAgICAgfVxuXG4gICAgICAvKiogQWxpZ25zIGN1cnNvciBvbmx5IGlmIHNlbGVjdGlvbiBpcyBlbXB0eSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYWxpZ25DdXJzb3JGcmllbmRseScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25DdXJzb3JGcmllbmRseSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuY3Vyc29yUG9zKSByZXR1cm47XG4gICAgICAgIHRoaXMuYWxpZ25DdXJzb3IoKTtcbiAgICAgIH1cblxuICAgICAgLyoqIEFkZHMgbGlzdGVuZXIgb24gY3VzdG9tIGV2ZW50ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbZXZdKSB0aGlzLl9saXN0ZW5lcnNbZXZdID0gW107XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldl0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKiBSZW1vdmVzIGN1c3RvbSBldmVudCBsaXN0ZW5lciAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb2ZmJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbZXZdKSByZXR1cm47XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaEluZGV4ID0gdGhpcy5fbGlzdGVuZXJzW2V2XS5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaEluZGV4ID49IDApIHRoaXMuX2xpc3RlbmVyc1tldl0uc3BsaWNlKGhJbmRleCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvKiogSGFuZGxlcyB2aWV3IGlucHV0IGV2ZW50ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25JbnB1dCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uSW5wdXQoKSB7XG4gICAgICAgIHRoaXMuX2Fib3J0VXBkYXRlQ3Vyc29yKCk7XG5cbiAgICAgICAgLy8gZml4IHN0cmFuZ2UgSUUgYmVoYXZpb3JcbiAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24pIHJldHVybiB0aGlzLnVwZGF0ZVZhbHVlKCk7XG5cbiAgICAgICAgdmFyIGRldGFpbHMgPSBuZXcgQWN0aW9uRGV0YWlscyhcbiAgICAgICAgLy8gbmV3IHN0YXRlXG4gICAgICAgIHRoaXMuZWwudmFsdWUsIHRoaXMuY3Vyc29yUG9zLFxuICAgICAgICAvLyBvbGQgc3RhdGVcbiAgICAgICAgdGhpcy52YWx1ZSwgdGhpcy5fc2VsZWN0aW9uKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5tYXNrZWQuc3BsaWNlKGRldGFpbHMuc3RhcnRDaGFuZ2VQb3MsIGRldGFpbHMucmVtb3ZlZC5sZW5ndGgsIGRldGFpbHMuaW5zZXJ0ZWQsIGRldGFpbHMucmVtb3ZlRGlyZWN0aW9uKS5vZmZzZXQ7XG5cbiAgICAgICAgdmFyIGN1cnNvclBvcyA9IHRoaXMubWFza2VkLm5lYXJlc3RJbnB1dFBvcyhkZXRhaWxzLnN0YXJ0Q2hhbmdlUG9zICsgb2Zmc2V0LCBkZXRhaWxzLnJlbW92ZURpcmVjdGlvbik7XG5cbiAgICAgICAgdGhpcy51cGRhdGVDb250cm9sKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ3Vyc29yKGN1cnNvclBvcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBIYW5kbGVzIHZpZXcgY2hhbmdlIGV2ZW50IGFuZCBjb21taXRzIG1vZGVsIHZhbHVlICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25DaGFuZ2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHRoaXMuZWwudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXNrZWQuZG9Db21taXQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDb250cm9sKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBIYW5kbGVzIHZpZXcgZHJvcCBldmVudCwgcHJldmVudHMgYnkgZGVmYXVsdCAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRHJvcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJvcChldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgLyoqIFVuYmluZCB2aWV3IGV2ZW50cyBhbmQgcmVtb3ZlcyBlbGVtZW50IHJlZmVyZW5jZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fdW5iaW5kRXZlbnRzKCk7XG4gICAgICAgIC8vICRGbG93Rml4TWUgd2h5IG5vdCBkbyBzbz9cbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ21hc2snLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hc2tlZC5tYXNrO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG1hc2spIHtcbiAgICAgICAgaWYgKG1hc2sgPT0gbnVsbCB8fCBtYXNrID09PSB0aGlzLm1hc2tlZC5tYXNrIHx8IG1hc2sgPT09IERhdGUgJiYgdGhpcy5tYXNrZWQgaW5zdGFuY2VvZiBNYXNrZWREYXRlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMubWFza2VkLmNvbnN0cnVjdG9yID09PSBtYXNrZWRDbGFzcyhtYXNrKSkge1xuICAgICAgICAgIHRoaXMubWFza2VkLm1hc2sgPSBtYXNrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXNrZWQgPSBjcmVhdGVNYXNrKHsgbWFzazogbWFzayB9KTtcbiAgICAgICAgbWFza2VkLnVubWFza2VkVmFsdWUgPSB0aGlzLm1hc2tlZC51bm1hc2tlZFZhbHVlO1xuICAgICAgICB0aGlzLm1hc2tlZCA9IG1hc2tlZDtcbiAgICAgIH1cblxuICAgICAgLyoqIFJhdyB2YWx1ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndmFsdWUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShzdHIpIHtcbiAgICAgICAgdGhpcy5tYXNrZWQudmFsdWUgPSBzdHI7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgICB0aGlzLmFsaWduQ3Vyc29yKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBVbm1hc2tlZCB2YWx1ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndW5tYXNrZWRWYWx1ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VubWFza2VkVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoc3RyKSB7XG4gICAgICAgIHRoaXMubWFza2VkLnVubWFza2VkVmFsdWUgPSBzdHI7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgICB0aGlzLmFsaWduQ3Vyc29yKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBUeXBlZCB1bm1hc2tlZCB2YWx1ZSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndHlwZWRWYWx1ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFza2VkLnR5cGVkVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodmFsKSB7XG4gICAgICAgIHRoaXMubWFza2VkLnR5cGVkVmFsdWUgPSB2YWw7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgICB0aGlzLmFsaWduQ3Vyc29yKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2VsZWN0aW9uU3RhcnQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3JDaGFuZ2luZyA/IHRoaXMuX2NoYW5naW5nQ3Vyc29yUG9zIDogdGhpcy5lbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgLyoqIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjdXJzb3JQb3MnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3JDaGFuZ2luZyA/IHRoaXMuX2NoYW5naW5nQ3Vyc29yUG9zIDogdGhpcy5lbC5zZWxlY3Rpb25FbmQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEocG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbC5pc0FjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuZWwuc2VsZWN0KHBvcywgcG9zKTtcbiAgICAgICAgdGhpcy5fc2F2ZVNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gSW5wdXRNYXNrO1xuICB9KCk7XG5cbiAgLyoqXHJcbiAgICBOdW1iZXIgbWFza1xyXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnJhZGl4IC0gU2luZ2xlIGNoYXJcclxuICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnRob3VzYW5kc1NlcGFyYXRvciAtIFNpbmdsZSBjaGFyXHJcbiAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IG9wdHMubWFwVG9SYWRpeCAtIEFycmF5IG9mIHNpbmdsZSBjaGFyc1xyXG4gICAgQHBhcmFtIHtudW1iZXJ9IG9wdHMubWluXHJcbiAgICBAcGFyYW0ge251bWJlcn0gb3B0cy5tYXhcclxuICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjYWxlIC0gRGlnaXRzIGFmdGVyIHBvaW50XHJcbiAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdHMuc2lnbmVkIC0gQWxsb3cgbmVnYXRpdmVcclxuICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5ub3JtYWxpemVaZXJvcyAtIEZsYWcgdG8gcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHplcm9zIGluIHRoZSBlbmQgb2YgZWRpdGluZ1xyXG4gICAgQHBhcmFtIHtib29sZWFufSBvcHRzLnBhZEZyYWN0aW9uYWxaZXJvcyAtIEZsYWcgdG8gcGFkIHRyYWlsaW5nIHplcm9zIGFmdGVyIHBvaW50IGluIHRoZSBlbmQgb2YgZWRpdGluZ1xyXG4gICovXG4gIHZhciBNYXNrZWROdW1iZXIgPSBmdW5jdGlvbiAoX01hc2tlZCkge1xuICAgIGluaGVyaXRzKE1hc2tlZE51bWJlciwgX01hc2tlZCk7XG5cbiAgICAvKiogRmxhZyB0byByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGVuZCBvZiBlZGl0aW5nICovXG5cbiAgICAvKiogRGlnaXRzIGFmdGVyIHBvaW50ICovXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiBTaW5nbGUgY2hhciAqL1xuICAgIGZ1bmN0aW9uIE1hc2tlZE51bWJlcihvcHRzKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWROdW1iZXIpO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE1hc2tlZE51bWJlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlcikpLmNhbGwodGhpcywgX2V4dGVuZHMoe30sIE1hc2tlZE51bWJlci5ERUZBVUxUUywgb3B0cykpKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gICAgLyoqIEZsYWcgdG8gcGFkIHRyYWlsaW5nIHplcm9zIGFmdGVyIHBvaW50IGluIHRoZSBlbmQgb2YgZWRpdGluZyAqL1xuXG4gICAgLyoqICovXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiBBcnJheSBvZiBzaW5nbGUgY2hhcnMgKi9cblxuXG4gICAgLyoqIFNpbmdsZSBjaGFyICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKE1hc2tlZE51bWJlciwgW3tcbiAgICAgIGtleTogJ191cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgICBnZXQoTWFza2VkTnVtYmVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCAnX3VwZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlZ0V4cHMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdXBkYXRlUmVnRXhwcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJlZ0V4cHMoKSB7XG4gICAgICAgIC8vIHVzZSBkaWZmZXJlbnQgcmVnZXhwIHRvIHByb2Nlc3MgdXNlciBpbnB1dCAobW9yZSBzdHJpY3QsIGlucHV0IHN1ZmZpeCkgYW5kIHRhaWwgc2hpZnRpbmdcbiAgICAgICAgdmFyIHN0YXJ0ID0gJ14nO1xuXG4gICAgICAgIHZhciBtaWRJbnB1dCA9ICcnO1xuICAgICAgICB2YXIgbWlkID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmFsbG93TmVnYXRpdmUpIHtcbiAgICAgICAgICBtaWRJbnB1dCArPSAnKFsrfFxcXFwtXT98KFsrfFxcXFwtXT8oMHwoWzEtOV0rXFxcXGQqKSkpKSc7XG4gICAgICAgICAgbWlkICs9ICdbK3xcXFxcLV0/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaWRJbnB1dCArPSAnKDB8KFsxLTldK1xcXFxkKikpJztcbiAgICAgICAgfVxuICAgICAgICBtaWQgKz0gJ1xcXFxkKic7XG5cbiAgICAgICAgdmFyIGVuZCA9ICh0aGlzLnNjYWxlID8gJygnICsgdGhpcy5yYWRpeCArICdcXFxcZHswLCcgKyB0aGlzLnNjYWxlICsgJ30pPycgOiAnJykgKyAnJCc7XG5cbiAgICAgICAgdGhpcy5fbnVtYmVyUmVnRXhwSW5wdXQgPSBuZXcgUmVnRXhwKHN0YXJ0ICsgbWlkSW5wdXQgKyBlbmQpO1xuICAgICAgICB0aGlzLl9udW1iZXJSZWdFeHAgPSBuZXcgUmVnRXhwKHN0YXJ0ICsgbWlkICsgZW5kKTtcbiAgICAgICAgdGhpcy5fbWFwVG9SYWRpeFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1snICsgdGhpcy5tYXBUb1JhZGl4Lm1hcChlc2NhcGVSZWdFeHApLmpvaW4oJycpICsgJ10nLCAnZycpO1xuICAgICAgICB0aGlzLl90aG91c2FuZHNTZXBhcmF0b3JSZWdFeHAgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh0aGlzLnRob3VzYW5kc1NlcGFyYXRvciksICdnJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V4dHJhY3RUYWlsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXh0cmFjdFRhaWwoKSB7XG4gICAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIHZhciB0YWlsID0gZ2V0KE1hc2tlZE51bWJlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgJ19leHRyYWN0VGFpbCcsIHRoaXMpLmNhbGwodGhpcywgZnJvbVBvcywgdG9Qb3MpO1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdGFpbCwge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHRhaWwudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKiogKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSh0aGlzLl90aG91c2FuZHNTZXBhcmF0b3JSZWdFeHAsICcnKTtcbiAgICAgIH1cblxuICAgICAgLyoqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydFRob3VzYW5kc1NlcGFyYXRvcnModmFsdWUpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkwMTEwMi9ob3ctdG8tcHJpbnQtYS1udW1iZXItd2l0aC1jb21tYXMtYXMtdGhvdXNhbmRzLXNlcGFyYXRvcnMtaW4tamF2YXNjcmlwdFxuICAgICAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdCh0aGlzLnJhZGl4KTtcbiAgICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCB0aGlzLnRob3VzYW5kc1NlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMucmFkaXgpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvUHJlcGFyZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9QcmVwYXJlKHN0cikge1xuICAgICAgICB2YXIgX2JhYmVsSGVscGVycyRnZXQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKF9iYWJlbEhlbHBlcnMkZ2V0ID0gZ2V0KE1hc2tlZE51bWJlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgJ2RvUHJlcGFyZScsIHRoaXMpKS5jYWxsLmFwcGx5KF9iYWJlbEhlbHBlcnMkZ2V0LCBbdGhpcywgdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyhzdHIucmVwbGFjZSh0aGlzLl9tYXBUb1JhZGl4UmVnRXhwLCB0aGlzLnJhZGl4KSldLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShhcmdzKSkpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FwcGVuZFdpdGhUYWlsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRXaXRoVGFpbCgpIHtcbiAgICAgICAgdmFyIF9iYWJlbEhlbHBlcnMkZ2V0MjtcblxuICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh0aGlzLnZhbHVlKTtcbiAgICAgICAgdmFyIHN0YXJ0Q2hhbmdlUG9zID0gdGhpcy52YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXBwZW5kRGV0YWlscyA9IChfYmFiZWxIZWxwZXJzJGdldDIgPSBnZXQoTWFza2VkTnVtYmVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCAnYXBwZW5kV2l0aFRhaWwnLCB0aGlzKSkuY2FsbC5hcHBseShfYmFiZWxIZWxwZXJzJGdldDIsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYXJncykpKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9pbnNlcnRUaG91c2FuZHNTZXBhcmF0b3JzKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXRzIGFmdGVyIGluc2VydCBzZXBhcmF0b3JzXG4gICAgICAgIHZhciBiZWZvcmVUYWlsUG9zID0gc3RhcnRDaGFuZ2VQb3MgKyBhcHBlbmREZXRhaWxzLmluc2VydGVkLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDw9IGJlZm9yZVRhaWxQb3M7ICsrcG9zKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVbcG9zXSA9PT0gdGhpcy50aG91c2FuZHNTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPCBzdGFydENoYW5nZVBvcyB8fFxuICAgICAgICAgICAgLy8gY2hlY2sgaGlnaCBib3VuZFxuICAgICAgICAgICAgLy8gaWYgc2VwYXJhdG9yIGlzIHN0aWxsIHRoZXJlIC0gY29uc2lkZXIgaXQgYWxzb1xuICAgICAgICAgICAgcG9zID09PSBzdGFydENoYW5nZVBvcyAmJiBwcmV2aW91c1ZhbHVlW3Bvc10gPT09IHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICsrc3RhcnRDaGFuZ2VQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgYmVmb3JlVGFpbFBvcykgKytiZWZvcmVUYWlsUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBkZXRhaWxzIHdpdGggc2VwYXJhdG9yc1xuICAgICAgICBhcHBlbmREZXRhaWxzLnJhd0luc2VydGVkID0gYXBwZW5kRGV0YWlscy5pbnNlcnRlZDtcbiAgICAgICAgYXBwZW5kRGV0YWlscy5pbnNlcnRlZCA9IHRoaXMudmFsdWUuc2xpY2Uoc3RhcnRDaGFuZ2VQb3MsIGJlZm9yZVRhaWxQb3MpO1xuICAgICAgICBhcHBlbmREZXRhaWxzLnNoaWZ0ICs9IHN0YXJ0Q2hhbmdlUG9zIC0gcHJldmlvdXNWYWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIGFwcGVuZERldGFpbHM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbmVhcmVzdElucHV0UG9zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZWFyZXN0SW5wdXRQb3MoY3Vyc29yUG9zLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24pIHJldHVybiBjdXJzb3JQb3M7XG5cbiAgICAgICAgdmFyIG5leHRQb3MgPSBpbmRleEluRGlyZWN0aW9uKGN1cnNvclBvcywgZGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbbmV4dFBvc10gPT09IHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yKSBjdXJzb3JQb3MgKz0gZGlyZWN0aW9uO1xuICAgICAgICByZXR1cm4gY3Vyc29yUG9zO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvVmFsaWRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlZ2V4cCA9IGZsYWdzLmlucHV0ID8gdGhpcy5fbnVtYmVyUmVnRXhwSW5wdXQgOiB0aGlzLl9udW1iZXJSZWdFeHA7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgYXMgc3RyaW5nXG4gICAgICAgIHZhciB2YWxpZCA9IHJlZ2V4cC50ZXN0KHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnModGhpcy52YWx1ZSkpO1xuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIC8vIHZhbGlkYXRlIGFzIG51bWJlclxuICAgICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm51bWJlcjtcbiAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICFpc05hTihudW1iZXIpICYmIChcbiAgICAgICAgICAvLyBjaGVjayBtaW4gYm91bmQgZm9yIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgIHRoaXMubWluID09IG51bGwgfHwgdGhpcy5taW4gPj0gMCB8fCB0aGlzLm1pbiA8PSB0aGlzLm51bWJlcikgJiYgKFxuICAgICAgICAgIC8vIGNoZWNrIG1heCBib3VuZCBmb3IgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgdGhpcy5tYXggPT0gbnVsbCB8fCB0aGlzLm1heCA8PSAwIHx8IHRoaXMubnVtYmVyIDw9IHRoaXMubWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWxpZCAmJiBnZXQoTWFza2VkTnVtYmVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCAnZG9WYWxpZGF0ZScsIHRoaXMpLmNhbGwodGhpcywgZmxhZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvQ29tbWl0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMubnVtYmVyO1xuICAgICAgICB2YXIgdmFsaWRudW0gPSBudW1iZXI7XG5cbiAgICAgICAgLy8gY2hlY2sgYm91bmRzXG4gICAgICAgIGlmICh0aGlzLm1pbiAhPSBudWxsKSB2YWxpZG51bSA9IE1hdGgubWF4KHZhbGlkbnVtLCB0aGlzLm1pbik7XG4gICAgICAgIGlmICh0aGlzLm1heCAhPSBudWxsKSB2YWxpZG51bSA9IE1hdGgubWluKHZhbGlkbnVtLCB0aGlzLm1heCk7XG5cbiAgICAgICAgaWYgKHZhbGlkbnVtICE9PSBudW1iZXIpIHRoaXMudW5tYXNrZWRWYWx1ZSA9IFN0cmluZyh2YWxpZG51bSk7XG5cbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IHRoaXMudmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplWmVyb3MpIGZvcm1hdHRlZCA9IHRoaXMuX25vcm1hbGl6ZVplcm9zKGZvcm1hdHRlZCk7XG4gICAgICAgIGlmICh0aGlzLnBhZEZyYWN0aW9uYWxaZXJvcykgZm9ybWF0dGVkID0gdGhpcy5fcGFkRnJhY3Rpb25hbFplcm9zKGZvcm1hdHRlZCk7XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9pbnNlcnRUaG91c2FuZHNTZXBhcmF0b3JzKGZvcm1hdHRlZCk7XG4gICAgICAgIGdldChNYXNrZWROdW1iZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksICdkb0NvbW1pdCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX25vcm1hbGl6ZVplcm9zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbm9ybWFsaXplWmVyb3ModmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh2YWx1ZSkuc3BsaXQodGhpcy5yYWRpeCk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKC9eKFxcRCopKDAqKShcXGQqKS8sIGZ1bmN0aW9uIChtYXRjaCwgc2lnbiwgemVyb3MsIG51bSkge1xuICAgICAgICAgIHJldHVybiBzaWduICsgbnVtO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIGxlYWRpbmcgemVyb1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICYmICEvXFxkJC8udGVzdChwYXJ0c1swXSkpIHBhcnRzWzBdID0gcGFydHNbMF0gKyAnMCc7XG5cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdLnJlcGxhY2UoLzAqJC8sICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgaWYgKCFwYXJ0c1sxXS5sZW5ndGgpIHBhcnRzLmxlbmd0aCA9IDE7IC8vIHJlbW92ZSBmcmFjdGlvbmFsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyhwYXJ0cy5qb2luKHRoaXMucmFkaXgpKTtcbiAgICAgIH1cblxuICAgICAgLyoqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGFkRnJhY3Rpb25hbFplcm9zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFkRnJhY3Rpb25hbFplcm9zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdCh0aGlzLnJhZGl4KTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHBhcnRzLnB1c2goJycpO1xuICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdLnBhZEVuZCh0aGlzLnNjYWxlLCAnMCcpO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbih0aGlzLnJhZGl4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1bm1hc2tlZFZhbHVlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh0aGlzLl9ub3JtYWxpemVaZXJvcyh0aGlzLnZhbHVlKSkucmVwbGFjZSh0aGlzLnJhZGl4LCAnLicpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHVubWFza2VkVmFsdWUpIHtcbiAgICAgICAgc2V0KE1hc2tlZE51bWJlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgJ3VubWFza2VkVmFsdWUnLCB1bm1hc2tlZFZhbHVlLnJlcGxhY2UoJy4nLCB0aGlzLnJhZGl4KSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBQYXJzZWQgTnVtYmVyICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdudW1iZXInLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy51bm1hc2tlZFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShudW1iZXIpIHtcbiAgICAgICAgdGhpcy51bm1hc2tlZFZhbHVlID0gU3RyaW5nKG51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndHlwZWRWYWx1ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubnVtYmVyID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIElzIG5lZ2F0aXZlIGFsbG93ZWRcclxuICAgICAgICBAcmVhZG9ubHlcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FsbG93TmVnYXRpdmUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lZCB8fCB0aGlzLm1pbiAhPSBudWxsICYmIHRoaXMubWluIDwgMCB8fCB0aGlzLm1heCAhPSBudWxsICYmIHRoaXMubWF4IDwgMDtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE1hc2tlZE51bWJlcjtcbiAgfShNYXNrZWQpO1xuXG4gIE1hc2tlZE51bWJlci5ERUZBVUxUUyA9IHtcbiAgICByYWRpeDogJywnLFxuICAgIHRob3VzYW5kc1NlcGFyYXRvcjogJycsXG4gICAgbWFwVG9SYWRpeDogWycuJ10sXG4gICAgc2NhbGU6IDIsXG4gICAgc2lnbmVkOiBmYWxzZSxcbiAgICBub3JtYWxpemVaZXJvczogdHJ1ZSxcbiAgICBwYWRGcmFjdGlvbmFsWmVyb3M6IGZhbHNlXG4gIH07XG5cbiAgLyoqIE1hc2tpbmcgYnkgUmVnRXhwICovXG5cbiAgdmFyIE1hc2tlZFJlZ0V4cCA9IGZ1bmN0aW9uIChfTWFza2VkKSB7XG4gICAgaW5oZXJpdHMoTWFza2VkUmVnRXhwLCBfTWFza2VkKTtcblxuICAgIGZ1bmN0aW9uIE1hc2tlZFJlZ0V4cCgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFJlZ0V4cCk7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTWFza2VkUmVnRXhwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkUmVnRXhwKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoTWFza2VkUmVnRXhwLCBbe1xuICAgICAga2V5OiAnX3VwZGF0ZScsXG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShvcHRzKSB7XG4gICAgICAgIG9wdHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuc2VhcmNoKG9wdHMubWFzaykgPj0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgZ2V0KE1hc2tlZFJlZ0V4cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWRSZWdFeHAucHJvdG90eXBlKSwgJ191cGRhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTWFza2VkUmVnRXhwO1xuICB9KE1hc2tlZCk7XG5cbiAgLyoqIE1hc2tpbmcgYnkgY3VzdG9tIEZ1bmN0aW9uICovXG5cbiAgdmFyIE1hc2tlZEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9NYXNrZWQpIHtcbiAgICBpbmhlcml0cyhNYXNrZWRGdW5jdGlvbiwgX01hc2tlZCk7XG5cbiAgICBmdW5jdGlvbiBNYXNrZWRGdW5jdGlvbigpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZEZ1bmN0aW9uKTtcbiAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChNYXNrZWRGdW5jdGlvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZEZ1bmN0aW9uKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoTWFza2VkRnVuY3Rpb24sIFt7XG4gICAgICBrZXk6ICdfdXBkYXRlJyxcblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgICAgb3B0cy52YWxpZGF0ZSA9IG9wdHMubWFzaztcbiAgICAgICAgZ2V0KE1hc2tlZEZ1bmN0aW9uLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZEZ1bmN0aW9uLnByb3RvdHlwZSksICdfdXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE1hc2tlZEZ1bmN0aW9uO1xuICB9KE1hc2tlZCk7XG5cbiAgLyoqIER5bmFtaWMgbWFzayBmb3IgY2hvb3NpbmcgYXByb3ByaWF0ZSBtYXNrIGluIHJ1bi10aW1lICovXG4gIHZhciBNYXNrZWREeW5hbWljID0gZnVuY3Rpb24gKF9NYXNrZWQpIHtcbiAgICBpbmhlcml0cyhNYXNrZWREeW5hbWljLCBfTWFza2VkKTtcblxuICAgIC8qKlxyXG4gICAgICBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgKi9cblxuICAgIC8qKiBDb21wbGlsZWQge0BsaW5rIE1hc2tlZH0gb3B0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIE1hc2tlZER5bmFtaWMob3B0cykge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza2VkRHluYW1pYyk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE1hc2tlZER5bmFtaWMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljKSkuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgTWFza2VkRHluYW1pYy5ERUZBVUxUUywgb3B0cykpKTtcblxuICAgICAgX3RoaXMuY3VycmVudE1hc2sgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgICAvKiogQ2hvb3NlcyB7QGxpbmsgTWFza2VkfSBkZXBlbmRpbmcgb24gaW5wdXQgdmFsdWUgKi9cblxuICAgIC8qKiBDdXJyZW50bHkgY2hvc2VuIG1hc2sgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoTWFza2VkRHluYW1pYywgW3tcbiAgICAgIGtleTogJ191cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgICBnZXQoTWFza2VkRHluYW1pYy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksICdfdXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgLy8gbWFzayBjb3VsZCBiZSB0b3RhbGx5IGR5bmFtaWMgd2l0aCBvbmx5IGBkaXNwYXRjaGAgb3B0aW9uXG4gICAgICAgIHRoaXMuY29tcGlsZWRNYXNrcyA9IEFycmF5LmlzQXJyYXkob3B0cy5tYXNrKSA/IG9wdHMubWFzay5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTWFzayhtKTtcbiAgICAgICAgfSkgOiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYXBwZW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kKHN0cikge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciA9IHRoaXMuZG9QcmVwYXJlLmFwcGx5KHRoaXMsIFtzdHJdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShhcmdzKSkpO1xuXG4gICAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5fYXBwbHlEaXNwYXRjaC5hcHBseSh0aGlzLCBbc3RyXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYXJncykpKTtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICAgIHZhciBfY3VycmVudE1hc2s7XG5cbiAgICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZSgoX2N1cnJlbnRNYXNrID0gdGhpcy5jdXJyZW50TWFzaykuX2FwcGVuZC5hcHBseShfY3VycmVudE1hc2ssIFtzdHJdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShhcmdzKSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hcHBseURpc3BhdGNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwbHlEaXNwYXRjaCgpIHtcbiAgICAgICAgdmFyIGFwcGVuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcblxuICAgICAgICB2YXIgb2xkVmFsdWVMZW5ndGggPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLnJhd0lucHV0VmFsdWU7XG4gICAgICAgIHZhciBvbGRNYXNrID0gdGhpcy5jdXJyZW50TWFzaztcbiAgICAgICAgdmFyIGRldGFpbHMgPSBuZXcgQ2hhbmdlRGV0YWlscygpO1xuXG4gICAgICAgIC8vIGRpc3BhdGNoIFNIT1VMRCBOT1QgbW9kaWZ5IG1hc2tcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudE1hc2sgPSB0aGlzLmRvRGlzcGF0Y2guYXBwbHkodGhpcywgW2FwcGVuZGVkXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYXJncykpKTtcblxuICAgICAgICAvLyByZXN0b3JlIHN0YXRlIGFmdGVyIGRpc3BhdGNoXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNYXNrICYmIHRoaXMuY3VycmVudE1hc2sgIT09IG9sZE1hc2spIHtcbiAgICAgICAgICAvLyBpZiBtYXNrIGNoYW5nZWQgcmVhcHBseSBpbnB1dFxuICAgICAgICAgIHRoaXMuY3VycmVudE1hc2sucmVzZXQoKTtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gaXQncyBvaywgd2UgZG9uJ3QgY2hhbmdlIGN1cnJlbnQgbWFza1xuICAgICAgICAgIHRoaXMuY3VycmVudE1hc2suX2FwcGVuZChpbnB1dFZhbHVlLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICBkZXRhaWxzLnNoaWZ0ID0gdGhpcy52YWx1ZS5sZW5ndGggLSBvbGRWYWx1ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvRGlzcGF0Y2gnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvRGlzcGF0Y2goYXBwZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChhcHBlbmRlZCwgdGhpcywgZmxhZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Nsb25lJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWFza2VkRHluYW1pYyh0aGlzKTtcbiAgICAgICAgbS5fdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgICAgIC8vIHRyeSB0byBrZWVwIHJlZmVyZW5jZSB0byBjb21waWxlZCBtYXNrc1xuICAgICAgICB2YXIgY3VycmVudE1hc2tJbmRleCA9IHRoaXMuY29tcGlsZWRNYXNrcy5pbmRleE9mKHRoaXMuY3VycmVudE1hc2spO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICAgIG0uY3VycmVudE1hc2sgPSBjdXJyZW50TWFza0luZGV4ID49IDAgPyBtLmNvbXBpbGVkTWFza3NbY3VycmVudE1hc2tJbmRleF0uYXNzaWduKHRoaXMuY3VycmVudE1hc2spIDogdGhpcy5jdXJyZW50TWFzay5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykgdGhpcy5jdXJyZW50TWFzay5yZXNldCgpO1xuICAgICAgICB0aGlzLmNvbXBpbGVkTWFza3MuZm9yRWFjaChmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICByZXR1cm4gY20ucmVzZXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlJyxcblxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRNYXNrMjtcblxuICAgICAgICAgIGRldGFpbHMuYWdncmVnYXRlKChfY3VycmVudE1hc2syID0gdGhpcy5jdXJyZW50TWFzaykucmVtb3ZlLmFwcGx5KF9jdXJyZW50TWFzazIsIGFyZ3VtZW50cykpXG4gICAgICAgICAgLy8gdXBkYXRlIHdpdGggZGlzcGF0Y2hcbiAgICAgICAgICAuYWdncmVnYXRlKHRoaXMuX2FwcGx5RGlzcGF0Y2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGV0YWlscztcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdleHRyYWN0SW5wdXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RJbnB1dCgpIHtcbiAgICAgICAgdmFyIF9jdXJyZW50TWFzazM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyAoX2N1cnJlbnRNYXNrMyA9IHRoaXMuY3VycmVudE1hc2spLmV4dHJhY3RJbnB1dC5hcHBseShfY3VycmVudE1hc2szLCBhcmd1bWVudHMpIDogJyc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V4dHJhY3RUYWlsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXh0cmFjdFRhaWwoKSB7XG4gICAgICAgIHZhciBfY3VycmVudE1hc2s0LCBfYmFiZWxIZWxwZXJzJGdldDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNYXNrID8gKF9jdXJyZW50TWFzazQgPSB0aGlzLmN1cnJlbnRNYXNrKS5fZXh0cmFjdFRhaWwuYXBwbHkoX2N1cnJlbnRNYXNrNCwgdG9Db25zdW1hYmxlQXJyYXkoYXJncykpIDogKF9iYWJlbEhlbHBlcnMkZ2V0ID0gZ2V0KE1hc2tlZER5bmFtaWMucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCAnX2V4dHJhY3RUYWlsJywgdGhpcykpLmNhbGwuYXBwbHkoX2JhYmVsSGVscGVycyRnZXQsIFt0aGlzXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYXJncykpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAgQG92ZXJyaWRlXHJcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYXBwZW5kVGFpbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZFRhaWwodGFpbCkge1xuICAgICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICAgIGlmICh0YWlsKSBkZXRhaWxzLmFnZ3JlZ2F0ZSh0aGlzLl9hcHBseURpc3BhdGNoKHRhaWwudmFsdWUpKTtcblxuICAgICAgICByZXR1cm4gZGV0YWlscy5hZ2dyZWdhdGUodGhpcy5jdXJyZW50TWFzayA/IHRoaXMuY3VycmVudE1hc2suX2FwcGVuZFRhaWwodGFpbCkgOiBnZXQoTWFza2VkRHluYW1pYy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksICdfYXBwZW5kVGFpbCcsIHRoaXMpLmNhbGwodGhpcywgdGFpbCkpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RvQ29tbWl0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHRoaXMuY3VycmVudE1hc2suZG9Db21taXQoKTtcbiAgICAgICAgZ2V0KE1hc2tlZER5bmFtaWMucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCAnZG9Db21taXQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ25lYXJlc3RJbnB1dFBvcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKCkge1xuICAgICAgICB2YXIgX2N1cnJlbnRNYXNrNSwgX2JhYmVsSGVscGVycyRnZXQyO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyAoX2N1cnJlbnRNYXNrNSA9IHRoaXMuY3VycmVudE1hc2spLm5lYXJlc3RJbnB1dFBvcy5hcHBseShfY3VycmVudE1hc2s1LCB0b0NvbnN1bWFibGVBcnJheShhcmdzKSkgOiAoX2JhYmVsSGVscGVycyRnZXQyID0gZ2V0KE1hc2tlZER5bmFtaWMucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCAnbmVhcmVzdElucHV0UG9zJywgdGhpcykpLmNhbGwuYXBwbHkoX2JhYmVsSGVscGVycyRnZXQyLCBbdGhpc10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndmFsdWUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNYXNrID8gdGhpcy5jdXJyZW50TWFzay52YWx1ZSA6ICcnO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHZhbHVlKSB7XG4gICAgICAgIHNldChNYXNrZWREeW5hbWljLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgJ3ZhbHVlJywgdmFsdWUsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3VubWFza2VkVmFsdWUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNYXNrID8gdGhpcy5jdXJyZW50TWFzay51bm1hc2tlZFZhbHVlIDogJyc7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodW5tYXNrZWRWYWx1ZSkge1xuICAgICAgICBzZXQoTWFza2VkRHluYW1pYy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksICd1bm1hc2tlZFZhbHVlJywgdW5tYXNrZWRWYWx1ZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgIEBvdmVycmlkZVxyXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndHlwZWRWYWx1ZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLnR5cGVkVmFsdWUgOiAnJztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2YWx1ZSkge1xuICAgICAgICB2YXIgdW5tYXNrZWRWYWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNYXNrKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TWFzay50eXBlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdW5tYXNrZWRWYWx1ZSA9IHRoaXMuY3VycmVudE1hc2sudW5tYXNrZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVubWFza2VkVmFsdWUgPSB1bm1hc2tlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICBAb3ZlcnJpZGVcclxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzQ29tcGxldGUnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY3VycmVudE1hc2sgJiYgdGhpcy5jdXJyZW50TWFzay5pc0NvbXBsZXRlO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTWFza2VkRHluYW1pYztcbiAgfShNYXNrZWQpO1xuXG5cbiAgTWFza2VkRHluYW1pYy5ERUZBVUxUUyA9IHtcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYXBwZW5kZWQsIG1hc2tlZCwgZmxhZ3MpIHtcbiAgICAgIGlmICghbWFza2VkLmNvbXBpbGVkTWFza3MubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgIHZhciBpbnB1dFZhbHVlID0gbWFza2VkLnJhd0lucHV0VmFsdWU7XG5cbiAgICAgIC8vIHNpbXVsYXRlIGlucHV0XG4gICAgICB2YXIgaW5wdXRzID0gbWFza2VkLmNvbXBpbGVkTWFza3MubWFwKGZ1bmN0aW9uIChjbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG0gPSBjbS5jbG9uZSgpO1xuICAgICAgICBtLnJhd0lucHV0VmFsdWUgPSBpbnB1dFZhbHVlO1xuICAgICAgICBtLl9hcHBlbmQoYXBwZW5kZWQsIGZsYWdzKTtcblxuICAgICAgICByZXR1cm4geyB2YWx1ZTogbS5yYXdJbnB1dFZhbHVlLmxlbmd0aCwgaW5kZXg6IGluZGV4IH07XG4gICAgICB9KTtcblxuICAgICAgLy8gcG9wIG1hc2tzIHdpdGggbG9uZ2VyIHZhbHVlcyBmaXJzdFxuICAgICAgaW5wdXRzLnNvcnQoZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICByZXR1cm4gaTIudmFsdWUgLSBpMS52YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFza2VkLmNvbXBpbGVkTWFza3NbaW5wdXRzWzBdLmluZGV4XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXHJcbiAgICogQXBwbGllcyBtYXNrIG9uIGVsZW1lbnQuXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR8TWFza0VsZW1lbnR9IGVsIC0gRWxlbWVudCB0byBhcHBseSBtYXNrXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBDdXN0b20gbWFzayBvcHRpb25zXHJcbiAgICogQHJldHVybiB7SW5wdXRNYXNrfVxyXG4gICAqL1xuICBmdW5jdGlvbiBJTWFzayhlbCkge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIC8vIGN1cnJlbnRseSBhdmFpbGFibGUgb25seSBmb3IgaW5wdXQtbGlrZSBlbGVtZW50c1xuICAgIHJldHVybiBuZXcgSW5wdXRNYXNrKGVsLCBvcHRzKTtcbiAgfVxuXG4gIC8qKiB7QGxpbmsgSW5wdXRNYXNrfSAqL1xuICBJTWFzay5JbnB1dE1hc2sgPSBJbnB1dE1hc2s7XG5cbiAgLyoqIHtAbGluayBNYXNrZWR9ICovXG4gIElNYXNrLk1hc2tlZCA9IE1hc2tlZDtcbiAgLyoqIHtAbGluayBNYXNrZWRQYXR0ZXJufSAqL1xuICBJTWFzay5NYXNrZWRQYXR0ZXJuID0gTWFza2VkUGF0dGVybjtcbiAgLyoqIHtAbGluayBNYXNrZWROdW1iZXJ9ICovXG4gIElNYXNrLk1hc2tlZE51bWJlciA9IE1hc2tlZE51bWJlcjtcbiAgLyoqIHtAbGluayBNYXNrZWREYXRlfSAqL1xuICBJTWFzay5NYXNrZWREYXRlID0gTWFza2VkRGF0ZTtcbiAgLyoqIHtAbGluayBNYXNrZWRSZWdFeHB9ICovXG4gIElNYXNrLk1hc2tlZFJlZ0V4cCA9IE1hc2tlZFJlZ0V4cDtcbiAgLyoqIHtAbGluayBNYXNrZWRGdW5jdGlvbn0gKi9cbiAgSU1hc2suTWFza2VkRnVuY3Rpb24gPSBNYXNrZWRGdW5jdGlvbjtcbiAgLyoqIHtAbGluayBNYXNrZWREeW5hbWljfSAqL1xuICBJTWFzay5NYXNrZWREeW5hbWljID0gTWFza2VkRHluYW1pYztcbiAgLyoqIHtAbGluayBjcmVhdGVNYXNrfSAqL1xuICBJTWFzay5jcmVhdGVNYXNrID0gY3JlYXRlTWFzaztcbiAgLyoqIHtAbGluayBNYXNrRWxlbWVudH0gKi9cbiAgSU1hc2suTWFza0VsZW1lbnQgPSBNYXNrRWxlbWVudDtcbiAgLyoqIHtAbGluayBIVE1MTWFza0VsZW1lbnR9ICovXG4gIElNYXNrLkhUTUxNYXNrRWxlbWVudCA9IEhUTUxNYXNrRWxlbWVudDtcblxuICBnLklNYXNrID0gSU1hc2s7XG5cbiAgcmV0dXJuIElNYXNrO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hc2suanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/imask/dist/imask.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hOTdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ "jquery":
/*!********************!*\
  !*** external "$" ***!
  \********************/
/***/ ((module) => {

"use strict";
module.exports = $;

/***/ }),

/***/ "./node_modules/datatables.net/js/jquery.dataTables.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"jquery\");\n/*! DataTables 1.13.4\n * ©2008-2023 SpryMedia Ltd - datatables.net/license\n */\n\n\n\n// DataTables code uses $ internally, but we want to be able to\n// reassign $ with the `use` method, so it is a regular var.\nlet $ = jquery__WEBPACK_IMPORTED_MODULE_0__;\n\n\nvar DataTable = function ( selector, options )\n{\n\t// Check if called with a window or jQuery object for DOM less applications\n\t// This is for backwards compatibility\n\tif (DataTable.factory(selector, options)) {\n\t\treturn DataTable;\n\t}\n\n\t// When creating with `new`, create a new DataTable, returning the API instance\n\tif (this instanceof DataTable) {\n\t\treturn $(selector).DataTable(options);\n\t}\n\telse {\n\t\t// Argument switching\n\t\toptions = selector;\n\t}\n\n\t/**\n\t * Perform a jQuery selector action on the table's TR elements (from the tbody) and\n\t * return the resulting jQuery object.\n\t *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n\t *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n\t *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\n\t *    criterion (\"applied\") or all TR elements (i.e. no filter).\n\t *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\n\t *    Can be either 'current', whereby the current sorting of the table is used, or\n\t *    'original' whereby the original order the data was read into the table is used.\n\t *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n\t *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n\t *    'current' and filter is 'applied', regardless of what they might be given as.\n\t *  @returns {object} jQuery object, filtered by the given selector.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Highlight every second row\n\t *      oTable.$('tr:odd').css('backgroundColor', 'blue');\n\t *    } );\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Filter to rows with 'Webkit' in them, add a background colour and then\n\t *      // remove the filter, thus highlighting the 'Webkit' rows only.\n\t *      oTable.fnFilter('Webkit');\n\t *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\n\t *      oTable.fnFilter('');\n\t *    } );\n\t */\n\tthis.$ = function ( sSelector, oOpts )\n\t{\n\t\treturn this.api(true).$( sSelector, oOpts );\n\t};\n\t\n\t\n\t/**\n\t * Almost identical to $ in operation, but in this case returns the data for the matched\n\t * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\n\t * rather than any descendants, so the data can be obtained for the row/cell. If matching\n\t * rows are found, the data returned is the original data array/object that was used to\n\t * create the row (or a generated array if from a DOM source).\n\t *\n\t * This method is often useful in-combination with $ where both functions are given the\n\t * same parameters and the array indexes will match identically.\n\t *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n\t *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n\t *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\n\t *    criterion (\"applied\") or all elements (i.e. no filter).\n\t *  @param {string} [oOpts.order=current] Order of the data in the processed array.\n\t *    Can be either 'current', whereby the current sorting of the table is used, or\n\t *    'original' whereby the original order the data was read into the table is used.\n\t *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n\t *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n\t *    'current' and filter is 'applied', regardless of what they might be given as.\n\t *  @returns {array} Data for the matched elements. If any elements, as a result of the\n\t *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\n\t *    entry in the array.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Get the data from the first row in the table\n\t *      var data = oTable._('tr:first');\n\t *\n\t *      // Do something useful with the data\n\t *      alert( \"First cell is: \"+data[0] );\n\t *    } );\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Filter to 'Webkit' and get all data for\n\t *      oTable.fnFilter('Webkit');\n\t *      var data = oTable._('tr', {\"search\": \"applied\"});\n\t *\n\t *      // Do something with the data\n\t *      alert( data.length+\" rows matched the search\" );\n\t *    } );\n\t */\n\tthis._ = function ( sSelector, oOpts )\n\t{\n\t\treturn this.api(true).rows( sSelector, oOpts ).data();\n\t};\n\t\n\t\n\t/**\n\t * Create a DataTables Api instance, with the currently selected tables for\n\t * the Api's context.\n\t * @param {boolean} [traditional=false] Set the API instance's context to be\n\t *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\n\t *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\n\t *   or if all tables captured in the jQuery object should be used.\n\t * @return {DataTables.Api}\n\t */\n\tthis.api = function ( traditional )\n\t{\n\t\treturn traditional ?\n\t\t\tnew _Api(\n\t\t\t\t_fnSettingsFromNode( this[ _ext.iApiIndex ] )\n\t\t\t) :\n\t\t\tnew _Api( this );\n\t};\n\t\n\t\n\t/**\n\t * Add a single new row or multiple rows of data to the table. Please note\n\t * that this is suitable for client-side processing only - if you are using\n\t * server-side processing (i.e. \"bServerSide\": true), then to add data, you\n\t * must add it to the data source, i.e. the server-side, through an Ajax call.\n\t *  @param {array|object} data The data to be added to the table. This can be:\n\t *    <ul>\n\t *      <li>1D array of data - add a single row with the data provided</li>\n\t *      <li>2D array of arrays - add multiple rows in a single call</li>\n\t *      <li>object - data object when using <i>mData</i></li>\n\t *      <li>array of objects - multiple data objects when using <i>mData</i></li>\n\t *    </ul>\n\t *  @param {bool} [redraw=true] redraw the table or not\n\t *  @returns {array} An array of integers, representing the list of indexes in\n\t *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\n\t *    the table.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    // Global var for counter\n\t *    var giCount = 2;\n\t *\n\t *    $(document).ready(function() {\n\t *      $('#example').dataTable();\n\t *    } );\n\t *\n\t *    function fnClickAddRow() {\n\t *      $('#example').dataTable().fnAddData( [\n\t *        giCount+\".1\",\n\t *        giCount+\".2\",\n\t *        giCount+\".3\",\n\t *        giCount+\".4\" ]\n\t *      );\n\t *\n\t *      giCount++;\n\t *    }\n\t */\n\tthis.fnAddData = function( data, redraw )\n\t{\n\t\tvar api = this.api( true );\n\t\n\t\t/* Check if we want to add multiple rows or not */\n\t\tvar rows = Array.isArray(data) && ( Array.isArray(data[0]) || $.isPlainObject(data[0]) ) ?\n\t\t\tapi.rows.add( data ) :\n\t\t\tapi.row.add( data );\n\t\n\t\tif ( redraw === undefined || redraw ) {\n\t\t\tapi.draw();\n\t\t}\n\t\n\t\treturn rows.flatten().toArray();\n\t};\n\t\n\t\n\t/**\n\t * This function will make DataTables recalculate the column sizes, based on the data\n\t * contained in the table and the sizes applied to the columns (in the DOM, CSS or\n\t * through the sWidth parameter). This can be useful when the width of the table's\n\t * parent element changes (for example a window resize).\n\t *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable( {\n\t *        \"sScrollY\": \"200px\",\n\t *        \"bPaginate\": false\n\t *      } );\n\t *\n\t *      $(window).on('resize', function () {\n\t *        oTable.fnAdjustColumnSizing();\n\t *      } );\n\t *    } );\n\t */\n\tthis.fnAdjustColumnSizing = function ( bRedraw )\n\t{\n\t\tvar api = this.api( true ).columns.adjust();\n\t\tvar settings = api.settings()[0];\n\t\tvar scroll = settings.oScroll;\n\t\n\t\tif ( bRedraw === undefined || bRedraw ) {\n\t\t\tapi.draw( false );\n\t\t}\n\t\telse if ( scroll.sX !== \"\" || scroll.sY !== \"\" ) {\n\t\t\t/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\n\t\t\t_fnScrollDraw( settings );\n\t\t}\n\t};\n\t\n\t\n\t/**\n\t * Quickly and simply clear a table\n\t *  @param {bool} [bRedraw=true] redraw the table or not\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\n\t *      oTable.fnClearTable();\n\t *    } );\n\t */\n\tthis.fnClearTable = function( bRedraw )\n\t{\n\t\tvar api = this.api( true ).clear();\n\t\n\t\tif ( bRedraw === undefined || bRedraw ) {\n\t\t\tapi.draw();\n\t\t}\n\t};\n\t\n\t\n\t/**\n\t * The exact opposite of 'opening' a row, this function will close any rows which\n\t * are currently 'open'.\n\t *  @param {node} nTr the table row to 'close'\n\t *  @returns {int} 0 on success, or 1 if failed (can't find the row)\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable;\n\t *\n\t *      // 'open' an information row when a row is clicked on\n\t *      $('#example tbody tr').click( function () {\n\t *        if ( oTable.fnIsOpen(this) ) {\n\t *          oTable.fnClose( this );\n\t *        } else {\n\t *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n\t *        }\n\t *      } );\n\t *\n\t *      oTable = $('#example').dataTable();\n\t *    } );\n\t */\n\tthis.fnClose = function( nTr )\n\t{\n\t\tthis.api( true ).row( nTr ).child.hide();\n\t};\n\t\n\t\n\t/**\n\t * Remove a row for the table\n\t *  @param {mixed} target The index of the row from aoData to be deleted, or\n\t *    the TR element you want to delete\n\t *  @param {function|null} [callBack] Callback function\n\t *  @param {bool} [redraw=true] Redraw the table or not\n\t *  @returns {array} The row that was deleted\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Immediately remove the first row\n\t *      oTable.fnDeleteRow( 0 );\n\t *    } );\n\t */\n\tthis.fnDeleteRow = function( target, callback, redraw )\n\t{\n\t\tvar api = this.api( true );\n\t\tvar rows = api.rows( target );\n\t\tvar settings = rows.settings()[0];\n\t\tvar data = settings.aoData[ rows[0][0] ];\n\t\n\t\trows.remove();\n\t\n\t\tif ( callback ) {\n\t\t\tcallback.call( this, settings, data );\n\t\t}\n\t\n\t\tif ( redraw === undefined || redraw ) {\n\t\t\tapi.draw();\n\t\t}\n\t\n\t\treturn data;\n\t};\n\t\n\t\n\t/**\n\t * Restore the table to it's original state in the DOM by removing all of DataTables\n\t * enhancements, alterations to the DOM structure of the table and event listeners.\n\t *  @param {boolean} [remove=false] Completely remove the table from the DOM\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\n\t *      var oTable = $('#example').dataTable();\n\t *      oTable.fnDestroy();\n\t *    } );\n\t */\n\tthis.fnDestroy = function ( remove )\n\t{\n\t\tthis.api( true ).destroy( remove );\n\t};\n\t\n\t\n\t/**\n\t * Redraw the table\n\t *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\n\t *      oTable.fnDraw();\n\t *    } );\n\t */\n\tthis.fnDraw = function( complete )\n\t{\n\t\t// Note that this isn't an exact match to the old call to _fnDraw - it takes\n\t\t// into account the new data, but can hold position.\n\t\tthis.api( true ).draw( complete );\n\t};\n\t\n\t\n\t/**\n\t * Filter the input based on data\n\t *  @param {string} sInput String to filter the table on\n\t *  @param {int|null} [iColumn] Column to limit filtering to\n\t *  @param {bool} [bRegex=false] Treat as regular expression or not\n\t *  @param {bool} [bSmart=true] Perform smart filtering or not\n\t *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\n\t *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Sometime later - filter...\n\t *      oTable.fnFilter( 'test string' );\n\t *    } );\n\t */\n\tthis.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )\n\t{\n\t\tvar api = this.api( true );\n\t\n\t\tif ( iColumn === null || iColumn === undefined ) {\n\t\t\tapi.search( sInput, bRegex, bSmart, bCaseInsensitive );\n\t\t}\n\t\telse {\n\t\t\tapi.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );\n\t\t}\n\t\n\t\tapi.draw();\n\t};\n\t\n\t\n\t/**\n\t * Get the data for the whole table, an individual row or an individual cell based on the\n\t * provided parameters.\n\t *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\n\t *    a TR node then the data source for the whole row will be returned. If given as a\n\t *    TD/TH cell node then iCol will be automatically calculated and the data for the\n\t *    cell returned. If given as an integer, then this is treated as the aoData internal\n\t *    data index for the row (see fnGetPosition) and the data for that row used.\n\t *  @param {int} [col] Optional column index that you want the data of.\n\t *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\n\t *    returned. If mRow is defined, just data for that row, and is iCol is\n\t *    defined, only data for the designated cell is returned.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    // Row data\n\t *    $(document).ready(function() {\n\t *      oTable = $('#example').dataTable();\n\t *\n\t *      oTable.$('tr').click( function () {\n\t *        var data = oTable.fnGetData( this );\n\t *        // ... do something with the array / object of data for the row\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Individual cell data\n\t *    $(document).ready(function() {\n\t *      oTable = $('#example').dataTable();\n\t *\n\t *      oTable.$('td').click( function () {\n\t *        var sData = oTable.fnGetData( this );\n\t *        alert( 'The cell clicked on had the value of '+sData );\n\t *      } );\n\t *    } );\n\t */\n\tthis.fnGetData = function( src, col )\n\t{\n\t\tvar api = this.api( true );\n\t\n\t\tif ( src !== undefined ) {\n\t\t\tvar type = src.nodeName ? src.nodeName.toLowerCase() : '';\n\t\n\t\t\treturn col !== undefined || type == 'td' || type == 'th' ?\n\t\t\t\tapi.cell( src, col ).data() :\n\t\t\t\tapi.row( src ).data() || null;\n\t\t}\n\t\n\t\treturn api.data().toArray();\n\t};\n\t\n\t\n\t/**\n\t * Get an array of the TR nodes that are used in the table's body. Note that you will\n\t * typically want to use the '$' API method in preference to this as it is more\n\t * flexible.\n\t *  @param {int} [iRow] Optional row index for the TR element you want\n\t *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\n\t *    in the table's body, or iRow is defined, just the TR element requested.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Get the nodes from the table\n\t *      var nNodes = oTable.fnGetNodes( );\n\t *    } );\n\t */\n\tthis.fnGetNodes = function( iRow )\n\t{\n\t\tvar api = this.api( true );\n\t\n\t\treturn iRow !== undefined ?\n\t\t\tapi.row( iRow ).node() :\n\t\t\tapi.rows().nodes().flatten().toArray();\n\t};\n\t\n\t\n\t/**\n\t * Get the array indexes of a particular cell from it's DOM element\n\t * and column index including hidden columns\n\t *  @param {node} node this can either be a TR, TD or TH in the table's body\n\t *  @returns {int} If nNode is given as a TR, then a single index is returned, or\n\t *    if given as a cell, an array of [row index, column index (visible),\n\t *    column index (all)] is given.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      $('#example tbody td').click( function () {\n\t *        // Get the position of the current data from the node\n\t *        var aPos = oTable.fnGetPosition( this );\n\t *\n\t *        // Get the data array for this row\n\t *        var aData = oTable.fnGetData( aPos[0] );\n\t *\n\t *        // Update the data array and return the value\n\t *        aData[ aPos[1] ] = 'clicked';\n\t *        this.innerHTML = 'clicked';\n\t *      } );\n\t *\n\t *      // Init DataTables\n\t *      oTable = $('#example').dataTable();\n\t *    } );\n\t */\n\tthis.fnGetPosition = function( node )\n\t{\n\t\tvar api = this.api( true );\n\t\tvar nodeName = node.nodeName.toUpperCase();\n\t\n\t\tif ( nodeName == 'TR' ) {\n\t\t\treturn api.row( node ).index();\n\t\t}\n\t\telse if ( nodeName == 'TD' || nodeName == 'TH' ) {\n\t\t\tvar cell = api.cell( node ).index();\n\t\n\t\t\treturn [\n\t\t\t\tcell.row,\n\t\t\t\tcell.columnVisible,\n\t\t\t\tcell.column\n\t\t\t];\n\t\t}\n\t\treturn null;\n\t};\n\t\n\t\n\t/**\n\t * Check to see if a row is 'open' or not.\n\t *  @param {node} nTr the table row to check\n\t *  @returns {boolean} true if the row is currently open, false otherwise\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable;\n\t *\n\t *      // 'open' an information row when a row is clicked on\n\t *      $('#example tbody tr').click( function () {\n\t *        if ( oTable.fnIsOpen(this) ) {\n\t *          oTable.fnClose( this );\n\t *        } else {\n\t *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n\t *        }\n\t *      } );\n\t *\n\t *      oTable = $('#example').dataTable();\n\t *    } );\n\t */\n\tthis.fnIsOpen = function( nTr )\n\t{\n\t\treturn this.api( true ).row( nTr ).child.isShown();\n\t};\n\t\n\t\n\t/**\n\t * This function will place a new row directly after a row which is currently\n\t * on display on the page, with the HTML contents that is passed into the\n\t * function. This can be used, for example, to ask for confirmation that a\n\t * particular record should be deleted.\n\t *  @param {node} nTr The table row to 'open'\n\t *  @param {string|node|jQuery} mHtml The HTML to put into the row\n\t *  @param {string} sClass Class to give the new TD cell\n\t *  @returns {node} The row opened. Note that if the table row passed in as the\n\t *    first parameter, is not found in the table, this method will silently\n\t *    return.\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable;\n\t *\n\t *      // 'open' an information row when a row is clicked on\n\t *      $('#example tbody tr').click( function () {\n\t *        if ( oTable.fnIsOpen(this) ) {\n\t *          oTable.fnClose( this );\n\t *        } else {\n\t *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n\t *        }\n\t *      } );\n\t *\n\t *      oTable = $('#example').dataTable();\n\t *    } );\n\t */\n\tthis.fnOpen = function( nTr, mHtml, sClass )\n\t{\n\t\treturn this.api( true )\n\t\t\t.row( nTr )\n\t\t\t.child( mHtml, sClass )\n\t\t\t.show()\n\t\t\t.child()[0];\n\t};\n\t\n\t\n\t/**\n\t * Change the pagination - provides the internal logic for pagination in a simple API\n\t * function. With this function you can have a DataTables table go to the next,\n\t * previous, first or last pages.\n\t *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\n\t *    or page number to jump to (integer), note that page 0 is the first page.\n\t *  @param {bool} [bRedraw=true] Redraw the table or not\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *      oTable.fnPageChange( 'next' );\n\t *    } );\n\t */\n\tthis.fnPageChange = function ( mAction, bRedraw )\n\t{\n\t\tvar api = this.api( true ).page( mAction );\n\t\n\t\tif ( bRedraw === undefined || bRedraw ) {\n\t\t\tapi.draw(false);\n\t\t}\n\t};\n\t\n\t\n\t/**\n\t * Show a particular column\n\t *  @param {int} iCol The column whose display should be changed\n\t *  @param {bool} bShow Show (true) or hide (false) the column\n\t *  @param {bool} [bRedraw=true] Redraw the table or not\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Hide the second column after initialisation\n\t *      oTable.fnSetColumnVis( 1, false );\n\t *    } );\n\t */\n\tthis.fnSetColumnVis = function ( iCol, bShow, bRedraw )\n\t{\n\t\tvar api = this.api( true ).column( iCol ).visible( bShow );\n\t\n\t\tif ( bRedraw === undefined || bRedraw ) {\n\t\t\tapi.columns.adjust().draw();\n\t\t}\n\t};\n\t\n\t\n\t/**\n\t * Get the settings for a particular table for external manipulation\n\t *  @returns {object} DataTables settings object. See\n\t *    {@link DataTable.models.oSettings}\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *      var oSettings = oTable.fnSettings();\n\t *\n\t *      // Show an example parameter from the settings\n\t *      alert( oSettings._iDisplayStart );\n\t *    } );\n\t */\n\tthis.fnSettings = function()\n\t{\n\t\treturn _fnSettingsFromNode( this[_ext.iApiIndex] );\n\t};\n\t\n\t\n\t/**\n\t * Sort the table by a particular column\n\t *  @param {int} iCol the data index to sort on. Note that this will not match the\n\t *    'display index' if you have hidden data entries\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Sort immediately with columns 0 and 1\n\t *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\n\t *    } );\n\t */\n\tthis.fnSort = function( aaSort )\n\t{\n\t\tthis.api( true ).order( aaSort ).draw();\n\t};\n\t\n\t\n\t/**\n\t * Attach a sort listener to an element for a given column\n\t *  @param {node} nNode the element to attach the sort listener to\n\t *  @param {int} iColumn the column that a click on this node will sort on\n\t *  @param {function} [fnCallback] callback function when sort is run\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *\n\t *      // Sort on column 1, when 'sorter' is clicked on\n\t *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\n\t *    } );\n\t */\n\tthis.fnSortListener = function( nNode, iColumn, fnCallback )\n\t{\n\t\tthis.api( true ).order.listener( nNode, iColumn, fnCallback );\n\t};\n\t\n\t\n\t/**\n\t * Update a table cell or row - this method will accept either a single value to\n\t * update the cell with, an array of values with one element for each column or\n\t * an object in the same format as the original data source. The function is\n\t * self-referencing in order to make the multi column updates easier.\n\t *  @param {object|array|string} mData Data to update the cell/row with\n\t *  @param {node|int} mRow TR element you want to update or the aoData index\n\t *  @param {int} [iColumn] The column to update, give as null or undefined to\n\t *    update a whole row.\n\t *  @param {bool} [bRedraw=true] Redraw the table or not\n\t *  @param {bool} [bAction=true] Perform pre-draw actions or not\n\t *  @returns {int} 0 on success, 1 on error\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\n\t *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\n\t *    } );\n\t */\n\tthis.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )\n\t{\n\t\tvar api = this.api( true );\n\t\n\t\tif ( iColumn === undefined || iColumn === null ) {\n\t\t\tapi.row( mRow ).data( mData );\n\t\t}\n\t\telse {\n\t\t\tapi.cell( mRow, iColumn ).data( mData );\n\t\t}\n\t\n\t\tif ( bAction === undefined || bAction ) {\n\t\t\tapi.columns.adjust();\n\t\t}\n\t\n\t\tif ( bRedraw === undefined || bRedraw ) {\n\t\t\tapi.draw();\n\t\t}\n\t\treturn 0;\n\t};\n\t\n\t\n\t/**\n\t * Provide a common method for plug-ins to check the version of DataTables being used, in order\n\t * to ensure compatibility.\n\t *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\n\t *    formats \"X\" and \"X.Y\" are also acceptable.\n\t *  @returns {boolean} true if this version of DataTables is greater or equal to the required\n\t *    version, or false if this version of DataTales is not suitable\n\t *  @method\n\t *  @dtopt API\n\t *  @deprecated Since v1.10\n\t *\n\t *  @example\n\t *    $(document).ready(function() {\n\t *      var oTable = $('#example').dataTable();\n\t *      alert( oTable.fnVersionCheck( '1.9.0' ) );\n\t *    } );\n\t */\n\tthis.fnVersionCheck = _ext.fnVersionCheck;\n\t\n\n\tvar _that = this;\n\tvar emptyInit = options === undefined;\n\tvar len = this.length;\n\n\tif ( emptyInit ) {\n\t\toptions = {};\n\t}\n\n\tthis.oApi = this.internal = _ext.internal;\n\n\t// Extend with old style plug-in API methods\n\tfor ( var fn in DataTable.ext.internal ) {\n\t\tif ( fn ) {\n\t\t\tthis[fn] = _fnExternApiFunc(fn);\n\t\t}\n\t}\n\n\tthis.each(function() {\n\t\t// For each initialisation we want to give it a clean initialisation\n\t\t// object that can be bashed around\n\t\tvar o = {};\n\t\tvar oInit = len > 1 ? // optimisation for single table case\n\t\t\t_fnExtend( o, options, true ) :\n\t\t\toptions;\n\n\t\t/*global oInit,_that,emptyInit*/\n\t\tvar i=0, iLen, j, jLen, k, kLen;\n\t\tvar sId = this.getAttribute( 'id' );\n\t\tvar bInitHandedOff = false;\n\t\tvar defaults = DataTable.defaults;\n\t\tvar $this = $(this);\n\t\t\n\t\t\n\t\t/* Sanity check */\n\t\tif ( this.nodeName.toLowerCase() != 'table' )\n\t\t{\n\t\t\t_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t/* Backwards compatibility for the defaults */\n\t\t_fnCompatOpts( defaults );\n\t\t_fnCompatCols( defaults.column );\n\t\t\n\t\t/* Convert the camel-case defaults to Hungarian */\n\t\t_fnCamelToHungarian( defaults, defaults, true );\n\t\t_fnCamelToHungarian( defaults.column, defaults.column, true );\n\t\t\n\t\t/* Setting up the initialisation object */\n\t\t_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );\n\t\t\n\t\t\n\t\t\n\t\t/* Check to see if we are re-initialising a table */\n\t\tvar allSettings = DataTable.settings;\n\t\tfor ( i=0, iLen=allSettings.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tvar s = allSettings[i];\n\t\t\n\t\t\t/* Base check on table node */\n\t\t\tif (\n\t\t\t\ts.nTable == this ||\n\t\t\t\t(s.nTHead && s.nTHead.parentNode == this) ||\n\t\t\t\t(s.nTFoot && s.nTFoot.parentNode == this)\n\t\t\t) {\n\t\t\t\tvar bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;\n\t\t\t\tvar bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;\n\t\t\n\t\t\t\tif ( emptyInit || bRetrieve )\n\t\t\t\t{\n\t\t\t\t\treturn s.oInstance;\n\t\t\t\t}\n\t\t\t\telse if ( bDestroy )\n\t\t\t\t{\n\t\t\t\t\ts.oInstance.fnDestroy();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t/* If the element we are initialising has the same ID as a table which was previously\n\t\t\t * initialised, but the table nodes don't match (from before) then we destroy the old\n\t\t\t * instance by simply deleting it. This is under the assumption that the table has been\n\t\t\t * destroyed by other methods. Anyone using non-id selectors will need to do this manually\n\t\t\t */\n\t\t\tif ( s.sTableId == this.id )\n\t\t\t{\n\t\t\t\tallSettings.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Ensure the table has an ID - required for accessibility */\n\t\tif ( sId === null || sId === \"\" )\n\t\t{\n\t\t\tsId = \"DataTables_Table_\"+(DataTable.ext._unique++);\n\t\t\tthis.id = sId;\n\t\t}\n\t\t\n\t\t/* Create the settings object for this table and set some of the default parameters */\n\t\tvar oSettings = $.extend( true, {}, DataTable.models.oSettings, {\n\t\t\t\"sDestroyWidth\": $this[0].style.width,\n\t\t\t\"sInstance\":     sId,\n\t\t\t\"sTableId\":      sId\n\t\t} );\n\t\toSettings.nTable = this;\n\t\toSettings.oApi   = _that.internal;\n\t\toSettings.oInit  = oInit;\n\t\t\n\t\tallSettings.push( oSettings );\n\t\t\n\t\t// Need to add the instance after the instance after the settings object has been added\n\t\t// to the settings array, so we can self reference the table instance if more than one\n\t\toSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();\n\t\t\n\t\t// Backwards compatibility, before we apply all the defaults\n\t\t_fnCompatOpts( oInit );\n\t\t_fnLanguageCompat( oInit.oLanguage );\n\t\t\n\t\t// If the length menu is given, but the init display length is not, use the length menu\n\t\tif ( oInit.aLengthMenu && ! oInit.iDisplayLength )\n\t\t{\n\t\t\toInit.iDisplayLength = Array.isArray( oInit.aLengthMenu[0] ) ?\n\t\t\t\toInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];\n\t\t}\n\t\t\n\t\t// Apply the defaults and init options to make a single init object will all\n\t\t// options defined from defaults and instance options.\n\t\toInit = _fnExtend( $.extend( true, {}, defaults ), oInit );\n\t\t\n\t\t\n\t\t// Map the initialisation options onto the settings object\n\t\t_fnMap( oSettings.oFeatures, oInit, [\n\t\t\t\"bPaginate\",\n\t\t\t\"bLengthChange\",\n\t\t\t\"bFilter\",\n\t\t\t\"bSort\",\n\t\t\t\"bSortMulti\",\n\t\t\t\"bInfo\",\n\t\t\t\"bProcessing\",\n\t\t\t\"bAutoWidth\",\n\t\t\t\"bSortClasses\",\n\t\t\t\"bServerSide\",\n\t\t\t\"bDeferRender\"\n\t\t] );\n\t\t_fnMap( oSettings, oInit, [\n\t\t\t\"asStripeClasses\",\n\t\t\t\"ajax\",\n\t\t\t\"fnServerData\",\n\t\t\t\"fnFormatNumber\",\n\t\t\t\"sServerMethod\",\n\t\t\t\"aaSorting\",\n\t\t\t\"aaSortingFixed\",\n\t\t\t\"aLengthMenu\",\n\t\t\t\"sPaginationType\",\n\t\t\t\"sAjaxSource\",\n\t\t\t\"sAjaxDataProp\",\n\t\t\t\"iStateDuration\",\n\t\t\t\"sDom\",\n\t\t\t\"bSortCellsTop\",\n\t\t\t\"iTabIndex\",\n\t\t\t\"fnStateLoadCallback\",\n\t\t\t\"fnStateSaveCallback\",\n\t\t\t\"renderer\",\n\t\t\t\"searchDelay\",\n\t\t\t\"rowId\",\n\t\t\t[ \"iCookieDuration\", \"iStateDuration\" ], // backwards compat\n\t\t\t[ \"oSearch\", \"oPreviousSearch\" ],\n\t\t\t[ \"aoSearchCols\", \"aoPreSearchCols\" ],\n\t\t\t[ \"iDisplayLength\", \"_iDisplayLength\" ]\n\t\t] );\n\t\t_fnMap( oSettings.oScroll, oInit, [\n\t\t\t[ \"sScrollX\", \"sX\" ],\n\t\t\t[ \"sScrollXInner\", \"sXInner\" ],\n\t\t\t[ \"sScrollY\", \"sY\" ],\n\t\t\t[ \"bScrollCollapse\", \"bCollapse\" ]\n\t\t] );\n\t\t_fnMap( oSettings.oLanguage, oInit, \"fnInfoCallback\" );\n\t\t\n\t\t/* Callback functions which are array driven */\n\t\t_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );\n\t\t_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );\n\t\t_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );\n\t\t_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );\n\t\t_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );\n\t\t_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );\n\t\t_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );\n\t\t_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );\n\t\t_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );\n\t\t_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );\n\t\t_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );\n\t\t\n\t\toSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );\n\t\t\n\t\t/* Browser support detection */\n\t\t_fnBrowserDetect( oSettings );\n\t\t\n\t\tvar oClasses = oSettings.oClasses;\n\t\t\n\t\t$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );\n\t\t$this.addClass( oClasses.sTable );\n\t\t\n\t\t\n\t\tif ( oSettings.iInitDisplayStart === undefined )\n\t\t{\n\t\t\t/* Display start point, taking into account the save saving */\n\t\t\toSettings.iInitDisplayStart = oInit.iDisplayStart;\n\t\t\toSettings._iDisplayStart = oInit.iDisplayStart;\n\t\t}\n\t\t\n\t\tif ( oInit.iDeferLoading !== null )\n\t\t{\n\t\t\toSettings.bDeferLoading = true;\n\t\t\tvar tmp = Array.isArray( oInit.iDeferLoading );\n\t\t\toSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;\n\t\t\toSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;\n\t\t}\n\t\t\n\t\t/* Language definitions */\n\t\tvar oLanguage = oSettings.oLanguage;\n\t\t$.extend( true, oLanguage, oInit.oLanguage );\n\t\t\n\t\tif ( oLanguage.sUrl )\n\t\t{\n\t\t\t/* Get the language definitions from a file - because this Ajax call makes the language\n\t\t\t * get async to the remainder of this function we use bInitHandedOff to indicate that\n\t\t\t * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\n\t\t\t */\n\t\t\t$.ajax( {\n\t\t\t\tdataType: 'json',\n\t\t\t\turl: oLanguage.sUrl,\n\t\t\t\tsuccess: function ( json ) {\n\t\t\t\t\t_fnCamelToHungarian( defaults.oLanguage, json );\n\t\t\t\t\t_fnLanguageCompat( json );\n\t\t\t\t\t$.extend( true, oLanguage, json, oSettings.oInit.oLanguage );\n\t\t\n\t\t\t\t\t_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);\n\t\t\t\t\t_fnInitialise( oSettings );\n\t\t\t\t},\n\t\t\t\terror: function () {\n\t\t\t\t\t// Error occurred loading language file, continue on as best we can\n\t\t\t\t\t_fnInitialise( oSettings );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tbInitHandedOff = true;\n\t\t}\n\t\telse {\n\t\t\t_fnCallbackFire( oSettings, null, 'i18n', [oSettings]);\n\t\t}\n\t\t\n\t\t/*\n\t\t * Stripes\n\t\t */\n\t\tif ( oInit.asStripeClasses === null )\n\t\t{\n\t\t\toSettings.asStripeClasses =[\n\t\t\t\toClasses.sStripeOdd,\n\t\t\t\toClasses.sStripeEven\n\t\t\t];\n\t\t}\n\t\t\n\t\t/* Remove row stripe classes if they are already on the table row */\n\t\tvar stripeClasses = oSettings.asStripeClasses;\n\t\tvar rowOne = $this.children('tbody').find('tr').eq(0);\n\t\tif ( $.inArray( true, $.map( stripeClasses, function(el, i) {\n\t\t\treturn rowOne.hasClass(el);\n\t\t} ) ) !== -1 ) {\n\t\t\t$('tbody tr', this).removeClass( stripeClasses.join(' ') );\n\t\t\toSettings.asDestroyStripes = stripeClasses.slice();\n\t\t}\n\t\t\n\t\t/*\n\t\t * Columns\n\t\t * See if we should load columns automatically or use defined ones\n\t\t */\n\t\tvar anThs = [];\n\t\tvar aoColumnsInit;\n\t\tvar nThead = this.getElementsByTagName('thead');\n\t\tif ( nThead.length !== 0 )\n\t\t{\n\t\t\t_fnDetectHeader( oSettings.aoHeader, nThead[0] );\n\t\t\tanThs = _fnGetUniqueThs( oSettings );\n\t\t}\n\t\t\n\t\t/* If not given a column array, generate one with nulls */\n\t\tif ( oInit.aoColumns === null )\n\t\t{\n\t\t\taoColumnsInit = [];\n\t\t\tfor ( i=0, iLen=anThs.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\taoColumnsInit.push( null );\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taoColumnsInit = oInit.aoColumns;\n\t\t}\n\t\t\n\t\t/* Add the columns */\n\t\tfor ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )\n\t\t{\n\t\t\t_fnAddColumn( oSettings, anThs ? anThs[i] : null );\n\t\t}\n\t\t\n\t\t/* Apply the column definitions */\n\t\t_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\n\t\t\t_fnColumnOptions( oSettings, iCol, oDef );\n\t\t} );\n\t\t\n\t\t/* HTML5 attribute detection - build an mData object automatically if the\n\t\t * attributes are found\n\t\t */\n\t\tif ( rowOne.length ) {\n\t\t\tvar a = function ( cell, name ) {\n\t\t\t\treturn cell.getAttribute( 'data-'+name ) !== null ? name : null;\n\t\t\t};\n\t\t\n\t\t\t$( rowOne[0] ).children('th, td').each( function (i, cell) {\n\t\t\t\tvar col = oSettings.aoColumns[i];\n\t\t\n\t\t\t\tif (! col) {\n\t\t\t\t\t_fnLog( oSettings, 0, 'Incorrect column count', 18 );\n\t\t\t\t}\n\t\t\n\t\t\t\tif ( col.mData === i ) {\n\t\t\t\t\tvar sort = a( cell, 'sort' ) || a( cell, 'order' );\n\t\t\t\t\tvar filter = a( cell, 'filter' ) || a( cell, 'search' );\n\t\t\n\t\t\t\t\tif ( sort !== null || filter !== null ) {\n\t\t\t\t\t\tcol.mData = {\n\t\t\t\t\t\t\t_:      i+'.display',\n\t\t\t\t\t\t\tsort:   sort !== null   ? i+'.@data-'+sort   : undefined,\n\t\t\t\t\t\t\ttype:   sort !== null   ? i+'.@data-'+sort   : undefined,\n\t\t\t\t\t\t\tfilter: filter !== null ? i+'.@data-'+filter : undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcol._isArrayHost = true;\n\t\t\n\t\t\t\t\t\t_fnColumnOptions( oSettings, i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\t\n\t\tvar features = oSettings.oFeatures;\n\t\tvar loadedInit = function () {\n\t\t\t/*\n\t\t\t * Sorting\n\t\t\t * @todo For modularisation (1.11) this needs to do into a sort start up handler\n\t\t\t */\n\t\t\n\t\t\t// If aaSorting is not defined, then we use the first indicator in asSorting\n\t\t\t// in case that has been altered, so the default sort reflects that option\n\t\t\tif ( oInit.aaSorting === undefined ) {\n\t\t\t\tvar sorting = oSettings.aaSorting;\n\t\t\t\tfor ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {\n\t\t\t\t\tsorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t/* Do a first pass on the sorting classes (allows any size changes to be taken into\n\t\t\t * account, and also will apply sorting disabled classes if disabled\n\t\t\t */\n\t\t\t_fnSortingClasses( oSettings );\n\t\t\n\t\t\tif ( features.bSort ) {\n\t\t\t\t_fnCallbackReg( oSettings, 'aoDrawCallback', function () {\n\t\t\t\t\tif ( oSettings.bSorted ) {\n\t\t\t\t\t\tvar aSort = _fnSortFlatten( oSettings );\n\t\t\t\t\t\tvar sortedColumns = {};\n\t\t\n\t\t\t\t\t\t$.each( aSort, function (i, val) {\n\t\t\t\t\t\t\tsortedColumns[ val.src ] = val.dir;\n\t\t\t\t\t\t} );\n\t\t\n\t\t\t\t\t\t_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );\n\t\t\t\t\t\t_fnSortAria( oSettings );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\n\t\t\t_fnCallbackReg( oSettings, 'aoDrawCallback', function () {\n\t\t\t\tif ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {\n\t\t\t\t\t_fnSortingClasses( oSettings );\n\t\t\t\t}\n\t\t\t}, 'sc' );\n\t\t\n\t\t\n\t\t\t/*\n\t\t\t * Final init\n\t\t\t * Cache the header, body and footer as required, creating them if needed\n\t\t\t */\n\t\t\n\t\t\t// Work around for Webkit bug 83867 - store the caption-side before removing from doc\n\t\t\tvar captions = $this.children('caption').each( function () {\n\t\t\t\tthis._captionSide = $(this).css('caption-side');\n\t\t\t} );\n\t\t\n\t\t\tvar thead = $this.children('thead');\n\t\t\tif ( thead.length === 0 ) {\n\t\t\t\tthead = $('<thead/>').appendTo($this);\n\t\t\t}\n\t\t\toSettings.nTHead = thead[0];\n\t\t\n\t\t\tvar tbody = $this.children('tbody');\n\t\t\tif ( tbody.length === 0 ) {\n\t\t\t\ttbody = $('<tbody/>').insertAfter(thead);\n\t\t\t}\n\t\t\toSettings.nTBody = tbody[0];\n\t\t\n\t\t\tvar tfoot = $this.children('tfoot');\n\t\t\tif ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== \"\" || oSettings.oScroll.sY !== \"\") ) {\n\t\t\t\t// If we are a scrolling table, and no footer has been given, then we need to create\n\t\t\t\t// a tfoot element for the caption element to be appended to\n\t\t\t\ttfoot = $('<tfoot/>').appendTo($this);\n\t\t\t}\n\t\t\n\t\t\tif ( tfoot.length === 0 || tfoot.children().length === 0 ) {\n\t\t\t\t$this.addClass( oClasses.sNoFooter );\n\t\t\t}\n\t\t\telse if ( tfoot.length > 0 ) {\n\t\t\t\toSettings.nTFoot = tfoot[0];\n\t\t\t\t_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );\n\t\t\t}\n\t\t\n\t\t\t/* Check if there is data passing into the constructor */\n\t\t\tif ( oInit.aaData ) {\n\t\t\t\tfor ( i=0 ; i<oInit.aaData.length ; i++ ) {\n\t\t\t\t\t_fnAddData( oSettings, oInit.aaData[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' ) {\n\t\t\t\t/* Grab the data from the page - only do this when deferred loading or no Ajax\n\t\t\t\t * source since there is no point in reading the DOM data if we are then going\n\t\t\t\t * to replace it with Ajax data\n\t\t\t\t */\n\t\t\t\t_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );\n\t\t\t}\n\t\t\n\t\t\t/* Copy the data index array */\n\t\t\toSettings.aiDisplay = oSettings.aiDisplayMaster.slice();\n\t\t\n\t\t\t/* Initialisation complete - table can be drawn */\n\t\t\toSettings.bInitialised = true;\n\t\t\n\t\t\t/* Check if we need to initialise the table (it might not have been handed off to the\n\t\t\t * language processor)\n\t\t\t */\n\t\t\tif ( bInitHandedOff === false ) {\n\t\t\t\t_fnInitialise( oSettings );\n\t\t\t}\n\t\t};\n\t\t\n\t\t/* Must be done after everything which can be overridden by the state saving! */\n\t\t_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );\n\t\t\n\t\tif ( oInit.bStateSave )\n\t\t{\n\t\t\tfeatures.bStateSave = true;\n\t\t\t_fnLoadState( oSettings, oInit, loadedInit );\n\t\t}\n\t\telse {\n\t\t\tloadedInit();\n\t\t}\n\t\t\n\t} );\n\t_that = null;\n\treturn this;\n};\n\n\n/*\n * It is useful to have variables which are scoped locally so only the\n * DataTables functions can access them and they don't leak into global space.\n * At the same time these functions are often useful over multiple files in the\n * core and API, so we list, or at least document, all variables which are used\n * by DataTables as private variables here. This also ensures that there is no\n * clashing of variable names and that they can easily referenced for reuse.\n */\n\n\n// Defined else where\n//  _selector_run\n//  _selector_opts\n//  _selector_first\n//  _selector_row_indexes\n\nvar _ext; // DataTable.ext\nvar _Api; // DataTable.Api\nvar _api_register; // DataTable.Api.register\nvar _api_registerPlural; // DataTable.Api.registerPlural\n\nvar _re_dic = {};\nvar _re_new_lines = /[\\r\\n\\u2028]/g;\nvar _re_html = /<.*?>/g;\n\n// This is not strict ISO8601 - Date.parse() is quite lax, although\n// implementations differ between browsers.\nvar _re_date = /^\\d{2,4}[\\.\\/\\-]\\d{1,2}[\\.\\/\\-]\\d{1,2}([T ]{1}\\d{1,2}[:\\.]\\d{2}([\\.:]\\d{2})?)?$/;\n\n// Escape regular expression special characters\nvar _re_escape_regex = new RegExp( '(\\\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-' ].join('|\\\\') + ')', 'g' );\n\n// http://en.wikipedia.org/wiki/Foreign_exchange_market\n// - \\u20BD - Russian ruble.\n// - \\u20a9 - South Korean Won\n// - \\u20BA - Turkish Lira\n// - \\u20B9 - Indian Rupee\n// - R - Brazil (R$) and South Africa\n// - fr - Swiss Franc\n// - kr - Swedish krona, Norwegian krone and Danish krone\n// - \\u2009 is thin space and \\u202F is narrow no-break space, both used in many\n// - Ƀ - Bitcoin\n// - Ξ - Ethereum\n//   standards as thousands separators.\nvar _re_formatted_numeric = /['\\u00A0,$£€¥%\\u2009\\u202F\\u20BD\\u20a9\\u20BArfkɃΞ]/gi;\n\n\nvar _empty = function ( d ) {\n\treturn !d || d === true || d === '-' ? true : false;\n};\n\n\nvar _intVal = function ( s ) {\n\tvar integer = parseInt( s, 10 );\n\treturn !isNaN(integer) && isFinite(s) ? integer : null;\n};\n\n// Convert from a formatted number with characters other than `.` as the\n// decimal place, to a Javascript number\nvar _numToDecimal = function ( num, decimalPoint ) {\n\t// Cache created regular expressions for speed as this function is called often\n\tif ( ! _re_dic[ decimalPoint ] ) {\n\t\t_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );\n\t}\n\treturn typeof num === 'string' && decimalPoint !== '.' ?\n\t\tnum.replace( /\\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :\n\t\tnum;\n};\n\n\nvar _isNumber = function ( d, decimalPoint, formatted ) {\n\tlet type = typeof d;\n\tvar strType = type === 'string';\n\n\tif ( type === 'number' || type === 'bigint') {\n\t\treturn true;\n\t}\n\n\t// If empty return immediately so there must be a number if it is a\n\t// formatted string (this stops the string \"k\", or \"kr\", etc being detected\n\t// as a formatted number for currency\n\tif ( _empty( d ) ) {\n\t\treturn true;\n\t}\n\n\tif ( decimalPoint && strType ) {\n\t\td = _numToDecimal( d, decimalPoint );\n\t}\n\n\tif ( formatted && strType ) {\n\t\td = d.replace( _re_formatted_numeric, '' );\n\t}\n\n\treturn !isNaN( parseFloat(d) ) && isFinite( d );\n};\n\n\n// A string without HTML in it can be considered to be HTML still\nvar _isHtml = function ( d ) {\n\treturn _empty( d ) || typeof d === 'string';\n};\n\n\nvar _htmlNumeric = function ( d, decimalPoint, formatted ) {\n\tif ( _empty( d ) ) {\n\t\treturn true;\n\t}\n\n\tvar html = _isHtml( d );\n\treturn ! html ?\n\t\tnull :\n\t\t_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?\n\t\t\ttrue :\n\t\t\tnull;\n};\n\n\nvar _pluck = function ( a, prop, prop2 ) {\n\tvar out = [];\n\tvar i=0, ien=a.length;\n\n\t// Could have the test in the loop for slightly smaller code, but speed\n\t// is essential here\n\tif ( prop2 !== undefined ) {\n\t\tfor ( ; i<ien ; i++ ) {\n\t\t\tif ( a[i] && a[i][ prop ] ) {\n\t\t\t\tout.push( a[i][ prop ][ prop2 ] );\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor ( ; i<ien ; i++ ) {\n\t\t\tif ( a[i] ) {\n\t\t\t\tout.push( a[i][ prop ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n};\n\n\n// Basically the same as _pluck, but rather than looping over `a` we use `order`\n// as the indexes to pick from `a`\nvar _pluck_order = function ( a, order, prop, prop2 )\n{\n\tvar out = [];\n\tvar i=0, ien=order.length;\n\n\t// Could have the test in the loop for slightly smaller code, but speed\n\t// is essential here\n\tif ( prop2 !== undefined ) {\n\t\tfor ( ; i<ien ; i++ ) {\n\t\t\tif ( a[ order[i] ][ prop ] ) {\n\t\t\t\tout.push( a[ order[i] ][ prop ][ prop2 ] );\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor ( ; i<ien ; i++ ) {\n\t\t\tout.push( a[ order[i] ][ prop ] );\n\t\t}\n\t}\n\n\treturn out;\n};\n\n\nvar _range = function ( len, start )\n{\n\tvar out = [];\n\tvar end;\n\n\tif ( start === undefined ) {\n\t\tstart = 0;\n\t\tend = len;\n\t}\n\telse {\n\t\tend = start;\n\t\tstart = len;\n\t}\n\n\tfor ( var i=start ; i<end ; i++ ) {\n\t\tout.push( i );\n\t}\n\n\treturn out;\n};\n\n\nvar _removeEmpty = function ( a )\n{\n\tvar out = [];\n\n\tfor ( var i=0, ien=a.length ; i<ien ; i++ ) {\n\t\tif ( a[i] ) { // careful - will remove all falsy values!\n\t\t\tout.push( a[i] );\n\t\t}\n\t}\n\n\treturn out;\n};\n\n\nvar _stripHtml = function ( d ) {\n\treturn d.replace( _re_html, '' );\n};\n\n\n/**\n * Determine if all values in the array are unique. This means we can short\n * cut the _unique method at the cost of a single loop. A sorted array is used\n * to easily check the values.\n *\n * @param  {array} src Source array\n * @return {boolean} true if all unique, false otherwise\n * @ignore\n */\nvar _areAllUnique = function ( src ) {\n\tif ( src.length < 2 ) {\n\t\treturn true;\n\t}\n\n\tvar sorted = src.slice().sort();\n\tvar last = sorted[0];\n\n\tfor ( var i=1, ien=sorted.length ; i<ien ; i++ ) {\n\t\tif ( sorted[i] === last ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlast = sorted[i];\n\t}\n\n\treturn true;\n};\n\n\n/**\n * Find the unique elements in a source array.\n *\n * @param  {array} src Source array\n * @return {array} Array of unique items\n * @ignore\n */\nvar _unique = function ( src )\n{\n\tif ( _areAllUnique( src ) ) {\n\t\treturn src.slice();\n\t}\n\n\t// A faster unique method is to use object keys to identify used values,\n\t// but this doesn't work with arrays or objects, which we must also\n\t// consider. See jsperf.com/compare-array-unique-versions/4 for more\n\t// information.\n\tvar\n\t\tout = [],\n\t\tval,\n\t\ti, ien=src.length,\n\t\tj, k=0;\n\n\tagain: for ( i=0 ; i<ien ; i++ ) {\n\t\tval = src[i];\n\n\t\tfor ( j=0 ; j<k ; j++ ) {\n\t\t\tif ( out[j] === val ) {\n\t\t\t\tcontinue again;\n\t\t\t}\n\t\t}\n\n\t\tout.push( val );\n\t\tk++;\n\t}\n\n\treturn out;\n};\n\n// Surprisingly this is faster than [].concat.apply\n// https://jsperf.com/flatten-an-array-loop-vs-reduce/2\nvar _flatten = function (out, val) {\n\tif (Array.isArray(val)) {\n\t\tfor (var i=0 ; i<val.length ; i++) {\n\t\t\t_flatten(out, val[i]);\n\t\t}\n\t}\n\telse {\n\t\tout.push(val);\n\t}\n  \n\treturn out;\n}\n\nvar _includes = function (search, start) {\n\tif (start === undefined) {\n\t\tstart = 0;\n\t}\n\n\treturn this.indexOf(search, start) !== -1;\t\n};\n\n// Array.isArray polyfill.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\nif (! Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\nif (! Array.prototype.includes) {\n\tArray.prototype.includes = _includes;\n}\n\n// .trim() polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\nif (! String.prototype.includes) {\n\tString.prototype.includes = _includes;\n}\n\n/**\n * DataTables utility methods\n * \n * This namespace provides helper methods that DataTables uses internally to\n * create a DataTable, but which are not exclusively used only for DataTables.\n * These methods can be used by extension authors to save the duplication of\n * code.\n *\n *  @namespace\n */\nDataTable.util = {\n\t/**\n\t * Throttle the calls to a function. Arguments and context are maintained\n\t * for the throttled function.\n\t *\n\t * @param {function} fn Function to be called\n\t * @param {integer} freq Call frequency in mS\n\t * @return {function} Wrapped function\n\t */\n\tthrottle: function ( fn, freq ) {\n\t\tvar\n\t\t\tfrequency = freq !== undefined ? freq : 200,\n\t\t\tlast,\n\t\t\ttimer;\n\n\t\treturn function () {\n\t\t\tvar\n\t\t\t\tthat = this,\n\t\t\t\tnow  = +new Date(),\n\t\t\t\targs = arguments;\n\n\t\t\tif ( last && now < last + frequency ) {\n\t\t\t\tclearTimeout( timer );\n\n\t\t\t\ttimer = setTimeout( function () {\n\t\t\t\t\tlast = undefined;\n\t\t\t\t\tfn.apply( that, args );\n\t\t\t\t}, frequency );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlast = now;\n\t\t\t\tfn.apply( that, args );\n\t\t\t}\n\t\t};\n\t},\n\n\n\t/**\n\t * Escape a string such that it can be used in a regular expression\n\t *\n\t *  @param {string} val string to escape\n\t *  @returns {string} escaped string\n\t */\n\tescapeRegex: function ( val ) {\n\t\treturn val.replace( _re_escape_regex, '\\\\$1' );\n\t},\n\n\t/**\n\t * Create a function that will write to a nested object or array\n\t * @param {*} source JSON notation string\n\t * @returns Write function\n\t */\n\tset: function ( source ) {\n\t\tif ( $.isPlainObject( source ) ) {\n\t\t\t/* Unlike get, only the underscore (global) option is used for for\n\t\t\t * setting data since we don't know the type here. This is why an object\n\t\t\t * option is not documented for `mData` (which is read/write), but it is\n\t\t\t * for `mRender` which is read only.\n\t\t\t */\n\t\t\treturn DataTable.util.set( source._ );\n\t\t}\n\t\telse if ( source === null ) {\n\t\t\t// Nothing to do when the data source is null\n\t\t\treturn function () {};\n\t\t}\n\t\telse if ( typeof source === 'function' ) {\n\t\t\treturn function (data, val, meta) {\n\t\t\t\tsource( data, 'set', val, meta );\n\t\t\t};\n\t\t}\n\t\telse if ( typeof source === 'string' && (source.indexOf('.') !== -1 ||\n\t\t\t\t  source.indexOf('[') !== -1 || source.indexOf('(') !== -1) )\n\t\t{\n\t\t\t// Like the get, we need to get data from a nested object\n\t\t\tvar setData = function (data, val, src) {\n\t\t\t\tvar a = _fnSplitObjNotation( src ), b;\n\t\t\t\tvar aLast = a[a.length-1];\n\t\t\t\tvar arrayNotation, funcNotation, o, innerSrc;\n\t\n\t\t\t\tfor ( var i=0, iLen=a.length-1 ; i<iLen ; i++ ) {\n\t\t\t\t\t// Protect against prototype pollution\n\t\t\t\t\tif (a[i] === '__proto__' || a[i] === 'constructor') {\n\t\t\t\t\t\tthrow new Error('Cannot set prototype values');\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Check if we are dealing with an array notation request\n\t\t\t\t\tarrayNotation = a[i].match(__reArray);\n\t\t\t\t\tfuncNotation = a[i].match(__reFn);\n\t\n\t\t\t\t\tif ( arrayNotation ) {\n\t\t\t\t\t\ta[i] = a[i].replace(__reArray, '');\n\t\t\t\t\t\tdata[ a[i] ] = [];\n\t\n\t\t\t\t\t\t// Get the remainder of the nested object to set so we can recurse\n\t\t\t\t\t\tb = a.slice();\n\t\t\t\t\t\tb.splice( 0, i+1 );\n\t\t\t\t\t\tinnerSrc = b.join('.');\n\t\n\t\t\t\t\t\t// Traverse each entry in the array setting the properties requested\n\t\t\t\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\t\t\t\tfor ( var j=0, jLen=val.length ; j<jLen ; j++ ) {\n\t\t\t\t\t\t\t\to = {};\n\t\t\t\t\t\t\t\tsetData( o, val[j], innerSrc );\n\t\t\t\t\t\t\t\tdata[ a[i] ].push( o );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We've been asked to save data to an array, but it\n\t\t\t\t\t\t\t// isn't array data to be saved. Best that can be done\n\t\t\t\t\t\t\t// is to just save the value.\n\t\t\t\t\t\t\tdata[ a[i] ] = val;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// The inner call to setData has already traversed through the remainder\n\t\t\t\t\t\t// of the source and has set the data, thus we can exit here\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( funcNotation ) {\n\t\t\t\t\t\t// Function call\n\t\t\t\t\t\ta[i] = a[i].replace(__reFn, '');\n\t\t\t\t\t\tdata = data[ a[i] ]( val );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// If the nested object doesn't currently exist - since we are\n\t\t\t\t\t// trying to set the value - create it\n\t\t\t\t\tif ( data[ a[i] ] === null || data[ a[i] ] === undefined ) {\n\t\t\t\t\t\tdata[ a[i] ] = {};\n\t\t\t\t\t}\n\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t}\n\t\n\t\t\t\t// Last item in the input - i.e, the actual set\n\t\t\t\tif ( aLast.match(__reFn ) ) {\n\t\t\t\t\t// Function call\n\t\t\t\t\tdata = data[ aLast.replace(__reFn, '') ]( val );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If array notation is used, we just want to strip it and use the property name\n\t\t\t\t\t// and assign the value. If it isn't used, then we get the result we want anyway\n\t\t\t\t\tdata[ aLast.replace(__reArray, '') ] = val;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\treturn function (data, val) { // meta is also passed in, but not used\n\t\t\t\treturn setData( data, val, source );\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\t// Array or flat object mapping\n\t\t\treturn function (data, val) { // meta is also passed in, but not used\n\t\t\t\tdata[source] = val;\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Create a function that will read nested objects from arrays, based on JSON notation\n\t * @param {*} source JSON notation string\n\t * @returns Value read\n\t */\n\tget: function ( source ) {\n\t\tif ( $.isPlainObject( source ) ) {\n\t\t\t// Build an object of get functions, and wrap them in a single call\n\t\t\tvar o = {};\n\t\t\t$.each( source, function (key, val) {\n\t\t\t\tif ( val ) {\n\t\t\t\t\to[key] = DataTable.util.get( val );\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\treturn function (data, type, row, meta) {\n\t\t\t\tvar t = o[type] || o._;\n\t\t\t\treturn t !== undefined ?\n\t\t\t\t\tt(data, type, row, meta) :\n\t\t\t\t\tdata;\n\t\t\t};\n\t\t}\n\t\telse if ( source === null ) {\n\t\t\t// Give an empty string for rendering / sorting etc\n\t\t\treturn function (data) { // type, row and meta also passed, but not used\n\t\t\t\treturn data;\n\t\t\t};\n\t\t}\n\t\telse if ( typeof source === 'function' ) {\n\t\t\treturn function (data, type, row, meta) {\n\t\t\t\treturn source( data, type, row, meta );\n\t\t\t};\n\t\t}\n\t\telse if ( typeof source === 'string' && (source.indexOf('.') !== -1 ||\n\t\t\t\t  source.indexOf('[') !== -1 || source.indexOf('(') !== -1) )\n\t\t{\n\t\t\t/* If there is a . in the source string then the data source is in a\n\t\t\t * nested object so we loop over the data for each level to get the next\n\t\t\t * level down. On each loop we test for undefined, and if found immediately\n\t\t\t * return. This allows entire objects to be missing and sDefaultContent to\n\t\t\t * be used if defined, rather than throwing an error\n\t\t\t */\n\t\t\tvar fetchData = function (data, type, src) {\n\t\t\t\tvar arrayNotation, funcNotation, out, innerSrc;\n\t\n\t\t\t\tif ( src !== \"\" ) {\n\t\t\t\t\tvar a = _fnSplitObjNotation( src );\n\t\n\t\t\t\t\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ ) {\n\t\t\t\t\t\t// Check if we are dealing with special notation\n\t\t\t\t\t\tarrayNotation = a[i].match(__reArray);\n\t\t\t\t\t\tfuncNotation = a[i].match(__reFn);\n\t\n\t\t\t\t\t\tif ( arrayNotation ) {\n\t\t\t\t\t\t\t// Array notation\n\t\t\t\t\t\t\ta[i] = a[i].replace(__reArray, '');\n\t\n\t\t\t\t\t\t\t// Condition allows simply [] to be passed in\n\t\t\t\t\t\t\tif ( a[i] !== \"\" ) {\n\t\t\t\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout = [];\n\t\n\t\t\t\t\t\t\t// Get the remainder of the nested object to get\n\t\t\t\t\t\t\ta.splice( 0, i+1 );\n\t\t\t\t\t\t\tinnerSrc = a.join('.');\n\t\n\t\t\t\t\t\t\t// Traverse each entry in the array getting the properties requested\n\t\t\t\t\t\t\tif ( Array.isArray( data ) ) {\n\t\t\t\t\t\t\t\tfor ( var j=0, jLen=data.length ; j<jLen ; j++ ) {\n\t\t\t\t\t\t\t\t\tout.push( fetchData( data[j], type, innerSrc ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// If a string is given in between the array notation indicators, that\n\t\t\t\t\t\t\t// is used to join the strings together, otherwise an array is returned\n\t\t\t\t\t\t\tvar join = arrayNotation[0].substring(1, arrayNotation[0].length-1);\n\t\t\t\t\t\t\tdata = (join===\"\") ? out : out.join(join);\n\t\n\t\t\t\t\t\t\t// The inner call to fetchData has already traversed through the remainder\n\t\t\t\t\t\t\t// of the source requested, so we exit from the loop\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( funcNotation ) {\n\t\t\t\t\t\t\t// Function call\n\t\t\t\t\t\t\ta[i] = a[i].replace(__reFn, '');\n\t\t\t\t\t\t\tdata = data[ a[i] ]();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( data === null || data[ a[i] ] === undefined ) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata = data[ a[i] ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\t\t};\n\t\n\t\t\treturn function (data, type) { // row and meta also passed, but not used\n\t\t\t\treturn fetchData( data, type, source );\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\t// Array or flat object mapping\n\t\t\treturn function (data, type) { // row and meta also passed, but not used\n\t\t\t\treturn data[source];\n\t\t\t};\n\t\t}\n\t}\n};\n\n\n\n/**\n * Create a mapping object that allows camel case parameters to be looked up\n * for their Hungarian counterparts. The mapping is stored in a private\n * parameter called `_hungarianMap` which can be accessed on the source object.\n *  @param {object} o\n *  @memberof DataTable#oApi\n */\nfunction _fnHungarianMap ( o )\n{\n\tvar\n\t\thungarian = 'a aa ai ao as b fn i m o s ',\n\t\tmatch,\n\t\tnewKey,\n\t\tmap = {};\n\n\t$.each( o, function (key, val) {\n\t\tmatch = key.match(/^([^A-Z]+?)([A-Z])/);\n\n\t\tif ( match && hungarian.indexOf(match[1]+' ') !== -1 )\n\t\t{\n\t\t\tnewKey = key.replace( match[0], match[2].toLowerCase() );\n\t\t\tmap[ newKey ] = key;\n\n\t\t\tif ( match[1] === 'o' )\n\t\t\t{\n\t\t\t\t_fnHungarianMap( o[key] );\n\t\t\t}\n\t\t}\n\t} );\n\n\to._hungarianMap = map;\n}\n\n\n/**\n * Convert from camel case parameters to Hungarian, based on a Hungarian map\n * created by _fnHungarianMap.\n *  @param {object} src The model object which holds all parameters that can be\n *    mapped.\n *  @param {object} user The object to convert from camel case to Hungarian.\n *  @param {boolean} force When set to `true`, properties which already have a\n *    Hungarian value in the `user` object will be overwritten. Otherwise they\n *    won't be.\n *  @memberof DataTable#oApi\n */\nfunction _fnCamelToHungarian ( src, user, force )\n{\n\tif ( ! src._hungarianMap ) {\n\t\t_fnHungarianMap( src );\n\t}\n\n\tvar hungarianKey;\n\n\t$.each( user, function (key, val) {\n\t\thungarianKey = src._hungarianMap[ key ];\n\n\t\tif ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )\n\t\t{\n\t\t\t// For objects, we need to buzz down into the object to copy parameters\n\t\t\tif ( hungarianKey.charAt(0) === 'o' )\n\t\t\t{\n\t\t\t\t// Copy the camelCase options over to the hungarian\n\t\t\t\tif ( ! user[ hungarianKey ] ) {\n\t\t\t\t\tuser[ hungarianKey ] = {};\n\t\t\t\t}\n\t\t\t\t$.extend( true, user[hungarianKey], user[key] );\n\n\t\t\t\t_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuser[hungarianKey] = user[ key ];\n\t\t\t}\n\t\t}\n\t} );\n}\n\n\n/**\n * Language compatibility - when certain options are given, and others aren't, we\n * need to duplicate the values over, in order to provide backwards compatibility\n * with older language files.\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnLanguageCompat( lang )\n{\n\t// Note the use of the Hungarian notation for the parameters in this method as\n\t// this is called after the mapping of camelCase to Hungarian\n\tvar defaults = DataTable.defaults.oLanguage;\n\n\t// Default mapping\n\tvar defaultDecimal = defaults.sDecimal;\n\tif ( defaultDecimal ) {\n\t\t_addNumericSort( defaultDecimal );\n\t}\n\n\tif ( lang ) {\n\t\tvar zeroRecords = lang.sZeroRecords;\n\n\t\t// Backwards compatibility - if there is no sEmptyTable given, then use the same as\n\t\t// sZeroRecords - assuming that is given.\n\t\tif ( ! lang.sEmptyTable && zeroRecords &&\n\t\t\tdefaults.sEmptyTable === \"No data available in table\" )\n\t\t{\n\t\t\t_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );\n\t\t}\n\n\t\t// Likewise with loading records\n\t\tif ( ! lang.sLoadingRecords && zeroRecords &&\n\t\t\tdefaults.sLoadingRecords === \"Loading...\" )\n\t\t{\n\t\t\t_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );\n\t\t}\n\n\t\t// Old parameter name of the thousands separator mapped onto the new\n\t\tif ( lang.sInfoThousands ) {\n\t\t\tlang.sThousands = lang.sInfoThousands;\n\t\t}\n\n\t\tvar decimal = lang.sDecimal;\n\t\tif ( decimal && defaultDecimal !== decimal ) {\n\t\t\t_addNumericSort( decimal );\n\t\t}\n\t}\n}\n\n\n/**\n * Map one parameter onto another\n *  @param {object} o Object to map\n *  @param {*} knew The new parameter name\n *  @param {*} old The old parameter name\n */\nvar _fnCompatMap = function ( o, knew, old ) {\n\tif ( o[ knew ] !== undefined ) {\n\t\to[ old ] = o[ knew ];\n\t}\n};\n\n\n/**\n * Provide backwards compatibility for the main DT options. Note that the new\n * options are mapped onto the old parameters, so this is an external interface\n * change only.\n *  @param {object} init Object to map\n */\nfunction _fnCompatOpts ( init )\n{\n\t_fnCompatMap( init, 'ordering',      'bSort' );\n\t_fnCompatMap( init, 'orderMulti',    'bSortMulti' );\n\t_fnCompatMap( init, 'orderClasses',  'bSortClasses' );\n\t_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );\n\t_fnCompatMap( init, 'order',         'aaSorting' );\n\t_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );\n\t_fnCompatMap( init, 'paging',        'bPaginate' );\n\t_fnCompatMap( init, 'pagingType',    'sPaginationType' );\n\t_fnCompatMap( init, 'pageLength',    'iDisplayLength' );\n\t_fnCompatMap( init, 'searching',     'bFilter' );\n\n\t// Boolean initialisation of x-scrolling\n\tif ( typeof init.sScrollX === 'boolean' ) {\n\t\tinit.sScrollX = init.sScrollX ? '100%' : '';\n\t}\n\tif ( typeof init.scrollX === 'boolean' ) {\n\t\tinit.scrollX = init.scrollX ? '100%' : '';\n\t}\n\n\t// Column search objects are in an array, so it needs to be converted\n\t// element by element\n\tvar searchCols = init.aoSearchCols;\n\n\tif ( searchCols ) {\n\t\tfor ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {\n\t\t\tif ( searchCols[i] ) {\n\t\t\t\t_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Provide backwards compatibility for column options. Note that the new options\n * are mapped onto the old parameters, so this is an external interface change\n * only.\n *  @param {object} init Object to map\n */\nfunction _fnCompatCols ( init )\n{\n\t_fnCompatMap( init, 'orderable',     'bSortable' );\n\t_fnCompatMap( init, 'orderData',     'aDataSort' );\n\t_fnCompatMap( init, 'orderSequence', 'asSorting' );\n\t_fnCompatMap( init, 'orderDataType', 'sortDataType' );\n\n\t// orderData can be given as an integer\n\tvar dataSort = init.aDataSort;\n\tif ( typeof dataSort === 'number' && ! Array.isArray( dataSort ) ) {\n\t\tinit.aDataSort = [ dataSort ];\n\t}\n}\n\n\n/**\n * Browser feature detection for capabilities, quirks\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnBrowserDetect( settings )\n{\n\t// We don't need to do this every time DataTables is constructed, the values\n\t// calculated are specific to the browser and OS configuration which we\n\t// don't expect to change between initialisations\n\tif ( ! DataTable.__browser ) {\n\t\tvar browser = {};\n\t\tDataTable.__browser = browser;\n\n\t\t// Scrolling feature / quirks detection\n\t\tvar n = $('<div/>')\n\t\t\t.css( {\n\t\t\t\tposition: 'fixed',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: $(window).scrollLeft()*-1, // allow for scrolling\n\t\t\t\theight: 1,\n\t\t\t\twidth: 1,\n\t\t\t\toverflow: 'hidden'\n\t\t\t} )\n\t\t\t.append(\n\t\t\t\t$('<div/>')\n\t\t\t\t\t.css( {\n\t\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\t\ttop: 1,\n\t\t\t\t\t\tleft: 1,\n\t\t\t\t\t\twidth: 100,\n\t\t\t\t\t\toverflow: 'scroll'\n\t\t\t\t\t} )\n\t\t\t\t\t.append(\n\t\t\t\t\t\t$('<div/>')\n\t\t\t\t\t\t\t.css( {\n\t\t\t\t\t\t\t\twidth: '100%',\n\t\t\t\t\t\t\t\theight: 10\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t)\n\t\t\t)\n\t\t\t.appendTo( 'body' );\n\n\t\tvar outer = n.children();\n\t\tvar inner = outer.children();\n\n\t\t// Numbers below, in order, are:\n\t\t// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth\n\t\t//\n\t\t// IE6 XP:                           100 100 100  83\n\t\t// IE7 Vista:                        100 100 100  83\n\t\t// IE 8+ Windows:                     83  83 100  83\n\t\t// Evergreen Windows:                 83  83 100  83\n\t\t// Evergreen Mac with scrollbars:     85  85 100  85\n\t\t// Evergreen Mac without scrollbars: 100 100 100 100\n\n\t\t// Get scrollbar width\n\t\tbrowser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;\n\n\t\t// IE6/7 will oversize a width 100% element inside a scrolling element, to\n\t\t// include the width of the scrollbar, while other browsers ensure the inner\n\t\t// element is contained without forcing scrolling\n\t\tbrowser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;\n\n\t\t// In rtl text layout, some browsers (most, but not all) will place the\n\t\t// scrollbar on the left, rather than the right.\n\t\tbrowser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;\n\n\t\t// IE8- don't provide height and width for getBoundingClientRect\n\t\tbrowser.bBounding = n[0].getBoundingClientRect().width ? true : false;\n\n\t\tn.remove();\n\t}\n\n\t$.extend( settings.oBrowser, DataTable.__browser );\n\tsettings.oScroll.iBarWidth = DataTable.__browser.barWidth;\n}\n\n\n/**\n * Array.prototype reduce[Right] method, used for browsers which don't support\n * JS 1.6. Done this way to reduce code size, since we iterate either way\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnReduce ( that, fn, init, start, end, inc )\n{\n\tvar\n\t\ti = start,\n\t\tvalue,\n\t\tisSet = false;\n\n\tif ( init !== undefined ) {\n\t\tvalue = init;\n\t\tisSet = true;\n\t}\n\n\twhile ( i !== end ) {\n\t\tif ( ! that.hasOwnProperty(i) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = isSet ?\n\t\t\tfn( value, that[i], i, that ) :\n\t\t\tthat[i];\n\n\t\tisSet = true;\n\t\ti += inc;\n\t}\n\n\treturn value;\n}\n\n/**\n * Add a column to the list used for the table with default values\n *  @param {object} oSettings dataTables settings object\n *  @param {node} nTh The th element for this column\n *  @memberof DataTable#oApi\n */\nfunction _fnAddColumn( oSettings, nTh )\n{\n\t// Add column to aoColumns array\n\tvar oDefaults = DataTable.defaults.column;\n\tvar iCol = oSettings.aoColumns.length;\n\tvar oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {\n\t\t\"nTh\": nTh ? nTh : document.createElement('th'),\n\t\t\"sTitle\":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',\n\t\t\"aDataSort\": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\n\t\t\"mData\": oDefaults.mData ? oDefaults.mData : iCol,\n\t\tidx: iCol\n\t} );\n\toSettings.aoColumns.push( oCol );\n\n\t// Add search object for column specific search. Note that the `searchCols[ iCol ]`\n\t// passed into extend can be undefined. This allows the user to give a default\n\t// with only some of the parameters defined, and also not give a default\n\tvar searchCols = oSettings.aoPreSearchCols;\n\tsearchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );\n\n\t// Use the default column options function to initialise classes etc\n\t_fnColumnOptions( oSettings, iCol, $(nTh).data() );\n}\n\n\n/**\n * Apply options for a column\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iCol column index to consider\n *  @param {object} oOptions object with sType, bVisible and bSearchable etc\n *  @memberof DataTable#oApi\n */\nfunction _fnColumnOptions( oSettings, iCol, oOptions )\n{\n\tvar oCol = oSettings.aoColumns[ iCol ];\n\tvar oClasses = oSettings.oClasses;\n\tvar th = $(oCol.nTh);\n\n\t// Try to get width information from the DOM. We can't get it from CSS\n\t// as we'd need to parse the CSS stylesheet. `width` option can override\n\tif ( ! oCol.sWidthOrig ) {\n\t\t// Width attribute\n\t\toCol.sWidthOrig = th.attr('width') || null;\n\n\t\t// Style attribute\n\t\tvar t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/);\n\t\tif ( t ) {\n\t\t\toCol.sWidthOrig = t[1];\n\t\t}\n\t}\n\n\t/* User specified column options */\n\tif ( oOptions !== undefined && oOptions !== null )\n\t{\n\t\t// Backwards compatibility\n\t\t_fnCompatCols( oOptions );\n\n\t\t// Map camel case parameters to their Hungarian counterparts\n\t\t_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );\n\n\t\t/* Backwards compatibility for mDataProp */\n\t\tif ( oOptions.mDataProp !== undefined && !oOptions.mData )\n\t\t{\n\t\t\toOptions.mData = oOptions.mDataProp;\n\t\t}\n\n\t\tif ( oOptions.sType )\n\t\t{\n\t\t\toCol._sManualType = oOptions.sType;\n\t\t}\n\n\t\t// `class` is a reserved word in Javascript, so we need to provide\n\t\t// the ability to use a valid name for the camel case input\n\t\tif ( oOptions.className && ! oOptions.sClass )\n\t\t{\n\t\t\toOptions.sClass = oOptions.className;\n\t\t}\n\t\tif ( oOptions.sClass ) {\n\t\t\tth.addClass( oOptions.sClass );\n\t\t}\n\n\t\tvar origClass = oCol.sClass;\n\n\t\t$.extend( oCol, oOptions );\n\t\t_fnMap( oCol, oOptions, \"sWidth\", \"sWidthOrig\" );\n\n\t\t// Merge class from previously defined classes with this one, rather than just\n\t\t// overwriting it in the extend above\n\t\tif (origClass !== oCol.sClass) {\n\t\t\toCol.sClass = origClass + ' ' + oCol.sClass;\n\t\t}\n\n\t\t/* iDataSort to be applied (backwards compatibility), but aDataSort will take\n\t\t * priority if defined\n\t\t */\n\t\tif ( oOptions.iDataSort !== undefined )\n\t\t{\n\t\t\toCol.aDataSort = [ oOptions.iDataSort ];\n\t\t}\n\t\t_fnMap( oCol, oOptions, \"aDataSort\" );\n\t}\n\n\t/* Cache the data get and set functions for speed */\n\tvar mDataSrc = oCol.mData;\n\tvar mData = _fnGetObjectDataFn( mDataSrc );\n\tvar mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;\n\n\tvar attrTest = function( src ) {\n\t\treturn typeof src === 'string' && src.indexOf('@') !== -1;\n\t};\n\toCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (\n\t\tattrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)\n\t);\n\toCol._setter = null;\n\n\toCol.fnGetData = function (rowData, type, meta) {\n\t\tvar innerData = mData( rowData, type, undefined, meta );\n\n\t\treturn mRender && type ?\n\t\t\tmRender( innerData, type, rowData, meta ) :\n\t\t\tinnerData;\n\t};\n\toCol.fnSetData = function ( rowData, val, meta ) {\n\t\treturn _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );\n\t};\n\n\t// Indicate if DataTables should read DOM data as an object or array\n\t// Used in _fnGetRowElements\n\tif ( typeof mDataSrc !== 'number' && ! oCol._isArrayHost ) {\n\t\toSettings._rowReadObject = true;\n\t}\n\n\t/* Feature sorting overrides column specific when off */\n\tif ( !oSettings.oFeatures.bSort )\n\t{\n\t\toCol.bSortable = false;\n\t\tth.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called\n\t}\n\n\t/* Check that the class assignment is correct for sorting */\n\tvar bAsc = $.inArray('asc', oCol.asSorting) !== -1;\n\tvar bDesc = $.inArray('desc', oCol.asSorting) !== -1;\n\tif ( !oCol.bSortable || (!bAsc && !bDesc) )\n\t{\n\t\toCol.sSortingClass = oClasses.sSortableNone;\n\t\toCol.sSortingClassJUI = \"\";\n\t}\n\telse if ( bAsc && !bDesc )\n\t{\n\t\toCol.sSortingClass = oClasses.sSortableAsc;\n\t\toCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;\n\t}\n\telse if ( !bAsc && bDesc )\n\t{\n\t\toCol.sSortingClass = oClasses.sSortableDesc;\n\t\toCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;\n\t}\n\telse\n\t{\n\t\toCol.sSortingClass = oClasses.sSortable;\n\t\toCol.sSortingClassJUI = oClasses.sSortJUI;\n\t}\n}\n\n\n/**\n * Adjust the table column widths for new data. Note: you would probably want to\n * do a redraw after calling this function!\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnAdjustColumnSizing ( settings )\n{\n\t/* Not interested in doing column width calculation if auto-width is disabled */\n\tif ( settings.oFeatures.bAutoWidth !== false )\n\t{\n\t\tvar columns = settings.aoColumns;\n\n\t\t_fnCalculateColumnWidths( settings );\n\t\tfor ( var i=0 , iLen=columns.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tcolumns[i].nTh.style.width = columns[i].sWidth;\n\t\t}\n\t}\n\n\tvar scroll = settings.oScroll;\n\tif ( scroll.sY !== '' || scroll.sX !== '')\n\t{\n\t\t_fnScrollDraw( settings );\n\t}\n\n\t_fnCallbackFire( settings, null, 'column-sizing', [settings] );\n}\n\n\n/**\n * Convert the index of a visible column to the index in the data array (take account\n * of hidden columns)\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iMatch Visible column index to lookup\n *  @returns {int} i the data index\n *  @memberof DataTable#oApi\n */\nfunction _fnVisibleToColumnIndex( oSettings, iMatch )\n{\n\tvar aiVis = _fnGetColumns( oSettings, 'bVisible' );\n\n\treturn typeof aiVis[iMatch] === 'number' ?\n\t\taiVis[iMatch] :\n\t\tnull;\n}\n\n\n/**\n * Convert the index of an index in the data array and convert it to the visible\n *   column index (take account of hidden columns)\n *  @param {int} iMatch Column index to lookup\n *  @param {object} oSettings dataTables settings object\n *  @returns {int} i the data index\n *  @memberof DataTable#oApi\n */\nfunction _fnColumnIndexToVisible( oSettings, iMatch )\n{\n\tvar aiVis = _fnGetColumns( oSettings, 'bVisible' );\n\tvar iPos = $.inArray( iMatch, aiVis );\n\n\treturn iPos !== -1 ? iPos : null;\n}\n\n\n/**\n * Get the number of visible columns\n *  @param {object} oSettings dataTables settings object\n *  @returns {int} i the number of visible columns\n *  @memberof DataTable#oApi\n */\nfunction _fnVisbleColumns( oSettings )\n{\n\tvar vis = 0;\n\n\t// No reduce in IE8, use a loop for now\n\t$.each( oSettings.aoColumns, function ( i, col ) {\n\t\tif ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {\n\t\t\tvis++;\n\t\t}\n\t} );\n\n\treturn vis;\n}\n\n\n/**\n * Get an array of column indexes that match a given property\n *  @param {object} oSettings dataTables settings object\n *  @param {string} sParam Parameter in aoColumns to look for - typically\n *    bVisible or bSearchable\n *  @returns {array} Array of indexes with matched properties\n *  @memberof DataTable#oApi\n */\nfunction _fnGetColumns( oSettings, sParam )\n{\n\tvar a = [];\n\n\t$.map( oSettings.aoColumns, function(val, i) {\n\t\tif ( val[sParam] ) {\n\t\t\ta.push( i );\n\t\t}\n\t} );\n\n\treturn a;\n}\n\n\n/**\n * Calculate the 'type' of a column\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnColumnTypes ( settings )\n{\n\tvar columns = settings.aoColumns;\n\tvar data = settings.aoData;\n\tvar types = DataTable.ext.type.detect;\n\tvar i, ien, j, jen, k, ken;\n\tvar col, cell, detectedType, cache;\n\n\t// For each column, spin over the \n\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\tcol = columns[i];\n\t\tcache = [];\n\n\t\tif ( ! col.sType && col._sManualType ) {\n\t\t\tcol.sType = col._sManualType;\n\t\t}\n\t\telse if ( ! col.sType ) {\n\t\t\tfor ( j=0, jen=types.length ; j<jen ; j++ ) {\n\t\t\t\tfor ( k=0, ken=data.length ; k<ken ; k++ ) {\n\t\t\t\t\t// Use a cache array so we only need to get the type data\n\t\t\t\t\t// from the formatter once (when using multiple detectors)\n\t\t\t\t\tif ( cache[k] === undefined ) {\n\t\t\t\t\t\tcache[k] = _fnGetCellData( settings, k, i, 'type' );\n\t\t\t\t\t}\n\n\t\t\t\t\tdetectedType = types[j]( cache[k], settings );\n\n\t\t\t\t\t// If null, then this type can't apply to this column, so\n\t\t\t\t\t// rather than testing all cells, break out. There is an\n\t\t\t\t\t// exception for the last type which is `html`. We need to\n\t\t\t\t\t// scan all rows since it is possible to mix string and HTML\n\t\t\t\t\t// types\n\t\t\t\t\tif ( ! detectedType && j !== types.length-1 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only a single match is needed for html type since it is\n\t\t\t\t\t// bottom of the pile and very similar to string - but it\n\t\t\t\t\t// must not be empty\n\t\t\t\t\tif ( detectedType === 'html' && ! _empty(cache[k]) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Type is valid for all data points in the column - use this\n\t\t\t\t// type\n\t\t\t\tif ( detectedType ) {\n\t\t\t\t\tcol.sType = detectedType;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fall back - if no type was detected, always use string\n\t\t\tif ( ! col.sType ) {\n\t\t\t\tcol.sType = 'string';\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Take the column definitions and static columns arrays and calculate how\n * they relate to column indexes. The callback function will then apply the\n * definition found for a column to a suitable configuration object.\n *  @param {object} oSettings dataTables settings object\n *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\n *  @param {array} aoCols The aoColumns array that defines columns individually\n *  @param {function} fn Callback function - takes two parameters, the calculated\n *    column index and the definition for that column.\n *  @memberof DataTable#oApi\n */\nfunction _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )\n{\n\tvar i, iLen, j, jLen, k, kLen, def;\n\tvar columns = oSettings.aoColumns;\n\n\t// Column definitions with aTargets\n\tif ( aoColDefs )\n\t{\n\t\t/* Loop over the definitions array - loop in reverse so first instance has priority */\n\t\tfor ( i=aoColDefs.length-1 ; i>=0 ; i-- )\n\t\t{\n\t\t\tdef = aoColDefs[i];\n\n\t\t\t/* Each definition can target multiple columns, as it is an array */\n\t\t\tvar aTargets = def.target !== undefined\n\t\t\t\t? def.target\n\t\t\t\t: def.targets !== undefined\n\t\t\t\t\t? def.targets\n\t\t\t\t\t: def.aTargets;\n\n\t\t\tif ( ! Array.isArray( aTargets ) )\n\t\t\t{\n\t\t\t\taTargets = [ aTargets ];\n\t\t\t}\n\n\t\t\tfor ( j=0, jLen=aTargets.length ; j<jLen ; j++ )\n\t\t\t{\n\t\t\t\tif ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )\n\t\t\t\t{\n\t\t\t\t\t/* Add columns that we don't yet know about */\n\t\t\t\t\twhile( columns.length <= aTargets[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\t_fnAddColumn( oSettings );\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Integer, basic index */\n\t\t\t\t\tfn( aTargets[j], def );\n\t\t\t\t}\n\t\t\t\telse if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )\n\t\t\t\t{\n\t\t\t\t\t/* Negative integer, right to left column counting */\n\t\t\t\t\tfn( columns.length+aTargets[j], def );\n\t\t\t\t}\n\t\t\t\telse if ( typeof aTargets[j] === 'string' )\n\t\t\t\t{\n\t\t\t\t\t/* Class name matching on TH element */\n\t\t\t\t\tfor ( k=0, kLen=columns.length ; k<kLen ; k++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( aTargets[j] == \"_all\" ||\n\t\t\t\t\t\t     $(columns[k].nTh).hasClass( aTargets[j] ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfn( k, def );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Statically defined columns array\n\tif ( aoCols )\n\t{\n\t\tfor ( i=0, iLen=aoCols.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfn( i, aoCols[i] );\n\t\t}\n\t}\n}\n\n/**\n * Add a data array to the table, creating DOM node etc. This is the parallel to\n * _fnGatherData, but for adding rows from a Javascript source, rather than a\n * DOM source.\n *  @param {object} oSettings dataTables settings object\n *  @param {array} aData data array to be added\n *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n *    DataTables will create a row automatically\n *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n *    if nTr is.\n *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n *  @memberof DataTable#oApi\n */\nfunction _fnAddData ( oSettings, aDataIn, nTr, anTds )\n{\n\t/* Create the object for storing information about this new row */\n\tvar iRow = oSettings.aoData.length;\n\tvar oData = $.extend( true, {}, DataTable.models.oRow, {\n\t\tsrc: nTr ? 'dom' : 'data',\n\t\tidx: iRow\n\t} );\n\n\toData._aData = aDataIn;\n\toSettings.aoData.push( oData );\n\n\t/* Create the cells */\n\tvar nTd, sThisType;\n\tvar columns = oSettings.aoColumns;\n\n\t// Invalidate the column types as the new data needs to be revalidated\n\tfor ( var i=0, iLen=columns.length ; i<iLen ; i++ )\n\t{\n\t\tcolumns[i].sType = null;\n\t}\n\n\t/* Add to the display array */\n\toSettings.aiDisplayMaster.push( iRow );\n\n\tvar id = oSettings.rowIdFn( aDataIn );\n\tif ( id !== undefined ) {\n\t\toSettings.aIds[ id ] = oData;\n\t}\n\n\t/* Create the DOM information, or register it if already present */\n\tif ( nTr || ! oSettings.oFeatures.bDeferRender )\n\t{\n\t\t_fnCreateTr( oSettings, iRow, nTr, anTds );\n\t}\n\n\treturn iRow;\n}\n\n\n/**\n * Add one or more TR elements to the table. Generally we'd expect to\n * use this for reading data from a DOM sourced table, but it could be\n * used for an TR element. Note that if a TR is given, it is used (i.e.\n * it is not cloned).\n *  @param {object} settings dataTables settings object\n *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n *  @returns {array} Array of indexes for the added rows\n *  @memberof DataTable#oApi\n */\nfunction _fnAddTr( settings, trs )\n{\n\tvar row;\n\n\t// Allow an individual node to be passed in\n\tif ( ! (trs instanceof $) ) {\n\t\ttrs = $(trs);\n\t}\n\n\treturn trs.map( function (i, el) {\n\t\trow = _fnGetRowElements( settings, el );\n\t\treturn _fnAddData( settings, row.data, el, row.cells );\n\t} );\n}\n\n\n/**\n * Take a TR element and convert it to an index in aoData\n *  @param {object} oSettings dataTables settings object\n *  @param {node} n the TR element to find\n *  @returns {int} index if the node is found, null if not\n *  @memberof DataTable#oApi\n */\nfunction _fnNodeToDataIndex( oSettings, n )\n{\n\treturn (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;\n}\n\n\n/**\n * Take a TD element and convert it into a column data index (not the visible index)\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iRow The row number the TD/TH can be found in\n *  @param {node} n The TD/TH element to find\n *  @returns {int} index if the node is found, -1 if not\n *  @memberof DataTable#oApi\n */\nfunction _fnNodeToColumnIndex( oSettings, iRow, n )\n{\n\treturn $.inArray( n, oSettings.aoData[ iRow ].anCells );\n}\n\n\n/**\n * Get the data for a given cell from the internal cache, taking into account data mapping\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')\n *  @returns {*} Cell data\n *  @memberof DataTable#oApi\n */\nfunction _fnGetCellData( settings, rowIdx, colIdx, type )\n{\n\tif (type === 'search') {\n\t\ttype = 'filter';\n\t}\n\telse if (type === 'order') {\n\t\ttype = 'sort';\n\t}\n\n\tvar draw           = settings.iDraw;\n\tvar col            = settings.aoColumns[colIdx];\n\tvar rowData        = settings.aoData[rowIdx]._aData;\n\tvar defaultContent = col.sDefaultContent;\n\tvar cellData       = col.fnGetData( rowData, type, {\n\t\tsettings: settings,\n\t\trow:      rowIdx,\n\t\tcol:      colIdx\n\t} );\n\n\tif ( cellData === undefined ) {\n\t\tif ( settings.iDrawError != draw && defaultContent === null ) {\n\t\t\t_fnLog( settings, 0, \"Requested unknown parameter \"+\n\t\t\t\t(typeof col.mData=='function' ? '{function}' : \"'\"+col.mData+\"'\")+\n\t\t\t\t\" for row \"+rowIdx+\", column \"+colIdx, 4 );\n\t\t\tsettings.iDrawError = draw;\n\t\t}\n\t\treturn defaultContent;\n\t}\n\n\t// When the data source is null and a specific data type is requested (i.e.\n\t// not the original data), we can use default column data\n\tif ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {\n\t\tcellData = defaultContent;\n\t}\n\telse if ( typeof cellData === 'function' ) {\n\t\t// If the data source is a function, then we run it and use the return,\n\t\t// executing in the scope of the data object (for instances)\n\t\treturn cellData.call( rowData );\n\t}\n\n\tif ( cellData === null && type === 'display' ) {\n\t\treturn '';\n\t}\n\n\tif ( type === 'filter' ) {\n\t\tvar fomatters = DataTable.ext.type.search;\n\n\t\tif ( fomatters[ col.sType ] ) {\n\t\t\tcellData = fomatters[ col.sType ]( cellData );\n\t\t}\n\t}\n\n\treturn cellData;\n}\n\n\n/**\n * Set the value for a specific cell, into the internal data cache\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {*} val Value to set\n *  @memberof DataTable#oApi\n */\nfunction _fnSetCellData( settings, rowIdx, colIdx, val )\n{\n\tvar col     = settings.aoColumns[colIdx];\n\tvar rowData = settings.aoData[rowIdx]._aData;\n\n\tcol.fnSetData( rowData, val, {\n\t\tsettings: settings,\n\t\trow:      rowIdx,\n\t\tcol:      colIdx\n\t}  );\n}\n\n\n// Private variable that is used to match action syntax in the data property object\nvar __reArray = /\\[.*?\\]$/;\nvar __reFn = /\\(\\)$/;\n\n/**\n * Split string on periods, taking into account escaped periods\n * @param  {string} str String to split\n * @return {array} Split string\n */\nfunction _fnSplitObjNotation( str )\n{\n\treturn $.map( str.match(/(\\\\.|[^\\.])+/g) || [''], function ( s ) {\n\t\treturn s.replace(/\\\\\\./g, '.');\n\t} );\n}\n\n\n/**\n * Return a function that can be used to get data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data get function\n *  @memberof DataTable#oApi\n */\nvar _fnGetObjectDataFn = DataTable.util.get;\n\n\n/**\n * Return a function that can be used to set data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data set function\n *  @memberof DataTable#oApi\n */\nvar _fnSetObjectDataFn = DataTable.util.set;\n\n\n/**\n * Return an array with the full table data\n *  @param {object} oSettings dataTables settings object\n *  @returns array {array} aData Master data array\n *  @memberof DataTable#oApi\n */\nfunction _fnGetDataMaster ( settings )\n{\n\treturn _pluck( settings.aoData, '_aData' );\n}\n\n\n/**\n * Nuke the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnClearTable( settings )\n{\n\tsettings.aoData.length = 0;\n\tsettings.aiDisplayMaster.length = 0;\n\tsettings.aiDisplay.length = 0;\n\tsettings.aIds = {};\n}\n\n\n /**\n * Take an array of integers (index array) and remove a target integer (value - not\n * the key!)\n *  @param {array} a Index array to target\n *  @param {int} iTarget value to find\n *  @memberof DataTable#oApi\n */\nfunction _fnDeleteIndex( a, iTarget, splice )\n{\n\tvar iTargetIndex = -1;\n\n\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t{\n\t\tif ( a[i] == iTarget )\n\t\t{\n\t\t\tiTargetIndex = i;\n\t\t}\n\t\telse if ( a[i] > iTarget )\n\t\t{\n\t\t\ta[i]--;\n\t\t}\n\t}\n\n\tif ( iTargetIndex != -1 && splice === undefined )\n\t{\n\t\ta.splice( iTargetIndex, 1 );\n\t}\n}\n\n\n/**\n * Mark cached data as invalid such that a re-read of the data will occur when\n * the cached data is next requested. Also update from the data source object.\n *\n * @param {object} settings DataTables settings object\n * @param {int}    rowIdx   Row index to invalidate\n * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'\n *     or 'data'\n * @param {int}    [colIdx] Column index to invalidate. If undefined the whole\n *     row will be invalidated\n * @memberof DataTable#oApi\n *\n * @todo For the modularisation of v1.11 this will need to become a callback, so\n *   the sort and filter methods can subscribe to it. That will required\n *   initialisation options for sorting, which is why it is not already baked in\n */\nfunction _fnInvalidate( settings, rowIdx, src, colIdx )\n{\n\tvar row = settings.aoData[ rowIdx ];\n\tvar i, ien;\n\tvar cellWrite = function ( cell, col ) {\n\t\t// This is very frustrating, but in IE if you just write directly\n\t\t// to innerHTML, and elements that are overwritten are GC'ed,\n\t\t// even if there is a reference to them elsewhere\n\t\twhile ( cell.childNodes.length ) {\n\t\t\tcell.removeChild( cell.firstChild );\n\t\t}\n\n\t\tcell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );\n\t};\n\n\t// Are we reading last data from DOM or the data object?\n\tif ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {\n\t\t// Read the data from the DOM\n\t\trow._aData = _fnGetRowElements(\n\t\t\t\tsettings, row, colIdx, colIdx === undefined ? undefined : row._aData\n\t\t\t)\n\t\t\t.data;\n\t}\n\telse {\n\t\t// Reading from data object, update the DOM\n\t\tvar cells = row.anCells;\n\n\t\tif ( cells ) {\n\t\t\tif ( colIdx !== undefined ) {\n\t\t\t\tcellWrite( cells[colIdx], colIdx );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\t\t\t\tcellWrite( cells[i], i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// For both row and cell invalidation, the cached data for sorting and\n\t// filtering is nulled out\n\trow._aSortData = null;\n\trow._aFilterData = null;\n\n\t// Invalidate the type for a specific column (if given) or all columns since\n\t// the data might have changed\n\tvar cols = settings.aoColumns;\n\tif ( colIdx !== undefined ) {\n\t\tcols[ colIdx ].sType = null;\n\t}\n\telse {\n\t\tfor ( i=0, ien=cols.length ; i<ien ; i++ ) {\n\t\t\tcols[i].sType = null;\n\t\t}\n\n\t\t// Update DataTables special `DT_*` attributes for the row\n\t\t_fnRowAttributes( settings, row );\n\t}\n}\n\n\n/**\n * Build a data source object from an HTML row, reading the contents of the\n * cells that are in the row.\n *\n * @param {object} settings DataTables settings object\n * @param {node|object} TR element from which to read data or existing row\n *   object from which to re-read the data from the cells\n * @param {int} [colIdx] Optional column index\n * @param {array|object} [d] Data source object. If `colIdx` is given then this\n *   parameter should also be given and will be used to write the data into.\n *   Only the column in question will be written\n * @returns {object} Object with two parameters: `data` the data read, in\n *   document order, and `cells` and array of nodes (they can be useful to the\n *   caller, so rather than needing a second traversal to get them, just return\n *   them from here).\n * @memberof DataTable#oApi\n */\nfunction _fnGetRowElements( settings, row, colIdx, d )\n{\n\tvar\n\t\ttds = [],\n\t\ttd = row.firstChild,\n\t\tname, col, o, i=0, contents,\n\t\tcolumns = settings.aoColumns,\n\t\tobjectRead = settings._rowReadObject;\n\n\t// Allow the data object to be passed in, or construct\n\td = d !== undefined ?\n\t\td :\n\t\tobjectRead ?\n\t\t\t{} :\n\t\t\t[];\n\n\tvar attr = function ( str, td  ) {\n\t\tif ( typeof str === 'string' ) {\n\t\t\tvar idx = str.indexOf('@');\n\n\t\t\tif ( idx !== -1 ) {\n\t\t\t\tvar attr = str.substring( idx+1 );\n\t\t\t\tvar setter = _fnSetObjectDataFn( str );\n\t\t\t\tsetter( d, td.getAttribute( attr ) );\n\t\t\t}\n\t\t}\n\t};\n\n\t// Read data from a cell and store into the data object\n\tvar cellProcess = function ( cell ) {\n\t\tif ( colIdx === undefined || colIdx === i ) {\n\t\t\tcol = columns[i];\n\t\t\tcontents = (cell.innerHTML).trim();\n\n\t\t\tif ( col && col._bAttrSrc ) {\n\t\t\t\tvar setter = _fnSetObjectDataFn( col.mData._ );\n\t\t\t\tsetter( d, contents );\n\n\t\t\t\tattr( col.mData.sort, cell );\n\t\t\t\tattr( col.mData.type, cell );\n\t\t\t\tattr( col.mData.filter, cell );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Depending on the `data` option for the columns the data can\n\t\t\t\t// be read to either an object or an array.\n\t\t\t\tif ( objectRead ) {\n\t\t\t\t\tif ( ! col._setter ) {\n\t\t\t\t\t\t// Cache the setter function\n\t\t\t\t\t\tcol._setter = _fnSetObjectDataFn( col.mData );\n\t\t\t\t\t}\n\t\t\t\t\tcol._setter( d, contents );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td[i] = contents;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t};\n\n\tif ( td ) {\n\t\t// `tr` element was passed in\n\t\twhile ( td ) {\n\t\t\tname = td.nodeName.toUpperCase();\n\n\t\t\tif ( name == \"TD\" || name == \"TH\" ) {\n\t\t\t\tcellProcess( td );\n\t\t\t\ttds.push( td );\n\t\t\t}\n\n\t\t\ttd = td.nextSibling;\n\t\t}\n\t}\n\telse {\n\t\t// Existing row object passed in\n\t\ttds = row.anCells;\n\n\t\tfor ( var j=0, jen=tds.length ; j<jen ; j++ ) {\n\t\t\tcellProcess( tds[j] );\n\t\t}\n\t}\n\n\t// Read the ID from the DOM if present\n\tvar rowNode = row.firstChild ? row : row.nTr;\n\n\tif ( rowNode ) {\n\t\tvar id = rowNode.getAttribute( 'id' );\n\n\t\tif ( id ) {\n\t\t\t_fnSetObjectDataFn( settings.rowId )( d, id );\n\t\t}\n\t}\n\n\treturn {\n\t\tdata: d,\n\t\tcells: tds\n\t};\n}\n/**\n * Create a new TR element (and it's TD children) for a row\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iRow Row to consider\n *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\n *    DataTables will create a row automatically\n *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n *    if nTr is.\n *  @memberof DataTable#oApi\n */\nfunction _fnCreateTr ( oSettings, iRow, nTrIn, anTds )\n{\n\tvar\n\t\trow = oSettings.aoData[iRow],\n\t\trowData = row._aData,\n\t\tcells = [],\n\t\tnTr, nTd, oCol,\n\t\ti, iLen, create;\n\n\tif ( row.nTr === null )\n\t{\n\t\tnTr = nTrIn || document.createElement('tr');\n\n\t\trow.nTr = nTr;\n\t\trow.anCells = cells;\n\n\t\t/* Use a private property on the node to allow reserve mapping from the node\n\t\t * to the aoData array for fast look up\n\t\t */\n\t\tnTr._DT_RowIndex = iRow;\n\n\t\t/* Special parameters can be given by the data source to be used on the row */\n\t\t_fnRowAttributes( oSettings, row );\n\n\t\t/* Process each column */\n\t\tfor ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )\n\t\t{\n\t\t\toCol = oSettings.aoColumns[i];\n\t\t\tcreate = nTrIn ? false : true;\n\n\t\t\tnTd = create ? document.createElement( oCol.sCellType ) : anTds[i];\n\n\t\t\tif (! nTd) {\n\t\t\t\t_fnLog( oSettings, 0, 'Incorrect column count', 18 );\n\t\t\t}\n\n\t\t\tnTd._DT_CellIndex = {\n\t\t\t\trow: iRow,\n\t\t\t\tcolumn: i\n\t\t\t};\n\t\t\t\n\t\t\tcells.push( nTd );\n\n\t\t\t// Need to create the HTML if new, or if a rendering function is defined\n\t\t\tif ( create || ((oCol.mRender || oCol.mData !== i) &&\n\t\t\t\t (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')\n\t\t\t)) {\n\t\t\t\tnTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );\n\t\t\t}\n\n\t\t\t/* Add user defined class */\n\t\t\tif ( oCol.sClass )\n\t\t\t{\n\t\t\t\tnTd.className += ' '+oCol.sClass;\n\t\t\t}\n\n\t\t\t// Visibility - add or remove as required\n\t\t\tif ( oCol.bVisible && ! nTrIn )\n\t\t\t{\n\t\t\t\tnTr.appendChild( nTd );\n\t\t\t}\n\t\t\telse if ( ! oCol.bVisible && nTrIn )\n\t\t\t{\n\t\t\t\tnTd.parentNode.removeChild( nTd );\n\t\t\t}\n\n\t\t\tif ( oCol.fnCreatedCell )\n\t\t\t{\n\t\t\t\toCol.fnCreatedCell.call( oSettings.oInstance,\n\t\t\t\t\tnTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells] );\n\t}\n}\n\n\n/**\n * Add attributes to a row based on the special `DT_*` parameters in a data\n * source object.\n *  @param {object} settings DataTables settings object\n *  @param {object} DataTables row object for the row to be modified\n *  @memberof DataTable#oApi\n */\nfunction _fnRowAttributes( settings, row )\n{\n\tvar tr = row.nTr;\n\tvar data = row._aData;\n\n\tif ( tr ) {\n\t\tvar id = settings.rowIdFn( data );\n\n\t\tif ( id ) {\n\t\t\ttr.id = id;\n\t\t}\n\n\t\tif ( data.DT_RowClass ) {\n\t\t\t// Remove any classes added by DT_RowClass before\n\t\t\tvar a = data.DT_RowClass.split(' ');\n\t\t\trow.__rowc = row.__rowc ?\n\t\t\t\t_unique( row.__rowc.concat( a ) ) :\n\t\t\t\ta;\n\n\t\t\t$(tr)\n\t\t\t\t.removeClass( row.__rowc.join(' ') )\n\t\t\t\t.addClass( data.DT_RowClass );\n\t\t}\n\n\t\tif ( data.DT_RowAttr ) {\n\t\t\t$(tr).attr( data.DT_RowAttr );\n\t\t}\n\n\t\tif ( data.DT_RowData ) {\n\t\t\t$(tr).data( data.DT_RowData );\n\t\t}\n\t}\n}\n\n\n/**\n * Create the HTML header for the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnBuildHead( oSettings )\n{\n\tvar i, ien, cell, row, column;\n\tvar thead = oSettings.nTHead;\n\tvar tfoot = oSettings.nTFoot;\n\tvar createHeader = $('th, td', thead).length === 0;\n\tvar classes = oSettings.oClasses;\n\tvar columns = oSettings.aoColumns;\n\n\tif ( createHeader ) {\n\t\trow = $('<tr/>').appendTo( thead );\n\t}\n\n\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\tcolumn = columns[i];\n\t\tcell = $( column.nTh ).addClass( column.sClass );\n\n\t\tif ( createHeader ) {\n\t\t\tcell.appendTo( row );\n\t\t}\n\n\t\t// 1.11 move into sorting\n\t\tif ( oSettings.oFeatures.bSort ) {\n\t\t\tcell.addClass( column.sSortingClass );\n\n\t\t\tif ( column.bSortable !== false ) {\n\t\t\t\tcell\n\t\t\t\t\t.attr( 'tabindex', oSettings.iTabIndex )\n\t\t\t\t\t.attr( 'aria-controls', oSettings.sTableId );\n\n\t\t\t\t_fnSortAttachListener( oSettings, column.nTh, i );\n\t\t\t}\n\t\t}\n\n\t\tif ( column.sTitle != cell[0].innerHTML ) {\n\t\t\tcell.html( column.sTitle );\n\t\t}\n\n\t\t_fnRenderer( oSettings, 'header' )(\n\t\t\toSettings, cell, column, classes\n\t\t);\n\t}\n\n\tif ( createHeader ) {\n\t\t_fnDetectHeader( oSettings.aoHeader, thead );\n\t}\n\n\t/* Deal with the footer - add classes if required */\n\t$(thead).children('tr').children('th, td').addClass( classes.sHeaderTH );\n\t$(tfoot).children('tr').children('th, td').addClass( classes.sFooterTH );\n\n\t// Cache the footer cells. Note that we only take the cells from the first\n\t// row in the footer. If there is more than one row the user wants to\n\t// interact with, they need to use the table().foot() method. Note also this\n\t// allows cells to be used for multiple columns using colspan\n\tif ( tfoot !== null ) {\n\t\tvar cells = oSettings.aoFooter[0];\n\n\t\tfor ( i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\t\tcolumn = columns[i];\n\n\t\t\tif (column) {\n\t\t\t\tcolumn.nTf = cells[i].cell;\n\t\n\t\t\t\tif ( column.sClass ) {\n\t\t\t\t\t$(column.nTf).addClass( column.sClass );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_fnLog( oSettings, 0, 'Incorrect column count', 18 );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Draw the header (or footer) element based on the column visibility states. The\n * methodology here is to use the layout array from _fnDetectHeader, modified for\n * the instantaneous column visibility, to construct the new layout. The grid is\n * traversed over cell at a time in a rows x columns grid fashion, although each\n * cell insert can cover multiple elements in the grid - which is tracks using the\n * aApplied array. Cell inserts in the grid will only occur where there isn't\n * already a cell in that position.\n *  @param {object} oSettings dataTables settings object\n *  @param array {objects} aoSource Layout array from _fnDetectHeader\n *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\n *  @memberof DataTable#oApi\n */\nfunction _fnDrawHead( oSettings, aoSource, bIncludeHidden )\n{\n\tvar i, iLen, j, jLen, k, kLen, n, nLocalTr;\n\tvar aoLocal = [];\n\tvar aApplied = [];\n\tvar iColumns = oSettings.aoColumns.length;\n\tvar iRowspan, iColspan;\n\n\tif ( ! aoSource )\n\t{\n\t\treturn;\n\t}\n\n\tif (  bIncludeHidden === undefined )\n\t{\n\t\tbIncludeHidden = false;\n\t}\n\n\t/* Make a copy of the master layout array, but without the visible columns in it */\n\tfor ( i=0, iLen=aoSource.length ; i<iLen ; i++ )\n\t{\n\t\taoLocal[i] = aoSource[i].slice();\n\t\taoLocal[i].nTr = aoSource[i].nTr;\n\n\t\t/* Remove any columns which are currently hidden */\n\t\tfor ( j=iColumns-1 ; j>=0 ; j-- )\n\t\t{\n\t\t\tif ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )\n\t\t\t{\n\t\t\t\taoLocal[i].splice( j, 1 );\n\t\t\t}\n\t\t}\n\n\t\t/* Prep the applied array - it needs an element for each row */\n\t\taApplied.push( [] );\n\t}\n\n\tfor ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )\n\t{\n\t\tnLocalTr = aoLocal[i].nTr;\n\n\t\t/* All cells are going to be replaced, so empty out the row */\n\t\tif ( nLocalTr )\n\t\t{\n\t\t\twhile( (n = nLocalTr.firstChild) )\n\t\t\t{\n\t\t\t\tnLocalTr.removeChild( n );\n\t\t\t}\n\t\t}\n\n\t\tfor ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )\n\t\t{\n\t\t\tiRowspan = 1;\n\t\t\tiColspan = 1;\n\n\t\t\t/* Check to see if there is already a cell (row/colspan) covering our target\n\t\t\t * insert point. If there is, then there is nothing to do.\n\t\t\t */\n\t\t\tif ( aApplied[i][j] === undefined )\n\t\t\t{\n\t\t\t\tnLocalTr.appendChild( aoLocal[i][j].cell );\n\t\t\t\taApplied[i][j] = 1;\n\n\t\t\t\t/* Expand the cell to cover as many rows as needed */\n\t\t\t\twhile ( aoLocal[i+iRowspan] !== undefined &&\n\t\t\t\t        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )\n\t\t\t\t{\n\t\t\t\t\taApplied[i+iRowspan][j] = 1;\n\t\t\t\t\tiRowspan++;\n\t\t\t\t}\n\n\t\t\t\t/* Expand the cell to cover as many columns as needed */\n\t\t\t\twhile ( aoLocal[i][j+iColspan] !== undefined &&\n\t\t\t\t        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )\n\t\t\t\t{\n\t\t\t\t\t/* Must update the applied array over the rows for the columns */\n\t\t\t\t\tfor ( k=0 ; k<iRowspan ; k++ )\n\t\t\t\t\t{\n\t\t\t\t\t\taApplied[i+k][j+iColspan] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tiColspan++;\n\t\t\t\t}\n\n\t\t\t\t/* Do the actual expansion in the DOM */\n\t\t\t\t$(aoLocal[i][j].cell)\n\t\t\t\t\t.attr('rowspan', iRowspan)\n\t\t\t\t\t.attr('colspan', iColspan);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Insert the required TR nodes into the table for display\n *  @param {object} oSettings dataTables settings object\n *  @param ajaxComplete true after ajax call to complete rendering\n *  @memberof DataTable#oApi\n */\nfunction _fnDraw( oSettings, ajaxComplete )\n{\n\t// Allow for state saving and a custom start position\n\t_fnStart( oSettings );\n\n\t/* Provide a pre-callback function which can be used to cancel the draw is false is returned */\n\tvar aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );\n\tif ( $.inArray( false, aPreDraw ) !== -1 )\n\t{\n\t\t_fnProcessingDisplay( oSettings, false );\n\t\treturn;\n\t}\n\n\tvar anRows = [];\n\tvar iRowCount = 0;\n\tvar asStripeClasses = oSettings.asStripeClasses;\n\tvar iStripes = asStripeClasses.length;\n\tvar oLang = oSettings.oLanguage;\n\tvar bServerSide = _fnDataSource( oSettings ) == 'ssp';\n\tvar aiDisplay = oSettings.aiDisplay;\n\tvar iDisplayStart = oSettings._iDisplayStart;\n\tvar iDisplayEnd = oSettings.fnDisplayEnd();\n\n\toSettings.bDrawing = true;\n\n\t/* Server-side processing draw intercept */\n\tif ( oSettings.bDeferLoading )\n\t{\n\t\toSettings.bDeferLoading = false;\n\t\toSettings.iDraw++;\n\t\t_fnProcessingDisplay( oSettings, false );\n\t}\n\telse if ( !bServerSide )\n\t{\n\t\toSettings.iDraw++;\n\t}\n\telse if ( !oSettings.bDestroying && !ajaxComplete)\n\t{\n\t\t_fnAjaxUpdate( oSettings );\n\t\treturn;\n\t}\n\n\tif ( aiDisplay.length !== 0 )\n\t{\n\t\tvar iStart = bServerSide ? 0 : iDisplayStart;\n\t\tvar iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;\n\n\t\tfor ( var j=iStart ; j<iEnd ; j++ )\n\t\t{\n\t\t\tvar iDataIndex = aiDisplay[j];\n\t\t\tvar aoData = oSettings.aoData[ iDataIndex ];\n\t\t\tif ( aoData.nTr === null )\n\t\t\t{\n\t\t\t\t_fnCreateTr( oSettings, iDataIndex );\n\t\t\t}\n\n\t\t\tvar nRow = aoData.nTr;\n\n\t\t\t/* Remove the old striping classes and then add the new one */\n\t\t\tif ( iStripes !== 0 )\n\t\t\t{\n\t\t\t\tvar sStripe = asStripeClasses[ iRowCount % iStripes ];\n\t\t\t\tif ( aoData._sRowStripe != sStripe )\n\t\t\t\t{\n\t\t\t\t\t$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );\n\t\t\t\t\taoData._sRowStripe = sStripe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Row callback functions - might want to manipulate the row\n\t\t\t// iRowCount and j are not currently documented. Are they at all\n\t\t\t// useful?\n\t\t\t_fnCallbackFire( oSettings, 'aoRowCallback', null,\n\t\t\t\t[nRow, aoData._aData, iRowCount, j, iDataIndex] );\n\n\t\t\tanRows.push( nRow );\n\t\t\tiRowCount++;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Table is empty - create a row with an empty message in it */\n\t\tvar sZero = oLang.sZeroRecords;\n\t\tif ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )\n\t\t{\n\t\t\tsZero = oLang.sLoadingRecords;\n\t\t}\n\t\telse if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )\n\t\t{\n\t\t\tsZero = oLang.sEmptyTable;\n\t\t}\n\n\t\tanRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )\n\t\t\t.append( $('<td />', {\n\t\t\t\t'valign':  'top',\n\t\t\t\t'colSpan': _fnVisbleColumns( oSettings ),\n\t\t\t\t'class':   oSettings.oClasses.sRowEmpty\n\t\t\t} ).html( sZero ) )[0];\n\t}\n\n\t/* Header and footer callbacks */\n\t_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],\n\t\t_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );\n\n\t_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],\n\t\t_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );\n\n\tvar body = $(oSettings.nTBody);\n\n\tbody.children().detach();\n\tbody.append( $(anRows) );\n\n\t/* Call all required callback functions for the end of a draw */\n\t_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );\n\n\t/* Draw is complete, sorting and filtering must be as well */\n\toSettings.bSorted = false;\n\toSettings.bFiltered = false;\n\toSettings.bDrawing = false;\n}\n\n\n/**\n * Redraw the table - taking account of the various features which are enabled\n *  @param {object} oSettings dataTables settings object\n *  @param {boolean} [holdPosition] Keep the current paging position. By default\n *    the paging is reset to the first page\n *  @memberof DataTable#oApi\n */\nfunction _fnReDraw( settings, holdPosition )\n{\n\tvar\n\t\tfeatures = settings.oFeatures,\n\t\tsort     = features.bSort,\n\t\tfilter   = features.bFilter;\n\n\tif ( sort ) {\n\t\t_fnSort( settings );\n\t}\n\n\tif ( filter ) {\n\t\t_fnFilterComplete( settings, settings.oPreviousSearch );\n\t}\n\telse {\n\t\t// No filtering, so we want to just use the display master\n\t\tsettings.aiDisplay = settings.aiDisplayMaster.slice();\n\t}\n\n\tif ( holdPosition !== true ) {\n\t\tsettings._iDisplayStart = 0;\n\t}\n\n\t// Let any modules know about the draw hold position state (used by\n\t// scrolling internally)\n\tsettings._drawHold = holdPosition;\n\n\t_fnDraw( settings );\n\n\tsettings._drawHold = false;\n}\n\n\n/**\n * Add the options to the page HTML for the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnAddOptionsHtml ( oSettings )\n{\n\tvar classes = oSettings.oClasses;\n\tvar table = $(oSettings.nTable);\n\tvar holding = $('<div/>').insertBefore( table ); // Holding element for speed\n\tvar features = oSettings.oFeatures;\n\n\t// All DataTables are wrapped in a div\n\tvar insert = $('<div/>', {\n\t\tid:      oSettings.sTableId+'_wrapper',\n\t\t'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)\n\t} );\n\n\toSettings.nHolding = holding[0];\n\toSettings.nTableWrapper = insert[0];\n\toSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;\n\n\t/* Loop over the user set positioning and place the elements as needed */\n\tvar aDom = oSettings.sDom.split('');\n\tvar featureNode, cOption, nNewNode, cNext, sAttr, j;\n\tfor ( var i=0 ; i<aDom.length ; i++ )\n\t{\n\t\tfeatureNode = null;\n\t\tcOption = aDom[i];\n\n\t\tif ( cOption == '<' )\n\t\t{\n\t\t\t/* New container div */\n\t\t\tnNewNode = $('<div/>')[0];\n\n\t\t\t/* Check to see if we should append an id and/or a class name to the container */\n\t\t\tcNext = aDom[i+1];\n\t\t\tif ( cNext == \"'\" || cNext == '\"' )\n\t\t\t{\n\t\t\t\tsAttr = \"\";\n\t\t\t\tj = 2;\n\t\t\t\twhile ( aDom[i+j] != cNext )\n\t\t\t\t{\n\t\t\t\t\tsAttr += aDom[i+j];\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\t/* Replace jQuery UI constants @todo depreciated */\n\t\t\t\tif ( sAttr == \"H\" )\n\t\t\t\t{\n\t\t\t\t\tsAttr = classes.sJUIHeader;\n\t\t\t\t}\n\t\t\t\telse if ( sAttr == \"F\" )\n\t\t\t\t{\n\t\t\t\t\tsAttr = classes.sJUIFooter;\n\t\t\t\t}\n\n\t\t\t\t/* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\n\t\t\t\t * breaks the string into parts and applies them as needed\n\t\t\t\t */\n\t\t\t\tif ( sAttr.indexOf('.') != -1 )\n\t\t\t\t{\n\t\t\t\t\tvar aSplit = sAttr.split('.');\n\t\t\t\t\tnNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);\n\t\t\t\t\tnNewNode.className = aSplit[1];\n\t\t\t\t}\n\t\t\t\telse if ( sAttr.charAt(0) == \"#\" )\n\t\t\t\t{\n\t\t\t\t\tnNewNode.id = sAttr.substr(1, sAttr.length-1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnNewNode.className = sAttr;\n\t\t\t\t}\n\n\t\t\t\ti += j; /* Move along the position array */\n\t\t\t}\n\n\t\t\tinsert.append( nNewNode );\n\t\t\tinsert = $(nNewNode);\n\t\t}\n\t\telse if ( cOption == '>' )\n\t\t{\n\t\t\t/* End container div */\n\t\t\tinsert = insert.parent();\n\t\t}\n\t\t// @todo Move options into their own plugins?\n\t\telse if ( cOption == 'l' && features.bPaginate && features.bLengthChange )\n\t\t{\n\t\t\t/* Length */\n\t\t\tfeatureNode = _fnFeatureHtmlLength( oSettings );\n\t\t}\n\t\telse if ( cOption == 'f' && features.bFilter )\n\t\t{\n\t\t\t/* Filter */\n\t\t\tfeatureNode = _fnFeatureHtmlFilter( oSettings );\n\t\t}\n\t\telse if ( cOption == 'r' && features.bProcessing )\n\t\t{\n\t\t\t/* pRocessing */\n\t\t\tfeatureNode = _fnFeatureHtmlProcessing( oSettings );\n\t\t}\n\t\telse if ( cOption == 't' )\n\t\t{\n\t\t\t/* Table */\n\t\t\tfeatureNode = _fnFeatureHtmlTable( oSettings );\n\t\t}\n\t\telse if ( cOption ==  'i' && features.bInfo )\n\t\t{\n\t\t\t/* Info */\n\t\t\tfeatureNode = _fnFeatureHtmlInfo( oSettings );\n\t\t}\n\t\telse if ( cOption == 'p' && features.bPaginate )\n\t\t{\n\t\t\t/* Pagination */\n\t\t\tfeatureNode = _fnFeatureHtmlPaginate( oSettings );\n\t\t}\n\t\telse if ( DataTable.ext.feature.length !== 0 )\n\t\t{\n\t\t\t/* Plug-in features */\n\t\t\tvar aoFeatures = DataTable.ext.feature;\n\t\t\tfor ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )\n\t\t\t{\n\t\t\t\tif ( cOption == aoFeatures[k].cFeature )\n\t\t\t\t{\n\t\t\t\t\tfeatureNode = aoFeatures[k].fnInit( oSettings );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Add to the 2D features array */\n\t\tif ( featureNode )\n\t\t{\n\t\t\tvar aanFeatures = oSettings.aanFeatures;\n\n\t\t\tif ( ! aanFeatures[cOption] )\n\t\t\t{\n\t\t\t\taanFeatures[cOption] = [];\n\t\t\t}\n\n\t\t\taanFeatures[cOption].push( featureNode );\n\t\t\tinsert.append( featureNode );\n\t\t}\n\t}\n\n\t/* Built our DOM structure - replace the holding div with what we want */\n\tholding.replaceWith( insert );\n\toSettings.nHolding = null;\n}\n\n\n/**\n * Use the DOM source to create up an array of header cells. The idea here is to\n * create a layout grid (array) of rows x columns, which contains a reference\n * to the cell that that point in the grid (regardless of col/rowspan), such that\n * any column / row could be removed and the new grid constructed\n *  @param array {object} aLayout Array to store the calculated layout in\n *  @param {node} nThead The header/footer element for the table\n *  @memberof DataTable#oApi\n */\nfunction _fnDetectHeader ( aLayout, nThead )\n{\n\tvar nTrs = $(nThead).children('tr');\n\tvar nTr, nCell;\n\tvar i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;\n\tvar bUnique;\n\tvar fnShiftCol = function ( a, i, j ) {\n\t\tvar k = a[i];\n                while ( k[j] ) {\n\t\t\tj++;\n\t\t}\n\t\treturn j;\n\t};\n\n\taLayout.splice( 0, aLayout.length );\n\n\t/* We know how many rows there are in the layout - so prep it */\n\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t{\n\t\taLayout.push( [] );\n\t}\n\n\t/* Calculate a layout array */\n\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t{\n\t\tnTr = nTrs[i];\n\t\tiColumn = 0;\n\n\t\t/* For every cell in the row... */\n\t\tnCell = nTr.firstChild;\n\t\twhile ( nCell ) {\n\t\t\tif ( nCell.nodeName.toUpperCase() == \"TD\" ||\n\t\t\t     nCell.nodeName.toUpperCase() == \"TH\" )\n\t\t\t{\n\t\t\t\t/* Get the col and rowspan attributes from the DOM and sanitise them */\n\t\t\t\tiColspan = nCell.getAttribute('colspan') * 1;\n\t\t\t\tiRowspan = nCell.getAttribute('rowspan') * 1;\n\t\t\t\tiColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;\n\t\t\t\tiRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;\n\n\t\t\t\t/* There might be colspan cells already in this row, so shift our target\n\t\t\t\t * accordingly\n\t\t\t\t */\n\t\t\t\tiColShifted = fnShiftCol( aLayout, i, iColumn );\n\n\t\t\t\t/* Cache calculation for unique columns */\n\t\t\t\tbUnique = iColspan === 1 ? true : false;\n\n\t\t\t\t/* If there is col / rowspan, copy the information into the layout grid */\n\t\t\t\tfor ( l=0 ; l<iColspan ; l++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( k=0 ; k<iRowspan ; k++ )\n\t\t\t\t\t{\n\t\t\t\t\t\taLayout[i+k][iColShifted+l] = {\n\t\t\t\t\t\t\t\"cell\": nCell,\n\t\t\t\t\t\t\t\"unique\": bUnique\n\t\t\t\t\t\t};\n\t\t\t\t\t\taLayout[i+k].nTr = nTr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnCell = nCell.nextSibling;\n\t\t}\n\t}\n}\n\n\n/**\n * Get an array of unique th elements, one for each column\n *  @param {object} oSettings dataTables settings object\n *  @param {node} nHeader automatically detect the layout from this node - optional\n *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\n *  @returns array {node} aReturn list of unique th's\n *  @memberof DataTable#oApi\n */\nfunction _fnGetUniqueThs ( oSettings, nHeader, aLayout )\n{\n\tvar aReturn = [];\n\tif ( !aLayout )\n\t{\n\t\taLayout = oSettings.aoHeader;\n\t\tif ( nHeader )\n\t\t{\n\t\t\taLayout = [];\n\t\t\t_fnDetectHeader( aLayout, nHeader );\n\t\t}\n\t}\n\n\tfor ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )\n\t{\n\t\tfor ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )\n\t\t{\n\t\t\tif ( aLayout[i][j].unique &&\n\t\t\t\t (!aReturn[j] || !oSettings.bSortCellsTop) )\n\t\t\t{\n\t\t\t\taReturn[j] = aLayout[i][j].cell;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn aReturn;\n}\n\n/**\n * Set the start position for draw\n *  @param {object} oSettings dataTables settings object\n */\nfunction _fnStart( oSettings )\n{\n\tvar bServerSide = _fnDataSource( oSettings ) == 'ssp';\n\tvar iInitDisplayStart = oSettings.iInitDisplayStart;\n\n\t// Check and see if we have an initial draw position from state saving\n\tif ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )\n\t{\n\t\toSettings._iDisplayStart = bServerSide ?\n\t\t\tiInitDisplayStart :\n\t\t\tiInitDisplayStart >= oSettings.fnRecordsDisplay() ?\n\t\t\t\t0 :\n\t\t\t\tiInitDisplayStart;\n\n\t\toSettings.iInitDisplayStart = -1;\n\t}\n}\n\n/**\n * Create an Ajax call based on the table's settings, taking into account that\n * parameters can have multiple forms, and backwards compatibility.\n *\n * @param {object} oSettings dataTables settings object\n * @param {array} data Data to send to the server, required by\n *     DataTables - may be augmented by developer callbacks\n * @param {function} fn Callback function to run when data is obtained\n */\nfunction _fnBuildAjax( oSettings, data, fn )\n{\n\t// Compatibility with 1.9-, allow fnServerData and event to manipulate\n\t_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );\n\n\t// Convert to object based for 1.10+ if using the old array scheme which can\n\t// come from server-side processing or serverParams\n\tif ( data && Array.isArray(data) ) {\n\t\tvar tmp = {};\n\t\tvar rbracket = /(.*?)\\[\\]$/;\n\n\t\t$.each( data, function (key, val) {\n\t\t\tvar match = val.name.match(rbracket);\n\n\t\t\tif ( match ) {\n\t\t\t\t// Support for arrays\n\t\t\t\tvar name = match[0];\n\n\t\t\t\tif ( ! tmp[ name ] ) {\n\t\t\t\t\ttmp[ name ] = [];\n\t\t\t\t}\n\t\t\t\ttmp[ name ].push( val.value );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmp[val.name] = val.value;\n\t\t\t}\n\t\t} );\n\t\tdata = tmp;\n\t}\n\n\tvar ajaxData;\n\tvar ajax = oSettings.ajax;\n\tvar instance = oSettings.oInstance;\n\tvar callback = function ( json ) {\n\t\tvar status = oSettings.jqXHR\n\t\t\t? oSettings.jqXHR.status\n\t\t\t: null;\n\n\t\tif ( json === null || (typeof status === 'number' && status == 204 ) ) {\n\t\t\tjson = {};\n\t\t\t_fnAjaxDataSrc( oSettings, json, [] );\n\t\t}\n\n\t\tvar error = json.error || json.sError;\n\t\tif ( error ) {\n\t\t\t_fnLog( oSettings, 0, error );\n\t\t}\n\n\t\toSettings.json = json;\n\n\t\t_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );\n\t\tfn( json );\n\t};\n\n\tif ( $.isPlainObject( ajax ) && ajax.data )\n\t{\n\t\tajaxData = ajax.data;\n\n\t\tvar newData = typeof ajaxData === 'function' ?\n\t\t\tajaxData( data, oSettings ) :  // fn can manipulate data or return\n\t\t\tajaxData;                      // an object object or array to merge\n\n\t\t// If the function returned something, use that alone\n\t\tdata = typeof ajaxData === 'function' && newData ?\n\t\t\tnewData :\n\t\t\t$.extend( true, data, newData );\n\n\t\t// Remove the data property as we've resolved it already and don't want\n\t\t// jQuery to do it again (it is restored at the end of the function)\n\t\tdelete ajax.data;\n\t}\n\n\tvar baseAjax = {\n\t\t\"data\": data,\n\t\t\"success\": callback,\n\t\t\"dataType\": \"json\",\n\t\t\"cache\": false,\n\t\t\"type\": oSettings.sServerMethod,\n\t\t\"error\": function (xhr, error, thrown) {\n\t\t\tvar ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );\n\n\t\t\tif ( $.inArray( true, ret ) === -1 ) {\n\t\t\t\tif ( error == \"parsererror\" ) {\n\t\t\t\t\t_fnLog( oSettings, 0, 'Invalid JSON response', 1 );\n\t\t\t\t}\n\t\t\t\telse if ( xhr.readyState === 4 ) {\n\t\t\t\t\t_fnLog( oSettings, 0, 'Ajax error', 7 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_fnProcessingDisplay( oSettings, false );\n\t\t}\n\t};\n\n\t// Store the data submitted for the API\n\toSettings.oAjaxData = data;\n\n\t// Allow plug-ins and external processes to modify the data\n\t_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );\n\n\tif ( oSettings.fnServerData )\n\t{\n\t\t// DataTables 1.9- compatibility\n\t\toSettings.fnServerData.call( instance,\n\t\t\toSettings.sAjaxSource,\n\t\t\t$.map( data, function (val, key) { // Need to convert back to 1.9 trad format\n\t\t\t\treturn { name: key, value: val };\n\t\t\t} ),\n\t\t\tcallback,\n\t\t\toSettings\n\t\t);\n\t}\n\telse if ( oSettings.sAjaxSource || typeof ajax === 'string' )\n\t{\n\t\t// DataTables 1.9- compatibility\n\t\toSettings.jqXHR = $.ajax( $.extend( baseAjax, {\n\t\t\turl: ajax || oSettings.sAjaxSource\n\t\t} ) );\n\t}\n\telse if ( typeof ajax === 'function' )\n\t{\n\t\t// Is a function - let the caller define what needs to be done\n\t\toSettings.jqXHR = ajax.call( instance, data, callback, oSettings );\n\t}\n\telse\n\t{\n\t\t// Object to extend the base settings\n\t\toSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );\n\n\t\t// Restore for next time around\n\t\tajax.data = ajaxData;\n\t}\n}\n\n\n/**\n * Update the table using an Ajax call\n *  @param {object} settings dataTables settings object\n *  @returns {boolean} Block the table drawing or not\n *  @memberof DataTable#oApi\n */\nfunction _fnAjaxUpdate( settings )\n{\n\tsettings.iDraw++;\n\t_fnProcessingDisplay( settings, true );\n\n\t_fnBuildAjax(\n\t\tsettings,\n\t\t_fnAjaxParameters( settings ),\n\t\tfunction(json) {\n\t\t\t_fnAjaxUpdateDraw( settings, json );\n\t\t}\n\t);\n}\n\n\n/**\n * Build up the parameters in an object needed for a server-side processing\n * request. Note that this is basically done twice, is different ways - a modern\n * method which is used by default in DataTables 1.10 which uses objects and\n * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\n * the sAjaxSource option is used in the initialisation, or the legacyAjax\n * option is set.\n *  @param {object} oSettings dataTables settings object\n *  @returns {bool} block the table drawing or not\n *  @memberof DataTable#oApi\n */\nfunction _fnAjaxParameters( settings )\n{\n\tvar\n\t\tcolumns = settings.aoColumns,\n\t\tcolumnCount = columns.length,\n\t\tfeatures = settings.oFeatures,\n\t\tpreSearch = settings.oPreviousSearch,\n\t\tpreColSearch = settings.aoPreSearchCols,\n\t\ti, data = [], dataProp, column, columnSearch,\n\t\tsort = _fnSortFlatten( settings ),\n\t\tdisplayStart = settings._iDisplayStart,\n\t\tdisplayLength = features.bPaginate !== false ?\n\t\t\tsettings._iDisplayLength :\n\t\t\t-1;\n\n\tvar param = function ( name, value ) {\n\t\tdata.push( { 'name': name, 'value': value } );\n\t};\n\n\t// DataTables 1.9- compatible method\n\tparam( 'sEcho',          settings.iDraw );\n\tparam( 'iColumns',       columnCount );\n\tparam( 'sColumns',       _pluck( columns, 'sName' ).join(',') );\n\tparam( 'iDisplayStart',  displayStart );\n\tparam( 'iDisplayLength', displayLength );\n\n\t// DataTables 1.10+ method\n\tvar d = {\n\t\tdraw:    settings.iDraw,\n\t\tcolumns: [],\n\t\torder:   [],\n\t\tstart:   displayStart,\n\t\tlength:  displayLength,\n\t\tsearch:  {\n\t\t\tvalue: preSearch.sSearch,\n\t\t\tregex: preSearch.bRegex\n\t\t}\n\t};\n\n\tfor ( i=0 ; i<columnCount ; i++ ) {\n\t\tcolumn = columns[i];\n\t\tcolumnSearch = preColSearch[i];\n\t\tdataProp = typeof column.mData==\"function\" ? 'function' : column.mData ;\n\n\t\td.columns.push( {\n\t\t\tdata:       dataProp,\n\t\t\tname:       column.sName,\n\t\t\tsearchable: column.bSearchable,\n\t\t\torderable:  column.bSortable,\n\t\t\tsearch:     {\n\t\t\t\tvalue: columnSearch.sSearch,\n\t\t\t\tregex: columnSearch.bRegex\n\t\t\t}\n\t\t} );\n\n\t\tparam( \"mDataProp_\"+i, dataProp );\n\n\t\tif ( features.bFilter ) {\n\t\t\tparam( 'sSearch_'+i,     columnSearch.sSearch );\n\t\t\tparam( 'bRegex_'+i,      columnSearch.bRegex );\n\t\t\tparam( 'bSearchable_'+i, column.bSearchable );\n\t\t}\n\n\t\tif ( features.bSort ) {\n\t\t\tparam( 'bSortable_'+i, column.bSortable );\n\t\t}\n\t}\n\n\tif ( features.bFilter ) {\n\t\tparam( 'sSearch', preSearch.sSearch );\n\t\tparam( 'bRegex', preSearch.bRegex );\n\t}\n\n\tif ( features.bSort ) {\n\t\t$.each( sort, function ( i, val ) {\n\t\t\td.order.push( { column: val.col, dir: val.dir } );\n\n\t\t\tparam( 'iSortCol_'+i, val.col );\n\t\t\tparam( 'sSortDir_'+i, val.dir );\n\t\t} );\n\n\t\tparam( 'iSortingCols', sort.length );\n\t}\n\n\t// If the legacy.ajax parameter is null, then we automatically decide which\n\t// form to use, based on sAjaxSource\n\tvar legacy = DataTable.ext.legacy.ajax;\n\tif ( legacy === null ) {\n\t\treturn settings.sAjaxSource ? data : d;\n\t}\n\n\t// Otherwise, if legacy has been specified then we use that to decide on the\n\t// form\n\treturn legacy ? data : d;\n}\n\n\n/**\n * Data the data from the server (nuking the old) and redraw the table\n *  @param {object} oSettings dataTables settings object\n *  @param {object} json json data return from the server.\n *  @param {string} json.sEcho Tracking flag for DataTables to match requests\n *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\n *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\n *  @param {array} json.aaData The data to display on this page\n *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\n *  @memberof DataTable#oApi\n */\nfunction _fnAjaxUpdateDraw ( settings, json )\n{\n\t// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\n\t// Support both\n\tvar compat = function ( old, modern ) {\n\t\treturn json[old] !== undefined ? json[old] : json[modern];\n\t};\n\n\tvar data = _fnAjaxDataSrc( settings, json );\n\tvar draw            = compat( 'sEcho',                'draw' );\n\tvar recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );\n\tvar recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );\n\n\tif ( draw !== undefined ) {\n\t\t// Protect against out of sequence returns\n\t\tif ( draw*1 < settings.iDraw ) {\n\t\t\treturn;\n\t\t}\n\t\tsettings.iDraw = draw * 1;\n\t}\n\n\t// No data in returned object, so rather than an array, we show an empty table\n\tif ( ! data ) {\n\t\tdata = [];\n\t}\n\n\t_fnClearTable( settings );\n\tsettings._iRecordsTotal   = parseInt(recordsTotal, 10);\n\tsettings._iRecordsDisplay = parseInt(recordsFiltered, 10);\n\n\tfor ( var i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t_fnAddData( settings, data[i] );\n\t}\n\tsettings.aiDisplay = settings.aiDisplayMaster.slice();\n\n\t_fnDraw( settings, true );\n\n\tif ( ! settings._bInitComplete ) {\n\t\t_fnInitComplete( settings, json );\n\t}\n\n\t_fnProcessingDisplay( settings, false );\n}\n\n\n/**\n * Get the data from the JSON data source to use for drawing a table. Using\n * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\n * source object, or from a processing function.\n *  @param {object} oSettings dataTables settings object\n *  @param  {object} json Data source object / array from the server\n *  @return {array} Array of data to use\n */\n function _fnAjaxDataSrc ( oSettings, json, write )\n {\n\tvar dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?\n\t\toSettings.ajax.dataSrc :\n\t\toSettings.sAjaxDataProp; // Compatibility with 1.9-.\n\n\tif ( ! write ) {\n\t\tif ( dataSrc === 'data' ) {\n\t\t\t// If the default, then we still want to support the old style, and safely ignore\n\t\t\t// it if possible\n\t\t\treturn json.aaData || json[dataSrc];\n\t\t}\n\n\t\treturn dataSrc !== \"\" ?\n\t\t\t_fnGetObjectDataFn( dataSrc )( json ) :\n\t\t\tjson;\n\t}\n\n\t// set\n\t_fnSetObjectDataFn( dataSrc )( json, write );\n}\n\n/**\n * Generate the node required for filtering text\n *  @returns {node} Filter control element\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnFeatureHtmlFilter ( settings )\n{\n\tvar classes = settings.oClasses;\n\tvar tableId = settings.sTableId;\n\tvar language = settings.oLanguage;\n\tvar previousSearch = settings.oPreviousSearch;\n\tvar features = settings.aanFeatures;\n\tvar input = '<input type=\"search\" class=\"'+classes.sFilterInput+'\"/>';\n\n\tvar str = language.sSearch;\n\tstr = str.match(/_INPUT_/) ?\n\t\tstr.replace('_INPUT_', input) :\n\t\tstr+input;\n\n\tvar filter = $('<div/>', {\n\t\t\t'id': ! features.f ? tableId+'_filter' : null,\n\t\t\t'class': classes.sFilter\n\t\t} )\n\t\t.append( $('<label/>' ).append( str ) );\n\n\tvar searchFn = function(event) {\n\t\t/* Update all other filter input elements for the new display */\n\t\tvar n = features.f;\n\t\tvar val = !this.value ? \"\" : this.value; // mental IE8 fix :-(\n\t\tif(previousSearch.return && event.key !== \"Enter\") {\n\t\t\treturn;\n\t\t}\n\t\t/* Now do the filter */\n\t\tif ( val != previousSearch.sSearch ) {\n\t\t\t_fnFilterComplete( settings, {\n\t\t\t\t\"sSearch\": val,\n\t\t\t\t\"bRegex\": previousSearch.bRegex,\n\t\t\t\t\"bSmart\": previousSearch.bSmart ,\n\t\t\t\t\"bCaseInsensitive\": previousSearch.bCaseInsensitive,\n\t\t\t\t\"return\": previousSearch.return\n\t\t\t} );\n\n\t\t\t// Need to redraw, without resorting\n\t\t\tsettings._iDisplayStart = 0;\n\t\t\t_fnDraw( settings );\n\t\t}\n\t};\n\n\tvar searchDelay = settings.searchDelay !== null ?\n\t\tsettings.searchDelay :\n\t\t_fnDataSource( settings ) === 'ssp' ?\n\t\t\t400 :\n\t\t\t0;\n\n\tvar jqFilter = $('input', filter)\n\t\t.val( previousSearch.sSearch )\n\t\t.attr( 'placeholder', language.sSearchPlaceholder )\n\t\t.on(\n\t\t\t'keyup.DT search.DT input.DT paste.DT cut.DT',\n\t\t\tsearchDelay ?\n\t\t\t\t_fnThrottle( searchFn, searchDelay ) :\n\t\t\t\tsearchFn\n\t\t)\n\t\t.on( 'mouseup', function(e) {\n\t\t\t// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking\n\t\t\t// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`\n\t\t\t// checks the value to see if it has changed. In other browsers it won't have.\n\t\t\tsetTimeout( function () {\n\t\t\t\tsearchFn.call(jqFilter[0], e);\n\t\t\t}, 10);\n\t\t} )\n\t\t.on( 'keypress.DT', function(e) {\n\t\t\t/* Prevent form submission */\n\t\t\tif ( e.keyCode == 13 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} )\n\t\t.attr('aria-controls', tableId);\n\n\t// Update the input elements whenever the table is filtered\n\t$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {\n\t\tif ( settings === s ) {\n\t\t\t// IE9 throws an 'unknown error' if document.activeElement is used\n\t\t\t// inside an iframe or frame...\n\t\t\ttry {\n\t\t\t\tif ( jqFilter[0] !== document.activeElement ) {\n\t\t\t\t\tjqFilter.val( previousSearch.sSearch );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch ( e ) {}\n\t\t}\n\t} );\n\n\treturn filter[0];\n}\n\n\n/**\n * Filter the table using both the global filter and column based filtering\n *  @param {object} oSettings dataTables settings object\n *  @param {object} oSearch search information\n *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\n *  @memberof DataTable#oApi\n */\nfunction _fnFilterComplete ( oSettings, oInput, iForce )\n{\n\tvar oPrevSearch = oSettings.oPreviousSearch;\n\tvar aoPrevSearch = oSettings.aoPreSearchCols;\n\tvar fnSaveFilter = function ( oFilter ) {\n\t\t/* Save the filtering values */\n\t\toPrevSearch.sSearch = oFilter.sSearch;\n\t\toPrevSearch.bRegex = oFilter.bRegex;\n\t\toPrevSearch.bSmart = oFilter.bSmart;\n\t\toPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;\n\t\toPrevSearch.return = oFilter.return;\n\t};\n\tvar fnRegex = function ( o ) {\n\t\t// Backwards compatibility with the bEscapeRegex option\n\t\treturn o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;\n\t};\n\n\t// Resolve any column types that are unknown due to addition or invalidation\n\t// @todo As per sort - can this be moved into an event handler?\n\t_fnColumnTypes( oSettings );\n\n\t/* In server-side processing all filtering is done by the server, so no point hanging around here */\n\tif ( _fnDataSource( oSettings ) != 'ssp' )\n\t{\n\t\t/* Global filter */\n\t\t_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive, oInput.return );\n\t\tfnSaveFilter( oInput );\n\n\t\t/* Now do the individual column filter */\n\t\tfor ( var i=0 ; i<aoPrevSearch.length ; i++ )\n\t\t{\n\t\t\t_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),\n\t\t\t\taoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );\n\t\t}\n\n\t\t/* Custom filtering */\n\t\t_fnFilterCustom( oSettings );\n\t}\n\telse\n\t{\n\t\tfnSaveFilter( oInput );\n\t}\n\n\t/* Tell the draw function we have been filtering */\n\toSettings.bFiltered = true;\n\t_fnCallbackFire( oSettings, null, 'search', [oSettings] );\n}\n\n\n/**\n * Apply custom filtering functions\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnFilterCustom( settings )\n{\n\tvar filters = DataTable.ext.search;\n\tvar displayRows = settings.aiDisplay;\n\tvar row, rowIdx;\n\n\tfor ( var i=0, ien=filters.length ; i<ien ; i++ ) {\n\t\tvar rows = [];\n\n\t\t// Loop over each row and see if it should be included\n\t\tfor ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {\n\t\t\trowIdx = displayRows[ j ];\n\t\t\trow = settings.aoData[ rowIdx ];\n\n\t\t\tif ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {\n\t\t\t\trows.push( rowIdx );\n\t\t\t}\n\t\t}\n\n\t\t// So the array reference doesn't break set the results into the\n\t\t// existing array\n\t\tdisplayRows.length = 0;\n\t\t$.merge( displayRows, rows );\n\t}\n}\n\n\n/**\n * Filter the table on a per-column basis\n *  @param {object} oSettings dataTables settings object\n *  @param {string} sInput string to filter on\n *  @param {int} iColumn column to filter\n *  @param {bool} bRegex treat search string as a regular expression or not\n *  @param {bool} bSmart use smart filtering or not\n *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n *  @memberof DataTable#oApi\n */\nfunction _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )\n{\n\tif ( searchStr === '' ) {\n\t\treturn;\n\t}\n\n\tvar data;\n\tvar out = [];\n\tvar display = settings.aiDisplay;\n\tvar rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );\n\n\tfor ( var i=0 ; i<display.length ; i++ ) {\n\t\tdata = settings.aoData[ display[i] ]._aFilterData[ colIdx ];\n\n\t\tif ( rpSearch.test( data ) ) {\n\t\t\tout.push( display[i] );\n\t\t}\n\t}\n\n\tsettings.aiDisplay = out;\n}\n\n\n/**\n * Filter the data table based on user input and draw the table\n *  @param {object} settings dataTables settings object\n *  @param {string} input string to filter on\n *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\n *  @param {bool} regex treat as a regular expression or not\n *  @param {bool} smart perform smart filtering or not\n *  @param {bool} caseInsensitive Do case insensitive matching or not\n *  @memberof DataTable#oApi\n */\nfunction _fnFilter( settings, input, force, regex, smart, caseInsensitive )\n{\n\tvar rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );\n\tvar prevSearch = settings.oPreviousSearch.sSearch;\n\tvar displayMaster = settings.aiDisplayMaster;\n\tvar display, invalidated, i;\n\tvar filtered = [];\n\n\t// Need to take account of custom filtering functions - always filter\n\tif ( DataTable.ext.search.length !== 0 ) {\n\t\tforce = true;\n\t}\n\n\t// Check if any of the rows were invalidated\n\tinvalidated = _fnFilterData( settings );\n\n\t// If the input is blank - we just want the full data set\n\tif ( input.length <= 0 ) {\n\t\tsettings.aiDisplay = displayMaster.slice();\n\t}\n\telse {\n\t\t// New search - start from the master array\n\t\tif ( invalidated ||\n\t\t\t force ||\n\t\t\t regex ||\n\t\t\t prevSearch.length > input.length ||\n\t\t\t input.indexOf(prevSearch) !== 0 ||\n\t\t\t settings.bSorted // On resort, the display master needs to be\n\t\t\t                  // re-filtered since indexes will have changed\n\t\t) {\n\t\t\tsettings.aiDisplay = displayMaster.slice();\n\t\t}\n\n\t\t// Search the display array\n\t\tdisplay = settings.aiDisplay;\n\n\t\tfor ( i=0 ; i<display.length ; i++ ) {\n\t\t\tif ( rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {\n\t\t\t\tfiltered.push( display[i] );\n\t\t\t}\n\t\t}\n\n\t\tsettings.aiDisplay = filtered;\n\t}\n}\n\n\n/**\n * Build a regular expression object suitable for searching a table\n *  @param {string} sSearch string to search for\n *  @param {bool} bRegex treat as a regular expression or not\n *  @param {bool} bSmart perform smart filtering or not\n *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n *  @returns {RegExp} constructed object\n *  @memberof DataTable#oApi\n */\nfunction _fnFilterCreateSearch( search, regex, smart, caseInsensitive )\n{\n\tsearch = regex ?\n\t\tsearch :\n\t\t_fnEscapeRegex( search );\n\t\n\tif ( smart ) {\n\t\t/* For smart filtering we want to allow the search to work regardless of\n\t\t * word order. We also want double quoted text to be preserved, so word\n\t\t * order is important - a la google. So this is what we want to\n\t\t * generate:\n\t\t * \n\t\t * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\n\t\t */\n\t\tvar a = $.map( search.match( /\"[^\"]+\"|[^ ]+/g ) || [''], function ( word ) {\n\t\t\tif ( word.charAt(0) === '\"' ) {\n\t\t\t\tvar m = word.match( /^\"(.*)\"$/ );\n\t\t\t\tword = m ? m[1] : word;\n\t\t\t}\n\n\t\t\treturn word.replace('\"', '');\n\t\t} );\n\n\t\tsearch = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';\n\t}\n\n\treturn new RegExp( search, caseInsensitive ? 'i' : '' );\n}\n\n\n/**\n * Escape a string such that it can be used in a regular expression\n *  @param {string} sVal string to escape\n *  @returns {string} escaped string\n *  @memberof DataTable#oApi\n */\nvar _fnEscapeRegex = DataTable.util.escapeRegex;\n\nvar __filter_div = $('<div>')[0];\nvar __filter_div_textContent = __filter_div.textContent !== undefined;\n\n// Update the filtering data for each row if needed (by invalidation or first run)\nfunction _fnFilterData ( settings )\n{\n\tvar columns = settings.aoColumns;\n\tvar column;\n\tvar i, j, ien, jen, filterData, cellData, row;\n\tvar wasInvalidated = false;\n\n\tfor ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n\t\trow = settings.aoData[i];\n\n\t\tif ( ! row._aFilterData ) {\n\t\t\tfilterData = [];\n\n\t\t\tfor ( j=0, jen=columns.length ; j<jen ; j++ ) {\n\t\t\t\tcolumn = columns[j];\n\n\t\t\t\tif ( column.bSearchable ) {\n\t\t\t\t\tcellData = _fnGetCellData( settings, i, j, 'filter' );\n\n\t\t\t\t\t// Search in DataTables 1.10 is string based. In 1.11 this\n\t\t\t\t\t// should be altered to also allow strict type checking.\n\t\t\t\t\tif ( cellData === null ) {\n\t\t\t\t\t\tcellData = '';\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof cellData !== 'string' && cellData.toString ) {\n\t\t\t\t\t\tcellData = cellData.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcellData = '';\n\t\t\t\t}\n\n\t\t\t\t// If it looks like there is an HTML entity in the string,\n\t\t\t\t// attempt to decode it so sorting works as expected. Note that\n\t\t\t\t// we could use a single line of jQuery to do this, but the DOM\n\t\t\t\t// method used here is much faster http://jsperf.com/html-decode\n\t\t\t\tif ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {\n\t\t\t\t\t__filter_div.innerHTML = cellData;\n\t\t\t\t\tcellData = __filter_div_textContent ?\n\t\t\t\t\t\t__filter_div.textContent :\n\t\t\t\t\t\t__filter_div.innerText;\n\t\t\t\t}\n\n\t\t\t\tif ( cellData.replace ) {\n\t\t\t\t\tcellData = cellData.replace(/[\\r\\n\\u2028]/g, '');\n\t\t\t\t}\n\n\t\t\t\tfilterData.push( cellData );\n\t\t\t}\n\n\t\t\trow._aFilterData = filterData;\n\t\t\trow._sFilterRow = filterData.join('  ');\n\t\t\twasInvalidated = true;\n\t\t}\n\t}\n\n\treturn wasInvalidated;\n}\n\n\n/**\n * Convert from the internal Hungarian notation to camelCase for external\n * interaction\n *  @param {object} obj Object to convert\n *  @returns {object} Inverted object\n *  @memberof DataTable#oApi\n */\nfunction _fnSearchToCamel ( obj )\n{\n\treturn {\n\t\tsearch:          obj.sSearch,\n\t\tsmart:           obj.bSmart,\n\t\tregex:           obj.bRegex,\n\t\tcaseInsensitive: obj.bCaseInsensitive\n\t};\n}\n\n\n\n/**\n * Convert from camelCase notation to the internal Hungarian. We could use the\n * Hungarian convert function here, but this is cleaner\n *  @param {object} obj Object to convert\n *  @returns {object} Inverted object\n *  @memberof DataTable#oApi\n */\nfunction _fnSearchToHung ( obj )\n{\n\treturn {\n\t\tsSearch:          obj.search,\n\t\tbSmart:           obj.smart,\n\t\tbRegex:           obj.regex,\n\t\tbCaseInsensitive: obj.caseInsensitive\n\t};\n}\n\n/**\n * Generate the node required for the info display\n *  @param {object} oSettings dataTables settings object\n *  @returns {node} Information element\n *  @memberof DataTable#oApi\n */\nfunction _fnFeatureHtmlInfo ( settings )\n{\n\tvar\n\t\ttid = settings.sTableId,\n\t\tnodes = settings.aanFeatures.i,\n\t\tn = $('<div/>', {\n\t\t\t'class': settings.oClasses.sInfo,\n\t\t\t'id': ! nodes ? tid+'_info' : null\n\t\t} );\n\n\tif ( ! nodes ) {\n\t\t// Update display on each draw\n\t\tsettings.aoDrawCallback.push( {\n\t\t\t\"fn\": _fnUpdateInfo,\n\t\t\t\"sName\": \"information\"\n\t\t} );\n\n\t\tn\n\t\t\t.attr( 'role', 'status' )\n\t\t\t.attr( 'aria-live', 'polite' );\n\n\t\t// Table is described by our info div\n\t\t$(settings.nTable).attr( 'aria-describedby', tid+'_info' );\n\t}\n\n\treturn n[0];\n}\n\n\n/**\n * Update the information elements in the display\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnUpdateInfo ( settings )\n{\n\t/* Show information about the table */\n\tvar nodes = settings.aanFeatures.i;\n\tif ( nodes.length === 0 ) {\n\t\treturn;\n\t}\n\n\tvar\n\t\tlang  = settings.oLanguage,\n\t\tstart = settings._iDisplayStart+1,\n\t\tend   = settings.fnDisplayEnd(),\n\t\tmax   = settings.fnRecordsTotal(),\n\t\ttotal = settings.fnRecordsDisplay(),\n\t\tout   = total ?\n\t\t\tlang.sInfo :\n\t\t\tlang.sInfoEmpty;\n\n\tif ( total !== max ) {\n\t\t/* Record set after filtering */\n\t\tout += ' ' + lang.sInfoFiltered;\n\t}\n\n\t// Convert the macros\n\tout += lang.sInfoPostFix;\n\tout = _fnInfoMacros( settings, out );\n\n\tvar callback = lang.fnInfoCallback;\n\tif ( callback !== null ) {\n\t\tout = callback.call( settings.oInstance,\n\t\t\tsettings, start, end, max, total, out\n\t\t);\n\t}\n\n\t$(nodes).html( out );\n}\n\n\nfunction _fnInfoMacros ( settings, str )\n{\n\t// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\n\t// internally\n\tvar\n\t\tformatter  = settings.fnFormatNumber,\n\t\tstart      = settings._iDisplayStart+1,\n\t\tlen        = settings._iDisplayLength,\n\t\tvis        = settings.fnRecordsDisplay(),\n\t\tall        = len === -1;\n\n\treturn str.\n\t\treplace(/_START_/g, formatter.call( settings, start ) ).\n\t\treplace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).\n\t\treplace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).\n\t\treplace(/_TOTAL_/g, formatter.call( settings, vis ) ).\n\t\treplace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).\n\t\treplace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );\n}\n\n\n\n/**\n * Draw the table for the first time, adding all required features\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnInitialise ( settings )\n{\n\tvar i, iLen, iAjaxStart=settings.iInitDisplayStart;\n\tvar columns = settings.aoColumns, column;\n\tvar features = settings.oFeatures;\n\tvar deferLoading = settings.bDeferLoading; // value modified by the draw\n\n\t/* Ensure that the table data is fully initialised */\n\tif ( ! settings.bInitialised ) {\n\t\tsetTimeout( function(){ _fnInitialise( settings ); }, 200 );\n\t\treturn;\n\t}\n\n\t/* Show the display HTML options */\n\t_fnAddOptionsHtml( settings );\n\n\t/* Build and draw the header / footer for the table */\n\t_fnBuildHead( settings );\n\t_fnDrawHead( settings, settings.aoHeader );\n\t_fnDrawHead( settings, settings.aoFooter );\n\n\t/* Okay to show that something is going on now */\n\t_fnProcessingDisplay( settings, true );\n\n\t/* Calculate sizes for columns */\n\tif ( features.bAutoWidth ) {\n\t\t_fnCalculateColumnWidths( settings );\n\t}\n\n\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ ) {\n\t\tcolumn = columns[i];\n\n\t\tif ( column.sWidth ) {\n\t\t\tcolumn.nTh.style.width = _fnStringToCss( column.sWidth );\n\t\t}\n\t}\n\n\t_fnCallbackFire( settings, null, 'preInit', [settings] );\n\n\t// If there is default sorting required - let's do it. The sort function\n\t// will do the drawing for us. Otherwise we draw the table regardless of the\n\t// Ajax source - this allows the table to look initialised for Ajax sourcing\n\t// data (show 'loading' message possibly)\n\t_fnReDraw( settings );\n\n\t// Server-side processing init complete is done by _fnAjaxUpdateDraw\n\tvar dataSrc = _fnDataSource( settings );\n\tif ( dataSrc != 'ssp' || deferLoading ) {\n\t\t// if there is an ajax source load the data\n\t\tif ( dataSrc == 'ajax' ) {\n\t\t\t_fnBuildAjax( settings, [], function(json) {\n\t\t\t\tvar aData = _fnAjaxDataSrc( settings, json );\n\n\t\t\t\t// Got the data - add it to the table\n\t\t\t\tfor ( i=0 ; i<aData.length ; i++ ) {\n\t\t\t\t\t_fnAddData( settings, aData[i] );\n\t\t\t\t}\n\n\t\t\t\t// Reset the init display for cookie saving. We've already done\n\t\t\t\t// a filter, and therefore cleared it before. So we need to make\n\t\t\t\t// it appear 'fresh'\n\t\t\t\tsettings.iInitDisplayStart = iAjaxStart;\n\n\t\t\t\t_fnReDraw( settings );\n\n\t\t\t\t_fnProcessingDisplay( settings, false );\n\t\t\t\t_fnInitComplete( settings, json );\n\t\t\t}, settings );\n\t\t}\n\t\telse {\n\t\t\t_fnProcessingDisplay( settings, false );\n\t\t\t_fnInitComplete( settings );\n\t\t}\n\t}\n}\n\n\n/**\n * Draw the table for the first time, adding all required features\n *  @param {object} oSettings dataTables settings object\n *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\n *    with client-side processing (optional)\n *  @memberof DataTable#oApi\n */\nfunction _fnInitComplete ( settings, json )\n{\n\tsettings._bInitComplete = true;\n\n\t// When data was added after the initialisation (data or Ajax) we need to\n\t// calculate the column sizing\n\tif ( json || settings.oInit.aaData ) {\n\t\t_fnAdjustColumnSizing( settings );\n\t}\n\n\t_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );\n\t_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );\n}\n\n\nfunction _fnLengthChange ( settings, val )\n{\n\tvar len = parseInt( val, 10 );\n\tsettings._iDisplayLength = len;\n\n\t_fnLengthOverflow( settings );\n\n\t// Fire length change event\n\t_fnCallbackFire( settings, null, 'length', [settings, len] );\n}\n\n\n/**\n * Generate the node required for user display length changing\n *  @param {object} settings dataTables settings object\n *  @returns {node} Display length feature node\n *  @memberof DataTable#oApi\n */\nfunction _fnFeatureHtmlLength ( settings )\n{\n\tvar\n\t\tclasses  = settings.oClasses,\n\t\ttableId  = settings.sTableId,\n\t\tmenu     = settings.aLengthMenu,\n\t\td2       = Array.isArray( menu[0] ),\n\t\tlengths  = d2 ? menu[0] : menu,\n\t\tlanguage = d2 ? menu[1] : menu;\n\n\tvar select = $('<select/>', {\n\t\t'name':          tableId+'_length',\n\t\t'aria-controls': tableId,\n\t\t'class':         classes.sLengthSelect\n\t} );\n\n\tfor ( var i=0, ien=lengths.length ; i<ien ; i++ ) {\n\t\tselect[0][ i ] = new Option(\n\t\t\ttypeof language[i] === 'number' ?\n\t\t\t\tsettings.fnFormatNumber( language[i] ) :\n\t\t\t\tlanguage[i],\n\t\t\tlengths[i]\n\t\t);\n\t}\n\n\tvar div = $('<div><label/></div>').addClass( classes.sLength );\n\tif ( ! settings.aanFeatures.l ) {\n\t\tdiv[0].id = tableId+'_length';\n\t}\n\n\tdiv.children().append(\n\t\tsettings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )\n\t);\n\n\t// Can't use `select` variable as user might provide their own and the\n\t// reference is broken by the use of outerHTML\n\t$('select', div)\n\t\t.val( settings._iDisplayLength )\n\t\t.on( 'change.DT', function(e) {\n\t\t\t_fnLengthChange( settings, $(this).val() );\n\t\t\t_fnDraw( settings );\n\t\t} );\n\n\t// Update node value whenever anything changes the table's length\n\t$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {\n\t\tif ( settings === s ) {\n\t\t\t$('select', div).val( len );\n\t\t}\n\t} );\n\n\treturn div[0];\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Note that most of the paging logic is done in\n * DataTable.ext.pager\n */\n\n/**\n * Generate the node required for default pagination\n *  @param {object} oSettings dataTables settings object\n *  @returns {node} Pagination feature node\n *  @memberof DataTable#oApi\n */\nfunction _fnFeatureHtmlPaginate ( settings )\n{\n\tvar\n\t\ttype   = settings.sPaginationType,\n\t\tplugin = DataTable.ext.pager[ type ],\n\t\tmodern = typeof plugin === 'function',\n\t\tredraw = function( settings ) {\n\t\t\t_fnDraw( settings );\n\t\t},\n\t\tnode = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],\n\t\tfeatures = settings.aanFeatures;\n\n\tif ( ! modern ) {\n\t\tplugin.fnInit( settings, node, redraw );\n\t}\n\n\t/* Add a draw callback for the pagination on first instance, to update the paging display */\n\tif ( ! features.p )\n\t{\n\t\tnode.id = settings.sTableId+'_paginate';\n\n\t\tsettings.aoDrawCallback.push( {\n\t\t\t\"fn\": function( settings ) {\n\t\t\t\tif ( modern ) {\n\t\t\t\t\tvar\n\t\t\t\t\t\tstart      = settings._iDisplayStart,\n\t\t\t\t\t\tlen        = settings._iDisplayLength,\n\t\t\t\t\t\tvisRecords = settings.fnRecordsDisplay(),\n\t\t\t\t\t\tall        = len === -1,\n\t\t\t\t\t\tpage = all ? 0 : Math.ceil( start / len ),\n\t\t\t\t\t\tpages = all ? 1 : Math.ceil( visRecords / len ),\n\t\t\t\t\t\tbuttons = plugin(page, pages),\n\t\t\t\t\t\ti, ien;\n\n\t\t\t\t\tfor ( i=0, ien=features.p.length ; i<ien ; i++ ) {\n\t\t\t\t\t\t_fnRenderer( settings, 'pageButton' )(\n\t\t\t\t\t\t\tsettings, features.p[i], i, buttons, page, pages\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tplugin.fnUpdate( settings, redraw );\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"sName\": \"pagination\"\n\t\t} );\n\t}\n\n\treturn node;\n}\n\n\n/**\n * Alter the display settings to change the page\n *  @param {object} settings DataTables settings object\n *  @param {string|int} action Paging action to take: \"first\", \"previous\",\n *    \"next\" or \"last\" or page number to jump to (integer)\n *  @param [bool] redraw Automatically draw the update or not\n *  @returns {bool} true page has changed, false - no change\n *  @memberof DataTable#oApi\n */\nfunction _fnPageChange ( settings, action, redraw )\n{\n\tvar\n\t\tstart     = settings._iDisplayStart,\n\t\tlen       = settings._iDisplayLength,\n\t\trecords   = settings.fnRecordsDisplay();\n\n\tif ( records === 0 || len === -1 )\n\t{\n\t\tstart = 0;\n\t}\n\telse if ( typeof action === \"number\" )\n\t{\n\t\tstart = action * len;\n\n\t\tif ( start > records )\n\t\t{\n\t\t\tstart = 0;\n\t\t}\n\t}\n\telse if ( action == \"first\" )\n\t{\n\t\tstart = 0;\n\t}\n\telse if ( action == \"previous\" )\n\t{\n\t\tstart = len >= 0 ?\n\t\t\tstart - len :\n\t\t\t0;\n\n\t\tif ( start < 0 )\n\t\t{\n\t\t  start = 0;\n\t\t}\n\t}\n\telse if ( action == \"next\" )\n\t{\n\t\tif ( start + len < records )\n\t\t{\n\t\t\tstart += len;\n\t\t}\n\t}\n\telse if ( action == \"last\" )\n\t{\n\t\tstart = Math.floor( (records-1) / len) * len;\n\t}\n\telse\n\t{\n\t\t_fnLog( settings, 0, \"Unknown paging action: \"+action, 5 );\n\t}\n\n\tvar changed = settings._iDisplayStart !== start;\n\tsettings._iDisplayStart = start;\n\n\tif ( changed ) {\n\t\t_fnCallbackFire( settings, null, 'page', [settings] );\n\n\t\tif ( redraw ) {\n\t\t\t_fnDraw( settings );\n\t\t}\n\t}\n\telse {\n\t\t// No change event - paging was called, but no change\n\t\t_fnCallbackFire( settings, null, 'page-nc', [settings] );\n\t}\n\n\treturn changed;\n}\n\n\n\n/**\n * Generate the node required for the processing node\n *  @param {object} settings dataTables settings object\n *  @returns {node} Processing element\n *  @memberof DataTable#oApi\n */\nfunction _fnFeatureHtmlProcessing ( settings )\n{\n\treturn $('<div/>', {\n\t\t\t'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,\n\t\t\t'class': settings.oClasses.sProcessing,\n\t\t\t'role': 'status'\n\t\t} )\n\t\t.html( settings.oLanguage.sProcessing )\n\t\t.append('<div><div></div><div></div><div></div><div></div></div>')\n\t\t.insertBefore( settings.nTable )[0];\n}\n\n\n/**\n * Display or hide the processing indicator\n *  @param {object} settings dataTables settings object\n *  @param {bool} show Show the processing indicator (true) or not (false)\n *  @memberof DataTable#oApi\n */\nfunction _fnProcessingDisplay ( settings, show )\n{\n\tif ( settings.oFeatures.bProcessing ) {\n\t\t$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );\n\t}\n\n\t_fnCallbackFire( settings, null, 'processing', [settings, show] );\n}\n\n/**\n * Add any control elements for the table - specifically scrolling\n *  @param {object} settings dataTables settings object\n *  @returns {node} Node to add to the DOM\n *  @memberof DataTable#oApi\n */\nfunction _fnFeatureHtmlTable ( settings )\n{\n\tvar table = $(settings.nTable);\n\n\t// Scrolling from here on in\n\tvar scroll = settings.oScroll;\n\n\tif ( scroll.sX === '' && scroll.sY === '' ) {\n\t\treturn settings.nTable;\n\t}\n\n\tvar scrollX = scroll.sX;\n\tvar scrollY = scroll.sY;\n\tvar classes = settings.oClasses;\n\tvar caption = table.children('caption');\n\tvar captionSide = caption.length ? caption[0]._captionSide : null;\n\tvar headerClone = $( table[0].cloneNode(false) );\n\tvar footerClone = $( table[0].cloneNode(false) );\n\tvar footer = table.children('tfoot');\n\tvar _div = '<div/>';\n\tvar size = function ( s ) {\n\t\treturn !s ? null : _fnStringToCss( s );\n\t};\n\n\tif ( ! footer.length ) {\n\t\tfooter = null;\n\t}\n\n\t/*\n\t * The HTML structure that we want to generate in this function is:\n\t *  div - scroller\n\t *    div - scroll head\n\t *      div - scroll head inner\n\t *        table - scroll head table\n\t *          thead - thead\n\t *    div - scroll body\n\t *      table - table (master table)\n\t *        thead - thead clone for sizing\n\t *        tbody - tbody\n\t *    div - scroll foot\n\t *      div - scroll foot inner\n\t *        table - scroll foot table\n\t *          tfoot - tfoot\n\t */\n\tvar scroller = $( _div, { 'class': classes.sScrollWrapper } )\n\t\t.append(\n\t\t\t$(_div, { 'class': classes.sScrollHead } )\n\t\t\t\t.css( {\n\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\tposition: 'relative',\n\t\t\t\t\tborder: 0,\n\t\t\t\t\twidth: scrollX ? size(scrollX) : '100%'\n\t\t\t\t} )\n\t\t\t\t.append(\n\t\t\t\t\t$(_div, { 'class': classes.sScrollHeadInner } )\n\t\t\t\t\t\t.css( {\n\t\t\t\t\t\t\t'box-sizing': 'content-box',\n\t\t\t\t\t\t\twidth: scroll.sXInner || '100%'\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\theaderClone\n\t\t\t\t\t\t\t\t.removeAttr('id')\n\t\t\t\t\t\t\t\t.css( 'margin-left', 0 )\n\t\t\t\t\t\t\t\t.append( captionSide === 'top' ? caption : null )\n\t\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t\ttable.children('thead')\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t)\n\t\t.append(\n\t\t\t$(_div, { 'class': classes.sScrollBody } )\n\t\t\t\t.css( {\n\t\t\t\t\tposition: 'relative',\n\t\t\t\t\toverflow: 'auto',\n\t\t\t\t\twidth: size( scrollX )\n\t\t\t\t} )\n\t\t\t\t.append( table )\n\t\t);\n\n\tif ( footer ) {\n\t\tscroller.append(\n\t\t\t$(_div, { 'class': classes.sScrollFoot } )\n\t\t\t\t.css( {\n\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\tborder: 0,\n\t\t\t\t\twidth: scrollX ? size(scrollX) : '100%'\n\t\t\t\t} )\n\t\t\t\t.append(\n\t\t\t\t\t$(_div, { 'class': classes.sScrollFootInner } )\n\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\tfooterClone\n\t\t\t\t\t\t\t\t.removeAttr('id')\n\t\t\t\t\t\t\t\t.css( 'margin-left', 0 )\n\t\t\t\t\t\t\t\t.append( captionSide === 'bottom' ? caption : null )\n\t\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t\ttable.children('tfoot')\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\t}\n\n\tvar children = scroller.children();\n\tvar scrollHead = children[0];\n\tvar scrollBody = children[1];\n\tvar scrollFoot = footer ? children[2] : null;\n\n\t// When the body is scrolled, then we also want to scroll the headers\n\tif ( scrollX ) {\n\t\t$(scrollBody).on( 'scroll.DT', function (e) {\n\t\t\tvar scrollLeft = this.scrollLeft;\n\n\t\t\tscrollHead.scrollLeft = scrollLeft;\n\n\t\t\tif ( footer ) {\n\t\t\t\tscrollFoot.scrollLeft = scrollLeft;\n\t\t\t}\n\t\t} );\n\t}\n\n\t$(scrollBody).css('max-height', scrollY);\n\tif (! scroll.bCollapse) {\n\t\t$(scrollBody).css('height', scrollY);\n\t}\n\n\tsettings.nScrollHead = scrollHead;\n\tsettings.nScrollBody = scrollBody;\n\tsettings.nScrollFoot = scrollFoot;\n\n\t// On redraw - align columns\n\tsettings.aoDrawCallback.push( {\n\t\t\"fn\": _fnScrollDraw,\n\t\t\"sName\": \"scrolling\"\n\t} );\n\n\treturn scroller[0];\n}\n\n\n\n/**\n * Update the header, footer and body tables for resizing - i.e. column\n * alignment.\n *\n * Welcome to the most horrible function DataTables. The process that this\n * function follows is basically:\n *   1. Re-create the table inside the scrolling div\n *   2. Take live measurements from the DOM\n *   3. Apply the measurements to align the columns\n *   4. Clean up\n *\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnScrollDraw ( settings )\n{\n\t// Given that this is such a monster function, a lot of variables are use\n\t// to try and keep the minimised size as small as possible\n\tvar\n\t\tscroll         = settings.oScroll,\n\t\tscrollX        = scroll.sX,\n\t\tscrollXInner   = scroll.sXInner,\n\t\tscrollY        = scroll.sY,\n\t\tbarWidth       = scroll.iBarWidth,\n\t\tdivHeader      = $(settings.nScrollHead),\n\t\tdivHeaderStyle = divHeader[0].style,\n\t\tdivHeaderInner = divHeader.children('div'),\n\t\tdivHeaderInnerStyle = divHeaderInner[0].style,\n\t\tdivHeaderTable = divHeaderInner.children('table'),\n\t\tdivBodyEl      = settings.nScrollBody,\n\t\tdivBody        = $(divBodyEl),\n\t\tdivBodyStyle   = divBodyEl.style,\n\t\tdivFooter      = $(settings.nScrollFoot),\n\t\tdivFooterInner = divFooter.children('div'),\n\t\tdivFooterTable = divFooterInner.children('table'),\n\t\theader         = $(settings.nTHead),\n\t\ttable          = $(settings.nTable),\n\t\ttableEl        = table[0],\n\t\ttableStyle     = tableEl.style,\n\t\tfooter         = settings.nTFoot ? $(settings.nTFoot) : null,\n\t\tbrowser        = settings.oBrowser,\n\t\tie67           = browser.bScrollOversize,\n\t\tdtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),\n\t\theaderTrgEls, footerTrgEls,\n\t\theaderSrcEls, footerSrcEls,\n\t\theaderCopy, footerCopy,\n\t\theaderWidths=[], footerWidths=[],\n\t\theaderContent=[], footerContent=[],\n\t\tidx, correction, sanityWidth,\n\t\tzeroOut = function(nSizer) {\n\t\t\tvar style = nSizer.style;\n\t\t\tstyle.paddingTop = \"0\";\n\t\t\tstyle.paddingBottom = \"0\";\n\t\t\tstyle.borderTopWidth = \"0\";\n\t\t\tstyle.borderBottomWidth = \"0\";\n\t\t\tstyle.height = 0;\n\t\t};\n\n\t// If the scrollbar visibility has changed from the last draw, we need to\n\t// adjust the column sizes as the table width will have changed to account\n\t// for the scrollbar\n\tvar scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;\n\t\n\tif ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {\n\t\tsettings.scrollBarVis = scrollBarVis;\n\t\t_fnAdjustColumnSizing( settings );\n\t\treturn; // adjust column sizing will call this function again\n\t}\n\telse {\n\t\tsettings.scrollBarVis = scrollBarVis;\n\t}\n\n\t/*\n\t * 1. Re-create the table inside the scrolling div\n\t */\n\n\t// Remove the old minimised thead and tfoot elements in the inner table\n\ttable.children('thead, tfoot').remove();\n\n\tif ( footer ) {\n\t\tfooterCopy = footer.clone().prependTo( table );\n\t\tfooterTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized\n\t\tfooterSrcEls = footerCopy.find('tr');\n\t\tfooterCopy.find('[id]').removeAttr('id');\n\t}\n\n\t// Clone the current header and footer elements and then place it into the inner table\n\theaderCopy = header.clone().prependTo( table );\n\theaderTrgEls = header.find('tr'); // original header is in its own table\n\theaderSrcEls = headerCopy.find('tr');\n\theaderCopy.find('th, td').removeAttr('tabindex');\n\theaderCopy.find('[id]').removeAttr('id');\n\n\n\t/*\n\t * 2. Take live measurements from the DOM - do not alter the DOM itself!\n\t */\n\n\t// Remove old sizing and apply the calculated column widths\n\t// Get the unique column headers in the newly created (cloned) header. We want to apply the\n\t// calculated sizes to this header\n\tif ( ! scrollX )\n\t{\n\t\tdivBodyStyle.width = '100%';\n\t\tdivHeader[0].style.width = '100%';\n\t}\n\n\t$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {\n\t\tidx = _fnVisibleToColumnIndex( settings, i );\n\t\tel.style.width = settings.aoColumns[idx].sWidth;\n\t} );\n\n\tif ( footer ) {\n\t\t_fnApplyToChildren( function(n) {\n\t\t\tn.style.width = \"\";\n\t\t}, footerSrcEls );\n\t}\n\n\t// Size the table as a whole\n\tsanityWidth = table.outerWidth();\n\tif ( scrollX === \"\" ) {\n\t\t// No x scrolling\n\t\ttableStyle.width = \"100%\";\n\n\t\t// IE7 will make the width of the table when 100% include the scrollbar\n\t\t// - which is shouldn't. When there is a scrollbar we need to take this\n\t\t// into account.\n\t\tif ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||\n\t\t\tdivBody.css('overflow-y') == \"scroll\")\n\t\t) {\n\t\t\ttableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);\n\t\t}\n\n\t\t// Recalculate the sanity width\n\t\tsanityWidth = table.outerWidth();\n\t}\n\telse if ( scrollXInner !== \"\" ) {\n\t\t// legacy x scroll inner has been given - use it\n\t\ttableStyle.width = _fnStringToCss(scrollXInner);\n\n\t\t// Recalculate the sanity width\n\t\tsanityWidth = table.outerWidth();\n\t}\n\n\t// Hidden header should have zero height, so remove padding and borders. Then\n\t// set the width based on the real headers\n\n\t// Apply all styles in one pass\n\t_fnApplyToChildren( zeroOut, headerSrcEls );\n\n\t// Read all widths in next pass\n\t_fnApplyToChildren( function(nSizer) {\n\t\tvar style = window.getComputedStyle ?\n\t\t\twindow.getComputedStyle(nSizer).width :\n\t\t\t_fnStringToCss( $(nSizer).width() );\n\n\t\theaderContent.push( nSizer.innerHTML );\n\t\theaderWidths.push( style );\n\t}, headerSrcEls );\n\n\t// Apply all widths in final pass\n\t_fnApplyToChildren( function(nToSize, i) {\n\t\tnToSize.style.width = headerWidths[i];\n\t}, headerTrgEls );\n\n\t$(headerSrcEls).css('height', 0);\n\n\t/* Same again with the footer if we have one */\n\tif ( footer )\n\t{\n\t\t_fnApplyToChildren( zeroOut, footerSrcEls );\n\n\t\t_fnApplyToChildren( function(nSizer) {\n\t\t\tfooterContent.push( nSizer.innerHTML );\n\t\t\tfooterWidths.push( _fnStringToCss( $(nSizer).css('width') ) );\n\t\t}, footerSrcEls );\n\n\t\t_fnApplyToChildren( function(nToSize, i) {\n\t\t\tnToSize.style.width = footerWidths[i];\n\t\t}, footerTrgEls );\n\n\t\t$(footerSrcEls).height(0);\n\t}\n\n\n\t/*\n\t * 3. Apply the measurements\n\t */\n\n\t// \"Hide\" the header and footer that we used for the sizing. We need to keep\n\t// the content of the cell so that the width applied to the header and body\n\t// both match, but we want to hide it completely. We want to also fix their\n\t// width to what they currently are\n\t_fnApplyToChildren( function(nSizer, i) {\n\t\tnSizer.innerHTML = '<div class=\"dataTables_sizing\">'+headerContent[i]+'</div>';\n\t\tnSizer.childNodes[0].style.height = \"0\";\n\t\tnSizer.childNodes[0].style.overflow = \"hidden\";\n\t\tnSizer.style.width = headerWidths[i];\n\t}, headerSrcEls );\n\n\tif ( footer )\n\t{\n\t\t_fnApplyToChildren( function(nSizer, i) {\n\t\t\tnSizer.innerHTML = '<div class=\"dataTables_sizing\">'+footerContent[i]+'</div>';\n\t\t\tnSizer.childNodes[0].style.height = \"0\";\n\t\t\tnSizer.childNodes[0].style.overflow = \"hidden\";\n\t\t\tnSizer.style.width = footerWidths[i];\n\t\t}, footerSrcEls );\n\t}\n\n\t// Sanity check that the table is of a sensible width. If not then we are going to get\n\t// misalignment - try to prevent this by not allowing the table to shrink below its min width\n\tif ( Math.round(table.outerWidth()) < Math.round(sanityWidth) )\n\t{\n\t\t// The min width depends upon if we have a vertical scrollbar visible or not */\n\t\tcorrection = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||\n\t\t\tdivBody.css('overflow-y') == \"scroll\")) ?\n\t\t\t\tsanityWidth+barWidth :\n\t\t\t\tsanityWidth;\n\n\t\t// IE6/7 are a law unto themselves...\n\t\tif ( ie67 && (divBodyEl.scrollHeight >\n\t\t\tdivBodyEl.offsetHeight || divBody.css('overflow-y') == \"scroll\")\n\t\t) {\n\t\t\ttableStyle.width = _fnStringToCss( correction-barWidth );\n\t\t}\n\n\t\t// And give the user a warning that we've stopped the table getting too small\n\t\tif ( scrollX === \"\" || scrollXInner !== \"\" ) {\n\t\t\t_fnLog( settings, 1, 'Possible column misalignment', 6 );\n\t\t}\n\t}\n\telse\n\t{\n\t\tcorrection = '100%';\n\t}\n\n\t// Apply to the container elements\n\tdivBodyStyle.width = _fnStringToCss( correction );\n\tdivHeaderStyle.width = _fnStringToCss( correction );\n\n\tif ( footer ) {\n\t\tsettings.nScrollFoot.style.width = _fnStringToCss( correction );\n\t}\n\n\n\t/*\n\t * 4. Clean up\n\t */\n\tif ( ! scrollY ) {\n\t\t/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\n\t\t * the scrollbar height from the visible display, rather than adding it on. We need to\n\t\t * set the height in order to sort this. Don't want to do it in any other browsers.\n\t\t */\n\t\tif ( ie67 ) {\n\t\t\tdivBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );\n\t\t}\n\t}\n\n\t/* Finally set the width's of the header and footer tables */\n\tvar iOuterWidth = table.outerWidth();\n\tdivHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );\n\tdivHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );\n\n\t// Figure out if there are scrollbar present - if so then we need a the header and footer to\n\t// provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\n\tvar bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == \"scroll\";\n\tvar padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );\n\tdivHeaderInnerStyle[ padding ] = bScrolling ? barWidth+\"px\" : \"0px\";\n\n\tif ( footer ) {\n\t\tdivFooterTable[0].style.width = _fnStringToCss( iOuterWidth );\n\t\tdivFooterInner[0].style.width = _fnStringToCss( iOuterWidth );\n\t\tdivFooterInner[0].style[padding] = bScrolling ? barWidth+\"px\" : \"0px\";\n\t}\n\n\t// Correct DOM ordering for colgroup - comes before the thead\n\ttable.children('colgroup').insertBefore( table.children('thead') );\n\n\t/* Adjust the position of the header in case we loose the y-scrollbar */\n\tdivBody.trigger('scroll');\n\n\t// If sorting or filtering has occurred, jump the scrolling back to the top\n\t// only if we aren't holding the position\n\tif ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {\n\t\tdivBodyEl.scrollTop = 0;\n\t}\n}\n\n\n\n/**\n * Apply a given function to the display child nodes of an element array (typically\n * TD children of TR rows\n *  @param {function} fn Method to apply to the objects\n *  @param array {nodes} an1 List of elements to look through for display children\n *  @param array {nodes} an2 Another list (identical structure to the first) - optional\n *  @memberof DataTable#oApi\n */\nfunction _fnApplyToChildren( fn, an1, an2 )\n{\n\tvar index=0, i=0, iLen=an1.length;\n\tvar nNode1, nNode2;\n\n\twhile ( i < iLen ) {\n\t\tnNode1 = an1[i].firstChild;\n\t\tnNode2 = an2 ? an2[i].firstChild : null;\n\n\t\twhile ( nNode1 ) {\n\t\t\tif ( nNode1.nodeType === 1 ) {\n\t\t\t\tif ( an2 ) {\n\t\t\t\t\tfn( nNode1, nNode2, index );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfn( nNode1, index );\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tnNode1 = nNode1.nextSibling;\n\t\t\tnNode2 = an2 ? nNode2.nextSibling : null;\n\t\t}\n\n\t\ti++;\n\t}\n}\n\n\n\nvar __re_html_remove = /<.*?>/g;\n\n\n/**\n * Calculate the width of columns for the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnCalculateColumnWidths ( oSettings )\n{\n\tvar\n\t\ttable = oSettings.nTable,\n\t\tcolumns = oSettings.aoColumns,\n\t\tscroll = oSettings.oScroll,\n\t\tscrollY = scroll.sY,\n\t\tscrollX = scroll.sX,\n\t\tscrollXInner = scroll.sXInner,\n\t\tcolumnCount = columns.length,\n\t\tvisibleColumns = _fnGetColumns( oSettings, 'bVisible' ),\n\t\theaderCells = $('th', oSettings.nTHead),\n\t\ttableWidthAttr = table.getAttribute('width'), // from DOM element\n\t\ttableContainer = table.parentNode,\n\t\tuserInputs = false,\n\t\ti, column, columnIdx, width, outerWidth,\n\t\tbrowser = oSettings.oBrowser,\n\t\tie67 = browser.bScrollOversize;\n\n\tvar styleWidth = table.style.width;\n\tif ( styleWidth && styleWidth.indexOf('%') !== -1 ) {\n\t\ttableWidthAttr = styleWidth;\n\t}\n\n\t/* Convert any user input sizes into pixel sizes */\n\tfor ( i=0 ; i<visibleColumns.length ; i++ ) {\n\t\tcolumn = columns[ visibleColumns[i] ];\n\n\t\tif ( column.sWidth !== null ) {\n\t\t\tcolumn.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );\n\n\t\t\tuserInputs = true;\n\t\t}\n\t}\n\n\t/* If the number of columns in the DOM equals the number that we have to\n\t * process in DataTables, then we can use the offsets that are created by\n\t * the web- browser. No custom sizes can be set in order for this to happen,\n\t * nor scrolling used\n\t */\n\tif ( ie67 || ! userInputs && ! scrollX && ! scrollY &&\n\t     columnCount == _fnVisbleColumns( oSettings ) &&\n\t     columnCount == headerCells.length\n\t) {\n\t\tfor ( i=0 ; i<columnCount ; i++ ) {\n\t\t\tvar colIdx = _fnVisibleToColumnIndex( oSettings, i );\n\n\t\t\tif ( colIdx !== null ) {\n\t\t\t\tcolumns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Otherwise construct a single row, worst case, table with the widest\n\t\t// node in the data, assign any user defined widths, then insert it into\n\t\t// the DOM and allow the browser to do all the hard work of calculating\n\t\t// table widths\n\t\tvar tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table\n\t\t\t.css( 'visibility', 'hidden' )\n\t\t\t.removeAttr( 'id' );\n\n\t\t// Clean up the table body\n\t\ttmpTable.find('tbody tr').remove();\n\t\tvar tr = $('<tr/>').appendTo( tmpTable.find('tbody') );\n\n\t\t// Clone the table header and footer - we can't use the header / footer\n\t\t// from the cloned table, since if scrolling is active, the table's\n\t\t// real header and footer are contained in different table tags\n\t\ttmpTable.find('thead, tfoot').remove();\n\t\ttmpTable\n\t\t\t.append( $(oSettings.nTHead).clone() )\n\t\t\t.append( $(oSettings.nTFoot).clone() );\n\n\t\t// Remove any assigned widths from the footer (from scrolling)\n\t\ttmpTable.find('tfoot th, tfoot td').css('width', '');\n\n\t\t// Apply custom sizing to the cloned header\n\t\theaderCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );\n\n\t\tfor ( i=0 ; i<visibleColumns.length ; i++ ) {\n\t\t\tcolumn = columns[ visibleColumns[i] ];\n\n\t\t\theaderCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?\n\t\t\t\t_fnStringToCss( column.sWidthOrig ) :\n\t\t\t\t'';\n\n\t\t\t// For scrollX we need to force the column width otherwise the\n\t\t\t// browser will collapse it. If this width is smaller than the\n\t\t\t// width the column requires, then it will have no effect\n\t\t\tif ( column.sWidthOrig && scrollX ) {\n\t\t\t\t$( headerCells[i] ).append( $('<div/>').css( {\n\t\t\t\t\twidth: column.sWidthOrig,\n\t\t\t\t\tmargin: 0,\n\t\t\t\t\tpadding: 0,\n\t\t\t\t\tborder: 0,\n\t\t\t\t\theight: 1\n\t\t\t\t} ) );\n\t\t\t}\n\t\t}\n\n\t\t// Find the widest cell for each column and put it into the table\n\t\tif ( oSettings.aoData.length ) {\n\t\t\tfor ( i=0 ; i<visibleColumns.length ; i++ ) {\n\t\t\t\tcolumnIdx = visibleColumns[i];\n\t\t\t\tcolumn = columns[ columnIdx ];\n\n\t\t\t\t$( _fnGetWidestNode( oSettings, columnIdx ) )\n\t\t\t\t\t.clone( false )\n\t\t\t\t\t.append( column.sContentPadding )\n\t\t\t\t\t.appendTo( tr );\n\t\t\t}\n\t\t}\n\n\t\t// Tidy the temporary table - remove name attributes so there aren't\n\t\t// duplicated in the dom (radio elements for example)\n\t\t$('[name]', tmpTable).removeAttr('name');\n\n\t\t// Table has been built, attach to the document so we can work with it.\n\t\t// A holding element is used, positioned at the top of the container\n\t\t// with minimal height, so it has no effect on if the container scrolls\n\t\t// or not. Otherwise it might trigger scrolling when it actually isn't\n\t\t// needed\n\t\tvar holder = $('<div/>').css( scrollX || scrollY ?\n\t\t\t\t{\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\theight: 1,\n\t\t\t\t\tright: 0,\n\t\t\t\t\toverflow: 'hidden'\n\t\t\t\t} :\n\t\t\t\t{}\n\t\t\t)\n\t\t\t.append( tmpTable )\n\t\t\t.appendTo( tableContainer );\n\n\t\t// When scrolling (X or Y) we want to set the width of the table as \n\t\t// appropriate. However, when not scrolling leave the table width as it\n\t\t// is. This results in slightly different, but I think correct behaviour\n\t\tif ( scrollX && scrollXInner ) {\n\t\t\ttmpTable.width( scrollXInner );\n\t\t}\n\t\telse if ( scrollX ) {\n\t\t\ttmpTable.css( 'width', 'auto' );\n\t\t\ttmpTable.removeAttr('width');\n\n\t\t\t// If there is no width attribute or style, then allow the table to\n\t\t\t// collapse\n\t\t\tif ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {\n\t\t\t\ttmpTable.width( tableContainer.clientWidth );\n\t\t\t}\n\t\t}\n\t\telse if ( scrollY ) {\n\t\t\ttmpTable.width( tableContainer.clientWidth );\n\t\t}\n\t\telse if ( tableWidthAttr ) {\n\t\t\ttmpTable.width( tableWidthAttr );\n\t\t}\n\n\t\t// Get the width of each column in the constructed table - we need to\n\t\t// know the inner width (so it can be assigned to the other table's\n\t\t// cells) and the outer width so we can calculate the full width of the\n\t\t// table. This is safe since DataTables requires a unique cell for each\n\t\t// column, but if ever a header can span multiple columns, this will\n\t\t// need to be modified.\n\t\tvar total = 0;\n\t\tfor ( i=0 ; i<visibleColumns.length ; i++ ) {\n\t\t\tvar cell = $(headerCells[i]);\n\t\t\tvar border = cell.outerWidth() - cell.width();\n\n\t\t\t// Use getBounding... where possible (not IE8-) because it can give\n\t\t\t// sub-pixel accuracy, which we then want to round up!\n\t\t\tvar bounding = browser.bBounding ?\n\t\t\t\tMath.ceil( headerCells[i].getBoundingClientRect().width ) :\n\t\t\t\tcell.outerWidth();\n\n\t\t\t// Total is tracked to remove any sub-pixel errors as the outerWidth\n\t\t\t// of the table might not equal the total given here (IE!).\n\t\t\ttotal += bounding;\n\n\t\t\t// Width for each column to use\n\t\t\tcolumns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );\n\t\t}\n\n\t\ttable.style.width = _fnStringToCss( total );\n\n\t\t// Finished with the table - ditch it\n\t\tholder.remove();\n\t}\n\n\t// If there is a width attr, we want to attach an event listener which\n\t// allows the table sizing to automatically adjust when the window is\n\t// resized. Use the width attr rather than CSS, since we can't know if the\n\t// CSS is a relative value or absolute - DOM read is always px.\n\tif ( tableWidthAttr ) {\n\t\ttable.style.width = _fnStringToCss( tableWidthAttr );\n\t}\n\n\tif ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {\n\t\tvar bindResize = function () {\n\t\t\t$(window).on('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {\n\t\t\t\t_fnAdjustColumnSizing( oSettings );\n\t\t\t} ) );\n\t\t};\n\n\t\t// IE6/7 will crash if we bind a resize event handler on page load.\n\t\t// To be removed in 1.11 which drops IE6/7 support\n\t\tif ( ie67 ) {\n\t\t\tsetTimeout( bindResize, 1000 );\n\t\t}\n\t\telse {\n\t\t\tbindResize();\n\t\t}\n\n\t\toSettings._reszEvt = true;\n\t}\n}\n\n\n/**\n * Throttle the calls to a function. Arguments and context are maintained for\n * the throttled function\n *  @param {function} fn Function to be called\n *  @param {int} [freq=200] call frequency in mS\n *  @returns {function} wrapped function\n *  @memberof DataTable#oApi\n */\nvar _fnThrottle = DataTable.util.throttle;\n\n\n/**\n * Convert a CSS unit width to pixels (e.g. 2em)\n *  @param {string} width width to be converted\n *  @param {node} parent parent to get the with for (required for relative widths) - optional\n *  @returns {int} width in pixels\n *  @memberof DataTable#oApi\n */\nfunction _fnConvertToWidth ( width, parent )\n{\n\tif ( ! width ) {\n\t\treturn 0;\n\t}\n\n\tvar n = $('<div/>')\n\t\t.css( 'width', _fnStringToCss( width ) )\n\t\t.appendTo( parent || document.body );\n\n\tvar val = n[0].offsetWidth;\n\tn.remove();\n\n\treturn val;\n}\n\n\n/**\n * Get the widest node\n *  @param {object} settings dataTables settings object\n *  @param {int} colIdx column of interest\n *  @returns {node} widest table node\n *  @memberof DataTable#oApi\n */\nfunction _fnGetWidestNode( settings, colIdx )\n{\n\tvar idx = _fnGetMaxLenString( settings, colIdx );\n\tif ( idx < 0 ) {\n\t\treturn null;\n\t}\n\n\tvar data = settings.aoData[ idx ];\n\treturn ! data.nTr ? // Might not have been created when deferred rendering\n\t\t$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :\n\t\tdata.anCells[ colIdx ];\n}\n\n\n/**\n * Get the maximum strlen for each data column\n *  @param {object} settings dataTables settings object\n *  @param {int} colIdx column of interest\n *  @returns {string} max string length for each column\n *  @memberof DataTable#oApi\n */\nfunction _fnGetMaxLenString( settings, colIdx )\n{\n\tvar s, max=-1, maxIdx = -1;\n\n\tfor ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n\t\ts = _fnGetCellData( settings, i, colIdx, 'display' )+'';\n\t\ts = s.replace( __re_html_remove, '' );\n\t\ts = s.replace( /&nbsp;/g, ' ' );\n\n\t\tif ( s.length > max ) {\n\t\t\tmax = s.length;\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\n\treturn maxIdx;\n}\n\n\n/**\n * Append a CSS unit (only if required) to a string\n *  @param {string} value to css-ify\n *  @returns {string} value with css unit\n *  @memberof DataTable#oApi\n */\nfunction _fnStringToCss( s )\n{\n\tif ( s === null ) {\n\t\treturn '0px';\n\t}\n\n\tif ( typeof s == 'number' ) {\n\t\treturn s < 0 ?\n\t\t\t'0px' :\n\t\t\ts+'px';\n\t}\n\n\t// Check it has a unit character already\n\treturn s.match(/\\d$/) ?\n\t\ts+'px' :\n\t\ts;\n}\n\n\n\nfunction _fnSortFlatten ( settings )\n{\n\tvar\n\t\ti, iLen, k, kLen,\n\t\taSort = [],\n\t\taiOrig = [],\n\t\taoColumns = settings.aoColumns,\n\t\taDataSort, iCol, sType, srcCol,\n\t\tfixed = settings.aaSortingFixed,\n\t\tfixedObj = $.isPlainObject( fixed ),\n\t\tnestedSort = [],\n\t\tadd = function ( a ) {\n\t\t\tif ( a.length && ! Array.isArray( a[0] ) ) {\n\t\t\t\t// 1D array\n\t\t\t\tnestedSort.push( a );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 2D array\n\t\t\t\t$.merge( nestedSort, a );\n\t\t\t}\n\t\t};\n\n\t// Build the sort array, with pre-fix and post-fix options if they have been\n\t// specified\n\tif ( Array.isArray( fixed ) ) {\n\t\tadd( fixed );\n\t}\n\n\tif ( fixedObj && fixed.pre ) {\n\t\tadd( fixed.pre );\n\t}\n\n\tadd( settings.aaSorting );\n\n\tif (fixedObj && fixed.post ) {\n\t\tadd( fixed.post );\n\t}\n\n\tfor ( i=0 ; i<nestedSort.length ; i++ )\n\t{\n\t\tsrcCol = nestedSort[i][0];\n\t\taDataSort = aoColumns[ srcCol ].aDataSort;\n\n\t\tfor ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )\n\t\t{\n\t\t\tiCol = aDataSort[k];\n\t\t\tsType = aoColumns[ iCol ].sType || 'string';\n\n\t\t\tif ( nestedSort[i]._idx === undefined ) {\n\t\t\t\tnestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );\n\t\t\t}\n\n\t\t\taSort.push( {\n\t\t\t\tsrc:       srcCol,\n\t\t\t\tcol:       iCol,\n\t\t\t\tdir:       nestedSort[i][1],\n\t\t\t\tindex:     nestedSort[i]._idx,\n\t\t\t\ttype:      sType,\n\t\t\t\tformatter: DataTable.ext.type.order[ sType+\"-pre\" ]\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn aSort;\n}\n\n/**\n * Change the order of the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n *  @todo This really needs split up!\n */\nfunction _fnSort ( oSettings )\n{\n\tvar\n\t\ti, ien, iLen, j, jLen, k, kLen,\n\t\tsDataType, nTh,\n\t\taiOrig = [],\n\t\toExtSort = DataTable.ext.type.order,\n\t\taoData = oSettings.aoData,\n\t\taoColumns = oSettings.aoColumns,\n\t\taDataSort, data, iCol, sType, oSort,\n\t\tformatters = 0,\n\t\tsortCol,\n\t\tdisplayMaster = oSettings.aiDisplayMaster,\n\t\taSort;\n\n\t// Resolve any column types that are unknown due to addition or invalidation\n\t// @todo Can this be moved into a 'data-ready' handler which is called when\n\t//   data is going to be used in the table?\n\t_fnColumnTypes( oSettings );\n\n\taSort = _fnSortFlatten( oSettings );\n\n\tfor ( i=0, ien=aSort.length ; i<ien ; i++ ) {\n\t\tsortCol = aSort[i];\n\n\t\t// Track if we can use the fast sort algorithm\n\t\tif ( sortCol.formatter ) {\n\t\t\tformatters++;\n\t\t}\n\n\t\t// Load the data needed for the sort, for each cell\n\t\t_fnSortData( oSettings, sortCol.col );\n\t}\n\n\t/* No sorting required if server-side or no sorting array */\n\tif ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )\n\t{\n\t\t// Create a value - key array of the current row positions such that we can use their\n\t\t// current position during the sort, if values match, in order to perform stable sorting\n\t\tfor ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {\n\t\t\taiOrig[ displayMaster[i] ] = i;\n\t\t}\n\n\t\t/* Do the sort - here we want multi-column sorting based on a given data source (column)\n\t\t * and sorting function (from oSort) in a certain direction. It's reasonably complex to\n\t\t * follow on it's own, but this is what we want (example two column sorting):\n\t\t *  fnLocalSorting = function(a,b){\n\t\t *    var iTest;\n\t\t *    iTest = oSort['string-asc']('data11', 'data12');\n\t\t *      if (iTest !== 0)\n\t\t *        return iTest;\n\t\t *    iTest = oSort['numeric-desc']('data21', 'data22');\n\t\t *    if (iTest !== 0)\n\t\t *      return iTest;\n\t\t *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\n\t\t *  }\n\t\t * Basically we have a test for each sorting column, if the data in that column is equal,\n\t\t * test the next column. If all columns match, then we use a numeric sort on the row\n\t\t * positions in the original data array to provide a stable sort.\n\t\t *\n\t\t * Note - I know it seems excessive to have two sorting methods, but the first is around\n\t\t * 15% faster, so the second is only maintained for backwards compatibility with sorting\n\t\t * methods which do not have a pre-sort formatting function.\n\t\t */\n\t\tif ( formatters === aSort.length ) {\n\t\t\t// All sort types have formatting functions\n\t\t\tdisplayMaster.sort( function ( a, b ) {\n\t\t\t\tvar\n\t\t\t\t\tx, y, k, test, sort,\n\t\t\t\t\tlen=aSort.length,\n\t\t\t\t\tdataA = aoData[a]._aSortData,\n\t\t\t\t\tdataB = aoData[b]._aSortData;\n\n\t\t\t\tfor ( k=0 ; k<len ; k++ ) {\n\t\t\t\t\tsort = aSort[k];\n\n\t\t\t\t\tx = dataA[ sort.col ];\n\t\t\t\t\ty = dataB[ sort.col ];\n\n\t\t\t\t\ttest = x<y ? -1 : x>y ? 1 : 0;\n\t\t\t\t\tif ( test !== 0 ) {\n\t\t\t\t\t\treturn sort.dir === 'asc' ? test : -test;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx = aiOrig[a];\n\t\t\t\ty = aiOrig[b];\n\t\t\t\treturn x<y ? -1 : x>y ? 1 : 0;\n\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\t// Depreciated - remove in 1.11 (providing a plug-in option)\n\t\t\t// Not all sort types have formatting methods, so we have to call their sorting\n\t\t\t// methods.\n\t\t\tdisplayMaster.sort( function ( a, b ) {\n\t\t\t\tvar\n\t\t\t\t\tx, y, k, l, test, sort, fn,\n\t\t\t\t\tlen=aSort.length,\n\t\t\t\t\tdataA = aoData[a]._aSortData,\n\t\t\t\t\tdataB = aoData[b]._aSortData;\n\n\t\t\t\tfor ( k=0 ; k<len ; k++ ) {\n\t\t\t\t\tsort = aSort[k];\n\n\t\t\t\t\tx = dataA[ sort.col ];\n\t\t\t\t\ty = dataB[ sort.col ];\n\n\t\t\t\t\tfn = oExtSort[ sort.type+\"-\"+sort.dir ] || oExtSort[ \"string-\"+sort.dir ];\n\t\t\t\t\ttest = fn( x, y );\n\t\t\t\t\tif ( test !== 0 ) {\n\t\t\t\t\t\treturn test;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx = aiOrig[a];\n\t\t\t\ty = aiOrig[b];\n\t\t\t\treturn x<y ? -1 : x>y ? 1 : 0;\n\t\t\t} );\n\t\t}\n\t}\n\n\t/* Tell the draw function that we have sorted the data */\n\toSettings.bSorted = true;\n}\n\n\nfunction _fnSortAria ( settings )\n{\n\tvar label;\n\tvar nextSort;\n\tvar columns = settings.aoColumns;\n\tvar aSort = _fnSortFlatten( settings );\n\tvar oAria = settings.oLanguage.oAria;\n\n\t// ARIA attributes - need to loop all columns, to update all (removing old\n\t// attributes as needed)\n\tfor ( var i=0, iLen=columns.length ; i<iLen ; i++ )\n\t{\n\t\tvar col = columns[i];\n\t\tvar asSorting = col.asSorting;\n\t\tvar sTitle = col.ariaTitle || col.sTitle.replace( /<.*?>/g, \"\" );\n\t\tvar th = col.nTh;\n\n\t\t// IE7 is throwing an error when setting these properties with jQuery's\n\t\t// attr() and removeAttr() methods...\n\t\tth.removeAttribute('aria-sort');\n\n\t\t/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\n\t\tif ( col.bSortable ) {\n\t\t\tif ( aSort.length > 0 && aSort[0].col == i ) {\n\t\t\t\tth.setAttribute('aria-sort', aSort[0].dir==\"asc\" ? \"ascending\" : \"descending\" );\n\t\t\t\tnextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnextSort = asSorting[0];\n\t\t\t}\n\n\t\t\tlabel = sTitle + ( nextSort === \"asc\" ?\n\t\t\t\toAria.sSortAscending :\n\t\t\t\toAria.sSortDescending\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tlabel = sTitle;\n\t\t}\n\n\t\tth.setAttribute('aria-label', label);\n\t}\n}\n\n\n/**\n * Function to run on user sort request\n *  @param {object} settings dataTables settings object\n *  @param {node} attachTo node to attach the handler to\n *  @param {int} colIdx column sorting index\n *  @param {boolean} [append=false] Append the requested sort to the existing\n *    sort if true (i.e. multi-column sort)\n *  @param {function} [callback] callback function\n *  @memberof DataTable#oApi\n */\nfunction _fnSortListener ( settings, colIdx, append, callback )\n{\n\tvar col = settings.aoColumns[ colIdx ];\n\tvar sorting = settings.aaSorting;\n\tvar asSorting = col.asSorting;\n\tvar nextSortIdx;\n\tvar next = function ( a, overflow ) {\n\t\tvar idx = a._idx;\n\t\tif ( idx === undefined ) {\n\t\t\tidx = $.inArray( a[1], asSorting );\n\t\t}\n\n\t\treturn idx+1 < asSorting.length ?\n\t\t\tidx+1 :\n\t\t\toverflow ?\n\t\t\t\tnull :\n\t\t\t\t0;\n\t};\n\n\t// Convert to 2D array if needed\n\tif ( typeof sorting[0] === 'number' ) {\n\t\tsorting = settings.aaSorting = [ sorting ];\n\t}\n\n\t// If appending the sort then we are multi-column sorting\n\tif ( append && settings.oFeatures.bSortMulti ) {\n\t\t// Are we already doing some kind of sort on this column?\n\t\tvar sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );\n\n\t\tif ( sortIdx !== -1 ) {\n\t\t\t// Yes, modify the sort\n\t\t\tnextSortIdx = next( sorting[sortIdx], true );\n\n\t\t\tif ( nextSortIdx === null && sorting.length === 1 ) {\n\t\t\t\tnextSortIdx = 0; // can't remove sorting completely\n\t\t\t}\n\n\t\t\tif ( nextSortIdx === null ) {\n\t\t\t\tsorting.splice( sortIdx, 1 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsorting[sortIdx][1] = asSorting[ nextSortIdx ];\n\t\t\t\tsorting[sortIdx]._idx = nextSortIdx;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No sort on this column yet\n\t\t\tsorting.push( [ colIdx, asSorting[0], 0 ] );\n\t\t\tsorting[sorting.length-1]._idx = 0;\n\t\t}\n\t}\n\telse if ( sorting.length && sorting[0][0] == colIdx ) {\n\t\t// Single column - already sorting on this column, modify the sort\n\t\tnextSortIdx = next( sorting[0] );\n\n\t\tsorting.length = 1;\n\t\tsorting[0][1] = asSorting[ nextSortIdx ];\n\t\tsorting[0]._idx = nextSortIdx;\n\t}\n\telse {\n\t\t// Single column - sort only on this column\n\t\tsorting.length = 0;\n\t\tsorting.push( [ colIdx, asSorting[0] ] );\n\t\tsorting[0]._idx = 0;\n\t}\n\n\t// Run the sort by calling a full redraw\n\t_fnReDraw( settings );\n\n\t// callback used for async user interaction\n\tif ( typeof callback == 'function' ) {\n\t\tcallback( settings );\n\t}\n}\n\n\n/**\n * Attach a sort handler (click) to a node\n *  @param {object} settings dataTables settings object\n *  @param {node} attachTo node to attach the handler to\n *  @param {int} colIdx column sorting index\n *  @param {function} [callback] callback function\n *  @memberof DataTable#oApi\n */\nfunction _fnSortAttachListener ( settings, attachTo, colIdx, callback )\n{\n\tvar col = settings.aoColumns[ colIdx ];\n\n\t_fnBindAction( attachTo, {}, function (e) {\n\t\t/* If the column is not sortable - don't to anything */\n\t\tif ( col.bSortable === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If processing is enabled use a timeout to allow the processing\n\t\t// display to be shown - otherwise to it synchronously\n\t\tif ( settings.oFeatures.bProcessing ) {\n\t\t\t_fnProcessingDisplay( settings, true );\n\n\t\t\tsetTimeout( function() {\n\t\t\t\t_fnSortListener( settings, colIdx, e.shiftKey, callback );\n\n\t\t\t\t// In server-side processing, the draw callback will remove the\n\t\t\t\t// processing display\n\t\t\t\tif ( _fnDataSource( settings ) !== 'ssp' ) {\n\t\t\t\t\t_fnProcessingDisplay( settings, false );\n\t\t\t\t}\n\t\t\t}, 0 );\n\t\t}\n\t\telse {\n\t\t\t_fnSortListener( settings, colIdx, e.shiftKey, callback );\n\t\t}\n\t} );\n}\n\n\n/**\n * Set the sorting classes on table's body, Note: it is safe to call this function\n * when bSort and bSortClasses are false\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnSortingClasses( settings )\n{\n\tvar oldSort = settings.aLastSort;\n\tvar sortClass = settings.oClasses.sSortColumn;\n\tvar sort = _fnSortFlatten( settings );\n\tvar features = settings.oFeatures;\n\tvar i, ien, colIdx;\n\n\tif ( features.bSort && features.bSortClasses ) {\n\t\t// Remove old sorting classes\n\t\tfor ( i=0, ien=oldSort.length ; i<ien ; i++ ) {\n\t\t\tcolIdx = oldSort[i].src;\n\n\t\t\t// Remove column sorting\n\t\t\t$( _pluck( settings.aoData, 'anCells', colIdx ) )\n\t\t\t\t.removeClass( sortClass + (i<2 ? i+1 : 3) );\n\t\t}\n\n\t\t// Add new column sorting\n\t\tfor ( i=0, ien=sort.length ; i<ien ; i++ ) {\n\t\t\tcolIdx = sort[i].src;\n\n\t\t\t$( _pluck( settings.aoData, 'anCells', colIdx ) )\n\t\t\t\t.addClass( sortClass + (i<2 ? i+1 : 3) );\n\t\t}\n\t}\n\n\tsettings.aLastSort = sort;\n}\n\n\n// Get the data to sort a column, be it from cache, fresh (populating the\n// cache), or from a sort formatter\nfunction _fnSortData( settings, idx )\n{\n\t// Custom sorting function - provided by the sort data type\n\tvar column = settings.aoColumns[ idx ];\n\tvar customSort = DataTable.ext.order[ column.sSortDataType ];\n\tvar customData;\n\n\tif ( customSort ) {\n\t\tcustomData = customSort.call( settings.oInstance, settings, idx,\n\t\t\t_fnColumnIndexToVisible( settings, idx )\n\t\t);\n\t}\n\n\t// Use / populate cache\n\tvar row, cellData;\n\tvar formatter = DataTable.ext.type.order[ column.sType+\"-pre\" ];\n\n\tfor ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n\t\trow = settings.aoData[i];\n\n\t\tif ( ! row._aSortData ) {\n\t\t\trow._aSortData = [];\n\t\t}\n\n\t\tif ( ! row._aSortData[idx] || customSort ) {\n\t\t\tcellData = customSort ?\n\t\t\t\tcustomData[i] : // If there was a custom sort function, use data from there\n\t\t\t\t_fnGetCellData( settings, i, idx, 'sort' );\n\n\t\t\trow._aSortData[ idx ] = formatter ?\n\t\t\t\tformatter( cellData ) :\n\t\t\t\tcellData;\n\t\t}\n\t}\n}\n\n\n\n/**\n * Save the state of a table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */\nfunction _fnSaveState ( settings )\n{\n\tif (settings._bLoadingState) {\n\t\treturn;\n\t}\n\n\t/* Store the interesting variables */\n\tvar state = {\n\t\ttime:    +new Date(),\n\t\tstart:   settings._iDisplayStart,\n\t\tlength:  settings._iDisplayLength,\n\t\torder:   $.extend( true, [], settings.aaSorting ),\n\t\tsearch:  _fnSearchToCamel( settings.oPreviousSearch ),\n\t\tcolumns: $.map( settings.aoColumns, function ( col, i ) {\n\t\t\treturn {\n\t\t\t\tvisible: col.bVisible,\n\t\t\t\tsearch: _fnSearchToCamel( settings.aoPreSearchCols[i] )\n\t\t\t};\n\t\t} )\n\t};\n\n\tsettings.oSavedState = state;\n\t_fnCallbackFire( settings, \"aoStateSaveParams\", 'stateSaveParams', [settings, state] );\n\t\n\tif ( settings.oFeatures.bStateSave && !settings.bDestroying )\n\t{\n\t\tsettings.fnStateSaveCallback.call( settings.oInstance, settings, state );\n\t}\t\n}\n\n\n/**\n * Attempt to load a saved table state\n *  @param {object} oSettings dataTables settings object\n *  @param {object} oInit DataTables init object so we can override settings\n *  @param {function} callback Callback to execute when the state has been loaded\n *  @memberof DataTable#oApi\n */\nfunction _fnLoadState ( settings, oInit, callback )\n{\n\tif ( ! settings.oFeatures.bStateSave ) {\n\t\tcallback();\n\t\treturn;\n\t}\n\n\tvar loaded = function(state) {\n\t\t_fnImplementState(settings, state, callback);\n\t}\n\n\tvar state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );\n\n\tif ( state !== undefined ) {\n\t\t_fnImplementState( settings, state, callback );\n\t}\n\t// otherwise, wait for the loaded callback to be executed\n\n\treturn true;\n}\n\nfunction _fnImplementState ( settings, s, callback) {\n\tvar i, ien;\n\tvar columns = settings.aoColumns;\n\tsettings._bLoadingState = true;\n\n\t// When StateRestore was introduced the state could now be implemented at any time\n\t// Not just initialisation. To do this an api instance is required in some places\n\tvar api = settings._bInitComplete ? new DataTable.Api(settings) : null;\n\n\tif ( ! s || ! s.time ) {\n\t\tsettings._bLoadingState = false;\n\t\tcallback();\n\t\treturn;\n\t}\n\n\t// Allow custom and plug-in manipulation functions to alter the saved data set and\n\t// cancelling of loading by returning false\n\tvar abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );\n\tif ( $.inArray( false, abStateLoad ) !== -1 ) {\n\t\tsettings._bLoadingState = false;\n\t\tcallback();\n\t\treturn;\n\t}\n\n\t// Reject old data\n\tvar duration = settings.iStateDuration;\n\tif ( duration > 0 && s.time < +new Date() - (duration*1000) ) {\n\t\tsettings._bLoadingState = false;\n\t\tcallback();\n\t\treturn;\n\t}\n\n\t// Number of columns have changed - all bets are off, no restore of settings\n\tif ( s.columns && columns.length !== s.columns.length ) {\n\t\tsettings._bLoadingState = false;\n\t\tcallback();\n\t\treturn;\n\t}\n\n\t// Store the saved state so it might be accessed at any time\n\tsettings.oLoadedState = $.extend( true, {}, s );\n\n\t// Page Length\n\tif ( s.length !== undefined ) {\n\t\t// If already initialised just set the value directly so that the select element is also updated\n\t\tif (api) {\n\t\t\tapi.page.len(s.length)\n\t\t}\n\t\telse {\n\t\t\tsettings._iDisplayLength   = s.length;\n\t\t}\n\t}\n\n\t// Restore key features - todo - for 1.11 this needs to be done by\n\t// subscribed events\n\tif ( s.start !== undefined ) {\n\t\tif(api === null) {\n\t\t\tsettings._iDisplayStart    = s.start;\n\t\t\tsettings.iInitDisplayStart = s.start;\n\t\t}\n\t\telse {\n\t\t\t_fnPageChange(settings, s.start/settings._iDisplayLength);\n\t\t}\n\t}\n\n\t// Order\n\tif ( s.order !== undefined ) {\n\t\tsettings.aaSorting = [];\n\t\t$.each( s.order, function ( i, col ) {\n\t\t\tsettings.aaSorting.push( col[0] >= columns.length ?\n\t\t\t\t[ 0, col[1] ] :\n\t\t\t\tcol\n\t\t\t);\n\t\t} );\n\t}\n\n\t// Search\n\tif ( s.search !== undefined ) {\n\t\t$.extend( settings.oPreviousSearch, _fnSearchToHung( s.search ) );\n\t}\n\n\t// Columns\n\tif ( s.columns ) {\n\t\tfor ( i=0, ien=s.columns.length ; i<ien ; i++ ) {\n\t\t\tvar col = s.columns[i];\n\n\t\t\t// Visibility\n\t\t\tif ( col.visible !== undefined ) {\n\t\t\t\t// If the api is defined, the table has been initialised so we need to use it rather than internal settings\n\t\t\t\tif (api) {\n\t\t\t\t\t// Don't redraw the columns on every iteration of this loop, we will do this at the end instead\n\t\t\t\t\tapi.column(i).visible(col.visible, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumns[i].bVisible = col.visible;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Search\n\t\t\tif ( col.search !== undefined ) {\n\t\t\t\t$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If the api is defined then we need to adjust the columns once the visibility has been changed\n\t\tif (api) {\n\t\t\tapi.columns.adjust();\n\t\t}\n\t}\n\n\tsettings._bLoadingState = false;\n\t_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );\n\tcallback();\n};\n\n\n/**\n * Return the settings object for a particular table\n *  @param {node} table table we are using as a dataTable\n *  @returns {object} Settings object - or null if not found\n *  @memberof DataTable#oApi\n */\nfunction _fnSettingsFromNode ( table )\n{\n\tvar settings = DataTable.settings;\n\tvar idx = $.inArray( table, _pluck( settings, 'nTable' ) );\n\n\treturn idx !== -1 ?\n\t\tsettings[ idx ] :\n\t\tnull;\n}\n\n\n/**\n * Log an error message\n *  @param {object} settings dataTables settings object\n *  @param {int} level log error messages, or display them to the user\n *  @param {string} msg error message\n *  @param {int} tn Technical note id to get more information about the error.\n *  @memberof DataTable#oApi\n */\nfunction _fnLog( settings, level, msg, tn )\n{\n\tmsg = 'DataTables warning: '+\n\t\t(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;\n\n\tif ( tn ) {\n\t\tmsg += '. For more information about this error, please see '+\n\t\t'http://datatables.net/tn/'+tn;\n\t}\n\n\tif ( ! level  ) {\n\t\t// Backwards compatibility pre 1.10\n\t\tvar ext = DataTable.ext;\n\t\tvar type = ext.sErrMode || ext.errMode;\n\n\t\tif ( settings ) {\n\t\t\t_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );\n\t\t}\n\n\t\tif ( type == 'alert' ) {\n\t\t\talert( msg );\n\t\t}\n\t\telse if ( type == 'throw' ) {\n\t\t\tthrow new Error(msg);\n\t\t}\n\t\telse if ( typeof type == 'function' ) {\n\t\t\ttype( settings, tn, msg );\n\t\t}\n\t}\n\telse if ( window.console && console.log ) {\n\t\tconsole.log( msg );\n\t}\n}\n\n\n/**\n * See if a property is defined on one object, if so assign it to the other object\n *  @param {object} ret target object\n *  @param {object} src source object\n *  @param {string} name property\n *  @param {string} [mappedName] name to map too - optional, name used if not given\n *  @memberof DataTable#oApi\n */\nfunction _fnMap( ret, src, name, mappedName )\n{\n\tif ( Array.isArray( name ) ) {\n\t\t$.each( name, function (i, val) {\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\t_fnMap( ret, src, val[0], val[1] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_fnMap( ret, src, val );\n\t\t\t}\n\t\t} );\n\n\t\treturn;\n\t}\n\n\tif ( mappedName === undefined ) {\n\t\tmappedName = name;\n\t}\n\n\tif ( src[name] !== undefined ) {\n\t\tret[mappedName] = src[name];\n\t}\n}\n\n\n/**\n * Extend objects - very similar to jQuery.extend, but deep copy objects, and\n * shallow copy arrays. The reason we need to do this, is that we don't want to\n * deep copy array init values (such as aaSorting) since the dev wouldn't be\n * able to override them, but we do want to deep copy arrays.\n *  @param {object} out Object to extend\n *  @param {object} extender Object from which the properties will be applied to\n *      out\n *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\n *      independent copy with the exception of the `data` or `aaData` parameters\n *      if they are present. This is so you can pass in a collection to\n *      DataTables and have that used as your data source without breaking the\n *      references\n *  @returns {object} out Reference, just for convenience - out === the return.\n *  @memberof DataTable#oApi\n *  @todo This doesn't take account of arrays inside the deep copied objects.\n */\nfunction _fnExtend( out, extender, breakRefs )\n{\n\tvar val;\n\n\tfor ( var prop in extender ) {\n\t\tif ( extender.hasOwnProperty(prop) ) {\n\t\t\tval = extender[prop];\n\n\t\t\tif ( $.isPlainObject( val ) ) {\n\t\t\t\tif ( ! $.isPlainObject( out[prop] ) ) {\n\t\t\t\t\tout[prop] = {};\n\t\t\t\t}\n\t\t\t\t$.extend( true, out[prop], val );\n\t\t\t}\n\t\t\telse if ( breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val) ) {\n\t\t\t\tout[prop] = val.slice();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout[prop] = val;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n}\n\n\n/**\n * Bind an event handers to allow a click or return key to activate the callback.\n * This is good for accessibility since a return on the keyboard will have the\n * same effect as a click, if the element has focus.\n *  @param {element} n Element to bind the action to\n *  @param {object} oData Data object to pass to the triggered function\n *  @param {function} fn Callback function for when the event is triggered\n *  @memberof DataTable#oApi\n */\nfunction _fnBindAction( n, oData, fn )\n{\n\t$(n)\n\t\t.on( 'click.DT', oData, function (e) {\n\t\t\t\t$(n).trigger('blur'); // Remove focus outline for mouse users\n\t\t\t\tfn(e);\n\t\t\t} )\n\t\t.on( 'keypress.DT', oData, function (e){\n\t\t\t\tif ( e.which === 13 ) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tfn(e);\n\t\t\t\t}\n\t\t\t} )\n\t\t.on( 'selectstart.DT', function () {\n\t\t\t\t/* Take the brutal approach to cancelling text selection */\n\t\t\t\treturn false;\n\t\t\t} );\n}\n\n\n/**\n * Register a callback function. Easily allows a callback function to be added to\n * an array store of callback functions that can then all be called together.\n *  @param {object} oSettings dataTables settings object\n *  @param {string} sStore Name of the array storage for the callbacks in oSettings\n *  @param {function} fn Function to be called back\n *  @param {string} sName Identifying name for the callback (i.e. a label)\n *  @memberof DataTable#oApi\n */\nfunction _fnCallbackReg( oSettings, sStore, fn, sName )\n{\n\tif ( fn )\n\t{\n\t\toSettings[sStore].push( {\n\t\t\t\"fn\": fn,\n\t\t\t\"sName\": sName\n\t\t} );\n\t}\n}\n\n\n/**\n * Fire callback functions and trigger events. Note that the loop over the\n * callback array store is done backwards! Further note that you do not want to\n * fire off triggers in time sensitive applications (for example cell creation)\n * as its slow.\n *  @param {object} settings dataTables settings object\n *  @param {string} callbackArr Name of the array storage for the callbacks in\n *      oSettings\n *  @param {string} eventName Name of the jQuery custom event to trigger. If\n *      null no trigger is fired\n *  @param {array} args Array of arguments to pass to the callback function /\n *      trigger\n *  @memberof DataTable#oApi\n */\nfunction _fnCallbackFire( settings, callbackArr, eventName, args )\n{\n\tvar ret = [];\n\n\tif ( callbackArr ) {\n\t\tret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {\n\t\t\treturn val.fn.apply( settings.oInstance, args );\n\t\t} );\n\t}\n\n\tif ( eventName !== null ) {\n\t\tvar e = $.Event( eventName+'.dt' );\n\t\tvar table = $(settings.nTable);\n\n\t\ttable.trigger( e, args );\n\n\t\t// If not yet attached to the document, trigger the event\n\t\t// on the body directly to sort of simulate the bubble\n\t\tif (table.parents('body').length === 0) {\n\t\t\t$('body').trigger( e, args );\n\t\t}\n\n\t\tret.push( e.result );\n\t}\n\n\treturn ret;\n}\n\n\nfunction _fnLengthOverflow ( settings )\n{\n\tvar\n\t\tstart = settings._iDisplayStart,\n\t\tend = settings.fnDisplayEnd(),\n\t\tlen = settings._iDisplayLength;\n\n\t/* If we have space to show extra rows (backing up from the end point - then do so */\n\tif ( start >= end )\n\t{\n\t\tstart = end - len;\n\t}\n\n\t// Keep the start record on the current page\n\tstart -= (start % len);\n\n\tif ( len === -1 || start < 0 )\n\t{\n\t\tstart = 0;\n\t}\n\n\tsettings._iDisplayStart = start;\n}\n\n\nfunction _fnRenderer( settings, type )\n{\n\tvar renderer = settings.renderer;\n\tvar host = DataTable.ext.renderer[type];\n\n\tif ( $.isPlainObject( renderer ) && renderer[type] ) {\n\t\t// Specific renderer for this type. If available use it, otherwise use\n\t\t// the default.\n\t\treturn host[renderer[type]] || host._;\n\t}\n\telse if ( typeof renderer === 'string' ) {\n\t\t// Common renderer - if there is one available for this type use it,\n\t\t// otherwise use the default\n\t\treturn host[renderer] || host._;\n\t}\n\n\t// Use the default\n\treturn host._;\n}\n\n\n/**\n * Detect the data source being used for the table. Used to simplify the code\n * a little (ajax) and to make it compress a little smaller.\n *\n *  @param {object} settings dataTables settings object\n *  @returns {string} Data source\n *  @memberof DataTable#oApi\n */\nfunction _fnDataSource ( settings )\n{\n\tif ( settings.oFeatures.bServerSide ) {\n\t\treturn 'ssp';\n\t}\n\telse if ( settings.ajax || settings.sAjaxSource ) {\n\t\treturn 'ajax';\n\t}\n\treturn 'dom';\n}\n\n\n\n\n/**\n * Computed structure of the DataTables API, defined by the options passed to\n * `DataTable.Api.register()` when building the API.\n *\n * The structure is built in order to speed creation and extension of the Api\n * objects since the extensions are effectively pre-parsed.\n *\n * The array is an array of objects with the following structure, where this\n * base array represents the Api prototype base:\n *\n *     [\n *       {\n *         name:      'data'                -- string   - Property name\n *         val:       function () {},       -- function - Api method (or undefined if just an object\n *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n *       },\n *       {\n *         name:     'row'\n *         val:       {},\n *         methodExt: [ ... ],\n *         propExt:   [\n *           {\n *             name:      'data'\n *             val:       function () {},\n *             methodExt: [ ... ],\n *             propExt:   [ ... ]\n *           },\n *           ...\n *         ]\n *       }\n *     ]\n *\n * @type {Array}\n * @ignore\n */\nvar __apiStruct = [];\n\n\n/**\n * `Array.prototype` reference.\n *\n * @type object\n * @ignore\n */\nvar __arrayProto = Array.prototype;\n\n\n/**\n * Abstraction for `context` parameter of the `Api` constructor to allow it to\n * take several different forms for ease of use.\n *\n * Each of the input parameter types will be converted to a DataTables settings\n * object where possible.\n *\n * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\n *   of:\n *\n *   * `string` - jQuery selector. Any DataTables' matching the given selector\n *     with be found and used.\n *   * `node` - `TABLE` node which has already been formed into a DataTable.\n *   * `jQuery` - A jQuery object of `TABLE` nodes.\n *   * `object` - DataTables settings object\n *   * `DataTables.Api` - API instance\n * @return {array|null} Matching DataTables settings objects. `null` or\n *   `undefined` is returned if no matching DataTable is found.\n * @ignore\n */\nvar _toSettings = function ( mixed )\n{\n\tvar idx, jq;\n\tvar settings = DataTable.settings;\n\tvar tables = $.map( settings, function (el, i) {\n\t\treturn el.nTable;\n\t} );\n\n\tif ( ! mixed ) {\n\t\treturn [];\n\t}\n\telse if ( mixed.nTable && mixed.oApi ) {\n\t\t// DataTables settings object\n\t\treturn [ mixed ];\n\t}\n\telse if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {\n\t\t// Table node\n\t\tidx = $.inArray( mixed, tables );\n\t\treturn idx !== -1 ? [ settings[idx] ] : null;\n\t}\n\telse if ( mixed && typeof mixed.settings === 'function' ) {\n\t\treturn mixed.settings().toArray();\n\t}\n\telse if ( typeof mixed === 'string' ) {\n\t\t// jQuery selector\n\t\tjq = $(mixed);\n\t}\n\telse if ( mixed instanceof $ ) {\n\t\t// jQuery object (also DataTables instance)\n\t\tjq = mixed;\n\t}\n\n\tif ( jq ) {\n\t\treturn jq.map( function(i) {\n\t\t\tidx = $.inArray( this, tables );\n\t\t\treturn idx !== -1 ? settings[idx] : null;\n\t\t} ).toArray();\n\t}\n};\n\n\n/**\n * DataTables API class - used to control and interface with  one or more\n * DataTables enhanced tables.\n *\n * The API class is heavily based on jQuery, presenting a chainable interface\n * that you can use to interact with tables. Each instance of the API class has\n * a \"context\" - i.e. the tables that it will operate on. This could be a single\n * table, all tables on a page or a sub-set thereof.\n *\n * Additionally the API is designed to allow you to easily work with the data in\n * the tables, retrieving and manipulating it as required. This is done by\n * presenting the API class as an array like interface. The contents of the\n * array depend upon the actions requested by each method (for example\n * `rows().nodes()` will return an array of nodes, while `rows().data()` will\n * return an array of objects or arrays depending upon your table's\n * configuration). The API object has a number of array like methods (`push`,\n * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\n * `unique` etc) to assist your working with the data held in a table.\n *\n * Most methods (those which return an Api instance) are chainable, which means\n * the return from a method call also has all of the methods available that the\n * top level object had. For example, these two calls are equivalent:\n *\n *     // Not chained\n *     api.row.add( {...} );\n *     api.draw();\n *\n *     // Chained\n *     api.row.add( {...} ).draw();\n *\n * @class DataTable.Api\n * @param {array|object|string|jQuery} context DataTable identifier. This is\n *   used to define which DataTables enhanced tables this API will operate on.\n *   Can be one of:\n *\n *   * `string` - jQuery selector. Any DataTables' matching the given selector\n *     with be found and used.\n *   * `node` - `TABLE` node which has already been formed into a DataTable.\n *   * `jQuery` - A jQuery object of `TABLE` nodes.\n *   * `object` - DataTables settings object\n * @param {array} [data] Data to initialise the Api instance with.\n *\n * @example\n *   // Direct initialisation during DataTables construction\n *   var api = $('#example').DataTable();\n *\n * @example\n *   // Initialisation using a DataTables jQuery object\n *   var api = $('#example').dataTable().api();\n *\n * @example\n *   // Initialisation as a constructor\n *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\n */\n_Api = function ( context, data )\n{\n\tif ( ! (this instanceof _Api) ) {\n\t\treturn new _Api( context, data );\n\t}\n\n\tvar settings = [];\n\tvar ctxSettings = function ( o ) {\n\t\tvar a = _toSettings( o );\n\t\tif ( a ) {\n\t\t\tsettings.push.apply( settings, a );\n\t\t}\n\t};\n\n\tif ( Array.isArray( context ) ) {\n\t\tfor ( var i=0, ien=context.length ; i<ien ; i++ ) {\n\t\t\tctxSettings( context[i] );\n\t\t}\n\t}\n\telse {\n\t\tctxSettings( context );\n\t}\n\n\t// Remove duplicates\n\tthis.context = _unique( settings );\n\n\t// Initial data\n\tif ( data ) {\n\t\t$.merge( this, data );\n\t}\n\n\t// selector\n\tthis.selector = {\n\t\trows: null,\n\t\tcols: null,\n\t\topts: null\n\t};\n\n\t_Api.extend( this, this, __apiStruct );\n};\n\nDataTable.Api = _Api;\n\n// Don't destroy the existing prototype, just extend it. Required for jQuery 2's\n// isPlainObject.\n$.extend( _Api.prototype, {\n\tany: function ()\n\t{\n\t\treturn this.count() !== 0;\n\t},\n\n\n\tconcat:  __arrayProto.concat,\n\n\n\tcontext: [], // array of table settings objects\n\n\n\tcount: function ()\n\t{\n\t\treturn this.flatten().length;\n\t},\n\n\n\teach: function ( fn )\n\t{\n\t\tfor ( var i=0, ien=this.length ; i<ien; i++ ) {\n\t\t\tfn.call( this, this[i], i, this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\n\teq: function ( idx )\n\t{\n\t\tvar ctx = this.context;\n\n\t\treturn ctx.length > idx ?\n\t\t\tnew _Api( ctx[idx], this[idx] ) :\n\t\t\tnull;\n\t},\n\n\n\tfilter: function ( fn )\n\t{\n\t\tvar a = [];\n\n\t\tif ( __arrayProto.filter ) {\n\t\t\ta = __arrayProto.filter.call( this, fn, this );\n\t\t}\n\t\telse {\n\t\t\t// Compatibility for browsers without EMCA-252-5 (JS 1.6)\n\t\t\tfor ( var i=0, ien=this.length ; i<ien ; i++ ) {\n\t\t\t\tif ( fn.call( this, this[i], i, this ) ) {\n\t\t\t\t\ta.push( this[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new _Api( this.context, a );\n\t},\n\n\n\tflatten: function ()\n\t{\n\t\tvar a = [];\n\t\treturn new _Api( this.context, a.concat.apply( a, this.toArray() ) );\n\t},\n\n\n\tjoin:    __arrayProto.join,\n\n\n\tindexOf: __arrayProto.indexOf || function (obj, start)\n\t{\n\t\tfor ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {\n\t\t\tif ( this[i] === obj ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\titerator: function ( flatten, type, fn, alwaysNew ) {\n\t\tvar\n\t\t\ta = [], ret,\n\t\t\ti, ien, j, jen,\n\t\t\tcontext = this.context,\n\t\t\trows, items, item,\n\t\t\tselector = this.selector;\n\n\t\t// Argument shifting\n\t\tif ( typeof flatten === 'string' ) {\n\t\t\talwaysNew = fn;\n\t\t\tfn = type;\n\t\t\ttype = flatten;\n\t\t\tflatten = false;\n\t\t}\n\n\t\tfor ( i=0, ien=context.length ; i<ien ; i++ ) {\n\t\t\tvar apiInst = new _Api( context[i] );\n\n\t\t\tif ( type === 'table' ) {\n\t\t\t\tret = fn.call( apiInst, context[i], i );\n\n\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\ta.push( ret );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( type === 'columns' || type === 'rows' ) {\n\t\t\t\t// this has same length as context - one entry for each table\n\t\t\t\tret = fn.call( apiInst, context[i], this[i], i );\n\n\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\ta.push( ret );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {\n\t\t\t\t// columns and rows share the same structure.\n\t\t\t\t// 'this' is an array of column indexes for each context\n\t\t\t\titems = this[i];\n\n\t\t\t\tif ( type === 'column-rows' ) {\n\t\t\t\t\trows = _selector_row_indexes( context[i], selector.opts );\n\t\t\t\t}\n\n\t\t\t\tfor ( j=0, jen=items.length ; j<jen ; j++ ) {\n\t\t\t\t\titem = items[j];\n\n\t\t\t\t\tif ( type === 'cell' ) {\n\t\t\t\t\t\tret = fn.call( apiInst, context[i], item.row, item.column, i, j );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tret = fn.call( apiInst, context[i], item, i, j, rows );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\ta.push( ret );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( a.length || alwaysNew ) {\n\t\t\tvar api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );\n\t\t\tvar apiSelector = api.selector;\n\t\t\tapiSelector.rows = selector.rows;\n\t\t\tapiSelector.cols = selector.cols;\n\t\t\tapiSelector.opts = selector.opts;\n\t\t\treturn api;\n\t\t}\n\t\treturn this;\n\t},\n\n\n\tlastIndexOf: __arrayProto.lastIndexOf || function (obj, start)\n\t{\n\t\t// Bit cheeky...\n\t\treturn this.indexOf.apply( this.toArray.reverse(), arguments );\n\t},\n\n\n\tlength:  0,\n\n\n\tmap: function ( fn )\n\t{\n\t\tvar a = [];\n\n\t\tif ( __arrayProto.map ) {\n\t\t\ta = __arrayProto.map.call( this, fn, this );\n\t\t}\n\t\telse {\n\t\t\t// Compatibility for browsers without EMCA-252-5 (JS 1.6)\n\t\t\tfor ( var i=0, ien=this.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( fn.call( this, this[i], i ) );\n\t\t\t}\n\t\t}\n\n\t\treturn new _Api( this.context, a );\n\t},\n\n\n\tpluck: function ( prop )\n\t{\n\t\tvar fn = DataTable.util.get(prop);\n\n\t\treturn this.map( function ( el ) {\n\t\t\treturn fn(el);\n\t\t} );\n\t},\n\n\tpop:     __arrayProto.pop,\n\n\n\tpush:    __arrayProto.push,\n\n\n\t// Does not return an API instance\n\treduce: __arrayProto.reduce || function ( fn, init )\n\t{\n\t\treturn _fnReduce( this, fn, init, 0, this.length, 1 );\n\t},\n\n\n\treduceRight: __arrayProto.reduceRight || function ( fn, init )\n\t{\n\t\treturn _fnReduce( this, fn, init, this.length-1, -1, -1 );\n\t},\n\n\n\treverse: __arrayProto.reverse,\n\n\n\t// Object with rows, columns and opts\n\tselector: null,\n\n\n\tshift:   __arrayProto.shift,\n\n\n\tslice: function () {\n\t\treturn new _Api( this.context, this );\n\t},\n\n\n\tsort:    __arrayProto.sort, // ? name - order?\n\n\n\tsplice:  __arrayProto.splice,\n\n\n\ttoArray: function ()\n\t{\n\t\treturn __arrayProto.slice.call( this );\n\t},\n\n\n\tto$: function ()\n\t{\n\t\treturn $( this );\n\t},\n\n\n\ttoJQuery: function ()\n\t{\n\t\treturn $( this );\n\t},\n\n\n\tunique: function ()\n\t{\n\t\treturn new _Api( this.context, _unique(this) );\n\t},\n\n\n\tunshift: __arrayProto.unshift\n} );\n\n\n_Api.extend = function ( scope, obj, ext )\n{\n\t// Only extend API instances and static properties of the API\n\tif ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {\n\t\treturn;\n\t}\n\n\tvar\n\t\ti, ien,\n\t\tstruct,\n\t\tmethodScoping = function ( scope, fn, struc ) {\n\t\t\treturn function () {\n\t\t\t\tvar ret = fn.apply( scope, arguments );\n\n\t\t\t\t// Method extension\n\t\t\t\t_Api.extend( ret, ret, struc.methodExt );\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t};\n\n\tfor ( i=0, ien=ext.length ; i<ien ; i++ ) {\n\t\tstruct = ext[i];\n\n\t\t// Value\n\t\tobj[ struct.name ] = struct.type === 'function' ?\n\t\t\tmethodScoping( scope, struct.val, struct ) :\n\t\t\tstruct.type === 'object' ?\n\t\t\t\t{} :\n\t\t\t\tstruct.val;\n\n\t\tobj[ struct.name ].__dt_wrapper = true;\n\n\t\t// Property extension\n\t\t_Api.extend( scope, obj[ struct.name ], struct.propExt );\n\t}\n};\n\n\n// @todo - Is there need for an augment function?\n// _Api.augment = function ( inst, name )\n// {\n// \t// Find src object in the structure from the name\n// \tvar parts = name.split('.');\n\n// \t_Api.extend( inst, obj );\n// };\n\n\n//     [\n//       {\n//         name:      'data'                -- string   - Property name\n//         val:       function () {},       -- function - Api method (or undefined if just an object\n//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n//       },\n//       {\n//         name:     'row'\n//         val:       {},\n//         methodExt: [ ... ],\n//         propExt:   [\n//           {\n//             name:      'data'\n//             val:       function () {},\n//             methodExt: [ ... ],\n//             propExt:   [ ... ]\n//           },\n//           ...\n//         ]\n//       }\n//     ]\n\n_Api.register = _api_register = function ( name, val )\n{\n\tif ( Array.isArray( name ) ) {\n\t\tfor ( var j=0, jen=name.length ; j<jen ; j++ ) {\n\t\t\t_Api.register( name[j], val );\n\t\t}\n\t\treturn;\n\t}\n\n\tvar\n\t\ti, ien,\n\t\their = name.split('.'),\n\t\tstruct = __apiStruct,\n\t\tkey, method;\n\n\tvar find = function ( src, name ) {\n\t\tfor ( var i=0, ien=src.length ; i<ien ; i++ ) {\n\t\t\tif ( src[i].name === name ) {\n\t\t\t\treturn src[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tfor ( i=0, ien=heir.length ; i<ien ; i++ ) {\n\t\tmethod = heir[i].indexOf('()') !== -1;\n\t\tkey = method ?\n\t\t\their[i].replace('()', '') :\n\t\t\their[i];\n\n\t\tvar src = find( struct, key );\n\t\tif ( ! src ) {\n\t\t\tsrc = {\n\t\t\t\tname:      key,\n\t\t\t\tval:       {},\n\t\t\t\tmethodExt: [],\n\t\t\t\tpropExt:   [],\n\t\t\t\ttype:      'object'\n\t\t\t};\n\t\t\tstruct.push( src );\n\t\t}\n\n\t\tif ( i === ien-1 ) {\n\t\t\tsrc.val = val;\n\t\t\tsrc.type = typeof val === 'function' ?\n\t\t\t\t'function' :\n\t\t\t\t$.isPlainObject( val ) ?\n\t\t\t\t\t'object' :\n\t\t\t\t\t'other';\n\t\t}\n\t\telse {\n\t\t\tstruct = method ?\n\t\t\t\tsrc.methodExt :\n\t\t\t\tsrc.propExt;\n\t\t}\n\t}\n};\n\n_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {\n\t_Api.register( pluralName, val );\n\n\t_Api.register( singularName, function () {\n\t\tvar ret = val.apply( this, arguments );\n\n\t\tif ( ret === this ) {\n\t\t\t// Returned item is the API instance that was passed in, return it\n\t\t\treturn this;\n\t\t}\n\t\telse if ( ret instanceof _Api ) {\n\t\t\t// New API instance returned, want the value from the first item\n\t\t\t// in the returned array for the singular result.\n\t\t\treturn ret.length ?\n\t\t\t\tArray.isArray( ret[0] ) ?\n\t\t\t\t\tnew _Api( ret.context, ret[0] ) : // Array results are 'enhanced'\n\t\t\t\t\tret[0] :\n\t\t\t\tundefined;\n\t\t}\n\n\t\t// Non-API return - just fire it back\n\t\treturn ret;\n\t} );\n};\n\n\n/**\n * Selector for HTML tables. Apply the given selector to the give array of\n * DataTables settings objects.\n *\n * @param {string|integer} [selector] jQuery selector string or integer\n * @param  {array} Array of DataTables settings objects to be filtered\n * @return {array}\n * @ignore\n */\nvar __table_selector = function ( selector, a )\n{\n\tif ( Array.isArray(selector) ) {\n\t\treturn $.map( selector, function (item) {\n\t\t\treturn __table_selector(item, a);\n\t\t} );\n\t}\n\n\t// Integer is used to pick out a table by index\n\tif ( typeof selector === 'number' ) {\n\t\treturn [ a[ selector ] ];\n\t}\n\n\t// Perform a jQuery selector on the table nodes\n\tvar nodes = $.map( a, function (el, i) {\n\t\treturn el.nTable;\n\t} );\n\n\treturn $(nodes)\n\t\t.filter( selector )\n\t\t.map( function (i) {\n\t\t\t// Need to translate back from the table node to the settings\n\t\t\tvar idx = $.inArray( this, nodes );\n\t\t\treturn a[ idx ];\n\t\t} )\n\t\t.toArray();\n};\n\n\n\n/**\n * Context selector for the API's context (i.e. the tables the API instance\n * refers to.\n *\n * @name    DataTable.Api#tables\n * @param {string|integer} [selector] Selector to pick which tables the iterator\n *   should operate on. If not given, all tables in the current context are\n *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\n *   select multiple tables or as an integer to select a single table.\n * @returns {DataTable.Api} Returns a new API instance if a selector is given.\n */\n_api_register( 'tables()', function ( selector ) {\n\t// A new instance is created if there was a selector specified\n\treturn selector !== undefined && selector !== null ?\n\t\tnew _Api( __table_selector( selector, this.context ) ) :\n\t\tthis;\n} );\n\n\n_api_register( 'table()', function ( selector ) {\n\tvar tables = this.tables( selector );\n\tvar ctx = tables.context;\n\n\t// Truncate to the first matched table\n\treturn ctx.length ?\n\t\tnew _Api( ctx[0] ) :\n\t\ttables;\n} );\n\n\n_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\treturn ctx.nTable;\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'tables().body()', 'table().body()' , function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\treturn ctx.nTBody;\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'tables().header()', 'table().header()' , function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\treturn ctx.nTHead;\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\treturn ctx.nTFoot;\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'tables().containers()', 'table().container()' , function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\treturn ctx.nTableWrapper;\n\t}, 1 );\n} );\n\n\n\n/**\n * Redraw the tables in the current context.\n */\n_api_register( 'draw()', function ( paging ) {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\tif ( paging === 'page' ) {\n\t\t\t_fnDraw( settings );\n\t\t}\n\t\telse {\n\t\t\tif ( typeof paging === 'string' ) {\n\t\t\t\tpaging = paging === 'full-hold' ?\n\t\t\t\t\tfalse :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\t_fnReDraw( settings, paging===false );\n\t\t}\n\t} );\n} );\n\n\n\n/**\n * Get the current page index.\n *\n * @return {integer} Current page index (zero based)\n *//**\n * Set the current page.\n *\n * Note that if you attempt to show a page which does not exist, DataTables will\n * not throw an error, but rather reset the paging.\n *\n * @param {integer|string} action The paging action to take. This can be one of:\n *  * `integer` - The page index to jump to\n *  * `string` - An action to take:\n *    * `first` - Jump to first page.\n *    * `next` - Jump to the next page\n *    * `previous` - Jump to previous page\n *    * `last` - Jump to the last page.\n * @returns {DataTables.Api} this\n */\n_api_register( 'page()', function ( action ) {\n\tif ( action === undefined ) {\n\t\treturn this.page.info().page; // not an expensive call\n\t}\n\n\t// else, have an action to take on all tables\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t_fnPageChange( settings, action );\n\t} );\n} );\n\n\n/**\n * Paging information for the first table in the current context.\n *\n * If you require paging information for another table, use the `table()` method\n * with a suitable selector.\n *\n * @return {object} Object with the following properties set:\n *  * `page` - Current page index (zero based - i.e. the first page is `0`)\n *  * `pages` - Total number of pages\n *  * `start` - Display index for the first record shown on the current page\n *  * `end` - Display index for the last record shown on the current page\n *  * `length` - Display length (number of records). Note that generally `start\n *    + length = end`, but this is not always true, for example if there are\n *    only 2 records to show on the final page, with a length of 10.\n *  * `recordsTotal` - Full data set length\n *  * `recordsDisplay` - Data set length once the current filtering criterion\n *    are applied.\n */\n_api_register( 'page.info()', function ( action ) {\n\tif ( this.context.length === 0 ) {\n\t\treturn undefined;\n\t}\n\n\tvar\n\t\tsettings   = this.context[0],\n\t\tstart      = settings._iDisplayStart,\n\t\tlen        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,\n\t\tvisRecords = settings.fnRecordsDisplay(),\n\t\tall        = len === -1;\n\n\treturn {\n\t\t\"page\":           all ? 0 : Math.floor( start / len ),\n\t\t\"pages\":          all ? 1 : Math.ceil( visRecords / len ),\n\t\t\"start\":          start,\n\t\t\"end\":            settings.fnDisplayEnd(),\n\t\t\"length\":         len,\n\t\t\"recordsTotal\":   settings.fnRecordsTotal(),\n\t\t\"recordsDisplay\": visRecords,\n\t\t\"serverSide\":     _fnDataSource( settings ) === 'ssp'\n\t};\n} );\n\n\n/**\n * Get the current page length.\n *\n * @return {integer} Current page length. Note `-1` indicates that all records\n *   are to be shown.\n *//**\n * Set the current page length.\n *\n * @param {integer} Page length to set. Use `-1` to show all records.\n * @returns {DataTables.Api} this\n */\n_api_register( 'page.len()', function ( len ) {\n\t// Note that we can't call this function 'length()' because `length`\n\t// is a Javascript property of functions which defines how many arguments\n\t// the function expects.\n\tif ( len === undefined ) {\n\t\treturn this.context.length !== 0 ?\n\t\t\tthis.context[0]._iDisplayLength :\n\t\t\tundefined;\n\t}\n\n\t// else, set the page length\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t_fnLengthChange( settings, len );\n\t} );\n} );\n\n\n\nvar __reload = function ( settings, holdPosition, callback ) {\n\t// Use the draw event to trigger a callback\n\tif ( callback ) {\n\t\tvar api = new _Api( settings );\n\n\t\tapi.one( 'draw', function () {\n\t\t\tcallback( api.ajax.json() );\n\t\t} );\n\t}\n\n\tif ( _fnDataSource( settings ) == 'ssp' ) {\n\t\t_fnReDraw( settings, holdPosition );\n\t}\n\telse {\n\t\t_fnProcessingDisplay( settings, true );\n\n\t\t// Cancel an existing request\n\t\tvar xhr = settings.jqXHR;\n\t\tif ( xhr && xhr.readyState !== 4 ) {\n\t\t\txhr.abort();\n\t\t}\n\n\t\t// Trigger xhr\n\t\t_fnBuildAjax( settings, [], function( json ) {\n\t\t\t_fnClearTable( settings );\n\n\t\t\tvar data = _fnAjaxDataSrc( settings, json );\n\t\t\tfor ( var i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t\t\t_fnAddData( settings, data[i] );\n\t\t\t}\n\n\t\t\t_fnReDraw( settings, holdPosition );\n\t\t\t_fnProcessingDisplay( settings, false );\n\t\t} );\n\t}\n};\n\n\n/**\n * Get the JSON response from the last Ajax request that DataTables made to the\n * server. Note that this returns the JSON from the first table in the current\n * context.\n *\n * @return {object} JSON received from the server.\n */\n_api_register( 'ajax.json()', function () {\n\tvar ctx = this.context;\n\n\tif ( ctx.length > 0 ) {\n\t\treturn ctx[0].json;\n\t}\n\n\t// else return undefined;\n} );\n\n\n/**\n * Get the data submitted in the last Ajax request\n */\n_api_register( 'ajax.params()', function () {\n\tvar ctx = this.context;\n\n\tif ( ctx.length > 0 ) {\n\t\treturn ctx[0].oAjaxData;\n\t}\n\n\t// else return undefined;\n} );\n\n\n/**\n * Reload tables from the Ajax data source. Note that this function will\n * automatically re-draw the table when the remote data has been loaded.\n *\n * @param {boolean} [reset=true] Reset (default) or hold the current paging\n *   position. A full re-sort and re-filter is performed when this method is\n *   called, which is why the pagination reset is the default action.\n * @returns {DataTables.Api} this\n */\n_api_register( 'ajax.reload()', function ( callback, resetPaging ) {\n\treturn this.iterator( 'table', function (settings) {\n\t\t__reload( settings, resetPaging===false, callback );\n\t} );\n} );\n\n\n/**\n * Get the current Ajax URL. Note that this returns the URL from the first\n * table in the current context.\n *\n * @return {string} Current Ajax source URL\n *//**\n * Set the Ajax URL. Note that this will set the URL for all tables in the\n * current context.\n *\n * @param {string} url URL to set.\n * @returns {DataTables.Api} this\n */\n_api_register( 'ajax.url()', function ( url ) {\n\tvar ctx = this.context;\n\n\tif ( url === undefined ) {\n\t\t// get\n\t\tif ( ctx.length === 0 ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tctx = ctx[0];\n\n\t\treturn ctx.ajax ?\n\t\t\t$.isPlainObject( ctx.ajax ) ?\n\t\t\t\tctx.ajax.url :\n\t\t\t\tctx.ajax :\n\t\t\tctx.sAjaxSource;\n\t}\n\n\t// set\n\treturn this.iterator( 'table', function ( settings ) {\n\t\tif ( $.isPlainObject( settings.ajax ) ) {\n\t\t\tsettings.ajax.url = url;\n\t\t}\n\t\telse {\n\t\t\tsettings.ajax = url;\n\t\t}\n\t\t// No need to consider sAjaxSource here since DataTables gives priority\n\t\t// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\n\t\t// value of `sAjaxSource` redundant.\n\t} );\n} );\n\n\n/**\n * Load data from the newly set Ajax URL. Note that this method is only\n * available when `ajax.url()` is used to set a URL. Additionally, this method\n * has the same effect as calling `ajax.reload()` but is provided for\n * convenience when setting a new URL. Like `ajax.reload()` it will\n * automatically redraw the table once the remote data has been loaded.\n *\n * @returns {DataTables.Api} this\n */\n_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {\n\t// Same as a reload, but makes sense to present it for easy access after a\n\t// url change\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\t__reload( ctx, resetPaging===false, callback );\n\t} );\n} );\n\n\n\n\nvar _selector_run = function ( type, selector, selectFn, settings, opts )\n{\n\tvar\n\t\tout = [], res,\n\t\ta, i, ien, j, jen,\n\t\tselectorType = typeof selector;\n\n\t// Can't just check for isArray here, as an API or jQuery instance might be\n\t// given with their array like look\n\tif ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {\n\t\tselector = [ selector ];\n\t}\n\n\tfor ( i=0, ien=selector.length ; i<ien ; i++ ) {\n\t\t// Only split on simple strings - complex expressions will be jQuery selectors\n\t\ta = selector[i] && selector[i].split && ! selector[i].match(/[\\[\\(:]/) ?\n\t\t\tselector[i].split(',') :\n\t\t\t[ selector[i] ];\n\n\t\tfor ( j=0, jen=a.length ; j<jen ; j++ ) {\n\t\t\tres = selectFn( typeof a[j] === 'string' ? (a[j]).trim() : a[j] );\n\n\t\t\tif ( res && res.length ) {\n\t\t\t\tout = out.concat( res );\n\t\t\t}\n\t\t}\n\t}\n\n\t// selector extensions\n\tvar ext = _ext.selector[ type ];\n\tif ( ext.length ) {\n\t\tfor ( i=0, ien=ext.length ; i<ien ; i++ ) {\n\t\t\tout = ext[i]( settings, opts, out );\n\t\t}\n\t}\n\n\treturn _unique( out );\n};\n\n\nvar _selector_opts = function ( opts )\n{\n\tif ( ! opts ) {\n\t\topts = {};\n\t}\n\n\t// Backwards compatibility for 1.9- which used the terminology filter rather\n\t// than search\n\tif ( opts.filter && opts.search === undefined ) {\n\t\topts.search = opts.filter;\n\t}\n\n\treturn $.extend( {\n\t\tsearch: 'none',\n\t\torder: 'current',\n\t\tpage: 'all'\n\t}, opts );\n};\n\n\nvar _selector_first = function ( inst )\n{\n\t// Reduce the API instance to the first item found\n\tfor ( var i=0, ien=inst.length ; i<ien ; i++ ) {\n\t\tif ( inst[i].length > 0 ) {\n\t\t\t// Assign the first element to the first item in the instance\n\t\t\t// and truncate the instance and context\n\t\t\tinst[0] = inst[i];\n\t\t\tinst[0].length = 1;\n\t\t\tinst.length = 1;\n\t\t\tinst.context = [ inst.context[i] ];\n\n\t\t\treturn inst;\n\t\t}\n\t}\n\n\t// Not found - return an empty instance\n\tinst.length = 0;\n\treturn inst;\n};\n\n\nvar _selector_row_indexes = function ( settings, opts )\n{\n\tvar\n\t\ti, ien, tmp, a=[],\n\t\tdisplayFiltered = settings.aiDisplay,\n\t\tdisplayMaster = settings.aiDisplayMaster;\n\n\tvar\n\t\tsearch = opts.search,  // none, applied, removed\n\t\torder  = opts.order,   // applied, current, index (original - compatibility with 1.9)\n\t\tpage   = opts.page;    // all, current\n\n\tif ( _fnDataSource( settings ) == 'ssp' ) {\n\t\t// In server-side processing mode, most options are irrelevant since\n\t\t// rows not shown don't exist and the index order is the applied order\n\t\t// Removed is a special case - for consistency just return an empty\n\t\t// array\n\t\treturn search === 'removed' ?\n\t\t\t[] :\n\t\t\t_range( 0, displayMaster.length );\n\t}\n\telse if ( page == 'current' ) {\n\t\t// Current page implies that order=current and filter=applied, since it is\n\t\t// fairly senseless otherwise, regardless of what order and search actually\n\t\t// are\n\t\tfor ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {\n\t\t\ta.push( displayFiltered[i] );\n\t\t}\n\t}\n\telse if ( order == 'current' || order == 'applied' ) {\n\t\tif ( search == 'none') {\n\t\t\ta = displayMaster.slice();\n\t\t}\n\t\telse if ( search == 'applied' ) {\n\t\t\ta = displayFiltered.slice();\n\t\t}\n\t\telse if ( search == 'removed' ) {\n\t\t\t// O(n+m) solution by creating a hash map\n\t\t\tvar displayFilteredMap = {};\n\n\t\t\tfor ( var i=0, ien=displayFiltered.length ; i<ien ; i++ ) {\n\t\t\t\tdisplayFilteredMap[displayFiltered[i]] = null;\n\t\t\t}\n\n\t\t\ta = $.map( displayMaster, function (el) {\n\t\t\t\treturn ! displayFilteredMap.hasOwnProperty(el) ?\n\t\t\t\t\tel :\n\t\t\t\t\tnull;\n\t\t\t} );\n\t\t}\n\t}\n\telse if ( order == 'index' || order == 'original' ) {\n\t\tfor ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n\t\t\tif ( search == 'none' ) {\n\t\t\t\ta.push( i );\n\t\t\t}\n\t\t\telse { // applied | removed\n\t\t\t\ttmp = $.inArray( i, displayFiltered );\n\n\t\t\t\tif ((tmp === -1 && search == 'removed') ||\n\t\t\t\t\t(tmp >= 0   && search == 'applied') )\n\t\t\t\t{\n\t\t\t\t\ta.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n};\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Rows\n *\n * {}          - no selector - use all available rows\n * {integer}   - row aoData index\n * {node}      - TR node\n * {string}    - jQuery selector to apply to the TR elements\n * {array}     - jQuery array of nodes, or simply an array of TR nodes\n *\n */\nvar __row_selector = function ( settings, selector, opts )\n{\n\tvar rows;\n\tvar run = function ( sel ) {\n\t\tvar selInt = _intVal( sel );\n\t\tvar i, ien;\n\t\tvar aoData = settings.aoData;\n\n\t\t// Short cut - selector is a number and no options provided (default is\n\t\t// all records, so no need to check if the index is in there, since it\n\t\t// must be - dev error if the index doesn't exist).\n\t\tif ( selInt !== null && ! opts ) {\n\t\t\treturn [ selInt ];\n\t\t}\n\n\t\tif ( ! rows ) {\n\t\t\trows = _selector_row_indexes( settings, opts );\n\t\t}\n\n\t\tif ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {\n\t\t\t// Selector - integer\n\t\t\treturn [ selInt ];\n\t\t}\n\t\telse if ( sel === null || sel === undefined || sel === '' ) {\n\t\t\t// Selector - none\n\t\t\treturn rows;\n\t\t}\n\n\t\t// Selector - function\n\t\tif ( typeof sel === 'function' ) {\n\t\t\treturn $.map( rows, function (idx) {\n\t\t\t\tvar row = aoData[ idx ];\n\t\t\t\treturn sel( idx, row._aData, row.nTr ) ? idx : null;\n\t\t\t} );\n\t\t}\n\n\t\t// Selector - node\n\t\tif ( sel.nodeName ) {\n\t\t\tvar rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup\n\t\t\tvar cellIdx = sel._DT_CellIndex;\n\n\t\t\tif ( rowIdx !== undefined ) {\n\t\t\t\t// Make sure that the row is actually still present in the table\n\t\t\t\treturn aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?\n\t\t\t\t\t[ rowIdx ] :\n\t\t\t\t\t[];\n\t\t\t}\n\t\t\telse if ( cellIdx ) {\n\t\t\t\treturn aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?\n\t\t\t\t\t[ cellIdx.row ] :\n\t\t\t\t\t[];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar host = $(sel).closest('*[data-dt-row]');\n\t\t\t\treturn host.length ?\n\t\t\t\t\t[ host.data('dt-row') ] :\n\t\t\t\t\t[];\n\t\t\t}\n\t\t}\n\n\t\t// ID selector. Want to always be able to select rows by id, regardless\n\t\t// of if the tr element has been created or not, so can't rely upon\n\t\t// jQuery here - hence a custom implementation. This does not match\n\t\t// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,\n\t\t// but to select it using a CSS selector engine (like Sizzle or\n\t\t// querySelect) it would need to need to be escaped for some characters.\n\t\t// DataTables simplifies this for row selectors since you can select\n\t\t// only a row. A # indicates an id any anything that follows is the id -\n\t\t// unescaped.\n\t\tif ( typeof sel === 'string' && sel.charAt(0) === '#' ) {\n\t\t\t// get row index from id\n\t\t\tvar rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];\n\t\t\tif ( rowObj !== undefined ) {\n\t\t\t\treturn [ rowObj.idx ];\n\t\t\t}\n\n\t\t\t// need to fall through to jQuery in case there is DOM id that\n\t\t\t// matches\n\t\t}\n\t\t\n\t\t// Get nodes in the order from the `rows` array with null values removed\n\t\tvar nodes = _removeEmpty(\n\t\t\t_pluck_order( settings.aoData, rows, 'nTr' )\n\t\t);\n\n\t\t// Selector - jQuery selector string, array of nodes or jQuery object/\n\t\t// As jQuery's .filter() allows jQuery objects to be passed in filter,\n\t\t// it also allows arrays, so this will cope with all three options\n\t\treturn $(nodes)\n\t\t\t.filter( sel )\n\t\t\t.map( function () {\n\t\t\t\treturn this._DT_RowIndex;\n\t\t\t} )\n\t\t\t.toArray();\n\t};\n\n\treturn _selector_run( 'row', selector, run, settings, opts );\n};\n\n\n_api_register( 'rows()', function ( selector, opts ) {\n\t// argument shifting\n\tif ( selector === undefined ) {\n\t\tselector = '';\n\t}\n\telse if ( $.isPlainObject( selector ) ) {\n\t\topts = selector;\n\t\tselector = '';\n\t}\n\n\topts = _selector_opts( opts );\n\n\tvar inst = this.iterator( 'table', function ( settings ) {\n\t\treturn __row_selector( settings, selector, opts );\n\t}, 1 );\n\n\t// Want argument shifting here and in __row_selector?\n\tinst.selector.rows = selector;\n\tinst.selector.opts = opts;\n\n\treturn inst;\n} );\n\n_api_register( 'rows().nodes()', function () {\n\treturn this.iterator( 'row', function ( settings, row ) {\n\t\treturn settings.aoData[ row ].nTr || undefined;\n\t}, 1 );\n} );\n\n_api_register( 'rows().data()', function () {\n\treturn this.iterator( true, 'rows', function ( settings, rows ) {\n\t\treturn _pluck_order( settings.aoData, rows, '_aData' );\n\t}, 1 );\n} );\n\n_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {\n\treturn this.iterator( 'row', function ( settings, row ) {\n\t\tvar r = settings.aoData[ row ];\n\t\treturn type === 'search' ? r._aFilterData : r._aSortData;\n\t}, 1 );\n} );\n\n_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {\n\treturn this.iterator( 'row', function ( settings, row ) {\n\t\t_fnInvalidate( settings, row, src );\n\t} );\n} );\n\n_api_registerPlural( 'rows().indexes()', 'row().index()', function () {\n\treturn this.iterator( 'row', function ( settings, row ) {\n\t\treturn row;\n\t}, 1 );\n} );\n\n_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {\n\tvar a = [];\n\tvar context = this.context;\n\n\t// `iterator` will drop undefined values, but in this case we want them\n\tfor ( var i=0, ien=context.length ; i<ien ; i++ ) {\n\t\tfor ( var j=0, jen=this[i].length ; j<jen ; j++ ) {\n\t\t\tvar id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );\n\t\t\ta.push( (hash === true ? '#' : '' )+ id );\n\t\t}\n\t}\n\n\treturn new _Api( context, a );\n} );\n\n_api_registerPlural( 'rows().remove()', 'row().remove()', function () {\n\tvar that = this;\n\n\tthis.iterator( 'row', function ( settings, row, thatIdx ) {\n\t\tvar data = settings.aoData;\n\t\tvar rowData = data[ row ];\n\t\tvar i, ien, j, jen;\n\t\tvar loopRow, loopCells;\n\n\t\tdata.splice( row, 1 );\n\n\t\t// Update the cached indexes\n\t\tfor ( i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t\tloopRow = data[i];\n\t\t\tloopCells = loopRow.anCells;\n\n\t\t\t// Rows\n\t\t\tif ( loopRow.nTr !== null ) {\n\t\t\t\tloopRow.nTr._DT_RowIndex = i;\n\t\t\t}\n\n\t\t\t// Cells\n\t\t\tif ( loopCells !== null ) {\n\t\t\t\tfor ( j=0, jen=loopCells.length ; j<jen ; j++ ) {\n\t\t\t\t\tloopCells[j]._DT_CellIndex.row = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Delete from the display arrays\n\t\t_fnDeleteIndex( settings.aiDisplayMaster, row );\n\t\t_fnDeleteIndex( settings.aiDisplay, row );\n\t\t_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes\n\n\t\t// For server-side processing tables - subtract the deleted row from the count\n\t\tif ( settings._iRecordsDisplay > 0 ) {\n\t\t\tsettings._iRecordsDisplay--;\n\t\t}\n\n\t\t// Check for an 'overflow' they case for displaying the table\n\t\t_fnLengthOverflow( settings );\n\n\t\t// Remove the row's ID reference if there is one\n\t\tvar id = settings.rowIdFn( rowData._aData );\n\t\tif ( id !== undefined ) {\n\t\t\tdelete settings.aIds[ id ];\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( settings ) {\n\t\tfor ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {\n\t\t\tsettings.aoData[i].idx = i;\n\t\t}\n\t} );\n\n\treturn this;\n} );\n\n\n_api_register( 'rows.add()', function ( rows ) {\n\tvar newRows = this.iterator( 'table', function ( settings ) {\n\t\t\tvar row, i, ien;\n\t\t\tvar out = [];\n\n\t\t\tfor ( i=0, ien=rows.length ; i<ien ; i++ ) {\n\t\t\t\trow = rows[i];\n\n\t\t\t\tif ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {\n\t\t\t\t\tout.push( _fnAddTr( settings, row )[0] );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout.push( _fnAddData( settings, row ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}, 1 );\n\n\t// Return an Api.rows() extended instance, so rows().nodes() etc can be used\n\tvar modRows = this.rows( -1 );\n\tmodRows.pop();\n\t$.merge( modRows, newRows );\n\n\treturn modRows;\n} );\n\n\n\n\n\n/**\n *\n */\n_api_register( 'row()', function ( selector, opts ) {\n\treturn _selector_first( this.rows( selector, opts ) );\n} );\n\n\n_api_register( 'row().data()', function ( data ) {\n\tvar ctx = this.context;\n\n\tif ( data === undefined ) {\n\t\t// Get\n\t\treturn ctx.length && this.length ?\n\t\t\tctx[0].aoData[ this[0] ]._aData :\n\t\t\tundefined;\n\t}\n\n\t// Set\n\tvar row = ctx[0].aoData[ this[0] ];\n\trow._aData = data;\n\n\t// If the DOM has an id, and the data source is an array\n\tif ( Array.isArray( data ) && row.nTr && row.nTr.id ) {\n\t\t_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );\n\t}\n\n\t// Automatically invalidate\n\t_fnInvalidate( ctx[0], this[0], 'data' );\n\n\treturn this;\n} );\n\n\n_api_register( 'row().node()', function () {\n\tvar ctx = this.context;\n\n\treturn ctx.length && this.length ?\n\t\tctx[0].aoData[ this[0] ].nTr || null :\n\t\tnull;\n} );\n\n\n_api_register( 'row.add()', function ( row ) {\n\t// Allow a jQuery object to be passed in - only a single row is added from\n\t// it though - the first element in the set\n\tif ( row instanceof $ && row.length ) {\n\t\trow = row[0];\n\t}\n\n\tvar rows = this.iterator( 'table', function ( settings ) {\n\t\tif ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {\n\t\t\treturn _fnAddTr( settings, row )[0];\n\t\t}\n\t\treturn _fnAddData( settings, row );\n\t} );\n\n\t// Return an Api.rows() extended instance, with the newly added row selected\n\treturn this.row( rows[0] );\n} );\n\n\n$(document).on('plugin-init.dt', function (e, context) {\n\tvar api = new _Api( context );\n\tvar namespace = 'on-plugin-init';\n\tvar stateSaveParamsEvent = 'stateSaveParams.' + namespace;\n\tvar destroyEvent = 'destroy. ' + namespace;\n\n\tapi.on( stateSaveParamsEvent, function ( e, settings, d ) {\n\t\t// This could be more compact with the API, but it is a lot faster as a simple\n\t\t// internal loop\n\t\tvar idFn = settings.rowIdFn;\n\t\tvar data = settings.aoData;\n\t\tvar ids = [];\n\n\t\tfor (var i=0 ; i<data.length ; i++) {\n\t\t\tif (data[i]._detailsShow) {\n\t\t\t\tids.push( '#' + idFn(data[i]._aData) );\n\t\t\t}\n\t\t}\n\n\t\td.childRows = ids;\n\t});\n\n\tapi.on( destroyEvent, function () {\n\t\tapi.off(stateSaveParamsEvent + ' ' + destroyEvent);\n\t});\n\n\tvar loaded = api.state.loaded();\n\n\tif ( loaded && loaded.childRows ) {\n\t\tapi\n\t\t\t.rows( $.map(loaded.childRows, function (id){\n\t\t\t\treturn id.replace(/:/g, '\\\\:')\n\t\t\t}) )\n\t\t\t.every( function () {\n\t\t\t\t_fnCallbackFire( context, null, 'requestChild', [ this ] )\n\t\t\t});\n\t}\n});\n\nvar __details_add = function ( ctx, row, data, klass )\n{\n\t// Convert to array of TR elements\n\tvar rows = [];\n\tvar addRow = function ( r, k ) {\n\t\t// Recursion to allow for arrays of jQuery objects\n\t\tif ( Array.isArray( r ) || r instanceof $ ) {\n\t\t\tfor ( var i=0, ien=r.length ; i<ien ; i++ ) {\n\t\t\t\taddRow( r[i], k );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// If we get a TR element, then just add it directly - up to the dev\n\t\t// to add the correct number of columns etc\n\t\tif ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {\n\t\t\trows.push( r );\n\t\t}\n\t\telse {\n\t\t\t// Otherwise create a row with a wrapper\n\t\t\tvar created = $('<tr><td></td></tr>').addClass( k );\n\t\t\t$('td', created)\n\t\t\t\t.addClass( k )\n\t\t\t\t.html( r )\n\t\t\t\t[0].colSpan = _fnVisbleColumns( ctx );\n\n\t\t\trows.push( created[0] );\n\t\t}\n\t};\n\n\taddRow( data, klass );\n\n\tif ( row._details ) {\n\t\trow._details.detach();\n\t}\n\n\trow._details = $(rows);\n\n\t// If the children were already shown, that state should be retained\n\tif ( row._detailsShow ) {\n\t\trow._details.insertAfter( row.nTr );\n\t}\n};\n\n\n// Make state saving of child row details async to allow them to be batch processed\nvar __details_state = DataTable.util.throttle(\n\tfunction (ctx) {\n\t\t_fnSaveState( ctx[0] )\n\t},\n\t500\n);\n\n\nvar __details_remove = function ( api, idx )\n{\n\tvar ctx = api.context;\n\n\tif ( ctx.length ) {\n\t\tvar row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];\n\n\t\tif ( row && row._details ) {\n\t\t\trow._details.remove();\n\n\t\t\trow._detailsShow = undefined;\n\t\t\trow._details = undefined;\n\t\t\t$( row.nTr ).removeClass( 'dt-hasChild' );\n\t\t\t__details_state( ctx );\n\t\t}\n\t}\n};\n\n\nvar __details_display = function ( api, show ) {\n\tvar ctx = api.context;\n\n\tif ( ctx.length && api.length ) {\n\t\tvar row = ctx[0].aoData[ api[0] ];\n\n\t\tif ( row._details ) {\n\t\t\trow._detailsShow = show;\n\n\t\t\tif ( show ) {\n\t\t\t\trow._details.insertAfter( row.nTr );\n\t\t\t\t$( row.nTr ).addClass( 'dt-hasChild' );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trow._details.detach();\n\t\t\t\t$( row.nTr ).removeClass( 'dt-hasChild' );\n\t\t\t}\n\n\t\t\t_fnCallbackFire( ctx[0], null, 'childRow', [ show, api.row( api[0] ) ] )\n\n\t\t\t__details_events( ctx[0] );\n\t\t\t__details_state( ctx );\n\t\t}\n\t}\n};\n\n\nvar __details_events = function ( settings )\n{\n\tvar api = new _Api( settings );\n\tvar namespace = '.dt.DT_details';\n\tvar drawEvent = 'draw'+namespace;\n\tvar colvisEvent = 'column-sizing'+namespace;\n\tvar destroyEvent = 'destroy'+namespace;\n\tvar data = settings.aoData;\n\n\tapi.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );\n\n\tif ( _pluck( data, '_details' ).length > 0 ) {\n\t\t// On each draw, insert the required elements into the document\n\t\tapi.on( drawEvent, function ( e, ctx ) {\n\t\t\tif ( settings !== ctx ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tapi.rows( {page:'current'} ).eq(0).each( function (idx) {\n\t\t\t\t// Internal data grab\n\t\t\t\tvar row = data[ idx ];\n\n\t\t\t\tif ( row._detailsShow ) {\n\t\t\t\t\trow._details.insertAfter( row.nTr );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\n\t\t// Column visibility change - update the colspan\n\t\tapi.on( colvisEvent, function ( e, ctx, idx, vis ) {\n\t\t\tif ( settings !== ctx ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Update the colspan for the details rows (note, only if it already has\n\t\t\t// a colspan)\n\t\t\tvar row, visible = _fnVisbleColumns( ctx );\n\n\t\t\tfor ( var i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t\t\trow = data[i];\n\n\t\t\t\tif ( row._details ) {\n\t\t\t\t\trow._details.children('td[colspan]').attr('colspan', visible );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Table destroyed - nuke any child rows\n\t\tapi.on( destroyEvent, function ( e, ctx ) {\n\t\t\tif ( settings !== ctx ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( var i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t\t\tif ( data[i]._details ) {\n\t\t\t\t\t__details_remove( api, i );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n};\n\n// Strings for the method names to help minification\nvar _emp = '';\nvar _child_obj = _emp+'row().child';\nvar _child_mth = _child_obj+'()';\n\n// data can be:\n//  tr\n//  string\n//  jQuery or array of any of the above\n_api_register( _child_mth, function ( data, klass ) {\n\tvar ctx = this.context;\n\n\tif ( data === undefined ) {\n\t\t// get\n\t\treturn ctx.length && this.length ?\n\t\t\tctx[0].aoData[ this[0] ]._details :\n\t\t\tundefined;\n\t}\n\telse if ( data === true ) {\n\t\t// show\n\t\tthis.child.show();\n\t}\n\telse if ( data === false ) {\n\t\t// remove\n\t\t__details_remove( this );\n\t}\n\telse if ( ctx.length && this.length ) {\n\t\t// set\n\t\t__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );\n\t}\n\n\treturn this;\n} );\n\n\n_api_register( [\n\t_child_obj+'.show()',\n\t_child_mth+'.show()' // only when `child()` was called with parameters (without\n], function ( show ) {   // it returns an object and this method is not executed)\n\t__details_display( this, true );\n\treturn this;\n} );\n\n\n_api_register( [\n\t_child_obj+'.hide()',\n\t_child_mth+'.hide()' // only when `child()` was called with parameters (without\n], function () {         // it returns an object and this method is not executed)\n\t__details_display( this, false );\n\treturn this;\n} );\n\n\n_api_register( [\n\t_child_obj+'.remove()',\n\t_child_mth+'.remove()' // only when `child()` was called with parameters (without\n], function () {           // it returns an object and this method is not executed)\n\t__details_remove( this );\n\treturn this;\n} );\n\n\n_api_register( _child_obj+'.isShown()', function () {\n\tvar ctx = this.context;\n\n\tif ( ctx.length && this.length ) {\n\t\t// _detailsShown as false or undefined will fall through to return false\n\t\treturn ctx[0].aoData[ this[0] ]._detailsShow || false;\n\t}\n\treturn false;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Columns\n *\n * {integer}           - column index (>=0 count from left, <0 count from right)\n * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\n * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\n * \"{string}:name\"     - column name\n * \"{string}\"          - jQuery selector on column header nodes\n *\n */\n\n// can be an array of these items, comma separated list, or an array of comma\n// separated lists\n\nvar __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;\n\n\n// r1 and r2 are redundant - but it means that the parameters match for the\n// iterator callback in columns().data()\nvar __columnData = function ( settings, column, r1, r2, rows ) {\n\tvar a = [];\n\tfor ( var row=0, ien=rows.length ; row<ien ; row++ ) {\n\t\ta.push( _fnGetCellData( settings, rows[row], column ) );\n\t}\n\treturn a;\n};\n\n\nvar __column_selector = function ( settings, selector, opts )\n{\n\tvar\n\t\tcolumns = settings.aoColumns,\n\t\tnames = _pluck( columns, 'sName' ),\n\t\tnodes = _pluck( columns, 'nTh' );\n\n\tvar run = function ( s ) {\n\t\tvar selInt = _intVal( s );\n\n\t\t// Selector - all\n\t\tif ( s === '' ) {\n\t\t\treturn _range( columns.length );\n\t\t}\n\n\t\t// Selector - index\n\t\tif ( selInt !== null ) {\n\t\t\treturn [ selInt >= 0 ?\n\t\t\t\tselInt : // Count from left\n\t\t\t\tcolumns.length + selInt // Count from right (+ because its a negative value)\n\t\t\t];\n\t\t}\n\n\t\t// Selector = function\n\t\tif ( typeof s === 'function' ) {\n\t\t\tvar rows = _selector_row_indexes( settings, opts );\n\n\t\t\treturn $.map( columns, function (col, idx) {\n\t\t\t\treturn s(\n\t\t\t\t\t\tidx,\n\t\t\t\t\t\t__columnData( settings, idx, 0, 0, rows ),\n\t\t\t\t\t\tnodes[ idx ]\n\t\t\t\t\t) ? idx : null;\n\t\t\t} );\n\t\t}\n\n\t\t// jQuery or string selector\n\t\tvar match = typeof s === 'string' ?\n\t\t\ts.match( __re_column_selector ) :\n\t\t\t'';\n\n\t\tif ( match ) {\n\t\t\tswitch( match[2] ) {\n\t\t\t\tcase 'visIdx':\n\t\t\t\tcase 'visible':\n\t\t\t\t\tvar idx = parseInt( match[1], 10 );\n\t\t\t\t\t// Visible index given, convert to column index\n\t\t\t\t\tif ( idx < 0 ) {\n\t\t\t\t\t\t// Counting from the right\n\t\t\t\t\t\tvar visColumns = $.map( columns, function (col,i) {\n\t\t\t\t\t\t\treturn col.bVisible ? i : null;\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn [ visColumns[ visColumns.length + idx ] ];\n\t\t\t\t\t}\n\t\t\t\t\t// Counting from the left\n\t\t\t\t\treturn [ _fnVisibleToColumnIndex( settings, idx ) ];\n\n\t\t\t\tcase 'name':\n\t\t\t\t\t// match by name. `names` is column index complete and in order\n\t\t\t\t\treturn $.map( names, function (name, i) {\n\t\t\t\t\t\treturn name === match[1] ? i : null;\n\t\t\t\t\t} );\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// Cell in the table body\n\t\tif ( s.nodeName && s._DT_CellIndex ) {\n\t\t\treturn [ s._DT_CellIndex.column ];\n\t\t}\n\n\t\t// jQuery selector on the TH elements for the columns\n\t\tvar jqResult = $( nodes )\n\t\t\t.filter( s )\n\t\t\t.map( function () {\n\t\t\t\treturn $.inArray( this, nodes ); // `nodes` is column index complete and in order\n\t\t\t} )\n\t\t\t.toArray();\n\n\t\tif ( jqResult.length || ! s.nodeName ) {\n\t\t\treturn jqResult;\n\t\t}\n\n\t\t// Otherwise a node which might have a `dt-column` data attribute, or be\n\t\t// a child or such an element\n\t\tvar host = $(s).closest('*[data-dt-column]');\n\t\treturn host.length ?\n\t\t\t[ host.data('dt-column') ] :\n\t\t\t[];\n\t};\n\n\treturn _selector_run( 'column', selector, run, settings, opts );\n};\n\n\nvar __setColumnVis = function ( settings, column, vis ) {\n\tvar\n\t\tcols = settings.aoColumns,\n\t\tcol  = cols[ column ],\n\t\tdata = settings.aoData,\n\t\trow, cells, i, ien, tr;\n\n\t// Get\n\tif ( vis === undefined ) {\n\t\treturn col.bVisible;\n\t}\n\n\t// Set\n\t// No change\n\tif ( col.bVisible === vis ) {\n\t\treturn;\n\t}\n\n\tif ( vis ) {\n\t\t// Insert column\n\t\t// Need to decide if we should use appendChild or insertBefore\n\t\tvar insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );\n\n\t\tfor ( i=0, ien=data.length ; i<ien ; i++ ) {\n\t\t\ttr = data[i].nTr;\n\t\t\tcells = data[i].anCells;\n\n\t\t\tif ( tr ) {\n\t\t\t\t// insertBefore can act like appendChild if 2nd arg is null\n\t\t\t\ttr.insertBefore( cells[ column ], cells[ insertBefore ] || null );\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Remove column\n\t\t$( _pluck( settings.aoData, 'anCells', column ) ).detach();\n\t}\n\n\t// Common actions\n\tcol.bVisible = vis;\n};\n\n\n_api_register( 'columns()', function ( selector, opts ) {\n\t// argument shifting\n\tif ( selector === undefined ) {\n\t\tselector = '';\n\t}\n\telse if ( $.isPlainObject( selector ) ) {\n\t\topts = selector;\n\t\tselector = '';\n\t}\n\n\topts = _selector_opts( opts );\n\n\tvar inst = this.iterator( 'table', function ( settings ) {\n\t\treturn __column_selector( settings, selector, opts );\n\t}, 1 );\n\n\t// Want argument shifting here and in _row_selector?\n\tinst.selector.cols = selector;\n\tinst.selector.opts = opts;\n\n\treturn inst;\n} );\n\n_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {\n\treturn this.iterator( 'column', function ( settings, column ) {\n\t\treturn settings.aoColumns[column].nTh;\n\t}, 1 );\n} );\n\n_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {\n\treturn this.iterator( 'column', function ( settings, column ) {\n\t\treturn settings.aoColumns[column].nTf;\n\t}, 1 );\n} );\n\n_api_registerPlural( 'columns().data()', 'column().data()', function () {\n\treturn this.iterator( 'column-rows', __columnData, 1 );\n} );\n\n_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {\n\treturn this.iterator( 'column', function ( settings, column ) {\n\t\treturn settings.aoColumns[column].mData;\n\t}, 1 );\n} );\n\n_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {\n\treturn this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {\n\t\treturn _pluck_order( settings.aoData, rows,\n\t\t\ttype === 'search' ? '_aFilterData' : '_aSortData', column\n\t\t);\n\t}, 1 );\n} );\n\n_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {\n\treturn this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {\n\t\treturn _pluck_order( settings.aoData, rows, 'anCells', column ) ;\n\t}, 1 );\n} );\n\n_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {\n\tvar that = this;\n\tvar ret = this.iterator( 'column', function ( settings, column ) {\n\t\tif ( vis === undefined ) {\n\t\t\treturn settings.aoColumns[ column ].bVisible;\n\t\t} // else\n\t\t__setColumnVis( settings, column, vis );\n\t} );\n\n\t// Group the column visibility changes\n\tif ( vis !== undefined ) {\n\t\tthis.iterator( 'table', function ( settings ) {\n\t\t\t// Redraw the header after changes\n\t\t\t_fnDrawHead( settings, settings.aoHeader );\n\t\t\t_fnDrawHead( settings, settings.aoFooter );\n\t\n\t\t\t// Update colspan for no records display. Child rows and extensions will use their own\n\t\t\t// listeners to do this - only need to update the empty table item here\n\t\t\tif ( ! settings.aiDisplay.length ) {\n\t\t\t\t$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));\n\t\t\t}\n\t\n\t\t\t_fnSaveState( settings );\n\n\t\t\t// Second loop once the first is done for events\n\t\t\tthat.iterator( 'column', function ( settings, column ) {\n\t\t\t\t_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );\n\t\t\t} );\n\n\t\t\tif ( calc === undefined || calc ) {\n\t\t\t\tthat.columns.adjust();\n\t\t\t}\n\t\t});\n\t}\n\n\treturn ret;\n} );\n\n_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {\n\treturn this.iterator( 'column', function ( settings, column ) {\n\t\treturn type === 'visible' ?\n\t\t\t_fnColumnIndexToVisible( settings, column ) :\n\t\t\tcolumn;\n\t}, 1 );\n} );\n\n_api_register( 'columns.adjust()', function () {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t_fnAdjustColumnSizing( settings );\n\t}, 1 );\n} );\n\n_api_register( 'column.index()', function ( type, idx ) {\n\tif ( this.context.length !== 0 ) {\n\t\tvar ctx = this.context[0];\n\n\t\tif ( type === 'fromVisible' || type === 'toData' ) {\n\t\t\treturn _fnVisibleToColumnIndex( ctx, idx );\n\t\t}\n\t\telse if ( type === 'fromData' || type === 'toVisible' ) {\n\t\t\treturn _fnColumnIndexToVisible( ctx, idx );\n\t\t}\n\t}\n} );\n\n_api_register( 'column()', function ( selector, opts ) {\n\treturn _selector_first( this.columns( selector, opts ) );\n} );\n\nvar __cell_selector = function ( settings, selector, opts )\n{\n\tvar data = settings.aoData;\n\tvar rows = _selector_row_indexes( settings, opts );\n\tvar cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );\n\tvar allCells = $(_flatten( [], cells ));\n\tvar row;\n\tvar columns = settings.aoColumns.length;\n\tvar a, i, ien, j, o, host;\n\n\tvar run = function ( s ) {\n\t\tvar fnSelector = typeof s === 'function';\n\n\t\tif ( s === null || s === undefined || fnSelector ) {\n\t\t\t// All cells and function selectors\n\t\t\ta = [];\n\n\t\t\tfor ( i=0, ien=rows.length ; i<ien ; i++ ) {\n\t\t\t\trow = rows[i];\n\n\t\t\t\tfor ( j=0 ; j<columns ; j++ ) {\n\t\t\t\t\to = {\n\t\t\t\t\t\trow: row,\n\t\t\t\t\t\tcolumn: j\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( fnSelector ) {\n\t\t\t\t\t\t// Selector - function\n\t\t\t\t\t\thost = data[ row ];\n\n\t\t\t\t\t\tif ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {\n\t\t\t\t\t\t\ta.push( o );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Selector - all\n\t\t\t\t\t\ta.push( o );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t// Selector - index\n\t\tif ( $.isPlainObject( s ) ) {\n\t\t\t// Valid cell index and its in the array of selectable rows\n\t\t\treturn s.column !== undefined && s.row !== undefined && $.inArray( s.row, rows ) !== -1 ?\n\t\t\t\t[s] :\n\t\t\t\t[];\n\t\t}\n\n\t\t// Selector - jQuery filtered cells\n\t\tvar jqResult = allCells\n\t\t\t.filter( s )\n\t\t\t.map( function (i, el) {\n\t\t\t\treturn { // use a new object, in case someone changes the values\n\t\t\t\t\trow:    el._DT_CellIndex.row,\n\t\t\t\t\tcolumn: el._DT_CellIndex.column\n \t\t\t\t};\n\t\t\t} )\n\t\t\t.toArray();\n\n\t\tif ( jqResult.length || ! s.nodeName ) {\n\t\t\treturn jqResult;\n\t\t}\n\n\t\t// Otherwise the selector is a node, and there is one last option - the\n\t\t// element might be a child of an element which has dt-row and dt-column\n\t\t// data attributes\n\t\thost = $(s).closest('*[data-dt-row]');\n\t\treturn host.length ?\n\t\t\t[ {\n\t\t\t\trow: host.data('dt-row'),\n\t\t\t\tcolumn: host.data('dt-column')\n\t\t\t} ] :\n\t\t\t[];\n\t};\n\n\treturn _selector_run( 'cell', selector, run, settings, opts );\n};\n\n\n\n\n_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {\n\t// Argument shifting\n\tif ( $.isPlainObject( rowSelector ) ) {\n\t\t// Indexes\n\t\tif ( rowSelector.row === undefined ) {\n\t\t\t// Selector options in first parameter\n\t\t\topts = rowSelector;\n\t\t\trowSelector = null;\n\t\t}\n\t\telse {\n\t\t\t// Cell index objects in first parameter\n\t\t\topts = columnSelector;\n\t\t\tcolumnSelector = null;\n\t\t}\n\t}\n\tif ( $.isPlainObject( columnSelector ) ) {\n\t\topts = columnSelector;\n\t\tcolumnSelector = null;\n\t}\n\n\t// Cell selector\n\tif ( columnSelector === null || columnSelector === undefined ) {\n\t\treturn this.iterator( 'table', function ( settings ) {\n\t\t\treturn __cell_selector( settings, rowSelector, _selector_opts( opts ) );\n\t\t} );\n\t}\n\n\t// The default built in options need to apply to row and columns\n\tvar internalOpts = opts ? {\n\t\tpage: opts.page,\n\t\torder: opts.order,\n\t\tsearch: opts.search\n\t} : {};\n\n\t// Row + column selector\n\tvar columns = this.columns( columnSelector, internalOpts );\n\tvar rows = this.rows( rowSelector, internalOpts );\n\tvar i, ien, j, jen;\n\n\tvar cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {\n\t\tvar a = [];\n\n\t\tfor ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {\n\t\t\tfor ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {\n\t\t\t\ta.push( {\n\t\t\t\t\trow:    rows[idx][i],\n\t\t\t\t\tcolumn: columns[idx][j]\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t}, 1 );\n\n\t// There is currently only one extension which uses a cell selector extension\n\t// It is a _major_ performance drag to run this if it isn't needed, so this is\n\t// an extension specific check at the moment\n\tvar cells = opts && opts.selected ?\n\t\tthis.cells( cellsNoOpts, opts ) :\n\t\tcellsNoOpts;\n\n\t$.extend( cells.selector, {\n\t\tcols: columnSelector,\n\t\trows: rowSelector,\n\t\topts: opts\n\t} );\n\n\treturn cells;\n} );\n\n\n_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {\n\treturn this.iterator( 'cell', function ( settings, row, column ) {\n\t\tvar data = settings.aoData[ row ];\n\n\t\treturn data && data.anCells ?\n\t\t\tdata.anCells[ column ] :\n\t\t\tundefined;\n\t}, 1 );\n} );\n\n\n_api_register( 'cells().data()', function () {\n\treturn this.iterator( 'cell', function ( settings, row, column ) {\n\t\treturn _fnGetCellData( settings, row, column );\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {\n\ttype = type === 'search' ? '_aFilterData' : '_aSortData';\n\n\treturn this.iterator( 'cell', function ( settings, row, column ) {\n\t\treturn settings.aoData[ row ][ type ][ column ];\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {\n\treturn this.iterator( 'cell', function ( settings, row, column ) {\n\t\treturn _fnGetCellData( settings, row, column, type );\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {\n\treturn this.iterator( 'cell', function ( settings, row, column ) {\n\t\treturn {\n\t\t\trow: row,\n\t\t\tcolumn: column,\n\t\t\tcolumnVisible: _fnColumnIndexToVisible( settings, column )\n\t\t};\n\t}, 1 );\n} );\n\n\n_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {\n\treturn this.iterator( 'cell', function ( settings, row, column ) {\n\t\t_fnInvalidate( settings, row, src, column );\n\t} );\n} );\n\n\n\n_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {\n\treturn _selector_first( this.cells( rowSelector, columnSelector, opts ) );\n} );\n\n\n_api_register( 'cell().data()', function ( data ) {\n\tvar ctx = this.context;\n\tvar cell = this[0];\n\n\tif ( data === undefined ) {\n\t\t// Get\n\t\treturn ctx.length && cell.length ?\n\t\t\t_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :\n\t\t\tundefined;\n\t}\n\n\t// Set\n\t_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );\n\t_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );\n\n\treturn this;\n} );\n\n\n\n/**\n * Get current ordering (sorting) that has been applied to the table.\n *\n * @returns {array} 2D array containing the sorting information for the first\n *   table in the current context. Each element in the parent array represents\n *   a column being sorted upon (i.e. multi-sorting with two columns would have\n *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\n *   the column index that the sorting condition applies to, the second is the\n *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\n *   index of the sorting order from the `column.sorting` initialisation array.\n *//**\n * Set the ordering for the table.\n *\n * @param {integer} order Column index to sort upon.\n * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\n * @returns {DataTables.Api} this\n *//**\n * Set the ordering for the table.\n *\n * @param {array} order 1D array of sorting information to be applied.\n * @param {array} [...] Optional additional sorting conditions\n * @returns {DataTables.Api} this\n *//**\n * Set the ordering for the table.\n *\n * @param {array} order 2D array of sorting information to be applied.\n * @returns {DataTables.Api} this\n */\n_api_register( 'order()', function ( order, dir ) {\n\tvar ctx = this.context;\n\n\tif ( order === undefined ) {\n\t\t// get\n\t\treturn ctx.length !== 0 ?\n\t\t\tctx[0].aaSorting :\n\t\t\tundefined;\n\t}\n\n\t// set\n\tif ( typeof order === 'number' ) {\n\t\t// Simple column / direction passed in\n\t\torder = [ [ order, dir ] ];\n\t}\n\telse if ( order.length && ! Array.isArray( order[0] ) ) {\n\t\t// Arguments passed in (list of 1D arrays)\n\t\torder = Array.prototype.slice.call( arguments );\n\t}\n\t// otherwise a 2D array was passed in\n\n\treturn this.iterator( 'table', function ( settings ) {\n\t\tsettings.aaSorting = order.slice();\n\t} );\n} );\n\n\n/**\n * Attach a sort listener to an element for a given column\n *\n * @param {node|jQuery|string} node Identifier for the element(s) to attach the\n *   listener to. This can take the form of a single DOM node, a jQuery\n *   collection of nodes or a jQuery selector which will identify the node(s).\n * @param {integer} column the column that a click on this node will sort on\n * @param {function} [callback] callback function when sort is run\n * @returns {DataTables.Api} this\n */\n_api_register( 'order.listener()', function ( node, column, callback ) {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t_fnSortAttachListener( settings, node, column, callback );\n\t} );\n} );\n\n\n_api_register( 'order.fixed()', function ( set ) {\n\tif ( ! set ) {\n\t\tvar ctx = this.context;\n\t\tvar fixed = ctx.length ?\n\t\t\tctx[0].aaSortingFixed :\n\t\t\tundefined;\n\n\t\treturn Array.isArray( fixed ) ?\n\t\t\t{ pre: fixed } :\n\t\t\tfixed;\n\t}\n\n\treturn this.iterator( 'table', function ( settings ) {\n\t\tsettings.aaSortingFixed = $.extend( true, {}, set );\n\t} );\n} );\n\n\n// Order by the selected column(s)\n_api_register( [\n\t'columns().order()',\n\t'column().order()'\n], function ( dir ) {\n\tvar that = this;\n\n\treturn this.iterator( 'table', function ( settings, i ) {\n\t\tvar sort = [];\n\n\t\t$.each( that[i], function (j, col) {\n\t\t\tsort.push( [ col, dir ] );\n\t\t} );\n\n\t\tsettings.aaSorting = sort;\n\t} );\n} );\n\n\n\n_api_register( 'search()', function ( input, regex, smart, caseInsen ) {\n\tvar ctx = this.context;\n\n\tif ( input === undefined ) {\n\t\t// get\n\t\treturn ctx.length !== 0 ?\n\t\t\tctx[0].oPreviousSearch.sSearch :\n\t\t\tundefined;\n\t}\n\n\t// set\n\treturn this.iterator( 'table', function ( settings ) {\n\t\tif ( ! settings.oFeatures.bFilter ) {\n\t\t\treturn;\n\t\t}\n\n\t\t_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {\n\t\t\t\"sSearch\": input+\"\",\n\t\t\t\"bRegex\":  regex === null ? false : regex,\n\t\t\t\"bSmart\":  smart === null ? true  : smart,\n\t\t\t\"bCaseInsensitive\": caseInsen === null ? true : caseInsen\n\t\t} ), 1 );\n\t} );\n} );\n\n\n_api_registerPlural(\n\t'columns().search()',\n\t'column().search()',\n\tfunction ( input, regex, smart, caseInsen ) {\n\t\treturn this.iterator( 'column', function ( settings, column ) {\n\t\t\tvar preSearch = settings.aoPreSearchCols;\n\n\t\t\tif ( input === undefined ) {\n\t\t\t\t// get\n\t\t\t\treturn preSearch[ column ].sSearch;\n\t\t\t}\n\n\t\t\t// set\n\t\t\tif ( ! settings.oFeatures.bFilter ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$.extend( preSearch[ column ], {\n\t\t\t\t\"sSearch\": input+\"\",\n\t\t\t\t\"bRegex\":  regex === null ? false : regex,\n\t\t\t\t\"bSmart\":  smart === null ? true  : smart,\n\t\t\t\t\"bCaseInsensitive\": caseInsen === null ? true : caseInsen\n\t\t\t} );\n\n\t\t\t_fnFilterComplete( settings, settings.oPreviousSearch, 1 );\n\t\t} );\n\t}\n);\n\n/*\n * State API methods\n */\n\n_api_register( 'state()', function () {\n\treturn this.context.length ?\n\t\tthis.context[0].oSavedState :\n\t\tnull;\n} );\n\n\n_api_register( 'state.clear()', function () {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t// Save an empty object\n\t\tsettings.fnStateSaveCallback.call( settings.oInstance, settings, {} );\n\t} );\n} );\n\n\n_api_register( 'state.loaded()', function () {\n\treturn this.context.length ?\n\t\tthis.context[0].oLoadedState :\n\t\tnull;\n} );\n\n\n_api_register( 'state.save()', function () {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t_fnSaveState( settings );\n\t} );\n} );\n\n\n\n/**\n * Set the jQuery or window object to be used by DataTables\n *\n * @param {*} module Library / container object\n * @param {string} type Library or container type `lib` or `win`.\n */\nDataTable.use = function (module, type) {\n\tif (type === 'lib' || module.fn) {\n\t\t$ = module;\n\t}\n\telse if (type == 'win' || module.document) {\n\t\twindow = module;\n\t\tdocument = module.document;\n\t}\n}\n\n/**\n * CommonJS factory function pass through. This will check if the arguments\n * given are a window object or a jQuery object. If so they are set\n * accordingly.\n * @param {*} root Window\n * @param {*} jq jQUery\n * @returns {boolean} Indicator\n */\nDataTable.factory = function (root, jq) {\n\tvar is = false;\n\n\t// Test if the first parameter is a window object\n\tif (root && root.document) {\n\t\twindow = root;\n\t\tdocument = root.document;\n\t}\n\n\t// Test if the second parameter is a jQuery object\n\tif (jq && jq.fn && jq.fn.jquery) {\n\t\t$ = jq;\n\t\tis = true;\n\t}\n\n\treturn is;\n}\n\n/**\n * Provide a common method for plug-ins to check the version of DataTables being\n * used, in order to ensure compatibility.\n *\n *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\n *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\n *  @returns {boolean} true if this version of DataTables is greater or equal to\n *    the required version, or false if this version of DataTales is not\n *    suitable\n *  @static\n *  @dtopt API-Static\n *\n *  @example\n *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\n */\nDataTable.versionCheck = DataTable.fnVersionCheck = function( version )\n{\n\tvar aThis = DataTable.version.split('.');\n\tvar aThat = version.split('.');\n\tvar iThis, iThat;\n\n\tfor ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {\n\t\tiThis = parseInt( aThis[i], 10 ) || 0;\n\t\tiThat = parseInt( aThat[i], 10 ) || 0;\n\n\t\t// Parts are the same, keep comparing\n\t\tif (iThis === iThat) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Parts are different, return immediately\n\t\treturn iThis > iThat;\n\t}\n\n\treturn true;\n};\n\n\n/**\n * Check if a `<table>` node is a DataTable table already or not.\n *\n *  @param {node|jquery|string} table Table node, jQuery object or jQuery\n *      selector for the table to test. Note that if more than more than one\n *      table is passed on, only the first will be checked\n *  @returns {boolean} true the table given is a DataTable, or false otherwise\n *  @static\n *  @dtopt API-Static\n *\n *  @example\n *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\n *      $('#example').dataTable();\n *    }\n */\nDataTable.isDataTable = DataTable.fnIsDataTable = function ( table )\n{\n\tvar t = $(table).get(0);\n\tvar is = false;\n\n\tif ( table instanceof DataTable.Api ) {\n\t\treturn true;\n\t}\n\n\t$.each( DataTable.settings, function (i, o) {\n\t\tvar head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;\n\t\tvar foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;\n\n\t\tif ( o.nTable === t || head === t || foot === t ) {\n\t\t\tis = true;\n\t\t}\n\t} );\n\n\treturn is;\n};\n\n\n/**\n * Get all DataTable tables that have been initialised - optionally you can\n * select to get only currently visible tables.\n *\n *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\n *    or visible tables only.\n *  @returns {array} Array of `table` nodes (not DataTable instances) which are\n *    DataTables\n *  @static\n *  @dtopt API-Static\n *\n *  @example\n *    $.each( $.fn.dataTable.tables(true), function () {\n *      $(table).DataTable().columns.adjust();\n *    } );\n */\nDataTable.tables = DataTable.fnTables = function ( visible )\n{\n\tvar api = false;\n\n\tif ( $.isPlainObject( visible ) ) {\n\t\tapi = visible.api;\n\t\tvisible = visible.visible;\n\t}\n\n\tvar a = $.map( DataTable.settings, function (o) {\n\t\tif ( !visible || (visible && $(o.nTable).is(':visible')) ) {\n\t\t\treturn o.nTable;\n\t\t}\n\t} );\n\n\treturn api ?\n\t\tnew _Api( a ) :\n\t\ta;\n};\n\n\n/**\n * Convert from camel case parameters to Hungarian notation. This is made public\n * for the extensions to provide the same ability as DataTables core to accept\n * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\n * parameters.\n *\n *  @param {object} src The model object which holds all parameters that can be\n *    mapped.\n *  @param {object} user The object to convert from camel case to Hungarian.\n *  @param {boolean} force When set to `true`, properties which already have a\n *    Hungarian value in the `user` object will be overwritten. Otherwise they\n *    won't be.\n */\nDataTable.camelToHungarian = _fnCamelToHungarian;\n\n\n\n/**\n *\n */\n_api_register( '$()', function ( selector, opts ) {\n\tvar\n\t\trows   = this.rows( opts ).nodes(), // Get all rows\n\t\tjqRows = $(rows);\n\n\treturn $( [].concat(\n\t\tjqRows.filter( selector ).toArray(),\n\t\tjqRows.find( selector ).toArray()\n\t) );\n} );\n\n\n// jQuery functions to operate on the tables\n$.each( [ 'on', 'one', 'off' ], function (i, key) {\n\t_api_register( key+'()', function ( /* event, handler */ ) {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\n\t\t// Add the `dt` namespace automatically if it isn't already present\n\t\targs[0] = $.map( args[0].split( /\\s/ ), function ( e ) {\n\t\t\treturn ! e.match(/\\.dt\\b/) ?\n\t\t\t\te+'.dt' :\n\t\t\t\te;\n\t\t\t} ).join( ' ' );\n\n\t\tvar inst = $( this.tables().nodes() );\n\t\tinst[key].apply( inst, args );\n\t\treturn this;\n\t} );\n} );\n\n\n_api_register( 'clear()', function () {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\t_fnClearTable( settings );\n\t} );\n} );\n\n\n_api_register( 'settings()', function () {\n\treturn new _Api( this.context, this.context );\n} );\n\n\n_api_register( 'init()', function () {\n\tvar ctx = this.context;\n\treturn ctx.length ? ctx[0].oInit : null;\n} );\n\n\n_api_register( 'data()', function () {\n\treturn this.iterator( 'table', function ( settings ) {\n\t\treturn _pluck( settings.aoData, '_aData' );\n\t} ).flatten();\n} );\n\n\n_api_register( 'destroy()', function ( remove ) {\n\tremove = remove || false;\n\n\treturn this.iterator( 'table', function ( settings ) {\n\t\tvar classes   = settings.oClasses;\n\t\tvar table     = settings.nTable;\n\t\tvar tbody     = settings.nTBody;\n\t\tvar thead     = settings.nTHead;\n\t\tvar tfoot     = settings.nTFoot;\n\t\tvar jqTable   = $(table);\n\t\tvar jqTbody   = $(tbody);\n\t\tvar jqWrapper = $(settings.nTableWrapper);\n\t\tvar rows      = $.map( settings.aoData, function (r) { return r.nTr; } );\n\t\tvar i, ien;\n\n\t\t// Flag to note that the table is currently being destroyed - no action\n\t\t// should be taken\n\t\tsettings.bDestroying = true;\n\n\t\t// Fire off the destroy callbacks for plug-ins etc\n\t\t_fnCallbackFire( settings, \"aoDestroyCallback\", \"destroy\", [settings] );\n\n\t\t// If not being removed from the document, make all columns visible\n\t\tif ( ! remove ) {\n\t\t\tnew _Api( settings ).columns().visible( true );\n\t\t}\n\n\t\t// Blitz all `DT` namespaced events (these are internal events, the\n\t\t// lowercase, `dt` events are user subscribed and they are responsible\n\t\t// for removing them\n\t\tjqWrapper.off('.DT').find(':not(tbody *)').off('.DT');\n\t\t$(window).off('.DT-'+settings.sInstance);\n\n\t\t// When scrolling we had to break the table up - restore it\n\t\tif ( table != thead.parentNode ) {\n\t\t\tjqTable.children('thead').detach();\n\t\t\tjqTable.append( thead );\n\t\t}\n\n\t\tif ( tfoot && table != tfoot.parentNode ) {\n\t\t\tjqTable.children('tfoot').detach();\n\t\t\tjqTable.append( tfoot );\n\t\t}\n\n\t\tsettings.aaSorting = [];\n\t\tsettings.aaSortingFixed = [];\n\t\t_fnSortingClasses( settings );\n\n\t\t$( rows ).removeClass( settings.asStripeClasses.join(' ') );\n\n\t\t$('th, td', thead).removeClass( classes.sSortable+' '+\n\t\t\tclasses.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone\n\t\t);\n\n\t\t// Add the TR elements back into the table in their original order\n\t\tjqTbody.children().detach();\n\t\tjqTbody.append( rows );\n\n\t\tvar orig = settings.nTableWrapper.parentNode;\n\n\t\t// Remove the DataTables generated nodes, events and classes\n\t\tvar removedMethod = remove ? 'remove' : 'detach';\n\t\tjqTable[ removedMethod ]();\n\t\tjqWrapper[ removedMethod ]();\n\n\t\t// If we need to reattach the table to the document\n\t\tif ( ! remove && orig ) {\n\t\t\t// insertBefore acts like appendChild if !arg[1]\n\t\t\torig.insertBefore( table, settings.nTableReinsertBefore );\n\n\t\t\t// Restore the width of the original table - was read from the style property,\n\t\t\t// so we can restore directly to that\n\t\t\tjqTable\n\t\t\t\t.css( 'width', settings.sDestroyWidth )\n\t\t\t\t.removeClass( classes.sTable );\n\n\t\t\t// If the were originally stripe classes - then we add them back here.\n\t\t\t// Note this is not fool proof (for example if not all rows had stripe\n\t\t\t// classes - but it's a good effort without getting carried away\n\t\t\tien = settings.asDestroyStripes.length;\n\n\t\t\tif ( ien ) {\n\t\t\t\tjqTbody.children().each( function (i) {\n\t\t\t\t\t$(this).addClass( settings.asDestroyStripes[i % ien] );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\t/* Remove the settings object from the settings array */\n\t\tvar idx = $.inArray( settings, DataTable.settings );\n\t\tif ( idx !== -1 ) {\n\t\t\tDataTable.settings.splice( idx, 1 );\n\t\t}\n\t} );\n} );\n\n\n// Add the `every()` method for rows, columns and cells in a compact form\n$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {\n\t_api_register( type+'s().every()', function ( fn ) {\n\t\tvar opts = this.selector.opts;\n\t\tvar api = this;\n\n\t\treturn this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {\n\t\t\t// Rows and columns:\n\t\t\t//  arg1 - index\n\t\t\t//  arg2 - table counter\n\t\t\t//  arg3 - loop counter\n\t\t\t//  arg4 - undefined\n\t\t\t// Cells:\n\t\t\t//  arg1 - row index\n\t\t\t//  arg2 - column index\n\t\t\t//  arg3 - table counter\n\t\t\t//  arg4 - loop counter\n\t\t\tfn.call(\n\t\t\t\tapi[ type ](\n\t\t\t\t\targ1,\n\t\t\t\t\ttype==='cell' ? arg2 : opts,\n\t\t\t\t\ttype==='cell' ? opts : undefined\n\t\t\t\t),\n\t\t\t\targ1, arg2, arg3, arg4\n\t\t\t);\n\t\t} );\n\t} );\n} );\n\n\n// i18n method for extensions to be able to use the language object from the\n// DataTable\n_api_register( 'i18n()', function ( token, def, plural ) {\n\tvar ctx = this.context[0];\n\tvar resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );\n\n\tif ( resolved === undefined ) {\n\t\tresolved = def;\n\t}\n\n\tif ( plural !== undefined && $.isPlainObject( resolved ) ) {\n\t\tresolved = resolved[ plural ] !== undefined ?\n\t\t\tresolved[ plural ] :\n\t\t\tresolved._;\n\t}\n\n\treturn resolved.replace( '%d', plural ); // nb: plural might be undefined,\n} );\n/**\n * Version string for plug-ins to check compatibility. Allowed format is\n * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\n * only for non-release builds. See http://semver.org/ for more information.\n *  @member\n *  @type string\n *  @default Version number\n */\nDataTable.version = \"1.13.4\";\n\n/**\n * Private data store, containing all of the settings objects that are\n * created for the tables on a given page.\n *\n * Note that the `DataTable.settings` object is aliased to\n * `jQuery.fn.dataTableExt` through which it may be accessed and\n * manipulated, or `jQuery.fn.dataTable.settings`.\n *  @member\n *  @type array\n *  @default []\n *  @private\n */\nDataTable.settings = [];\n\n/**\n * Object models container, for the various models that DataTables has\n * available to it. These models define the objects that are used to hold\n * the active state and configuration of the table.\n *  @namespace\n */\nDataTable.models = {};\n\n\n\n/**\n * Template object for the way in which DataTables holds information about\n * search information for the global filter and individual column filters.\n *  @namespace\n */\nDataTable.models.oSearch = {\n\t/**\n\t * Flag to indicate if the filtering should be case insensitive or not\n\t *  @type boolean\n\t *  @default true\n\t */\n\t\"bCaseInsensitive\": true,\n\n\t/**\n\t * Applied search term\n\t *  @type string\n\t *  @default <i>Empty string</i>\n\t */\n\t\"sSearch\": \"\",\n\n\t/**\n\t * Flag to indicate if the search term should be interpreted as a\n\t * regular expression (true) or not (false) and therefore and special\n\t * regex characters escaped.\n\t *  @type boolean\n\t *  @default false\n\t */\n\t\"bRegex\": false,\n\n\t/**\n\t * Flag to indicate if DataTables is to use its smart filtering or not.\n\t *  @type boolean\n\t *  @default true\n\t */\n\t\"bSmart\": true,\n\n\t/**\n\t * Flag to indicate if DataTables should only trigger a search when\n\t * the return key is pressed.\n\t *  @type boolean\n\t *  @default false\n\t */\n\t\"return\": false\n};\n\n\n\n\n/**\n * Template object for the way in which DataTables holds information about\n * each individual row. This is the object format used for the settings\n * aoData array.\n *  @namespace\n */\nDataTable.models.oRow = {\n\t/**\n\t * TR element for the row\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTr\": null,\n\n\t/**\n\t * Array of TD elements for each row. This is null until the row has been\n\t * created.\n\t *  @type array nodes\n\t *  @default []\n\t */\n\t\"anCells\": null,\n\n\t/**\n\t * Data object from the original data source for the row. This is either\n\t * an array if using the traditional form of DataTables, or an object if\n\t * using mData options. The exact type will depend on the passed in\n\t * data from the data source, or will be an array if using DOM a data\n\t * source.\n\t *  @type array|object\n\t *  @default []\n\t */\n\t\"_aData\": [],\n\n\t/**\n\t * Sorting data cache - this array is ostensibly the same length as the\n\t * number of columns (although each index is generated only as it is\n\t * needed), and holds the data that is used for sorting each column in the\n\t * row. We do this cache generation at the start of the sort in order that\n\t * the formatting of the sort data need be done only once for each cell\n\t * per sort. This array should not be read from or written to by anything\n\t * other than the master sorting methods.\n\t *  @type array\n\t *  @default null\n\t *  @private\n\t */\n\t\"_aSortData\": null,\n\n\t/**\n\t * Per cell filtering data cache. As per the sort data cache, used to\n\t * increase the performance of the filtering in DataTables\n\t *  @type array\n\t *  @default null\n\t *  @private\n\t */\n\t\"_aFilterData\": null,\n\n\t/**\n\t * Filtering data cache. This is the same as the cell filtering cache, but\n\t * in this case a string rather than an array. This is easily computed with\n\t * a join on `_aFilterData`, but is provided as a cache so the join isn't\n\t * needed on every search (memory traded for performance)\n\t *  @type array\n\t *  @default null\n\t *  @private\n\t */\n\t\"_sFilterRow\": null,\n\n\t/**\n\t * Cache of the class name that DataTables has applied to the row, so we\n\t * can quickly look at this variable rather than needing to do a DOM check\n\t * on className for the nTr property.\n\t *  @type string\n\t *  @default <i>Empty string</i>\n\t *  @private\n\t */\n\t\"_sRowStripe\": \"\",\n\n\t/**\n\t * Denote if the original data source was from the DOM, or the data source\n\t * object. This is used for invalidating data, so DataTables can\n\t * automatically read data from the original source, unless uninstructed\n\t * otherwise.\n\t *  @type string\n\t *  @default null\n\t *  @private\n\t */\n\t\"src\": null,\n\n\t/**\n\t * Index in the aoData array. This saves an indexOf lookup when we have the\n\t * object, but want to know the index\n\t *  @type integer\n\t *  @default -1\n\t *  @private\n\t */\n\t\"idx\": -1\n};\n\n\n/**\n * Template object for the column information object in DataTables. This object\n * is held in the settings aoColumns array and contains all the information that\n * DataTables needs about each individual column.\n *\n * Note that this object is related to {@link DataTable.defaults.column}\n * but this one is the internal data store for DataTables's cache of columns.\n * It should NOT be manipulated outside of DataTables. Any configuration should\n * be done through the initialisation options.\n *  @namespace\n */\nDataTable.models.oColumn = {\n\t/**\n\t * Column index. This could be worked out on-the-fly with $.inArray, but it\n\t * is faster to just hold it as a variable\n\t *  @type integer\n\t *  @default null\n\t */\n\t\"idx\": null,\n\n\t/**\n\t * A list of the columns that sorting should occur on when this column\n\t * is sorted. That this property is an array allows multi-column sorting\n\t * to be defined for a column (for example first name / last name columns\n\t * would benefit from this). The values are integers pointing to the\n\t * columns to be sorted on (typically it will be a single integer pointing\n\t * at itself, but that doesn't need to be the case).\n\t *  @type array\n\t */\n\t\"aDataSort\": null,\n\n\t/**\n\t * Define the sorting directions that are applied to the column, in sequence\n\t * as the column is repeatedly sorted upon - i.e. the first value is used\n\t * as the sorting direction when the column if first sorted (clicked on).\n\t * Sort it again (click again) and it will move on to the next index.\n\t * Repeat until loop.\n\t *  @type array\n\t */\n\t\"asSorting\": null,\n\n\t/**\n\t * Flag to indicate if the column is searchable, and thus should be included\n\t * in the filtering or not.\n\t *  @type boolean\n\t */\n\t\"bSearchable\": null,\n\n\t/**\n\t * Flag to indicate if the column is sortable or not.\n\t *  @type boolean\n\t */\n\t\"bSortable\": null,\n\n\t/**\n\t * Flag to indicate if the column is currently visible in the table or not\n\t *  @type boolean\n\t */\n\t\"bVisible\": null,\n\n\t/**\n\t * Store for manual type assignment using the `column.type` option. This\n\t * is held in store so we can manipulate the column's `sType` property.\n\t *  @type string\n\t *  @default null\n\t *  @private\n\t */\n\t\"_sManualType\": null,\n\n\t/**\n\t * Flag to indicate if HTML5 data attributes should be used as the data\n\t * source for filtering or sorting. True is either are.\n\t *  @type boolean\n\t *  @default false\n\t *  @private\n\t */\n\t\"_bAttrSrc\": false,\n\n\t/**\n\t * Developer definable function that is called whenever a cell is created (Ajax source,\n\t * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n\t * allowing you to modify the DOM element (add background colour for example) when the\n\t * element is available.\n\t *  @type function\n\t *  @param {element} nTd The TD node that has been created\n\t *  @param {*} sData The Data for the cell\n\t *  @param {array|object} oData The data for the whole row\n\t *  @param {int} iRow The row index for the aoData data store\n\t *  @default null\n\t */\n\t\"fnCreatedCell\": null,\n\n\t/**\n\t * Function to get data from a cell in a column. You should <b>never</b>\n\t * access data directly through _aData internally in DataTables - always use\n\t * the method attached to this property. It allows mData to function as\n\t * required. This function is automatically assigned by the column\n\t * initialisation method\n\t *  @type function\n\t *  @param {array|object} oData The data array/object for the array\n\t *    (i.e. aoData[]._aData)\n\t *  @param {string} sSpecific The specific data type you want to get -\n\t *    'display', 'type' 'filter' 'sort'\n\t *  @returns {*} The data for the cell from the given row's data\n\t *  @default null\n\t */\n\t\"fnGetData\": null,\n\n\t/**\n\t * Function to set data for a cell in the column. You should <b>never</b>\n\t * set the data directly to _aData internally in DataTables - always use\n\t * this method. It allows mData to function as required. This function\n\t * is automatically assigned by the column initialisation method\n\t *  @type function\n\t *  @param {array|object} oData The data array/object for the array\n\t *    (i.e. aoData[]._aData)\n\t *  @param {*} sValue Value to set\n\t *  @default null\n\t */\n\t\"fnSetData\": null,\n\n\t/**\n\t * Property to read the value for the cells in the column from the data\n\t * source array / object. If null, then the default content is used, if a\n\t * function is given then the return from the function is used.\n\t *  @type function|int|string|null\n\t *  @default null\n\t */\n\t\"mData\": null,\n\n\t/**\n\t * Partner property to mData which is used (only when defined) to get\n\t * the data - i.e. it is basically the same as mData, but without the\n\t * 'set' option, and also the data fed to it is the result from mData.\n\t * This is the rendering method to match the data method of mData.\n\t *  @type function|int|string|null\n\t *  @default null\n\t */\n\t\"mRender\": null,\n\n\t/**\n\t * Unique header TH/TD element for this column - this is what the sorting\n\t * listener is attached to (if sorting is enabled.)\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTh\": null,\n\n\t/**\n\t * Unique footer TH/TD element for this column (if there is one). Not used\n\t * in DataTables as such, but can be used for plug-ins to reference the\n\t * footer for each column.\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTf\": null,\n\n\t/**\n\t * The class to apply to all TD elements in the table's TBODY for the column\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sClass\": null,\n\n\t/**\n\t * When DataTables calculates the column widths to assign to each column,\n\t * it finds the longest string in each column and then constructs a\n\t * temporary table and reads the widths from that. The problem with this\n\t * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n\t * string - thus the calculation can go wrong (doing it properly and putting\n\t * it into an DOM object and measuring that is horribly(!) slow). Thus as\n\t * a \"work around\" we provide this option. It will append its value to the\n\t * text that is found to be the longest string for the column - i.e. padding.\n\t *  @type string\n\t */\n\t\"sContentPadding\": null,\n\n\t/**\n\t * Allows a default value to be given for a column's data, and will be used\n\t * whenever a null data source is encountered (this can be because mData\n\t * is set to null, or because the data source itself is null).\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sDefaultContent\": null,\n\n\t/**\n\t * Name for the column, allowing reference to the column by name as well as\n\t * by index (needs a lookup to work by name).\n\t *  @type string\n\t */\n\t\"sName\": null,\n\n\t/**\n\t * Custom sorting data type - defines which of the available plug-ins in\n\t * afnSortData the custom sorting will use - if any is defined.\n\t *  @type string\n\t *  @default std\n\t */\n\t\"sSortDataType\": 'std',\n\n\t/**\n\t * Class to be applied to the header element when sorting on this column\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sSortingClass\": null,\n\n\t/**\n\t * Class to be applied to the header element when sorting on this column -\n\t * when jQuery UI theming is used.\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sSortingClassJUI\": null,\n\n\t/**\n\t * Title of the column - what is seen in the TH element (nTh).\n\t *  @type string\n\t */\n\t\"sTitle\": null,\n\n\t/**\n\t * Column sorting and filtering type\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sType\": null,\n\n\t/**\n\t * Width of the column\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sWidth\": null,\n\n\t/**\n\t * Width of the column when it was first \"encountered\"\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sWidthOrig\": null\n};\n\n\n/*\n * Developer note: The properties of the object below are given in Hungarian\n * notation, that was used as the interface for DataTables prior to v1.10, however\n * from v1.10 onwards the primary interface is camel case. In order to avoid\n * breaking backwards compatibility utterly with this change, the Hungarian\n * version is still, internally the primary interface, but is is not documented\n * - hence the @name tags in each doc comment. This allows a Javascript function\n * to create a map from Hungarian notation to camel case (going the other direction\n * would require each property to be listed, which would add around 3K to the size\n * of DataTables, while this method is about a 0.5K hit).\n *\n * Ultimately this does pave the way for Hungarian notation to be dropped\n * completely, but that is a massive amount of work and will break current\n * installs (therefore is on-hold until v2).\n */\n\n/**\n * Initialisation options that can be given to DataTables at initialisation\n * time.\n *  @namespace\n */\nDataTable.defaults = {\n\t/**\n\t * An array of data to use for the table, passed in at initialisation which\n\t * will be used in preference to any data which is already in the DOM. This is\n\t * particularly useful for constructing tables purely in Javascript, for\n\t * example with a custom Ajax call.\n\t *  @type array\n\t *  @default null\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.data\n\t *\n\t *  @example\n\t *    // Using a 2D array data source\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"data\": [\n\t *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\n\t *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\n\t *        ],\n\t *        \"columns\": [\n\t *          { \"title\": \"Engine\" },\n\t *          { \"title\": \"Browser\" },\n\t *          { \"title\": \"Platform\" },\n\t *          { \"title\": \"Version\" },\n\t *          { \"title\": \"Grade\" }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using an array of objects as a data source (`data`)\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"data\": [\n\t *          {\n\t *            \"engine\":   \"Trident\",\n\t *            \"browser\":  \"Internet Explorer 4.0\",\n\t *            \"platform\": \"Win 95+\",\n\t *            \"version\":  4,\n\t *            \"grade\":    \"X\"\n\t *          },\n\t *          {\n\t *            \"engine\":   \"Trident\",\n\t *            \"browser\":  \"Internet Explorer 5.0\",\n\t *            \"platform\": \"Win 95+\",\n\t *            \"version\":  5,\n\t *            \"grade\":    \"C\"\n\t *          }\n\t *        ],\n\t *        \"columns\": [\n\t *          { \"title\": \"Engine\",   \"data\": \"engine\" },\n\t *          { \"title\": \"Browser\",  \"data\": \"browser\" },\n\t *          { \"title\": \"Platform\", \"data\": \"platform\" },\n\t *          { \"title\": \"Version\",  \"data\": \"version\" },\n\t *          { \"title\": \"Grade\",    \"data\": \"grade\" }\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"aaData\": null,\n\n\n\t/**\n\t * If ordering is enabled, then DataTables will perform a first pass sort on\n\t * initialisation. You can define which column(s) the sort is performed\n\t * upon, and the sorting direction, with this variable. The `sorting` array\n\t * should contain an array for each column to be sorted initially containing\n\t * the column's index and a direction string ('asc' or 'desc').\n\t *  @type array\n\t *  @default [[0,'asc']]\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.order\n\t *\n\t *  @example\n\t *    // Sort by 3rd column first, and then 4th column\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"order\": [[2,'asc'], [3,'desc']]\n\t *      } );\n\t *    } );\n\t *\n\t *    // No initial sorting\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"order\": []\n\t *      } );\n\t *    } );\n\t */\n\t\"aaSorting\": [[0,'asc']],\n\n\n\t/**\n\t * This parameter is basically identical to the `sorting` parameter, but\n\t * cannot be overridden by user interaction with the table. What this means\n\t * is that you could have a column (visible or hidden) which the sorting\n\t * will always be forced on first - any sorting after that (from the user)\n\t * will then be performed as required. This can be useful for grouping rows\n\t * together.\n\t *  @type array\n\t *  @default null\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.orderFixed\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"orderFixed\": [[0,'asc']]\n\t *      } );\n\t *    } )\n\t */\n\t\"aaSortingFixed\": [],\n\n\n\t/**\n\t * DataTables can be instructed to load data to display in the table from a\n\t * Ajax source. This option defines how that Ajax call is made and where to.\n\t *\n\t * The `ajax` property has three different modes of operation, depending on\n\t * how it is defined. These are:\n\t *\n\t * * `string` - Set the URL from where the data should be loaded from.\n\t * * `object` - Define properties for `jQuery.ajax`.\n\t * * `function` - Custom data get function\n\t *\n\t * `string`\n\t * --------\n\t *\n\t * As a string, the `ajax` property simply defines the URL from which\n\t * DataTables will load data.\n\t *\n\t * `object`\n\t * --------\n\t *\n\t * As an object, the parameters in the object are passed to\n\t * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\n\t * of the Ajax request. DataTables has a number of default parameters which\n\t * you can override using this option. Please refer to the jQuery\n\t * documentation for a full description of the options available, although\n\t * the following parameters provide additional options in DataTables or\n\t * require special consideration:\n\t *\n\t * * `data` - As with jQuery, `data` can be provided as an object, but it\n\t *   can also be used as a function to manipulate the data DataTables sends\n\t *   to the server. The function takes a single parameter, an object of\n\t *   parameters with the values that DataTables has readied for sending. An\n\t *   object may be returned which will be merged into the DataTables\n\t *   defaults, or you can add the items to the object that was passed in and\n\t *   not return anything from the function. This supersedes `fnServerParams`\n\t *   from DataTables 1.9-.\n\t *\n\t * * `dataSrc` - By default DataTables will look for the property `data` (or\n\t *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\n\t *   from an Ajax source or for server-side processing - this parameter\n\t *   allows that property to be changed. You can use Javascript dotted\n\t *   object notation to get a data source for multiple levels of nesting, or\n\t *   it my be used as a function. As a function it takes a single parameter,\n\t *   the JSON returned from the server, which can be manipulated as\n\t *   required, with the returned value being that used by DataTables as the\n\t *   data source for the table. This supersedes `sAjaxDataProp` from\n\t *   DataTables 1.9-.\n\t *\n\t * * `success` - Should not be overridden it is used internally in\n\t *   DataTables. To manipulate / transform the data returned by the server\n\t *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\n\t *\n\t * `function`\n\t * ----------\n\t *\n\t * As a function, making the Ajax call is left up to yourself allowing\n\t * complete control of the Ajax request. Indeed, if desired, a method other\n\t * than Ajax could be used to obtain the required data, such as Web storage\n\t * or an AIR database.\n\t *\n\t * The function is given four parameters and no return is required. The\n\t * parameters are:\n\t *\n\t * 1. _object_ - Data to send to the server\n\t * 2. _function_ - Callback function that must be executed when the required\n\t *    data has been obtained. That data should be passed into the callback\n\t *    as the only parameter\n\t * 3. _object_ - DataTables settings object for the table\n\t *\n\t * Note that this supersedes `fnServerData` from DataTables 1.9-.\n\t *\n\t *  @type string|object|function\n\t *  @default null\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.ajax\n\t *  @since 1.10.0\n\t *\n\t * @example\n\t *   // Get JSON data from a file via Ajax.\n\t *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": \"data.json\"\n\t *   } );\n\t *\n\t * @example\n\t *   // Get JSON data from a file via Ajax, using `dataSrc` to change\n\t *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": {\n\t *       \"url\": \"data.json\",\n\t *       \"dataSrc\": \"tableData\"\n\t *     }\n\t *   } );\n\t *\n\t * @example\n\t *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\n\t *   // from a plain array rather than an array in an object\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": {\n\t *       \"url\": \"data.json\",\n\t *       \"dataSrc\": \"\"\n\t *     }\n\t *   } );\n\t *\n\t * @example\n\t *   // Manipulate the data returned from the server - add a link to data\n\t *   // (note this can, should, be done using `render` for the column - this\n\t *   // is just a simple example of how the data can be manipulated).\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": {\n\t *       \"url\": \"data.json\",\n\t *       \"dataSrc\": function ( json ) {\n\t *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\n\t *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\n\t *         }\n\t *         return json;\n\t *       }\n\t *     }\n\t *   } );\n\t *\n\t * @example\n\t *   // Add data to the request\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": {\n\t *       \"url\": \"data.json\",\n\t *       \"data\": function ( d ) {\n\t *         return {\n\t *           \"extra_search\": $('#extra').val()\n\t *         };\n\t *       }\n\t *     }\n\t *   } );\n\t *\n\t * @example\n\t *   // Send request as POST\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": {\n\t *       \"url\": \"data.json\",\n\t *       \"type\": \"POST\"\n\t *     }\n\t *   } );\n\t *\n\t * @example\n\t *   // Get the data from localStorage (could interface with a form for\n\t *   // adding, editing and removing rows).\n\t *   $('#example').dataTable( {\n\t *     \"ajax\": function (data, callback, settings) {\n\t *       callback(\n\t *         JSON.parse( localStorage.getItem('dataTablesData') )\n\t *       );\n\t *     }\n\t *   } );\n\t */\n\t\"ajax\": null,\n\n\n\t/**\n\t * This parameter allows you to readily specify the entries in the length drop\n\t * down menu that DataTables shows when pagination is enabled. It can be\n\t * either a 1D array of options which will be used for both the displayed\n\t * option and the value, or a 2D array which will use the array in the first\n\t * position as the value, and the array in the second position as the\n\t * displayed options (useful for language strings such as 'All').\n\t *\n\t * Note that the `pageLength` property will be automatically set to the\n\t * first value given in this array, unless `pageLength` is also provided.\n\t *  @type array\n\t *  @default [ 10, 25, 50, 100 ]\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.lengthMenu\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\n\t *      } );\n\t *    } );\n\t */\n\t\"aLengthMenu\": [ 10, 25, 50, 100 ],\n\n\n\t/**\n\t * The `columns` option in the initialisation parameter allows you to define\n\t * details about the way individual columns behave. For a full list of\n\t * column options that can be set, please see\n\t * {@link DataTable.defaults.column}. Note that if you use `columns` to\n\t * define your columns, you must have an entry in the array for every single\n\t * column that you have in your table (these can be null if you don't which\n\t * to specify any options).\n\t *  @member\n\t *\n\t *  @name DataTable.defaults.column\n\t */\n\t\"aoColumns\": null,\n\n\t/**\n\t * Very similar to `columns`, `columnDefs` allows you to target a specific\n\t * column, multiple columns, or all columns, using the `targets` property of\n\t * each object in the array. This allows great flexibility when creating\n\t * tables, as the `columnDefs` arrays can be of any length, targeting the\n\t * columns you specifically want. `columnDefs` may use any of the column\n\t * options available: {@link DataTable.defaults.column}, but it _must_\n\t * have `targets` defined in each object in the array. Values in the `targets`\n\t * array may be:\n\t *   <ul>\n\t *     <li>a string - class name will be matched on the TH for the column</li>\n\t *     <li>0 or a positive integer - column index counting from the left</li>\n\t *     <li>a negative integer - column index counting from the right</li>\n\t *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\n\t *   </ul>\n\t *  @member\n\t *\n\t *  @name DataTable.defaults.columnDefs\n\t */\n\t\"aoColumnDefs\": null,\n\n\n\t/**\n\t * Basically the same as `search`, this parameter defines the individual column\n\t * filtering state at initialisation time. The array must be of the same size\n\t * as the number of columns, and each element be an object with the parameters\n\t * `search` and `escapeRegex` (the latter is optional). 'null' is also\n\t * accepted and the default will be used.\n\t *  @type array\n\t *  @default []\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.searchCols\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"searchCols\": [\n\t *          null,\n\t *          { \"search\": \"My filter\" },\n\t *          null,\n\t *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\n\t *        ]\n\t *      } );\n\t *    } )\n\t */\n\t\"aoSearchCols\": [],\n\n\n\t/**\n\t * An array of CSS classes that should be applied to displayed rows. This\n\t * array may be of any length, and DataTables will apply each class\n\t * sequentially, looping when required.\n\t *  @type array\n\t *  @default null <i>Will take the values determined by the `oClasses.stripe*`\n\t *    options</i>\n\t *\n\t *  @dtopt Option\n\t *  @name DataTable.defaults.stripeClasses\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\n\t *      } );\n\t *    } )\n\t */\n\t\"asStripeClasses\": null,\n\n\n\t/**\n\t * Enable or disable automatic column width calculation. This can be disabled\n\t * as an optimisation (it takes some time to calculate the widths) if the\n\t * tables widths are passed in using `columns`.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.autoWidth\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"autoWidth\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bAutoWidth\": true,\n\n\n\t/**\n\t * Deferred rendering can provide DataTables with a huge speed boost when you\n\t * are using an Ajax or JS data source for the table. This option, when set to\n\t * true, will cause DataTables to defer the creation of the table elements for\n\t * each row until they are needed for a draw - saving a significant amount of\n\t * time.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.deferRender\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"ajax\": \"sources/arrays.txt\",\n\t *        \"deferRender\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"bDeferRender\": false,\n\n\n\t/**\n\t * Replace a DataTable which matches the given selector and replace it with\n\t * one which has the properties of the new initialisation object passed. If no\n\t * table matches the selector, then the new DataTable will be constructed as\n\t * per normal.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.destroy\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"srollY\": \"200px\",\n\t *        \"paginate\": false\n\t *      } );\n\t *\n\t *      // Some time later....\n\t *      $('#example').dataTable( {\n\t *        \"filter\": false,\n\t *        \"destroy\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"bDestroy\": false,\n\n\n\t/**\n\t * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\n\t * that it allows the end user to input multiple words (space separated) and\n\t * will match a row containing those words, even if not in the order that was\n\t * specified (this allow matching across multiple columns). Note that if you\n\t * wish to use filtering in DataTables this must remain 'true' - to remove the\n\t * default filtering input box and retain filtering abilities, please use\n\t * {@link DataTable.defaults.dom}.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.searching\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"searching\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bFilter\": true,\n\n\n\t/**\n\t * Enable or disable the table information display. This shows information\n\t * about the data that is currently visible on the page, including information\n\t * about filtered data if that action is being performed.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.info\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"info\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bInfo\": true,\n\n\n\t/**\n\t * Allows the end user to select the size of a formatted page from a select\n\t * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.lengthChange\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"lengthChange\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bLengthChange\": true,\n\n\n\t/**\n\t * Enable or disable pagination.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.paging\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"paging\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bPaginate\": true,\n\n\n\t/**\n\t * Enable or disable the display of a 'processing' indicator when the table is\n\t * being processed (e.g. a sort). This is particularly useful for tables with\n\t * large amounts of data where it can take a noticeable amount of time to sort\n\t * the entries.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.processing\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"processing\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"bProcessing\": false,\n\n\n\t/**\n\t * Retrieve the DataTables object for the given selector. Note that if the\n\t * table has already been initialised, this parameter will cause DataTables\n\t * to simply return the object that has already been set up - it will not take\n\t * account of any changes you might have made to the initialisation object\n\t * passed to DataTables (setting this parameter to true is an acknowledgement\n\t * that you understand this). `destroy` can be used to reinitialise a table if\n\t * you need.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.retrieve\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      initTable();\n\t *      tableActions();\n\t *    } );\n\t *\n\t *    function initTable ()\n\t *    {\n\t *      return $('#example').dataTable( {\n\t *        \"scrollY\": \"200px\",\n\t *        \"paginate\": false,\n\t *        \"retrieve\": true\n\t *      } );\n\t *    }\n\t *\n\t *    function tableActions ()\n\t *    {\n\t *      var table = initTable();\n\t *      // perform API operations with oTable\n\t *    }\n\t */\n\t\"bRetrieve\": false,\n\n\n\t/**\n\t * When vertical (y) scrolling is enabled, DataTables will force the height of\n\t * the table's viewport to the given height at all times (useful for layout).\n\t * However, this can look odd when filtering data down to a small data set,\n\t * and the footer is left \"floating\" further down. This parameter (when\n\t * enabled) will cause DataTables to collapse the table's viewport down when\n\t * the result set will fit within the given Y height.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.scrollCollapse\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"scrollY\": \"200\",\n\t *        \"scrollCollapse\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"bScrollCollapse\": false,\n\n\n\t/**\n\t * Configure DataTables to use server-side processing. Note that the\n\t * `ajax` parameter must also be given in order to give DataTables a\n\t * source to obtain the required data for each draw.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Features\n\t *  @dtopt Server-side\n\t *  @name DataTable.defaults.serverSide\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"serverSide\": true,\n\t *        \"ajax\": \"xhr.php\"\n\t *      } );\n\t *    } );\n\t */\n\t\"bServerSide\": false,\n\n\n\t/**\n\t * Enable or disable sorting of columns. Sorting of individual columns can be\n\t * disabled by the `sortable` option for each column.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.ordering\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"ordering\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bSort\": true,\n\n\n\t/**\n\t * Enable or display DataTables' ability to sort multiple columns at the\n\t * same time (activated by shift-click by the user).\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.orderMulti\n\t *\n\t *  @example\n\t *    // Disable multiple column sorting ability\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"orderMulti\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bSortMulti\": true,\n\n\n\t/**\n\t * Allows control over whether DataTables should use the top (true) unique\n\t * cell that is found for a single column, or the bottom (false - default).\n\t * This is useful when using complex headers.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.orderCellsTop\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"orderCellsTop\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"bSortCellsTop\": false,\n\n\n\t/**\n\t * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\n\t * `sorting\\_3` to the columns which are currently being sorted on. This is\n\t * presented as a feature switch as it can increase processing time (while\n\t * classes are removed and added) so for large data sets you might want to\n\t * turn this off.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.orderClasses\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"orderClasses\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"bSortClasses\": true,\n\n\n\t/**\n\t * Enable or disable state saving. When enabled HTML5 `localStorage` will be\n\t * used to save table display information such as pagination information,\n\t * display length, filtering and sorting. As such when the end user reloads\n\t * the page the display display will match what thy had previously set up.\n\t *\n\t * Due to the use of `localStorage` the default state saving is not supported\n\t * in IE6 or 7. If state saving is required in those browsers, use\n\t * `stateSaveCallback` to provide a storage solution such as cookies.\n\t *  @type boolean\n\t *  @default false\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.stateSave\n\t *\n\t *  @example\n\t *    $(document).ready( function () {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"bStateSave\": false,\n\n\n\t/**\n\t * This function is called when a TR element is created (and all TD child\n\t * elements have been inserted), or registered if using a DOM source, allowing\n\t * manipulation of the TR element (adding classes etc).\n\t *  @type function\n\t *  @param {node} row \"TR\" element for the current row\n\t *  @param {array} data Raw data array for this row\n\t *  @param {int} dataIndex The index of this row in the internal aoData array\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.createdRow\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"createdRow\": function( row, data, dataIndex ) {\n\t *          // Bold the grade for all 'A' grade browsers\n\t *          if ( data[4] == \"A\" )\n\t *          {\n\t *            $('td:eq(4)', row).html( '<b>A</b>' );\n\t *          }\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnCreatedRow\": null,\n\n\n\t/**\n\t * This function is called on every 'draw' event, and allows you to\n\t * dynamically modify any aspect you want about the created DOM.\n\t *  @type function\n\t *  @param {object} settings DataTables settings object\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.drawCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"drawCallback\": function( settings ) {\n\t *          alert( 'DataTables has redrawn the table' );\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnDrawCallback\": null,\n\n\n\t/**\n\t * Identical to fnHeaderCallback() but for the table footer this function\n\t * allows you to modify the table footer on every 'draw' event.\n\t *  @type function\n\t *  @param {node} foot \"TR\" element for the footer\n\t *  @param {array} data Full table data (as derived from the original HTML)\n\t *  @param {int} start Index for the current display starting point in the\n\t *    display array\n\t *  @param {int} end Index for the current display ending point in the\n\t *    display array\n\t *  @param {array int} display Index array to translate the visual position\n\t *    to the full data array\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.footerCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"footerCallback\": function( tfoot, data, start, end, display ) {\n\t *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\n\t *        }\n\t *      } );\n\t *    } )\n\t */\n\t\"fnFooterCallback\": null,\n\n\n\t/**\n\t * When rendering large numbers in the information element for the table\n\t * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\n\t * to have a comma separator for the 'thousands' units (e.g. 1 million is\n\t * rendered as \"1,000,000\") to help readability for the end user. This\n\t * function will override the default method DataTables uses.\n\t *  @type function\n\t *  @member\n\t *  @param {int} toFormat number to be formatted\n\t *  @returns {string} formatted string for DataTables to show the number\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.formatNumber\n\t *\n\t *  @example\n\t *    // Format a number using a single quote for the separator (note that\n\t *    // this can also be done with the language.thousands option)\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"formatNumber\": function ( toFormat ) {\n\t *          return toFormat.toString().replace(\n\t *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\n\t *          );\n\t *        };\n\t *      } );\n\t *    } );\n\t */\n\t\"fnFormatNumber\": function ( toFormat ) {\n\t\treturn toFormat.toString().replace(\n\t\t\t/\\B(?=(\\d{3})+(?!\\d))/g,\n\t\t\tthis.oLanguage.sThousands\n\t\t);\n\t},\n\n\n\t/**\n\t * This function is called on every 'draw' event, and allows you to\n\t * dynamically modify the header row. This can be used to calculate and\n\t * display useful information about the table.\n\t *  @type function\n\t *  @param {node} head \"TR\" element for the header\n\t *  @param {array} data Full table data (as derived from the original HTML)\n\t *  @param {int} start Index for the current display starting point in the\n\t *    display array\n\t *  @param {int} end Index for the current display ending point in the\n\t *    display array\n\t *  @param {array int} display Index array to translate the visual position\n\t *    to the full data array\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.headerCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"fheaderCallback\": function( head, data, start, end, display ) {\n\t *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\n\t *        }\n\t *      } );\n\t *    } )\n\t */\n\t\"fnHeaderCallback\": null,\n\n\n\t/**\n\t * The information element can be used to convey information about the current\n\t * state of the table. Although the internationalisation options presented by\n\t * DataTables are quite capable of dealing with most customisations, there may\n\t * be times where you wish to customise the string further. This callback\n\t * allows you to do exactly that.\n\t *  @type function\n\t *  @param {object} oSettings DataTables settings object\n\t *  @param {int} start Starting position in data for the draw\n\t *  @param {int} end End position in data for the draw\n\t *  @param {int} max Total number of rows in the table (regardless of\n\t *    filtering)\n\t *  @param {int} total Total number of rows in the data set, after filtering\n\t *  @param {string} pre The string that DataTables has formatted using it's\n\t *    own rules\n\t *  @returns {string} The string to be displayed in the information element.\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.infoCallback\n\t *\n\t *  @example\n\t *    $('#example').dataTable( {\n\t *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\n\t *        return start +\" to \"+ end;\n\t *      }\n\t *    } );\n\t */\n\t\"fnInfoCallback\": null,\n\n\n\t/**\n\t * Called when the table has been initialised. Normally DataTables will\n\t * initialise sequentially and there will be no need for this function,\n\t * however, this does not hold true when using external language information\n\t * since that is obtained using an async XHR call.\n\t *  @type function\n\t *  @param {object} settings DataTables settings object\n\t *  @param {object} json The JSON object request from the server - only\n\t *    present if client-side Ajax sourced data is used\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.initComplete\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"initComplete\": function(settings, json) {\n\t *          alert( 'DataTables has finished its initialisation.' );\n\t *        }\n\t *      } );\n\t *    } )\n\t */\n\t\"fnInitComplete\": null,\n\n\n\t/**\n\t * Called at the very start of each table draw and can be used to cancel the\n\t * draw by returning false, any other return (including undefined) results in\n\t * the full draw occurring).\n\t *  @type function\n\t *  @param {object} settings DataTables settings object\n\t *  @returns {boolean} False will cancel the draw, anything else (including no\n\t *    return) will allow it to complete.\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.preDrawCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"preDrawCallback\": function( settings ) {\n\t *          if ( $('#test').val() == 1 ) {\n\t *            return false;\n\t *          }\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnPreDrawCallback\": null,\n\n\n\t/**\n\t * This function allows you to 'post process' each row after it have been\n\t * generated for each table draw, but before it is rendered on screen. This\n\t * function might be used for setting the row class name etc.\n\t *  @type function\n\t *  @param {node} row \"TR\" element for the current row\n\t *  @param {array} data Raw data array for this row\n\t *  @param {int} displayIndex The display index for the current table draw\n\t *  @param {int} displayIndexFull The index of the data in the full list of\n\t *    rows (after filtering)\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.rowCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\n\t *          // Bold the grade for all 'A' grade browsers\n\t *          if ( data[4] == \"A\" ) {\n\t *            $('td:eq(4)', row).html( '<b>A</b>' );\n\t *          }\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnRowCallback\": null,\n\n\n\t/**\n\t * __Deprecated__ The functionality provided by this parameter has now been\n\t * superseded by that provided through `ajax`, which should be used instead.\n\t *\n\t * This parameter allows you to override the default function which obtains\n\t * the data from the server so something more suitable for your application.\n\t * For example you could use POST data, or pull information from a Gears or\n\t * AIR database.\n\t *  @type function\n\t *  @member\n\t *  @param {string} source HTTP source to obtain the data from (`ajax`)\n\t *  @param {array} data A key/value pair object containing the data to send\n\t *    to the server\n\t *  @param {function} callback to be called on completion of the data get\n\t *    process that will draw the data on the page.\n\t *  @param {object} settings DataTables settings object\n\t *\n\t *  @dtopt Callbacks\n\t *  @dtopt Server-side\n\t *  @name DataTable.defaults.serverData\n\t *\n\t *  @deprecated 1.10. Please use `ajax` for this functionality now.\n\t */\n\t\"fnServerData\": null,\n\n\n\t/**\n\t * __Deprecated__ The functionality provided by this parameter has now been\n\t * superseded by that provided through `ajax`, which should be used instead.\n\t *\n\t *  It is often useful to send extra data to the server when making an Ajax\n\t * request - for example custom filtering information, and this callback\n\t * function makes it trivial to send extra information to the server. The\n\t * passed in parameter is the data set that has been constructed by\n\t * DataTables, and you can add to this or modify it as you require.\n\t *  @type function\n\t *  @param {array} data Data array (array of objects which are name/value\n\t *    pairs) that has been constructed by DataTables and will be sent to the\n\t *    server. In the case of Ajax sourced data with server-side processing\n\t *    this will be an empty array, for server-side processing there will be a\n\t *    significant number of parameters!\n\t *  @returns {undefined} Ensure that you modify the data array passed in,\n\t *    as this is passed by reference.\n\t *\n\t *  @dtopt Callbacks\n\t *  @dtopt Server-side\n\t *  @name DataTable.defaults.serverParams\n\t *\n\t *  @deprecated 1.10. Please use `ajax` for this functionality now.\n\t */\n\t\"fnServerParams\": null,\n\n\n\t/**\n\t * Load the table state. With this function you can define from where, and how, the\n\t * state of a table is loaded. By default DataTables will load from `localStorage`\n\t * but you might wish to use a server-side database or cookies.\n\t *  @type function\n\t *  @member\n\t *  @param {object} settings DataTables settings object\n\t *  @param {object} callback Callback that can be executed when done. It\n\t *    should be passed the loaded state object.\n\t *  @return {object} The DataTables state object to be loaded\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.stateLoadCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true,\n\t *        \"stateLoadCallback\": function (settings, callback) {\n\t *          $.ajax( {\n\t *            \"url\": \"/state_load\",\n\t *            \"dataType\": \"json\",\n\t *            \"success\": function (json) {\n\t *              callback( json );\n\t *            }\n\t *          } );\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnStateLoadCallback\": function ( settings ) {\n\t\ttry {\n\t\t\treturn JSON.parse(\n\t\t\t\t(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\n\t\t\t\t\t'DataTables_'+settings.sInstance+'_'+location.pathname\n\t\t\t\t)\n\t\t\t);\n\t\t} catch (e) {\n\t\t\treturn {};\n\t\t}\n\t},\n\n\n\t/**\n\t * Callback which allows modification of the saved state prior to loading that state.\n\t * This callback is called when the table is loading state from the stored data, but\n\t * prior to the settings object being modified by the saved state. Note that for\n\t * plug-in authors, you should use the `stateLoadParams` event to load parameters for\n\t * a plug-in.\n\t *  @type function\n\t *  @param {object} settings DataTables settings object\n\t *  @param {object} data The state object that is to be loaded\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.stateLoadParams\n\t *\n\t *  @example\n\t *    // Remove a saved filter, so filtering is never loaded\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true,\n\t *        \"stateLoadParams\": function (settings, data) {\n\t *          data.oSearch.sSearch = \"\";\n\t *        }\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Disallow state loading by returning false\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true,\n\t *        \"stateLoadParams\": function (settings, data) {\n\t *          return false;\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnStateLoadParams\": null,\n\n\n\t/**\n\t * Callback that is called when the state has been loaded from the state saving method\n\t * and the DataTables settings object has been modified as a result of the loaded state.\n\t *  @type function\n\t *  @param {object} settings DataTables settings object\n\t *  @param {object} data The state object that was loaded\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.stateLoaded\n\t *\n\t *  @example\n\t *    // Show an alert with the filtering value that was saved\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true,\n\t *        \"stateLoaded\": function (settings, data) {\n\t *          alert( 'Saved filter was: '+data.oSearch.sSearch );\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnStateLoaded\": null,\n\n\n\t/**\n\t * Save the table state. This function allows you to define where and how the state\n\t * information for the table is stored By default DataTables will use `localStorage`\n\t * but you might wish to use a server-side database or cookies.\n\t *  @type function\n\t *  @member\n\t *  @param {object} settings DataTables settings object\n\t *  @param {object} data The state object to be saved\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.stateSaveCallback\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true,\n\t *        \"stateSaveCallback\": function (settings, data) {\n\t *          // Send an Ajax request to the server with the state object\n\t *          $.ajax( {\n\t *            \"url\": \"/state_save\",\n\t *            \"data\": data,\n\t *            \"dataType\": \"json\",\n\t *            \"method\": \"POST\"\n\t *            \"success\": function () {}\n\t *          } );\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnStateSaveCallback\": function ( settings, data ) {\n\t\ttry {\n\t\t\t(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\n\t\t\t\t'DataTables_'+settings.sInstance+'_'+location.pathname,\n\t\t\t\tJSON.stringify( data )\n\t\t\t);\n\t\t} catch (e) {}\n\t},\n\n\n\t/**\n\t * Callback which allows modification of the state to be saved. Called when the table\n\t * has changed state a new state save is required. This method allows modification of\n\t * the state saving object prior to actually doing the save, including addition or\n\t * other state properties or modification. Note that for plug-in authors, you should\n\t * use the `stateSaveParams` event to save parameters for a plug-in.\n\t *  @type function\n\t *  @param {object} settings DataTables settings object\n\t *  @param {object} data The state object to be saved\n\t *\n\t *  @dtopt Callbacks\n\t *  @name DataTable.defaults.stateSaveParams\n\t *\n\t *  @example\n\t *    // Remove a saved filter, so filtering is never saved\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateSave\": true,\n\t *        \"stateSaveParams\": function (settings, data) {\n\t *          data.oSearch.sSearch = \"\";\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"fnStateSaveParams\": null,\n\n\n\t/**\n\t * Duration for which the saved state information is considered valid. After this period\n\t * has elapsed the state will be returned to the default.\n\t * Value is given in seconds.\n\t *  @type int\n\t *  @default 7200 <i>(2 hours)</i>\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.stateDuration\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"stateDuration\": 60*60*24; // 1 day\n\t *      } );\n\t *    } )\n\t */\n\t\"iStateDuration\": 7200,\n\n\n\t/**\n\t * When enabled DataTables will not make a request to the server for the first\n\t * page draw - rather it will use the data already on the page (no sorting etc\n\t * will be applied to it), thus saving on an XHR at load time. `deferLoading`\n\t * is used to indicate that deferred loading is required, but it is also used\n\t * to tell DataTables how many records there are in the full table (allowing\n\t * the information element and pagination to be displayed correctly). In the case\n\t * where a filtering is applied to the table on initial load, this can be\n\t * indicated by giving the parameter as an array, where the first element is\n\t * the number of records available after filtering and the second element is the\n\t * number of records without filtering (allowing the table information element\n\t * to be shown correctly).\n\t *  @type int | array\n\t *  @default null\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.deferLoading\n\t *\n\t *  @example\n\t *    // 57 records available in the table, no filtering applied\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"serverSide\": true,\n\t *        \"ajax\": \"scripts/server_processing.php\",\n\t *        \"deferLoading\": 57\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // 57 records after filtering, 100 without filtering (an initial filter applied)\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"serverSide\": true,\n\t *        \"ajax\": \"scripts/server_processing.php\",\n\t *        \"deferLoading\": [ 57, 100 ],\n\t *        \"search\": {\n\t *          \"search\": \"my_filter\"\n\t *        }\n\t *      } );\n\t *    } );\n\t */\n\t\"iDeferLoading\": null,\n\n\n\t/**\n\t * Number of rows to display on a single page when using pagination. If\n\t * feature enabled (`lengthChange`) then the end user will be able to override\n\t * this to a custom setting using a pop-up menu.\n\t *  @type int\n\t *  @default 10\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.pageLength\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"pageLength\": 50\n\t *      } );\n\t *    } )\n\t */\n\t\"iDisplayLength\": 10,\n\n\n\t/**\n\t * Define the starting point for data display when using DataTables with\n\t * pagination. Note that this parameter is the number of records, rather than\n\t * the page number, so if you have 10 records per page and want to start on\n\t * the third page, it should be \"20\".\n\t *  @type int\n\t *  @default 0\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.displayStart\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"displayStart\": 20\n\t *      } );\n\t *    } )\n\t */\n\t\"iDisplayStart\": 0,\n\n\n\t/**\n\t * By default DataTables allows keyboard navigation of the table (sorting, paging,\n\t * and filtering) by adding a `tabindex` attribute to the required elements. This\n\t * allows you to tab through the controls and press the enter key to activate them.\n\t * The tabindex is default 0, meaning that the tab follows the flow of the document.\n\t * You can overrule this using this parameter if you wish. Use a value of -1 to\n\t * disable built-in keyboard navigation.\n\t *  @type int\n\t *  @default 0\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.tabIndex\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"tabIndex\": 1\n\t *      } );\n\t *    } );\n\t */\n\t\"iTabIndex\": 0,\n\n\n\t/**\n\t * Classes that DataTables assigns to the various components and features\n\t * that it adds to the HTML table. This allows classes to be configured\n\t * during initialisation in addition to through the static\n\t * {@link DataTable.ext.oStdClasses} object).\n\t *  @namespace\n\t *  @name DataTable.defaults.classes\n\t */\n\t\"oClasses\": {},\n\n\n\t/**\n\t * All strings that DataTables uses in the user interface that it creates\n\t * are defined in this object, allowing you to modified them individually or\n\t * completely replace them all as required.\n\t *  @namespace\n\t *  @name DataTable.defaults.language\n\t */\n\t\"oLanguage\": {\n\t\t/**\n\t\t * Strings that are used for WAI-ARIA labels and controls only (these are not\n\t\t * actually visible on the page, but will be read by screenreaders, and thus\n\t\t * must be internationalised as well).\n\t\t *  @namespace\n\t\t *  @name DataTable.defaults.language.aria\n\t\t */\n\t\t\"oAria\": {\n\t\t\t/**\n\t\t\t * ARIA label that is added to the table headers when the column may be\n\t\t\t * sorted ascending by activing the column (click or return when focused).\n\t\t\t * Note that the column header is prefixed to this string.\n\t\t\t *  @type string\n\t\t\t *  @default : activate to sort column ascending\n\t\t\t *\n\t\t\t *  @dtopt Language\n\t\t\t *  @name DataTable.defaults.language.aria.sortAscending\n\t\t\t *\n\t\t\t *  @example\n\t\t\t *    $(document).ready( function() {\n\t\t\t *      $('#example').dataTable( {\n\t\t\t *        \"language\": {\n\t\t\t *          \"aria\": {\n\t\t\t *            \"sortAscending\": \" - click/return to sort ascending\"\n\t\t\t *          }\n\t\t\t *        }\n\t\t\t *      } );\n\t\t\t *    } );\n\t\t\t */\n\t\t\t\"sSortAscending\": \": activate to sort column ascending\",\n\n\t\t\t/**\n\t\t\t * ARIA label that is added to the table headers when the column may be\n\t\t\t * sorted descending by activing the column (click or return when focused).\n\t\t\t * Note that the column header is prefixed to this string.\n\t\t\t *  @type string\n\t\t\t *  @default : activate to sort column ascending\n\t\t\t *\n\t\t\t *  @dtopt Language\n\t\t\t *  @name DataTable.defaults.language.aria.sortDescending\n\t\t\t *\n\t\t\t *  @example\n\t\t\t *    $(document).ready( function() {\n\t\t\t *      $('#example').dataTable( {\n\t\t\t *        \"language\": {\n\t\t\t *          \"aria\": {\n\t\t\t *            \"sortDescending\": \" - click/return to sort descending\"\n\t\t\t *          }\n\t\t\t *        }\n\t\t\t *      } );\n\t\t\t *    } );\n\t\t\t */\n\t\t\t\"sSortDescending\": \": activate to sort column descending\"\n\t\t},\n\n\t\t/**\n\t\t * Pagination string used by DataTables for the built-in pagination\n\t\t * control types.\n\t\t *  @namespace\n\t\t *  @name DataTable.defaults.language.paginate\n\t\t */\n\t\t\"oPaginate\": {\n\t\t\t/**\n\t\t\t * Text to use when using the 'full_numbers' type of pagination for the\n\t\t\t * button to take the user to the first page.\n\t\t\t *  @type string\n\t\t\t *  @default First\n\t\t\t *\n\t\t\t *  @dtopt Language\n\t\t\t *  @name DataTable.defaults.language.paginate.first\n\t\t\t *\n\t\t\t *  @example\n\t\t\t *    $(document).ready( function() {\n\t\t\t *      $('#example').dataTable( {\n\t\t\t *        \"language\": {\n\t\t\t *          \"paginate\": {\n\t\t\t *            \"first\": \"First page\"\n\t\t\t *          }\n\t\t\t *        }\n\t\t\t *      } );\n\t\t\t *    } );\n\t\t\t */\n\t\t\t\"sFirst\": \"First\",\n\n\n\t\t\t/**\n\t\t\t * Text to use when using the 'full_numbers' type of pagination for the\n\t\t\t * button to take the user to the last page.\n\t\t\t *  @type string\n\t\t\t *  @default Last\n\t\t\t *\n\t\t\t *  @dtopt Language\n\t\t\t *  @name DataTable.defaults.language.paginate.last\n\t\t\t *\n\t\t\t *  @example\n\t\t\t *    $(document).ready( function() {\n\t\t\t *      $('#example').dataTable( {\n\t\t\t *        \"language\": {\n\t\t\t *          \"paginate\": {\n\t\t\t *            \"last\": \"Last page\"\n\t\t\t *          }\n\t\t\t *        }\n\t\t\t *      } );\n\t\t\t *    } );\n\t\t\t */\n\t\t\t\"sLast\": \"Last\",\n\n\n\t\t\t/**\n\t\t\t * Text to use for the 'next' pagination button (to take the user to the\n\t\t\t * next page).\n\t\t\t *  @type string\n\t\t\t *  @default Next\n\t\t\t *\n\t\t\t *  @dtopt Language\n\t\t\t *  @name DataTable.defaults.language.paginate.next\n\t\t\t *\n\t\t\t *  @example\n\t\t\t *    $(document).ready( function() {\n\t\t\t *      $('#example').dataTable( {\n\t\t\t *        \"language\": {\n\t\t\t *          \"paginate\": {\n\t\t\t *            \"next\": \"Next page\"\n\t\t\t *          }\n\t\t\t *        }\n\t\t\t *      } );\n\t\t\t *    } );\n\t\t\t */\n\t\t\t\"sNext\": \"Next\",\n\n\n\t\t\t/**\n\t\t\t * Text to use for the 'previous' pagination button (to take the user to\n\t\t\t * the previous page).\n\t\t\t *  @type string\n\t\t\t *  @default Previous\n\t\t\t *\n\t\t\t *  @dtopt Language\n\t\t\t *  @name DataTable.defaults.language.paginate.previous\n\t\t\t *\n\t\t\t *  @example\n\t\t\t *    $(document).ready( function() {\n\t\t\t *      $('#example').dataTable( {\n\t\t\t *        \"language\": {\n\t\t\t *          \"paginate\": {\n\t\t\t *            \"previous\": \"Previous page\"\n\t\t\t *          }\n\t\t\t *        }\n\t\t\t *      } );\n\t\t\t *    } );\n\t\t\t */\n\t\t\t\"sPrevious\": \"Previous\"\n\t\t},\n\n\t\t/**\n\t\t * This string is shown in preference to `zeroRecords` when the table is\n\t\t * empty of data (regardless of filtering). Note that this is an optional\n\t\t * parameter - if it is not given, the value of `zeroRecords` will be used\n\t\t * instead (either the default or given value).\n\t\t *  @type string\n\t\t *  @default No data available in table\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.emptyTable\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"emptyTable\": \"No data available in table\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sEmptyTable\": \"No data available in table\",\n\n\n\t\t/**\n\t\t * This string gives information to the end user about the information\n\t\t * that is current on display on the page. The following tokens can be\n\t\t * used in the string and will be dynamically replaced as the table\n\t\t * display updates. This tokens can be placed anywhere in the string, or\n\t\t * removed as needed by the language requires:\n\t\t *\n\t\t * * `\\_START\\_` - Display index of the first record on the current page\n\t\t * * `\\_END\\_` - Display index of the last record on the current page\n\t\t * * `\\_TOTAL\\_` - Number of records in the table after filtering\n\t\t * * `\\_MAX\\_` - Number of records in the table without filtering\n\t\t * * `\\_PAGE\\_` - Current page number\n\t\t * * `\\_PAGES\\_` - Total number of pages of data in the table\n\t\t *\n\t\t *  @type string\n\t\t *  @default Showing _START_ to _END_ of _TOTAL_ entries\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.info\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sInfo\": \"Showing _START_ to _END_ of _TOTAL_ entries\",\n\n\n\t\t/**\n\t\t * Display information string for when the table is empty. Typically the\n\t\t * format of this string should match `info`.\n\t\t *  @type string\n\t\t *  @default Showing 0 to 0 of 0 entries\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.infoEmpty\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"infoEmpty\": \"No entries to show\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sInfoEmpty\": \"Showing 0 to 0 of 0 entries\",\n\n\n\t\t/**\n\t\t * When a user filters the information in a table, this string is appended\n\t\t * to the information (`info`) to give an idea of how strong the filtering\n\t\t * is. The variable _MAX_ is dynamically updated.\n\t\t *  @type string\n\t\t *  @default (filtered from _MAX_ total entries)\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.infoFiltered\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"infoFiltered\": \" - filtering from _MAX_ records\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sInfoFiltered\": \"(filtered from _MAX_ total entries)\",\n\n\n\t\t/**\n\t\t * If can be useful to append extra information to the info string at times,\n\t\t * and this variable does exactly that. This information will be appended to\n\t\t * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\n\t\t * being used) at all times.\n\t\t *  @type string\n\t\t *  @default <i>Empty string</i>\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.infoPostFix\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"infoPostFix\": \"All records shown are derived from real information.\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sInfoPostFix\": \"\",\n\n\n\t\t/**\n\t\t * This decimal place operator is a little different from the other\n\t\t * language options since DataTables doesn't output floating point\n\t\t * numbers, so it won't ever use this for display of a number. Rather,\n\t\t * what this parameter does is modify the sort methods of the table so\n\t\t * that numbers which are in a format which has a character other than\n\t\t * a period (`.`) as a decimal place will be sorted numerically.\n\t\t *\n\t\t * Note that numbers with different decimal places cannot be shown in\n\t\t * the same table and still be sortable, the table must be consistent.\n\t\t * However, multiple different tables on the page can use different\n\t\t * decimal place characters.\n\t\t *  @type string\n\t\t *  @default \n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.decimal\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"decimal\": \",\"\n\t\t *          \"thousands\": \".\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sDecimal\": \"\",\n\n\n\t\t/**\n\t\t * DataTables has a build in number formatter (`formatNumber`) which is\n\t\t * used to format large numbers that are used in the table information.\n\t\t * By default a comma is used, but this can be trivially changed to any\n\t\t * character you wish with this parameter.\n\t\t *  @type string\n\t\t *  @default ,\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.thousands\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"thousands\": \"'\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sThousands\": \",\",\n\n\n\t\t/**\n\t\t * Detail the action that will be taken when the drop down menu for the\n\t\t * pagination length option is changed. The '_MENU_' variable is replaced\n\t\t * with a default select list of 10, 25, 50 and 100, and can be replaced\n\t\t * with a custom select box if required.\n\t\t *  @type string\n\t\t *  @default Show _MENU_ entries\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.lengthMenu\n\t\t *\n\t\t *  @example\n\t\t *    // Language change only\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"lengthMenu\": \"Display _MENU_ records\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t *\n\t\t *  @example\n\t\t *    // Language and options change\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"lengthMenu\": 'Display <select>'+\n\t\t *            '<option value=\"10\">10</option>'+\n\t\t *            '<option value=\"20\">20</option>'+\n\t\t *            '<option value=\"30\">30</option>'+\n\t\t *            '<option value=\"40\">40</option>'+\n\t\t *            '<option value=\"50\">50</option>'+\n\t\t *            '<option value=\"-1\">All</option>'+\n\t\t *            '</select> records'\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sLengthMenu\": \"Show _MENU_ entries\",\n\n\n\t\t/**\n\t\t * When using Ajax sourced data and during the first draw when DataTables is\n\t\t * gathering the data, this message is shown in an empty row in the table to\n\t\t * indicate to the end user the the data is being loaded. Note that this\n\t\t * parameter is not used when loading data by server-side processing, just\n\t\t * Ajax sourced data with client-side processing.\n\t\t *  @type string\n\t\t *  @default Loading...\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.loadingRecords\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"loadingRecords\": \"Please wait - loading...\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sLoadingRecords\": \"Loading...\",\n\n\n\t\t/**\n\t\t * Text which is displayed when the table is processing a user action\n\t\t * (usually a sort command or similar).\n\t\t *  @type string\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.processing\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"processing\": \"DataTables is currently busy\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sProcessing\": \"\",\n\n\n\t\t/**\n\t\t * Details the actions that will be taken when the user types into the\n\t\t * filtering input text box. The variable \"_INPUT_\", if used in the string,\n\t\t * is replaced with the HTML text box for the filtering input allowing\n\t\t * control over where it appears in the string. If \"_INPUT_\" is not given\n\t\t * then the input box is appended to the string automatically.\n\t\t *  @type string\n\t\t *  @default Search:\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.search\n\t\t *\n\t\t *  @example\n\t\t *    // Input text box will be appended at the end automatically\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"search\": \"Filter records:\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t *\n\t\t *  @example\n\t\t *    // Specify where the filter should appear\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"search\": \"Apply filter _INPUT_ to table\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sSearch\": \"Search:\",\n\n\n\t\t/**\n\t\t * Assign a `placeholder` attribute to the search `input` element\n\t\t *  @type string\n\t\t *  @default \n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.searchPlaceholder\n\t\t */\n\t\t\"sSearchPlaceholder\": \"\",\n\n\n\t\t/**\n\t\t * All of the language information can be stored in a file on the\n\t\t * server-side, which DataTables will look up if this parameter is passed.\n\t\t * It must store the URL of the language file, which is in a JSON format,\n\t\t * and the object has the same properties as the oLanguage object in the\n\t\t * initialiser object (i.e. the above parameters). Please refer to one of\n\t\t * the example language files to see how this works in action.\n\t\t *  @type string\n\t\t *  @default <i>Empty string - i.e. disabled</i>\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.url\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sUrl\": \"\",\n\n\n\t\t/**\n\t\t * Text shown inside the table records when the is no information to be\n\t\t * displayed after filtering. `emptyTable` is shown when there is simply no\n\t\t * information in the table at all (regardless of filtering).\n\t\t *  @type string\n\t\t *  @default No matching records found\n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.zeroRecords\n\t\t *\n\t\t *  @example\n\t\t *    $(document).ready( function() {\n\t\t *      $('#example').dataTable( {\n\t\t *        \"language\": {\n\t\t *          \"zeroRecords\": \"No records to display\"\n\t\t *        }\n\t\t *      } );\n\t\t *    } );\n\t\t */\n\t\t\"sZeroRecords\": \"No matching records found\"\n\t},\n\n\n\t/**\n\t * This parameter allows you to have define the global filtering state at\n\t * initialisation time. As an object the `search` parameter must be\n\t * defined, but all other parameters are optional. When `regex` is true,\n\t * the search string will be treated as a regular expression, when false\n\t * (default) it will be treated as a straight string. When `smart`\n\t * DataTables will use it's smart filtering methods (to word match at\n\t * any point in the data), when false this will not be done.\n\t *  @namespace\n\t *  @extends DataTable.models.oSearch\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.search\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"search\": {\"search\": \"Initial search\"}\n\t *      } );\n\t *    } )\n\t */\n\t\"oSearch\": $.extend( {}, DataTable.models.oSearch ),\n\n\n\t/**\n\t * __Deprecated__ The functionality provided by this parameter has now been\n\t * superseded by that provided through `ajax`, which should be used instead.\n\t *\n\t * By default DataTables will look for the property `data` (or `aaData` for\n\t * compatibility with DataTables 1.9-) when obtaining data from an Ajax\n\t * source or for server-side processing - this parameter allows that\n\t * property to be changed. You can use Javascript dotted object notation to\n\t * get a data source for multiple levels of nesting.\n\t *  @type string\n\t *  @default data\n\t *\n\t *  @dtopt Options\n\t *  @dtopt Server-side\n\t *  @name DataTable.defaults.ajaxDataProp\n\t *\n\t *  @deprecated 1.10. Please use `ajax` for this functionality now.\n\t */\n\t\"sAjaxDataProp\": \"data\",\n\n\n\t/**\n\t * __Deprecated__ The functionality provided by this parameter has now been\n\t * superseded by that provided through `ajax`, which should be used instead.\n\t *\n\t * You can instruct DataTables to load data from an external\n\t * source using this parameter (use aData if you want to pass data in you\n\t * already have). Simply provide a url a JSON object can be obtained from.\n\t *  @type string\n\t *  @default null\n\t *\n\t *  @dtopt Options\n\t *  @dtopt Server-side\n\t *  @name DataTable.defaults.ajaxSource\n\t *\n\t *  @deprecated 1.10. Please use `ajax` for this functionality now.\n\t */\n\t\"sAjaxSource\": null,\n\n\n\t/**\n\t * This initialisation variable allows you to specify exactly where in the\n\t * DOM you want DataTables to inject the various controls it adds to the page\n\t * (for example you might want the pagination controls at the top of the\n\t * table). DIV elements (with or without a custom class) can also be added to\n\t * aid styling. The follow syntax is used:\n\t *   <ul>\n\t *     <li>The following options are allowed:\n\t *       <ul>\n\t *         <li>'l' - Length changing</li>\n\t *         <li>'f' - Filtering input</li>\n\t *         <li>'t' - The table!</li>\n\t *         <li>'i' - Information</li>\n\t *         <li>'p' - Pagination</li>\n\t *         <li>'r' - pRocessing</li>\n\t *       </ul>\n\t *     </li>\n\t *     <li>The following constants are allowed:\n\t *       <ul>\n\t *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\n\t *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\n\t *       </ul>\n\t *     </li>\n\t *     <li>The following syntax is expected:\n\t *       <ul>\n\t *         <li>'&lt;' and '&gt;' - div elements</li>\n\t *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\n\t *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\n\t *       </ul>\n\t *     </li>\n\t *     <li>Examples:\n\t *       <ul>\n\t *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\n\t *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\n\t *       </ul>\n\t *     </li>\n\t *   </ul>\n\t *  @type string\n\t *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\n\t *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.dom\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\n\t *      } );\n\t *    } );\n\t */\n\t\"sDom\": \"lfrtip\",\n\n\n\t/**\n\t * Search delay option. This will throttle full table searches that use the\n\t * DataTables provided search input element (it does not effect calls to\n\t * `dt-api search()`, providing a delay before the search is made.\n\t *  @type integer\n\t *  @default 0\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.searchDelay\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"searchDelay\": 200\n\t *      } );\n\t *    } )\n\t */\n\t\"searchDelay\": null,\n\n\n\t/**\n\t * DataTables features six different built-in options for the buttons to\n\t * display for pagination control:\n\t *\n\t * * `numbers` - Page number buttons only\n\t * * `simple` - 'Previous' and 'Next' buttons only\n\t * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\n\t * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\n\t * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers\n\t * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers\n\t *  \n\t * Further methods can be added using {@link DataTable.ext.oPagination}.\n\t *  @type string\n\t *  @default simple_numbers\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.pagingType\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"pagingType\": \"full_numbers\"\n\t *      } );\n\t *    } )\n\t */\n\t\"sPaginationType\": \"simple_numbers\",\n\n\n\t/**\n\t * Enable horizontal scrolling. When a table is too wide to fit into a\n\t * certain layout, or you have a large number of columns in the table, you\n\t * can enable x-scrolling to show the table in a viewport, which can be\n\t * scrolled. This property can be `true` which will allow the table to\n\t * scroll horizontally when needed, or any CSS unit, or a number (in which\n\t * case it will be treated as a pixel measurement). Setting as simply `true`\n\t * is recommended.\n\t *  @type boolean|string\n\t *  @default <i>blank string - i.e. disabled</i>\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.scrollX\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"scrollX\": true,\n\t *        \"scrollCollapse\": true\n\t *      } );\n\t *    } );\n\t */\n\t\"sScrollX\": \"\",\n\n\n\t/**\n\t * This property can be used to force a DataTable to use more width than it\n\t * might otherwise do when x-scrolling is enabled. For example if you have a\n\t * table which requires to be well spaced, this parameter is useful for\n\t * \"over-sizing\" the table, and thus forcing scrolling. This property can by\n\t * any CSS unit, or a number (in which case it will be treated as a pixel\n\t * measurement).\n\t *  @type string\n\t *  @default <i>blank string - i.e. disabled</i>\n\t *\n\t *  @dtopt Options\n\t *  @name DataTable.defaults.scrollXInner\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"scrollX\": \"100%\",\n\t *        \"scrollXInner\": \"110%\"\n\t *      } );\n\t *    } );\n\t */\n\t\"sScrollXInner\": \"\",\n\n\n\t/**\n\t * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\n\t * to the given height, and enable scrolling for any data which overflows the\n\t * current viewport. This can be used as an alternative to paging to display\n\t * a lot of data in a small area (although paging and scrolling can both be\n\t * enabled at the same time). This property can be any CSS unit, or a number\n\t * (in which case it will be treated as a pixel measurement).\n\t *  @type string\n\t *  @default <i>blank string - i.e. disabled</i>\n\t *\n\t *  @dtopt Features\n\t *  @name DataTable.defaults.scrollY\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"scrollY\": \"200px\",\n\t *        \"paginate\": false\n\t *      } );\n\t *    } );\n\t */\n\t\"sScrollY\": \"\",\n\n\n\t/**\n\t * __Deprecated__ The functionality provided by this parameter has now been\n\t * superseded by that provided through `ajax`, which should be used instead.\n\t *\n\t * Set the HTTP method that is used to make the Ajax call for server-side\n\t * processing or Ajax sourced data.\n\t *  @type string\n\t *  @default GET\n\t *\n\t *  @dtopt Options\n\t *  @dtopt Server-side\n\t *  @name DataTable.defaults.serverMethod\n\t *\n\t *  @deprecated 1.10. Please use `ajax` for this functionality now.\n\t */\n\t\"sServerMethod\": \"GET\",\n\n\n\t/**\n\t * DataTables makes use of renderers when displaying HTML elements for\n\t * a table. These renderers can be added or modified by plug-ins to\n\t * generate suitable mark-up for a site. For example the Bootstrap\n\t * integration plug-in for DataTables uses a paging button renderer to\n\t * display pagination buttons in the mark-up required by Bootstrap.\n\t *\n\t * For further information about the renderers available see\n\t * DataTable.ext.renderer\n\t *  @type string|object\n\t *  @default null\n\t *\n\t *  @name DataTable.defaults.renderer\n\t *\n\t */\n\t\"renderer\": null,\n\n\n\t/**\n\t * Set the data property name that DataTables should use to get a row's id\n\t * to set as the `id` property in the node.\n\t *  @type string\n\t *  @default DT_RowId\n\t *\n\t *  @name DataTable.defaults.rowId\n\t */\n\t\"rowId\": \"DT_RowId\"\n};\n\n_fnHungarianMap( DataTable.defaults );\n\n\n\n/*\n * Developer note - See note in model.defaults.js about the use of Hungarian\n * notation and camel case.\n */\n\n/**\n * Column options that can be given to DataTables at initialisation time.\n *  @namespace\n */\nDataTable.defaults.column = {\n\t/**\n\t * Define which column(s) an order will occur on for this column. This\n\t * allows a column's ordering to take multiple columns into account when\n\t * doing a sort or use the data from a different column. For example first\n\t * name / last name columns make sense to do a multi-column sort over the\n\t * two columns.\n\t *  @type array|int\n\t *  @default null <i>Takes the value of the column index automatically</i>\n\t *\n\t *  @name DataTable.defaults.column.orderData\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\n\t *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\n\t *          { \"orderData\": 2, \"targets\": [ 2 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"orderData\": [ 0, 1 ] },\n\t *          { \"orderData\": [ 1, 0 ] },\n\t *          { \"orderData\": 2 },\n\t *          null,\n\t *          null\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"aDataSort\": null,\n\t\"iDataSort\": -1,\n\n\n\t/**\n\t * You can control the default ordering direction, and even alter the\n\t * behaviour of the sort handler (i.e. only allow ascending ordering etc)\n\t * using this parameter.\n\t *  @type array\n\t *  @default [ 'asc', 'desc' ]\n\t *\n\t *  @name DataTable.defaults.column.orderSequence\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\n\t *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\n\t *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          null,\n\t *          { \"orderSequence\": [ \"asc\" ] },\n\t *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\n\t *          { \"orderSequence\": [ \"desc\" ] },\n\t *          null\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"asSorting\": [ 'asc', 'desc' ],\n\n\n\t/**\n\t * Enable or disable filtering on the data in this column.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @name DataTable.defaults.column.searchable\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"searchable\": false, \"targets\": [ 0 ] }\n\t *        ] } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"searchable\": false },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ] } );\n\t *    } );\n\t */\n\t\"bSearchable\": true,\n\n\n\t/**\n\t * Enable or disable ordering on this column.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @name DataTable.defaults.column.orderable\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"orderable\": false, \"targets\": [ 0 ] }\n\t *        ] } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"orderable\": false },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ] } );\n\t *    } );\n\t */\n\t\"bSortable\": true,\n\n\n\t/**\n\t * Enable or disable the display of this column.\n\t *  @type boolean\n\t *  @default true\n\t *\n\t *  @name DataTable.defaults.column.visible\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"visible\": false, \"targets\": [ 0 ] }\n\t *        ] } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"visible\": false },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ] } );\n\t *    } );\n\t */\n\t\"bVisible\": true,\n\n\n\t/**\n\t * Developer definable function that is called whenever a cell is created (Ajax source,\n\t * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n\t * allowing you to modify the DOM element (add background colour for example) when the\n\t * element is available.\n\t *  @type function\n\t *  @param {element} td The TD node that has been created\n\t *  @param {*} cellData The Data for the cell\n\t *  @param {array|object} rowData The data for the whole row\n\t *  @param {int} row The row index for the aoData data store\n\t *  @param {int} col The column index for aoColumns\n\t *\n\t *  @name DataTable.defaults.column.createdCell\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [3],\n\t *          \"createdCell\": function (td, cellData, rowData, row, col) {\n\t *            if ( cellData == \"1.7\" ) {\n\t *              $(td).css('color', 'blue')\n\t *            }\n\t *          }\n\t *        } ]\n\t *      });\n\t *    } );\n\t */\n\t\"fnCreatedCell\": null,\n\n\n\t/**\n\t * This parameter has been replaced by `data` in DataTables to ensure naming\n\t * consistency. `dataProp` can still be used, as there is backwards\n\t * compatibility in DataTables for this option, but it is strongly\n\t * recommended that you use `data` in preference to `dataProp`.\n\t *  @name DataTable.defaults.column.dataProp\n\t */\n\n\n\t/**\n\t * This property can be used to read data from any data source property,\n\t * including deeply nested objects / properties. `data` can be given in a\n\t * number of different ways which effect its behaviour:\n\t *\n\t * * `integer` - treated as an array index for the data source. This is the\n\t *   default that DataTables uses (incrementally increased for each column).\n\t * * `string` - read an object property from the data source. There are\n\t *   three 'special' options that can be used in the string to alter how\n\t *   DataTables reads the data from the source object:\n\t *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n\t *      Javascript to read from nested objects, so to can the options\n\t *      specified in `data`. For example: `browser.version` or\n\t *      `browser.name`. If your object parameter name contains a period, use\n\t *      `\\\\` to escape it - i.e. `first\\\\.name`.\n\t *    * `[]` - Array notation. DataTables can automatically combine data\n\t *      from and array source, joining the data with the characters provided\n\t *      between the two brackets. For example: `name[, ]` would provide a\n\t *      comma-space separated list from the source array. If no characters\n\t *      are provided between the brackets, the original array source is\n\t *      returned.\n\t *    * `()` - Function notation. Adding `()` to the end of a parameter will\n\t *      execute a function of the name given. For example: `browser()` for a\n\t *      simple function on the data source, `browser.version()` for a\n\t *      function in a nested property or even `browser().version` to get an\n\t *      object property if the function called returns an object. Note that\n\t *      function notation is recommended for use in `render` rather than\n\t *      `data` as it is much simpler to use as a renderer.\n\t * * `null` - use the original data source for the row rather than plucking\n\t *   data directly from it. This action has effects on two other\n\t *   initialisation options:\n\t *    * `defaultContent` - When null is given as the `data` option and\n\t *      `defaultContent` is specified for the column, the value defined by\n\t *      `defaultContent` will be used for the cell.\n\t *    * `render` - When null is used for the `data` option and the `render`\n\t *      option is specified for the column, the whole data source for the\n\t *      row is used for the renderer.\n\t * * `function` - the function given will be executed whenever DataTables\n\t *   needs to set or get the data for a cell in the column. The function\n\t *   takes three parameters:\n\t *    * Parameters:\n\t *      * `{array|object}` The data source for the row\n\t *      * `{string}` The type call data requested - this will be 'set' when\n\t *        setting data or 'filter', 'display', 'type', 'sort' or undefined\n\t *        when gathering data. Note that when `undefined` is given for the\n\t *        type DataTables expects to get the raw data for the object back<\n\t *      * `{*}` Data to set when the second parameter is 'set'.\n\t *    * Return:\n\t *      * The return value from the function is not required when 'set' is\n\t *        the type of call, but otherwise the return is what will be used\n\t *        for the data requested.\n\t *\n\t * Note that `data` is a getter and setter option. If you just require\n\t * formatting of data for output, you will likely want to use `render` which\n\t * is simply a getter and thus simpler to use.\n\t *\n\t * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\n\t * name change reflects the flexibility of this property and is consistent\n\t * with the naming of mRender. If 'mDataProp' is given, then it will still\n\t * be used by DataTables, as it automatically maps the old name to the new\n\t * if required.\n\t *\n\t *  @type string|int|function|null\n\t *  @default null <i>Use automatically calculated column index</i>\n\t *\n\t *  @name DataTable.defaults.column.data\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Read table data from objects\n\t *    // JSON structure for each row:\n\t *    //   {\n\t *    //      \"engine\": {value},\n\t *    //      \"browser\": {value},\n\t *    //      \"platform\": {value},\n\t *    //      \"version\": {value},\n\t *    //      \"grade\": {value}\n\t *    //   }\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"ajaxSource\": \"sources/objects.txt\",\n\t *        \"columns\": [\n\t *          { \"data\": \"engine\" },\n\t *          { \"data\": \"browser\" },\n\t *          { \"data\": \"platform\" },\n\t *          { \"data\": \"version\" },\n\t *          { \"data\": \"grade\" }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Read information from deeply nested objects\n\t *    // JSON structure for each row:\n\t *    //   {\n\t *    //      \"engine\": {value},\n\t *    //      \"browser\": {value},\n\t *    //      \"platform\": {\n\t *    //         \"inner\": {value}\n\t *    //      },\n\t *    //      \"details\": [\n\t *    //         {value}, {value}\n\t *    //      ]\n\t *    //   }\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"ajaxSource\": \"sources/deep.txt\",\n\t *        \"columns\": [\n\t *          { \"data\": \"engine\" },\n\t *          { \"data\": \"browser\" },\n\t *          { \"data\": \"platform.inner\" },\n\t *          { \"data\": \"details.0\" },\n\t *          { \"data\": \"details.1\" }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `data` as a function to provide different information for\n\t *    // sorting, filtering and display. In this case, currency (price)\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"data\": function ( source, type, val ) {\n\t *            if (type === 'set') {\n\t *              source.price = val;\n\t *              // Store the computed display and filter values for efficiency\n\t *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\n\t *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\n\t *              return;\n\t *            }\n\t *            else if (type === 'display') {\n\t *              return source.price_display;\n\t *            }\n\t *            else if (type === 'filter') {\n\t *              return source.price_filter;\n\t *            }\n\t *            // 'sort', 'type' and undefined all just use the integer\n\t *            return source.price;\n\t *          }\n\t *        } ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using default content\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"data\": null,\n\t *          \"defaultContent\": \"Click to edit\"\n\t *        } ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using array notation - outputting a list from an array\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"data\": \"name[, ]\"\n\t *        } ]\n\t *      } );\n\t *    } );\n\t *\n\t */\n\t\"mData\": null,\n\n\n\t/**\n\t * This property is the rendering partner to `data` and it is suggested that\n\t * when you want to manipulate data for display (including filtering,\n\t * sorting etc) without altering the underlying data for the table, use this\n\t * property. `render` can be considered to be the the read only companion to\n\t * `data` which is read / write (then as such more complex). Like `data`\n\t * this option can be given in a number of different ways to effect its\n\t * behaviour:\n\t *\n\t * * `integer` - treated as an array index for the data source. This is the\n\t *   default that DataTables uses (incrementally increased for each column).\n\t * * `string` - read an object property from the data source. There are\n\t *   three 'special' options that can be used in the string to alter how\n\t *   DataTables reads the data from the source object:\n\t *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n\t *      Javascript to read from nested objects, so to can the options\n\t *      specified in `data`. For example: `browser.version` or\n\t *      `browser.name`. If your object parameter name contains a period, use\n\t *      `\\\\` to escape it - i.e. `first\\\\.name`.\n\t *    * `[]` - Array notation. DataTables can automatically combine data\n\t *      from and array source, joining the data with the characters provided\n\t *      between the two brackets. For example: `name[, ]` would provide a\n\t *      comma-space separated list from the source array. If no characters\n\t *      are provided between the brackets, the original array source is\n\t *      returned.\n\t *    * `()` - Function notation. Adding `()` to the end of a parameter will\n\t *      execute a function of the name given. For example: `browser()` for a\n\t *      simple function on the data source, `browser.version()` for a\n\t *      function in a nested property or even `browser().version` to get an\n\t *      object property if the function called returns an object.\n\t * * `object` - use different data for the different data types requested by\n\t *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\n\t *   of the object is the data type the property refers to and the value can\n\t *   defined using an integer, string or function using the same rules as\n\t *   `render` normally does. Note that an `_` option _must_ be specified.\n\t *   This is the default value to use if you haven't specified a value for\n\t *   the data type requested by DataTables.\n\t * * `function` - the function given will be executed whenever DataTables\n\t *   needs to set or get the data for a cell in the column. The function\n\t *   takes three parameters:\n\t *    * Parameters:\n\t *      * {array|object} The data source for the row (based on `data`)\n\t *      * {string} The type call data requested - this will be 'filter',\n\t *        'display', 'type' or 'sort'.\n\t *      * {array|object} The full data source for the row (not based on\n\t *        `data`)\n\t *    * Return:\n\t *      * The return value from the function is what will be used for the\n\t *        data requested.\n\t *\n\t *  @type string|int|function|object|null\n\t *  @default null Use the data source value.\n\t *\n\t *  @name DataTable.defaults.column.render\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Create a comma separated list from an array of objects\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"ajaxSource\": \"sources/deep.txt\",\n\t *        \"columns\": [\n\t *          { \"data\": \"engine\" },\n\t *          { \"data\": \"browser\" },\n\t *          {\n\t *            \"data\": \"platform\",\n\t *            \"render\": \"[, ].name\"\n\t *          }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Execute a function to obtain data\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"data\": null, // Use the full data source object for the renderer's source\n\t *          \"render\": \"browserName()\"\n\t *        } ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // As an object, extracting different data for the different types\n\t *    // This would be used with a data source such as:\n\t *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\n\t *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\n\t *    // (which has both forms) is used for filtering for if a user inputs either format, while\n\t *    // the formatted phone number is the one that is shown in the table.\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"data\": null, // Use the full data source object for the renderer's source\n\t *          \"render\": {\n\t *            \"_\": \"phone\",\n\t *            \"filter\": \"phone_filter\",\n\t *            \"display\": \"phone_display\"\n\t *          }\n\t *        } ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Use as a function to create a link from the data source\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"data\": \"download_link\",\n\t *          \"render\": function ( data, type, full ) {\n\t *            return '<a href=\"'+data+'\">Download</a>';\n\t *          }\n\t *        } ]\n\t *      } );\n\t *    } );\n\t */\n\t\"mRender\": null,\n\n\n\t/**\n\t * Change the cell type created for the column - either TD cells or TH cells. This\n\t * can be useful as TH cells have semantic meaning in the table body, allowing them\n\t * to act as a header for a row (you may wish to add scope='row' to the TH elements).\n\t *  @type string\n\t *  @default td\n\t *\n\t *  @name DataTable.defaults.column.cellType\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Make the first column use TH cells\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [ {\n\t *          \"targets\": [ 0 ],\n\t *          \"cellType\": \"th\"\n\t *        } ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sCellType\": \"td\",\n\n\n\t/**\n\t * Class to give to each cell in this column.\n\t *  @type string\n\t *  @default <i>Empty string</i>\n\t *\n\t *  @name DataTable.defaults.column.class\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"class\": \"my_class\" },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sClass\": \"\",\n\n\t/**\n\t * When DataTables calculates the column widths to assign to each column,\n\t * it finds the longest string in each column and then constructs a\n\t * temporary table and reads the widths from that. The problem with this\n\t * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n\t * string - thus the calculation can go wrong (doing it properly and putting\n\t * it into an DOM object and measuring that is horribly(!) slow). Thus as\n\t * a \"work around\" we provide this option. It will append its value to the\n\t * text that is found to be the longest string for the column - i.e. padding.\n\t * Generally you shouldn't need this!\n\t *  @type string\n\t *  @default <i>Empty string<i>\n\t *\n\t *  @name DataTable.defaults.column.contentPadding\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          {\n\t *            \"contentPadding\": \"mmm\"\n\t *          }\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sContentPadding\": \"\",\n\n\n\t/**\n\t * Allows a default value to be given for a column's data, and will be used\n\t * whenever a null data source is encountered (this can be because `data`\n\t * is set to null, or because the data source itself is null).\n\t *  @type string\n\t *  @default null\n\t *\n\t *  @name DataTable.defaults.column.defaultContent\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          {\n\t *            \"data\": null,\n\t *            \"defaultContent\": \"Edit\",\n\t *            \"targets\": [ -1 ]\n\t *          }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          {\n\t *            \"data\": null,\n\t *            \"defaultContent\": \"Edit\"\n\t *          }\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sDefaultContent\": null,\n\n\n\t/**\n\t * This parameter is only used in DataTables' server-side processing. It can\n\t * be exceptionally useful to know what columns are being displayed on the\n\t * client side, and to map these to database fields. When defined, the names\n\t * also allow DataTables to reorder information from the server if it comes\n\t * back in an unexpected order (i.e. if you switch your columns around on the\n\t * client-side, your server-side code does not also need updating).\n\t *  @type string\n\t *  @default <i>Empty string</i>\n\t *\n\t *  @name DataTable.defaults.column.name\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"name\": \"engine\", \"targets\": [ 0 ] },\n\t *          { \"name\": \"browser\", \"targets\": [ 1 ] },\n\t *          { \"name\": \"platform\", \"targets\": [ 2 ] },\n\t *          { \"name\": \"version\", \"targets\": [ 3 ] },\n\t *          { \"name\": \"grade\", \"targets\": [ 4 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"name\": \"engine\" },\n\t *          { \"name\": \"browser\" },\n\t *          { \"name\": \"platform\" },\n\t *          { \"name\": \"version\" },\n\t *          { \"name\": \"grade\" }\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sName\": \"\",\n\n\n\t/**\n\t * Defines a data source type for the ordering which can be used to read\n\t * real-time information from the table (updating the internally cached\n\t * version) prior to ordering. This allows ordering to occur on user\n\t * editable elements such as form inputs.\n\t *  @type string\n\t *  @default std\n\t *\n\t *  @name DataTable.defaults.column.orderDataType\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\n\t *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\n\t *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\n\t *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          null,\n\t *          null,\n\t *          { \"orderDataType\": \"dom-text\" },\n\t *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\n\t *          { \"orderDataType\": \"dom-select\" },\n\t *          { \"orderDataType\": \"dom-checkbox\" }\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sSortDataType\": \"std\",\n\n\n\t/**\n\t * The title of this column.\n\t *  @type string\n\t *  @default null <i>Derived from the 'TH' value for this column in the\n\t *    original HTML table.</i>\n\t *\n\t *  @name DataTable.defaults.column.title\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"title\": \"My column title\" },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sTitle\": null,\n\n\n\t/**\n\t * The type allows you to specify how the data for this column will be\n\t * ordered. Four types (string, numeric, date and html (which will strip\n\t * HTML tags before ordering)) are currently available. Note that only date\n\t * formats understood by Javascript's Date() object will be accepted as type\n\t * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\n\t * 'numeric', 'date' or 'html' (by default). Further types can be adding\n\t * through plug-ins.\n\t *  @type string\n\t *  @default null <i>Auto-detected from raw data</i>\n\t *\n\t *  @name DataTable.defaults.column.type\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"type\": \"html\", \"targets\": [ 0 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"type\": \"html\" },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sType\": null,\n\n\n\t/**\n\t * Defining the width of the column, this parameter may take any CSS value\n\t * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\n\t * been given a specific width through this interface ensuring that the table\n\t * remains readable.\n\t *  @type string\n\t *  @default null <i>Automatic</i>\n\t *\n\t *  @name DataTable.defaults.column.width\n\t *  @dtopt Columns\n\t *\n\t *  @example\n\t *    // Using `columnDefs`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columnDefs\": [\n\t *          { \"width\": \"20%\", \"targets\": [ 0 ] }\n\t *        ]\n\t *      } );\n\t *    } );\n\t *\n\t *  @example\n\t *    // Using `columns`\n\t *    $(document).ready( function() {\n\t *      $('#example').dataTable( {\n\t *        \"columns\": [\n\t *          { \"width\": \"20%\" },\n\t *          null,\n\t *          null,\n\t *          null,\n\t *          null\n\t *        ]\n\t *      } );\n\t *    } );\n\t */\n\t\"sWidth\": null\n};\n\n_fnHungarianMap( DataTable.defaults.column );\n\n\n\n/**\n * DataTables settings object - this holds all the information needed for a\n * given table, including configuration, data and current application of the\n * table options. DataTables does not have a single instance for each DataTable\n * with the settings attached to that instance, but rather instances of the\n * DataTable \"class\" are created on-the-fly as needed (typically by a\n * $().dataTable() call) and the settings object is then applied to that\n * instance.\n *\n * Note that this object is related to {@link DataTable.defaults} but this\n * one is the internal data store for DataTables's cache of columns. It should\n * NOT be manipulated outside of DataTables. Any configuration should be done\n * through the initialisation options.\n *  @namespace\n *  @todo Really should attach the settings object to individual instances so we\n *    don't need to create new instances on each $().dataTable() call (if the\n *    table already exists). It would also save passing oSettings around and\n *    into every single function. However, this is a very significant\n *    architecture change for DataTables and will almost certainly break\n *    backwards compatibility with older installations. This is something that\n *    will be done in 2.0.\n */\nDataTable.models.oSettings = {\n\t/**\n\t * Primary features of DataTables and their enablement state.\n\t *  @namespace\n\t */\n\t\"oFeatures\": {\n\n\t\t/**\n\t\t * Flag to say if DataTables should automatically try to calculate the\n\t\t * optimum table and columns widths (true) or not (false).\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bAutoWidth\": null,\n\n\t\t/**\n\t\t * Delay the creation of TR and TD elements until they are actually\n\t\t * needed by a driven page draw. This can give a significant speed\n\t\t * increase for Ajax source and Javascript source data, but makes no\n\t\t * difference at all for DOM and server-side processing tables.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bDeferRender\": null,\n\n\t\t/**\n\t\t * Enable filtering on the table or not. Note that if this is disabled\n\t\t * then there is no filtering at all on the table, including fnFilter.\n\t\t * To just remove the filtering input use sDom and remove the 'f' option.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bFilter\": null,\n\n\t\t/**\n\t\t * Table information element (the 'Showing x of y records' div) enable\n\t\t * flag.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bInfo\": null,\n\n\t\t/**\n\t\t * Present a user control allowing the end user to change the page size\n\t\t * when pagination is enabled.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bLengthChange\": null,\n\n\t\t/**\n\t\t * Pagination enabled or not. Note that if this is disabled then length\n\t\t * changing must also be disabled.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bPaginate\": null,\n\n\t\t/**\n\t\t * Processing indicator enable flag whenever DataTables is enacting a\n\t\t * user request - typically an Ajax request for server-side processing.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bProcessing\": null,\n\n\t\t/**\n\t\t * Server-side processing enabled flag - when enabled DataTables will\n\t\t * get all data from the server for every draw - there is no filtering,\n\t\t * sorting or paging done on the client-side.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bServerSide\": null,\n\n\t\t/**\n\t\t * Sorting enablement flag.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bSort\": null,\n\n\t\t/**\n\t\t * Multi-column sorting\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bSortMulti\": null,\n\n\t\t/**\n\t\t * Apply a class to the columns which are being sorted to provide a\n\t\t * visual highlight or not. This can slow things down when enabled since\n\t\t * there is a lot of DOM interaction.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bSortClasses\": null,\n\n\t\t/**\n\t\t * State saving enablement flag.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bStateSave\": null\n\t},\n\n\n\t/**\n\t * Scrolling settings for a table.\n\t *  @namespace\n\t */\n\t\"oScroll\": {\n\t\t/**\n\t\t * When the table is shorter in height than sScrollY, collapse the\n\t\t * table container down to the height of the table (when true).\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type boolean\n\t\t */\n\t\t\"bCollapse\": null,\n\n\t\t/**\n\t\t * Width of the scrollbar for the web-browser's platform. Calculated\n\t\t * during table initialisation.\n\t\t *  @type int\n\t\t *  @default 0\n\t\t */\n\t\t\"iBarWidth\": 0,\n\n\t\t/**\n\t\t * Viewport width for horizontal scrolling. Horizontal scrolling is\n\t\t * disabled if an empty string.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type string\n\t\t */\n\t\t\"sX\": null,\n\n\t\t/**\n\t\t * Width to expand the table to when using x-scrolling. Typically you\n\t\t * should not need to use this.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type string\n\t\t *  @deprecated\n\t\t */\n\t\t\"sXInner\": null,\n\n\t\t/**\n\t\t * Viewport height for vertical scrolling. Vertical scrolling is disabled\n\t\t * if an empty string.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @type string\n\t\t */\n\t\t\"sY\": null\n\t},\n\n\t/**\n\t * Language information for the table.\n\t *  @namespace\n\t *  @extends DataTable.defaults.oLanguage\n\t */\n\t\"oLanguage\": {\n\t\t/**\n\t\t * Information callback function. See\n\t\t * {@link DataTable.defaults.fnInfoCallback}\n\t\t *  @type function\n\t\t *  @default null\n\t\t */\n\t\t\"fnInfoCallback\": null\n\t},\n\n\t/**\n\t * Browser support parameters\n\t *  @namespace\n\t */\n\t\"oBrowser\": {\n\t\t/**\n\t\t * Indicate if the browser incorrectly calculates width:100% inside a\n\t\t * scrolling element (IE6/7)\n\t\t *  @type boolean\n\t\t *  @default false\n\t\t */\n\t\t\"bScrollOversize\": false,\n\n\t\t/**\n\t\t * Determine if the vertical scrollbar is on the right or left of the\n\t\t * scrolling container - needed for rtl language layout, although not\n\t\t * all browsers move the scrollbar (Safari).\n\t\t *  @type boolean\n\t\t *  @default false\n\t\t */\n\t\t\"bScrollbarLeft\": false,\n\n\t\t/**\n\t\t * Flag for if `getBoundingClientRect` is fully supported or not\n\t\t *  @type boolean\n\t\t *  @default false\n\t\t */\n\t\t\"bBounding\": false,\n\n\t\t/**\n\t\t * Browser scrollbar width\n\t\t *  @type integer\n\t\t *  @default 0\n\t\t */\n\t\t\"barWidth\": 0\n\t},\n\n\n\t\"ajax\": null,\n\n\n\t/**\n\t * Array referencing the nodes which are used for the features. The\n\t * parameters of this object match what is allowed by sDom - i.e.\n\t *   <ul>\n\t *     <li>'l' - Length changing</li>\n\t *     <li>'f' - Filtering input</li>\n\t *     <li>'t' - The table!</li>\n\t *     <li>'i' - Information</li>\n\t *     <li>'p' - Pagination</li>\n\t *     <li>'r' - pRocessing</li>\n\t *   </ul>\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aanFeatures\": [],\n\n\t/**\n\t * Store data information - see {@link DataTable.models.oRow} for detailed\n\t * information.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoData\": [],\n\n\t/**\n\t * Array of indexes which are in the current display (after filtering etc)\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aiDisplay\": [],\n\n\t/**\n\t * Array of indexes for display - no filtering\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aiDisplayMaster\": [],\n\n\t/**\n\t * Map of row ids to data indexes\n\t *  @type object\n\t *  @default {}\n\t */\n\t\"aIds\": {},\n\n\t/**\n\t * Store information about each column that is in use\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoColumns\": [],\n\n\t/**\n\t * Store information about the table's header\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoHeader\": [],\n\n\t/**\n\t * Store information about the table's footer\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoFooter\": [],\n\n\t/**\n\t * Store the applied global search information in case we want to force a\n\t * research or compare the old search to a new one.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @namespace\n\t *  @extends DataTable.models.oSearch\n\t */\n\t\"oPreviousSearch\": {},\n\n\t/**\n\t * Store the applied search for each column - see\n\t * {@link DataTable.models.oSearch} for the format that is used for the\n\t * filtering information for each column.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoPreSearchCols\": [],\n\n\t/**\n\t * Sorting that is applied to the table. Note that the inner arrays are\n\t * used in the following manner:\n\t * <ul>\n\t *   <li>Index 0 - column number</li>\n\t *   <li>Index 1 - current sorting direction</li>\n\t * </ul>\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type array\n\t *  @todo These inner arrays should really be objects\n\t */\n\t\"aaSorting\": null,\n\n\t/**\n\t * Sorting that is always applied to the table (i.e. prefixed in front of\n\t * aaSorting).\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aaSortingFixed\": [],\n\n\t/**\n\t * Classes to use for the striping of a table.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"asStripeClasses\": null,\n\n\t/**\n\t * If restoring a table - we should restore its striping classes as well\n\t *  @type array\n\t *  @default []\n\t */\n\t\"asDestroyStripes\": [],\n\n\t/**\n\t * If restoring a table - we should restore its width\n\t *  @type int\n\t *  @default 0\n\t */\n\t\"sDestroyWidth\": 0,\n\n\t/**\n\t * Callback functions array for every time a row is inserted (i.e. on a draw).\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoRowCallback\": [],\n\n\t/**\n\t * Callback functions for the header on each draw.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoHeaderCallback\": [],\n\n\t/**\n\t * Callback function for the footer on each draw.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoFooterCallback\": [],\n\n\t/**\n\t * Array of callback functions for draw callback functions\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoDrawCallback\": [],\n\n\t/**\n\t * Array of callback functions for row created function\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoRowCreatedCallback\": [],\n\n\t/**\n\t * Callback functions for just before the table is redrawn. A return of\n\t * false will be used to cancel the draw.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoPreDrawCallback\": [],\n\n\t/**\n\t * Callback functions for when the table has been initialised.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoInitComplete\": [],\n\n\n\t/**\n\t * Callbacks for modifying the settings to be stored for state saving, prior to\n\t * saving state.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoStateSaveParams\": [],\n\n\t/**\n\t * Callbacks for modifying the settings that have been stored for state saving\n\t * prior to using the stored values to restore the state.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoStateLoadParams\": [],\n\n\t/**\n\t * Callbacks for operating on the settings object once the saved state has been\n\t * loaded\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoStateLoaded\": [],\n\n\t/**\n\t * Cache the table ID for quick access\n\t *  @type string\n\t *  @default <i>Empty string</i>\n\t */\n\t\"sTableId\": \"\",\n\n\t/**\n\t * The TABLE node for the main table\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTable\": null,\n\n\t/**\n\t * Permanent ref to the thead element\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTHead\": null,\n\n\t/**\n\t * Permanent ref to the tfoot element - if it exists\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTFoot\": null,\n\n\t/**\n\t * Permanent ref to the tbody element\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTBody\": null,\n\n\t/**\n\t * Cache the wrapper node (contains all DataTables controlled elements)\n\t *  @type node\n\t *  @default null\n\t */\n\t\"nTableWrapper\": null,\n\n\t/**\n\t * Indicate if when using server-side processing the loading of data\n\t * should be deferred until the second draw.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type boolean\n\t *  @default false\n\t */\n\t\"bDeferLoading\": false,\n\n\t/**\n\t * Indicate if all required information has been read in\n\t *  @type boolean\n\t *  @default false\n\t */\n\t\"bInitialised\": false,\n\n\t/**\n\t * Information about open rows. Each object in the array has the parameters\n\t * 'nTr' and 'nParent'\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoOpenRows\": [],\n\n\t/**\n\t * Dictate the positioning of DataTables' control elements - see\n\t * {@link DataTable.model.oInit.sDom}.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sDom\": null,\n\n\t/**\n\t * Search delay (in mS)\n\t *  @type integer\n\t *  @default null\n\t */\n\t\"searchDelay\": null,\n\n\t/**\n\t * Which type of pagination should be used.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type string\n\t *  @default two_button\n\t */\n\t\"sPaginationType\": \"two_button\",\n\n\t/**\n\t * The state duration (for `stateSave`) in seconds.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type int\n\t *  @default 0\n\t */\n\t\"iStateDuration\": 0,\n\n\t/**\n\t * Array of callback functions for state saving. Each array element is an\n\t * object with the following parameters:\n\t *   <ul>\n\t *     <li>function:fn - function to call. Takes two parameters, oSettings\n\t *       and the JSON string to save that has been thus far created. Returns\n\t *       a JSON string to be inserted into a json object\n\t *       (i.e. '\"param\": [ 0, 1, 2]')</li>\n\t *     <li>string:sName - name of callback</li>\n\t *   </ul>\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoStateSave\": [],\n\n\t/**\n\t * Array of callback functions for state loading. Each array element is an\n\t * object with the following parameters:\n\t *   <ul>\n\t *     <li>function:fn - function to call. Takes two parameters, oSettings\n\t *       and the object stored. May return false to cancel state loading</li>\n\t *     <li>string:sName - name of callback</li>\n\t *   </ul>\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoStateLoad\": [],\n\n\t/**\n\t * State that was saved. Useful for back reference\n\t *  @type object\n\t *  @default null\n\t */\n\t\"oSavedState\": null,\n\n\t/**\n\t * State that was loaded. Useful for back reference\n\t *  @type object\n\t *  @default null\n\t */\n\t\"oLoadedState\": null,\n\n\t/**\n\t * Source url for AJAX data for the table.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sAjaxSource\": null,\n\n\t/**\n\t * Property from a given object from which to read the table data from. This\n\t * can be an empty string (when not server-side processing), in which case\n\t * it is  assumed an an array is given directly.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type string\n\t */\n\t\"sAjaxDataProp\": null,\n\n\t/**\n\t * The last jQuery XHR object that was used for server-side data gathering.\n\t * This can be used for working with the XHR information in one of the\n\t * callbacks\n\t *  @type object\n\t *  @default null\n\t */\n\t\"jqXHR\": null,\n\n\t/**\n\t * JSON returned from the server in the last Ajax request\n\t *  @type object\n\t *  @default undefined\n\t */\n\t\"json\": undefined,\n\n\t/**\n\t * Data submitted as part of the last Ajax request\n\t *  @type object\n\t *  @default undefined\n\t */\n\t\"oAjaxData\": undefined,\n\n\t/**\n\t * Function to get the server-side data.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type function\n\t */\n\t\"fnServerData\": null,\n\n\t/**\n\t * Functions which are called prior to sending an Ajax request so extra\n\t * parameters can easily be sent to the server\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoServerParams\": [],\n\n\t/**\n\t * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\n\t * required).\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type string\n\t */\n\t\"sServerMethod\": null,\n\n\t/**\n\t * Format numbers for display.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type function\n\t */\n\t\"fnFormatNumber\": null,\n\n\t/**\n\t * List of options that can be used for the user selectable length menu.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aLengthMenu\": null,\n\n\t/**\n\t * Counter for the draws that the table does. Also used as a tracker for\n\t * server-side processing\n\t *  @type int\n\t *  @default 0\n\t */\n\t\"iDraw\": 0,\n\n\t/**\n\t * Indicate if a redraw is being done - useful for Ajax\n\t *  @type boolean\n\t *  @default false\n\t */\n\t\"bDrawing\": false,\n\n\t/**\n\t * Draw index (iDraw) of the last error when parsing the returned data\n\t *  @type int\n\t *  @default -1\n\t */\n\t\"iDrawError\": -1,\n\n\t/**\n\t * Paging display length\n\t *  @type int\n\t *  @default 10\n\t */\n\t\"_iDisplayLength\": 10,\n\n\t/**\n\t * Paging start point - aiDisplay index\n\t *  @type int\n\t *  @default 0\n\t */\n\t\"_iDisplayStart\": 0,\n\n\t/**\n\t * Server-side processing - number of records in the result set\n\t * (i.e. before filtering), Use fnRecordsTotal rather than\n\t * this property to get the value of the number of records, regardless of\n\t * the server-side processing setting.\n\t *  @type int\n\t *  @default 0\n\t *  @private\n\t */\n\t\"_iRecordsTotal\": 0,\n\n\t/**\n\t * Server-side processing - number of records in the current display set\n\t * (i.e. after filtering). Use fnRecordsDisplay rather than\n\t * this property to get the value of the number of records, regardless of\n\t * the server-side processing setting.\n\t *  @type boolean\n\t *  @default 0\n\t *  @private\n\t */\n\t\"_iRecordsDisplay\": 0,\n\n\t/**\n\t * The classes to use for the table\n\t *  @type object\n\t *  @default {}\n\t */\n\t\"oClasses\": {},\n\n\t/**\n\t * Flag attached to the settings object so you can check in the draw\n\t * callback if filtering has been done in the draw. Deprecated in favour of\n\t * events.\n\t *  @type boolean\n\t *  @default false\n\t *  @deprecated\n\t */\n\t\"bFiltered\": false,\n\n\t/**\n\t * Flag attached to the settings object so you can check in the draw\n\t * callback if sorting has been done in the draw. Deprecated in favour of\n\t * events.\n\t *  @type boolean\n\t *  @default false\n\t *  @deprecated\n\t */\n\t\"bSorted\": false,\n\n\t/**\n\t * Indicate that if multiple rows are in the header and there is more than\n\t * one unique cell per column, if the top one (true) or bottom one (false)\n\t * should be used for sorting / title by DataTables.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t *  @type boolean\n\t */\n\t\"bSortCellsTop\": null,\n\n\t/**\n\t * Initialisation object that is used for the table\n\t *  @type object\n\t *  @default null\n\t */\n\t\"oInit\": null,\n\n\t/**\n\t * Destroy callback functions - for plug-ins to attach themselves to the\n\t * destroy so they can clean up markup and events.\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aoDestroyCallback\": [],\n\n\n\t/**\n\t * Get the number of records in the current record set, before filtering\n\t *  @type function\n\t */\n\t\"fnRecordsTotal\": function ()\n\t{\n\t\treturn _fnDataSource( this ) == 'ssp' ?\n\t\t\tthis._iRecordsTotal * 1 :\n\t\t\tthis.aiDisplayMaster.length;\n\t},\n\n\t/**\n\t * Get the number of records in the current record set, after filtering\n\t *  @type function\n\t */\n\t\"fnRecordsDisplay\": function ()\n\t{\n\t\treturn _fnDataSource( this ) == 'ssp' ?\n\t\t\tthis._iRecordsDisplay * 1 :\n\t\t\tthis.aiDisplay.length;\n\t},\n\n\t/**\n\t * Get the display end point - aiDisplay index\n\t *  @type function\n\t */\n\t\"fnDisplayEnd\": function ()\n\t{\n\t\tvar\n\t\t\tlen      = this._iDisplayLength,\n\t\t\tstart    = this._iDisplayStart,\n\t\t\tcalc     = start + len,\n\t\t\trecords  = this.aiDisplay.length,\n\t\t\tfeatures = this.oFeatures,\n\t\t\tpaginate = features.bPaginate;\n\n\t\tif ( features.bServerSide ) {\n\t\t\treturn paginate === false || len === -1 ?\n\t\t\t\tstart + records :\n\t\t\t\tMath.min( start+len, this._iRecordsDisplay );\n\t\t}\n\t\telse {\n\t\t\treturn ! paginate || calc>records || len===-1 ?\n\t\t\t\trecords :\n\t\t\t\tcalc;\n\t\t}\n\t},\n\n\t/**\n\t * The DataTables object for this table\n\t *  @type object\n\t *  @default null\n\t */\n\t\"oInstance\": null,\n\n\t/**\n\t * Unique identifier for each instance of the DataTables object. If there\n\t * is an ID on the table node, then it takes that value, otherwise an\n\t * incrementing internal counter is used.\n\t *  @type string\n\t *  @default null\n\t */\n\t\"sInstance\": null,\n\n\t/**\n\t * tabindex attribute value that is added to DataTables control elements, allowing\n\t * keyboard navigation of the table and its controls.\n\t */\n\t\"iTabIndex\": 0,\n\n\t/**\n\t * DIV container for the footer scrolling table if scrolling\n\t */\n\t\"nScrollHead\": null,\n\n\t/**\n\t * DIV container for the footer scrolling table if scrolling\n\t */\n\t\"nScrollFoot\": null,\n\n\t/**\n\t * Last applied sort\n\t *  @type array\n\t *  @default []\n\t */\n\t\"aLastSort\": [],\n\n\t/**\n\t * Stored plug-in instances\n\t *  @type object\n\t *  @default {}\n\t */\n\t\"oPlugins\": {},\n\n\t/**\n\t * Function used to get a row's id from the row's data\n\t *  @type function\n\t *  @default null\n\t */\n\t\"rowIdFn\": null,\n\n\t/**\n\t * Data location where to store a row's id\n\t *  @type string\n\t *  @default null\n\t */\n\t\"rowId\": null\n};\n\n/**\n * Extension object for DataTables that is used to provide all extension\n * options.\n *\n * Note that the `DataTable.ext` object is available through\n * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\n * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\n *  @namespace\n *  @extends DataTable.models.ext\n */\n\n\n/**\n * DataTables extensions\n * \n * This namespace acts as a collection area for plug-ins that can be used to\n * extend DataTables capabilities. Indeed many of the build in methods\n * use this method to provide their own capabilities (sorting methods for\n * example).\n *\n * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\n * reasons\n *\n *  @namespace\n */\nDataTable.ext = _ext = {\n\t/**\n\t * Buttons. For use with the Buttons extension for DataTables. This is\n\t * defined here so other extensions can define buttons regardless of load\n\t * order. It is _not_ used by DataTables core.\n\t *\n\t *  @type object\n\t *  @default {}\n\t */\n\tbuttons: {},\n\n\n\t/**\n\t * Element class names\n\t *\n\t *  @type object\n\t *  @default {}\n\t */\n\tclasses: {},\n\n\n\t/**\n\t * DataTables build type (expanded by the download builder)\n\t *\n\t *  @type string\n\t */\n\tbuilder: \"-source-\",\n\n\n\t/**\n\t * Error reporting.\n\t * \n\t * How should DataTables report an error. Can take the value 'alert',\n\t * 'throw', 'none' or a function.\n\t *\n\t *  @type string|function\n\t *  @default alert\n\t */\n\terrMode: \"alert\",\n\n\n\t/**\n\t * Feature plug-ins.\n\t * \n\t * This is an array of objects which describe the feature plug-ins that are\n\t * available to DataTables. These feature plug-ins are then available for\n\t * use through the `dom` initialisation option.\n\t * \n\t * Each feature plug-in is described by an object which must have the\n\t * following properties:\n\t * \n\t * * `fnInit` - function that is used to initialise the plug-in,\n\t * * `cFeature` - a character so the feature can be enabled by the `dom`\n\t *   instillation option. This is case sensitive.\n\t *\n\t * The `fnInit` function has the following input parameters:\n\t *\n\t * 1. `{object}` DataTables settings object: see\n\t *    {@link DataTable.models.oSettings}\n\t *\n\t * And the following return is expected:\n\t * \n\t * * {node|null} The element which contains your feature. Note that the\n\t *   return may also be void if your plug-in does not require to inject any\n\t *   DOM elements into DataTables control (`dom`) - for example this might\n\t *   be useful when developing a plug-in which allows table control via\n\t *   keyboard entry\n\t *\n\t *  @type array\n\t *\n\t *  @example\n\t *    $.fn.dataTable.ext.features.push( {\n\t *      \"fnInit\": function( oSettings ) {\n\t *        return new TableTools( { \"oDTSettings\": oSettings } );\n\t *      },\n\t *      \"cFeature\": \"T\"\n\t *    } );\n\t */\n\tfeature: [],\n\n\n\t/**\n\t * Row searching.\n\t * \n\t * This method of searching is complimentary to the default type based\n\t * searching, and a lot more comprehensive as it allows you complete control\n\t * over the searching logic. Each element in this array is a function\n\t * (parameters described below) that is called for every row in the table,\n\t * and your logic decides if it should be included in the searching data set\n\t * or not.\n\t *\n\t * Searching functions have the following input parameters:\n\t *\n\t * 1. `{object}` DataTables settings object: see\n\t *    {@link DataTable.models.oSettings}\n\t * 2. `{array|object}` Data for the row to be processed (same as the\n\t *    original format that was passed in as the data source, or an array\n\t *    from a DOM data source\n\t * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\n\t *    can be useful to retrieve the `TR` element if you need DOM interaction.\n\t *\n\t * And the following return is expected:\n\t *\n\t * * {boolean} Include the row in the searched result set (true) or not\n\t *   (false)\n\t *\n\t * Note that as with the main search ability in DataTables, technically this\n\t * is \"filtering\", since it is subtractive. However, for consistency in\n\t * naming we call it searching here.\n\t *\n\t *  @type array\n\t *  @default []\n\t *\n\t *  @example\n\t *    // The following example shows custom search being applied to the\n\t *    // fourth column (i.e. the data[3] index) based on two input values\n\t *    // from the end-user, matching the data in a certain range.\n\t *    $.fn.dataTable.ext.search.push(\n\t *      function( settings, data, dataIndex ) {\n\t *        var min = document.getElementById('min').value * 1;\n\t *        var max = document.getElementById('max').value * 1;\n\t *        var version = data[3] == \"-\" ? 0 : data[3]*1;\n\t *\n\t *        if ( min == \"\" && max == \"\" ) {\n\t *          return true;\n\t *        }\n\t *        else if ( min == \"\" && version < max ) {\n\t *          return true;\n\t *        }\n\t *        else if ( min < version && \"\" == max ) {\n\t *          return true;\n\t *        }\n\t *        else if ( min < version && version < max ) {\n\t *          return true;\n\t *        }\n\t *        return false;\n\t *      }\n\t *    );\n\t */\n\tsearch: [],\n\n\n\t/**\n\t * Selector extensions\n\t *\n\t * The `selector` option can be used to extend the options available for the\n\t * selector modifier options (`selector-modifier` object data type) that\n\t * each of the three built in selector types offer (row, column and cell +\n\t * their plural counterparts). For example the Select extension uses this\n\t * mechanism to provide an option to select only rows, columns and cells\n\t * that have been marked as selected by the end user (`{selected: true}`),\n\t * which can be used in conjunction with the existing built in selector\n\t * options.\n\t *\n\t * Each property is an array to which functions can be pushed. The functions\n\t * take three attributes:\n\t *\n\t * * Settings object for the host table\n\t * * Options object (`selector-modifier` object type)\n\t * * Array of selected item indexes\n\t *\n\t * The return is an array of the resulting item indexes after the custom\n\t * selector has been applied.\n\t *\n\t *  @type object\n\t */\n\tselector: {\n\t\tcell: [],\n\t\tcolumn: [],\n\t\trow: []\n\t},\n\n\n\t/**\n\t * Internal functions, exposed for used in plug-ins.\n\t * \n\t * Please note that you should not need to use the internal methods for\n\t * anything other than a plug-in (and even then, try to avoid if possible).\n\t * The internal function may change between releases.\n\t *\n\t *  @type object\n\t *  @default {}\n\t */\n\tinternal: {},\n\n\n\t/**\n\t * Legacy configuration options. Enable and disable legacy options that\n\t * are available in DataTables.\n\t *\n\t *  @type object\n\t */\n\tlegacy: {\n\t\t/**\n\t\t * Enable / disable DataTables 1.9 compatible server-side processing\n\t\t * requests\n\t\t *\n\t\t *  @type boolean\n\t\t *  @default null\n\t\t */\n\t\tajax: null\n\t},\n\n\n\t/**\n\t * Pagination plug-in methods.\n\t * \n\t * Each entry in this object is a function and defines which buttons should\n\t * be shown by the pagination rendering method that is used for the table:\n\t * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\n\t * buttons are displayed in the document, while the functions here tell it\n\t * what buttons to display. This is done by returning an array of button\n\t * descriptions (what each button will do).\n\t *\n\t * Pagination types (the four built in options and any additional plug-in\n\t * options defined here) can be used through the `paginationType`\n\t * initialisation parameter.\n\t *\n\t * The functions defined take two parameters:\n\t *\n\t * 1. `{int} page` The current page index\n\t * 2. `{int} pages` The number of pages in the table\n\t *\n\t * Each function is expected to return an array where each element of the\n\t * array can be one of:\n\t *\n\t * * `first` - Jump to first page when activated\n\t * * `last` - Jump to last page when activated\n\t * * `previous` - Show previous page when activated\n\t * * `next` - Show next page when activated\n\t * * `{int}` - Show page of the index given\n\t * * `{array}` - A nested array containing the above elements to add a\n\t *   containing 'DIV' element (might be useful for styling).\n\t *\n\t * Note that DataTables v1.9- used this object slightly differently whereby\n\t * an object with two functions would be defined for each plug-in. That\n\t * ability is still supported by DataTables 1.10+ to provide backwards\n\t * compatibility, but this option of use is now decremented and no longer\n\t * documented in DataTables 1.10+.\n\t *\n\t *  @type object\n\t *  @default {}\n\t *\n\t *  @example\n\t *    // Show previous, next and current page buttons only\n\t *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\n\t *      return [ 'previous', page, 'next' ];\n\t *    };\n\t */\n\tpager: {},\n\n\n\trenderer: {\n\t\tpageButton: {},\n\t\theader: {}\n\t},\n\n\n\t/**\n\t * Ordering plug-ins - custom data source\n\t * \n\t * The extension options for ordering of data available here is complimentary\n\t * to the default type based ordering that DataTables typically uses. It\n\t * allows much greater control over the the data that is being used to\n\t * order a column, but is necessarily therefore more complex.\n\t * \n\t * This type of ordering is useful if you want to do ordering based on data\n\t * live from the DOM (for example the contents of an 'input' element) rather\n\t * than just the static string that DataTables knows of.\n\t * \n\t * The way these plug-ins work is that you create an array of the values you\n\t * wish to be ordering for the column in question and then return that\n\t * array. The data in the array much be in the index order of the rows in\n\t * the table (not the currently ordering order!). Which order data gathering\n\t * function is run here depends on the `dt-init columns.orderDataType`\n\t * parameter that is used for the column (if any).\n\t *\n\t * The functions defined take two parameters:\n\t *\n\t * 1. `{object}` DataTables settings object: see\n\t *    {@link DataTable.models.oSettings}\n\t * 2. `{int}` Target column index\n\t *\n\t * Each function is expected to return an array:\n\t *\n\t * * `{array}` Data for the column to be ordering upon\n\t *\n\t *  @type array\n\t *\n\t *  @example\n\t *    // Ordering using `input` node values\n\t *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\n\t *    {\n\t *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\n\t *        return $('input', td).val();\n\t *      } );\n\t *    }\n\t */\n\torder: {},\n\n\n\t/**\n\t * Type based plug-ins.\n\t *\n\t * Each column in DataTables has a type assigned to it, either by automatic\n\t * detection or by direct assignment using the `type` option for the column.\n\t * The type of a column will effect how it is ordering and search (plug-ins\n\t * can also make use of the column type if required).\n\t *\n\t * @namespace\n\t */\n\ttype: {\n\t\t/**\n\t\t * Type detection functions.\n\t\t *\n\t\t * The functions defined in this object are used to automatically detect\n\t\t * a column's type, making initialisation of DataTables super easy, even\n\t\t * when complex data is in the table.\n\t\t *\n\t\t * The functions defined take two parameters:\n\t\t *\n\t     *  1. `{*}` Data from the column cell to be analysed\n\t     *  2. `{settings}` DataTables settings object. This can be used to\n\t     *     perform context specific type detection - for example detection\n\t     *     based on language settings such as using a comma for a decimal\n\t     *     place. Generally speaking the options from the settings will not\n\t     *     be required\n\t\t *\n\t\t * Each function is expected to return:\n\t\t *\n\t\t * * `{string|null}` Data type detected, or null if unknown (and thus\n\t\t *   pass it on to the other type detection functions.\n\t\t *\n\t\t *  @type array\n\t\t *\n\t\t *  @example\n\t\t *    // Currency type detection plug-in:\n\t\t *    $.fn.dataTable.ext.type.detect.push(\n\t\t *      function ( data, settings ) {\n\t\t *        // Check the numeric part\n\t\t *        if ( ! data.substring(1).match(/[0-9]/) ) {\n\t\t *          return null;\n\t\t *        }\n\t\t *\n\t\t *        // Check prefixed by currency\n\t\t *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\n\t\t *          return 'currency';\n\t\t *        }\n\t\t *        return null;\n\t\t *      }\n\t\t *    );\n\t\t */\n\t\tdetect: [],\n\n\n\t\t/**\n\t\t * Type based search formatting.\n\t\t *\n\t\t * The type based searching functions can be used to pre-format the\n\t\t * data to be search on. For example, it can be used to strip HTML\n\t\t * tags or to de-format telephone numbers for numeric only searching.\n\t\t *\n\t\t * Note that is a search is not defined for a column of a given type,\n\t\t * no search formatting will be performed.\n\t\t * \n\t\t * Pre-processing of searching data plug-ins - When you assign the sType\n\t\t * for a column (or have it automatically detected for you by DataTables\n\t\t * or a type detection plug-in), you will typically be using this for\n\t\t * custom sorting, but it can also be used to provide custom searching\n\t\t * by allowing you to pre-processing the data and returning the data in\n\t\t * the format that should be searched upon. This is done by adding\n\t\t * functions this object with a parameter name which matches the sType\n\t\t * for that target column. This is the corollary of <i>afnSortData</i>\n\t\t * for searching data.\n\t\t *\n\t\t * The functions defined take a single parameter:\n\t\t *\n\t     *  1. `{*}` Data from the column cell to be prepared for searching\n\t\t *\n\t\t * Each function is expected to return:\n\t\t *\n\t\t * * `{string|null}` Formatted string that will be used for the searching.\n\t\t *\n\t\t *  @type object\n\t\t *  @default {}\n\t\t *\n\t\t *  @example\n\t\t *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\n\t\t *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\n\t\t *    }\n\t\t */\n\t\tsearch: {},\n\n\n\t\t/**\n\t\t * Type based ordering.\n\t\t *\n\t\t * The column type tells DataTables what ordering to apply to the table\n\t\t * when a column is sorted upon. The order for each type that is defined,\n\t\t * is defined by the functions available in this object.\n\t\t *\n\t\t * Each ordering option can be described by three properties added to\n\t\t * this object:\n\t\t *\n\t\t * * `{type}-pre` - Pre-formatting function\n\t\t * * `{type}-asc` - Ascending order function\n\t\t * * `{type}-desc` - Descending order function\n\t\t *\n\t\t * All three can be used together, only `{type}-pre` or only\n\t\t * `{type}-asc` and `{type}-desc` together. It is generally recommended\n\t\t * that only `{type}-pre` is used, as this provides the optimal\n\t\t * implementation in terms of speed, although the others are provided\n\t\t * for compatibility with existing Javascript sort functions.\n\t\t *\n\t\t * `{type}-pre`: Functions defined take a single parameter:\n\t\t *\n\t     *  1. `{*}` Data from the column cell to be prepared for ordering\n\t\t *\n\t\t * And return:\n\t\t *\n\t\t * * `{*}` Data to be sorted upon\n\t\t *\n\t\t * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\n\t\t * functions, taking two parameters:\n\t\t *\n\t     *  1. `{*}` Data to compare to the second parameter\n\t     *  2. `{*}` Data to compare to the first parameter\n\t\t *\n\t\t * And returning:\n\t\t *\n\t\t * * `{*}` Ordering match: <0 if first parameter should be sorted lower\n\t\t *   than the second parameter, ===0 if the two parameters are equal and\n\t\t *   >0 if the first parameter should be sorted height than the second\n\t\t *   parameter.\n\t\t * \n\t\t *  @type object\n\t\t *  @default {}\n\t\t *\n\t\t *  @example\n\t\t *    // Numeric ordering of formatted numbers with a pre-formatter\n\t\t *    $.extend( $.fn.dataTable.ext.type.order, {\n\t\t *      \"string-pre\": function(x) {\n\t\t *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\n\t\t *        return parseFloat( a );\n\t\t *      }\n\t\t *    } );\n\t\t *\n\t\t *  @example\n\t\t *    // Case-sensitive string ordering, with no pre-formatting method\n\t\t *    $.extend( $.fn.dataTable.ext.order, {\n\t\t *      \"string-case-asc\": function(x,y) {\n\t\t *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n\t\t *      },\n\t\t *      \"string-case-desc\": function(x,y) {\n\t\t *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n\t\t *      }\n\t\t *    } );\n\t\t */\n\t\torder: {}\n\t},\n\n\t/**\n\t * Unique DataTables instance counter\n\t *\n\t * @type int\n\t * @private\n\t */\n\t_unique: 0,\n\n\n\t//\n\t// Depreciated\n\t// The following properties are retained for backwards compatibility only.\n\t// The should not be used in new projects and will be removed in a future\n\t// version\n\t//\n\n\t/**\n\t * Version check function.\n\t *  @type function\n\t *  @depreciated Since 1.10\n\t */\n\tfnVersionCheck: DataTable.fnVersionCheck,\n\n\n\t/**\n\t * Index for what 'this' index API functions should use\n\t *  @type int\n\t *  @deprecated Since v1.10\n\t */\n\tiApiIndex: 0,\n\n\n\t/**\n\t * jQuery UI class container\n\t *  @type object\n\t *  @deprecated Since v1.10\n\t */\n\toJUIClasses: {},\n\n\n\t/**\n\t * Software version\n\t *  @type string\n\t *  @deprecated Since v1.10\n\t */\n\tsVersion: DataTable.version\n};\n\n\n//\n// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\n//\n$.extend( _ext, {\n\tafnFiltering: _ext.search,\n\taTypes:       _ext.type.detect,\n\tofnSearch:    _ext.type.search,\n\toSort:        _ext.type.order,\n\tafnSortData:  _ext.order,\n\taoFeatures:   _ext.feature,\n\toApi:         _ext.internal,\n\toStdClasses:  _ext.classes,\n\toPagination:  _ext.pager\n} );\n\n\n$.extend( DataTable.ext.classes, {\n\t\"sTable\": \"dataTable\",\n\t\"sNoFooter\": \"no-footer\",\n\n\t/* Paging buttons */\n\t\"sPageButton\": \"paginate_button\",\n\t\"sPageButtonActive\": \"current\",\n\t\"sPageButtonDisabled\": \"disabled\",\n\n\t/* Striping classes */\n\t\"sStripeOdd\": \"odd\",\n\t\"sStripeEven\": \"even\",\n\n\t/* Empty row */\n\t\"sRowEmpty\": \"dataTables_empty\",\n\n\t/* Features */\n\t\"sWrapper\": \"dataTables_wrapper\",\n\t\"sFilter\": \"dataTables_filter\",\n\t\"sInfo\": \"dataTables_info\",\n\t\"sPaging\": \"dataTables_paginate paging_\", /* Note that the type is postfixed */\n\t\"sLength\": \"dataTables_length\",\n\t\"sProcessing\": \"dataTables_processing\",\n\n\t/* Sorting */\n\t\"sSortAsc\": \"sorting_asc\",\n\t\"sSortDesc\": \"sorting_desc\",\n\t\"sSortable\": \"sorting\", /* Sortable in both directions */\n\t\"sSortableAsc\": \"sorting_desc_disabled\",\n\t\"sSortableDesc\": \"sorting_asc_disabled\",\n\t\"sSortableNone\": \"sorting_disabled\",\n\t\"sSortColumn\": \"sorting_\", /* Note that an int is postfixed for the sorting order */\n\n\t/* Filtering */\n\t\"sFilterInput\": \"\",\n\n\t/* Page length */\n\t\"sLengthSelect\": \"\",\n\n\t/* Scrolling */\n\t\"sScrollWrapper\": \"dataTables_scroll\",\n\t\"sScrollHead\": \"dataTables_scrollHead\",\n\t\"sScrollHeadInner\": \"dataTables_scrollHeadInner\",\n\t\"sScrollBody\": \"dataTables_scrollBody\",\n\t\"sScrollFoot\": \"dataTables_scrollFoot\",\n\t\"sScrollFootInner\": \"dataTables_scrollFootInner\",\n\n\t/* Misc */\n\t\"sHeaderTH\": \"\",\n\t\"sFooterTH\": \"\",\n\n\t// Deprecated\n\t\"sSortJUIAsc\": \"\",\n\t\"sSortJUIDesc\": \"\",\n\t\"sSortJUI\": \"\",\n\t\"sSortJUIAscAllowed\": \"\",\n\t\"sSortJUIDescAllowed\": \"\",\n\t\"sSortJUIWrapper\": \"\",\n\t\"sSortIcon\": \"\",\n\t\"sJUIHeader\": \"\",\n\t\"sJUIFooter\": \"\"\n} );\n\n\nvar extPagination = DataTable.ext.pager;\n\nfunction _numbers ( page, pages ) {\n\tvar\n\t\tnumbers = [],\n\t\tbuttons = extPagination.numbers_length,\n\t\thalf = Math.floor( buttons / 2 ),\n\t\ti = 1;\n\n\tif ( pages <= buttons ) {\n\t\tnumbers = _range( 0, pages );\n\t}\n\telse if ( page <= half ) {\n\t\tnumbers = _range( 0, buttons-2 );\n\t\tnumbers.push( 'ellipsis' );\n\t\tnumbers.push( pages-1 );\n\t}\n\telse if ( page >= pages - 1 - half ) {\n\t\tnumbers = _range( pages-(buttons-2), pages );\n\t\tnumbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6\n\t\tnumbers.splice( 0, 0, 0 );\n\t}\n\telse {\n\t\tnumbers = _range( page-half+2, page+half-1 );\n\t\tnumbers.push( 'ellipsis' );\n\t\tnumbers.push( pages-1 );\n\t\tnumbers.splice( 0, 0, 'ellipsis' );\n\t\tnumbers.splice( 0, 0, 0 );\n\t}\n\n\tnumbers.DT_el = 'span';\n\treturn numbers;\n}\n\n\n$.extend( extPagination, {\n\tsimple: function ( page, pages ) {\n\t\treturn [ 'previous', 'next' ];\n\t},\n\n\tfull: function ( page, pages ) {\n\t\treturn [  'first', 'previous', 'next', 'last' ];\n\t},\n\n\tnumbers: function ( page, pages ) {\n\t\treturn [ _numbers(page, pages) ];\n\t},\n\n\tsimple_numbers: function ( page, pages ) {\n\t\treturn [ 'previous', _numbers(page, pages), 'next' ];\n\t},\n\n\tfull_numbers: function ( page, pages ) {\n\t\treturn [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];\n\t},\n\t\n\tfirst_last_numbers: function (page, pages) {\n \t\treturn ['first', _numbers(page, pages), 'last'];\n \t},\n\n\t// For testing and plug-ins to use\n\t_numbers: _numbers,\n\n\t// Number of number buttons (including ellipsis) to show. _Must be odd!_\n\tnumbers_length: 7\n} );\n\n\n$.extend( true, DataTable.ext.renderer, {\n\tpageButton: {\n\t\t_: function ( settings, host, idx, buttons, page, pages ) {\n\t\t\tvar classes = settings.oClasses;\n\t\t\tvar lang = settings.oLanguage.oPaginate;\n\t\t\tvar aria = settings.oLanguage.oAria.paginate || {};\n\t\t\tvar btnDisplay, btnClass;\n\n\t\t\tvar attach = function( container, buttons ) {\n\t\t\t\tvar i, ien, node, button, tabIndex;\n\t\t\t\tvar disabledClass = classes.sPageButtonDisabled;\n\t\t\t\tvar clickHandler = function ( e ) {\n\t\t\t\t\t_fnPageChange( settings, e.data.action, true );\n\t\t\t\t};\n\n\t\t\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\t\t\tbutton = buttons[i];\n\n\t\t\t\t\tif ( Array.isArray( button ) ) {\n\t\t\t\t\t\tvar inner = $( '<'+(button.DT_el || 'div')+'/>' )\n\t\t\t\t\t\t\t.appendTo( container );\n\t\t\t\t\t\tattach( inner, button );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbtnDisplay = null;\n\t\t\t\t\t\tbtnClass = button;\n\t\t\t\t\t\ttabIndex = settings.iTabIndex;\n\n\t\t\t\t\t\tswitch ( button ) {\n\t\t\t\t\t\t\tcase 'ellipsis':\n\t\t\t\t\t\t\t\tcontainer.append('<span class=\"ellipsis\">&#x2026;</span>');\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'first':\n\t\t\t\t\t\t\t\tbtnDisplay = lang.sFirst;\n\n\t\t\t\t\t\t\t\tif ( page === 0 ) {\n\t\t\t\t\t\t\t\t\ttabIndex = -1;\n\t\t\t\t\t\t\t\t\tbtnClass += ' ' + disabledClass;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'previous':\n\t\t\t\t\t\t\t\tbtnDisplay = lang.sPrevious;\n\n\t\t\t\t\t\t\t\tif ( page === 0 ) {\n\t\t\t\t\t\t\t\t\ttabIndex = -1;\n\t\t\t\t\t\t\t\t\tbtnClass += ' ' + disabledClass;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'next':\n\t\t\t\t\t\t\t\tbtnDisplay = lang.sNext;\n\n\t\t\t\t\t\t\t\tif ( pages === 0 || page === pages-1 ) {\n\t\t\t\t\t\t\t\t\ttabIndex = -1;\n\t\t\t\t\t\t\t\t\tbtnClass += ' ' + disabledClass;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'last':\n\t\t\t\t\t\t\t\tbtnDisplay = lang.sLast;\n\n\t\t\t\t\t\t\t\tif ( pages === 0 || page === pages-1 ) {\n\t\t\t\t\t\t\t\t\ttabIndex = -1;\n\t\t\t\t\t\t\t\t\tbtnClass += ' ' + disabledClass;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbtnDisplay = settings.fnFormatNumber( button + 1 );\n\t\t\t\t\t\t\t\tbtnClass = page === button ?\n\t\t\t\t\t\t\t\t\tclasses.sPageButtonActive : '';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( btnDisplay !== null ) {\n\t\t\t\t\t\t\tvar tag = settings.oInit.pagingTag || 'a';\n\t\t\t\t\t\t\tvar disabled = btnClass.indexOf(disabledClass) !== -1;\n\t\t\n\n\t\t\t\t\t\t\tnode = $('<'+tag+'>', {\n\t\t\t\t\t\t\t\t\t'class': classes.sPageButton+' '+btnClass,\n\t\t\t\t\t\t\t\t\t'aria-controls': settings.sTableId,\n\t\t\t\t\t\t\t\t\t'aria-disabled': disabled ? 'true' : null,\n\t\t\t\t\t\t\t\t\t'aria-label': aria[ button ],\n\t\t\t\t\t\t\t\t\t'aria-role': 'link',\n\t\t\t\t\t\t\t\t\t'aria-current': btnClass === classes.sPageButtonActive ? 'page' : null,\n\t\t\t\t\t\t\t\t\t'data-dt-idx': button,\n\t\t\t\t\t\t\t\t\t'tabindex': tabIndex,\n\t\t\t\t\t\t\t\t\t'id': idx === 0 && typeof button === 'string' ?\n\t\t\t\t\t\t\t\t\t\tsettings.sTableId +'_'+ button :\n\t\t\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t\t.html( btnDisplay )\n\t\t\t\t\t\t\t\t.appendTo( container );\n\n\t\t\t\t\t\t\t_fnBindAction(\n\t\t\t\t\t\t\t\tnode, {action: button}, clickHandler\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// IE9 throws an 'unknown error' if document.activeElement is used\n\t\t\t// inside an iframe or frame. Try / catch the error. Not good for\n\t\t\t// accessibility, but neither are frames.\n\t\t\tvar activeEl;\n\n\t\t\ttry {\n\t\t\t\t// Because this approach is destroying and recreating the paging\n\t\t\t\t// elements, focus is lost on the select button which is bad for\n\t\t\t\t// accessibility. So we want to restore focus once the draw has\n\t\t\t\t// completed\n\t\t\t\tactiveEl = $(host).find(document.activeElement).data('dt-idx');\n\t\t\t}\n\t\t\tcatch (e) {}\n\n\t\t\tattach( $(host).empty(), buttons );\n\n\t\t\tif ( activeEl !== undefined ) {\n\t\t\t\t$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');\n\t\t\t}\n\t\t}\n\t}\n} );\n\n\n\n// Built in type detection. See model.ext.aTypes for information about\n// what is required from this methods.\n$.extend( DataTable.ext.type.detect, [\n\t// Plain numbers - first since V8 detects some plain numbers as dates\n\t// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\n\tfunction ( d, settings )\n\t{\n\t\tvar decimal = settings.oLanguage.sDecimal;\n\t\treturn _isNumber( d, decimal ) ? 'num'+decimal : null;\n\t},\n\n\t// Dates (only those recognised by the browser's Date.parse)\n\tfunction ( d, settings )\n\t{\n\t\t// V8 tries _very_ hard to make a string passed into `Date.parse()`\n\t\t// valid, so we need to use a regex to restrict date formats. Use a\n\t\t// plug-in for anything other than ISO8601 style strings\n\t\tif ( d && !(d instanceof Date) && ! _re_date.test(d) ) {\n\t\t\treturn null;\n\t\t}\n\t\tvar parsed = Date.parse(d);\n\t\treturn (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;\n\t},\n\n\t// Formatted numbers\n\tfunction ( d, settings )\n\t{\n\t\tvar decimal = settings.oLanguage.sDecimal;\n\t\treturn _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;\n\t},\n\n\t// HTML numeric\n\tfunction ( d, settings )\n\t{\n\t\tvar decimal = settings.oLanguage.sDecimal;\n\t\treturn _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;\n\t},\n\n\t// HTML numeric, formatted\n\tfunction ( d, settings )\n\t{\n\t\tvar decimal = settings.oLanguage.sDecimal;\n\t\treturn _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;\n\t},\n\n\t// HTML (this is strict checking - there must be html)\n\tfunction ( d, settings )\n\t{\n\t\treturn _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?\n\t\t\t'html' : null;\n\t}\n] );\n\n\n\n// Filter formatting functions. See model.ext.ofnSearch for information about\n// what is required from these methods.\n// \n// Note that additional search methods are added for the html numbers and\n// html formatted numbers by `_addNumericSort()` when we know what the decimal\n// place is\n\n\n$.extend( DataTable.ext.type.search, {\n\thtml: function ( data ) {\n\t\treturn _empty(data) ?\n\t\t\tdata :\n\t\t\ttypeof data === 'string' ?\n\t\t\t\tdata\n\t\t\t\t\t.replace( _re_new_lines, \" \" )\n\t\t\t\t\t.replace( _re_html, \"\" ) :\n\t\t\t\t'';\n\t},\n\n\tstring: function ( data ) {\n\t\treturn _empty(data) ?\n\t\t\tdata :\n\t\t\ttypeof data === 'string' ?\n\t\t\t\tdata.replace( _re_new_lines, \" \" ) :\n\t\t\t\tdata;\n\t}\n} );\n\n\n\nvar __numericReplace = function ( d, decimalPlace, re1, re2 ) {\n\tif ( d !== 0 && (!d || d === '-') ) {\n\t\treturn -Infinity;\n\t}\n\t\n\tlet type = typeof d;\n\n\tif (type === 'number' || type === 'bigint') {\n\t\treturn d;\n\t}\n\n\t// If a decimal place other than `.` is used, it needs to be given to the\n\t// function so we can detect it and replace with a `.` which is the only\n\t// decimal place Javascript recognises - it is not locale aware.\n\tif ( decimalPlace ) {\n\t\td = _numToDecimal( d, decimalPlace );\n\t}\n\n\tif ( d.replace ) {\n\t\tif ( re1 ) {\n\t\t\td = d.replace( re1, '' );\n\t\t}\n\n\t\tif ( re2 ) {\n\t\t\td = d.replace( re2, '' );\n\t\t}\n\t}\n\n\treturn d * 1;\n};\n\n\n// Add the numeric 'deformatting' functions for sorting and search. This is done\n// in a function to provide an easy ability for the language options to add\n// additional methods if a non-period decimal place is used.\nfunction _addNumericSort ( decimalPlace ) {\n\t$.each(\n\t\t{\n\t\t\t// Plain numbers\n\t\t\t\"num\": function ( d ) {\n\t\t\t\treturn __numericReplace( d, decimalPlace );\n\t\t\t},\n\n\t\t\t// Formatted numbers\n\t\t\t\"num-fmt\": function ( d ) {\n\t\t\t\treturn __numericReplace( d, decimalPlace, _re_formatted_numeric );\n\t\t\t},\n\n\t\t\t// HTML numeric\n\t\t\t\"html-num\": function ( d ) {\n\t\t\t\treturn __numericReplace( d, decimalPlace, _re_html );\n\t\t\t},\n\n\t\t\t// HTML numeric, formatted\n\t\t\t\"html-num-fmt\": function ( d ) {\n\t\t\t\treturn __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );\n\t\t\t}\n\t\t},\n\t\tfunction ( key, fn ) {\n\t\t\t// Add the ordering method\n\t\t\t_ext.type.order[ key+decimalPlace+'-pre' ] = fn;\n\n\t\t\t// For HTML types add a search formatter that will strip the HTML\n\t\t\tif ( key.match(/^html\\-/) ) {\n\t\t\t\t_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;\n\t\t\t}\n\t\t}\n\t);\n}\n\n\n// Default sort methods\n$.extend( _ext.type.order, {\n\t// Dates\n\t\"date-pre\": function ( d ) {\n\t\tvar ts = Date.parse( d );\n\t\treturn isNaN(ts) ? -Infinity : ts;\n\t},\n\n\t// html\n\t\"html-pre\": function ( a ) {\n\t\treturn _empty(a) ?\n\t\t\t'' :\n\t\t\ta.replace ?\n\t\t\t\ta.replace( /<.*?>/g, \"\" ).toLowerCase() :\n\t\t\t\ta+'';\n\t},\n\n\t// string\n\t\"string-pre\": function ( a ) {\n\t\t// This is a little complex, but faster than always calling toString,\n\t\t// http://jsperf.com/tostring-v-check\n\t\treturn _empty(a) ?\n\t\t\t'' :\n\t\t\ttypeof a === 'string' ?\n\t\t\t\ta.toLowerCase() :\n\t\t\t\t! a.toString ?\n\t\t\t\t\t'' :\n\t\t\t\t\ta.toString();\n\t},\n\n\t// string-asc and -desc are retained only for compatibility with the old\n\t// sort methods\n\t\"string-asc\": function ( x, y ) {\n\t\treturn ((x < y) ? -1 : ((x > y) ? 1 : 0));\n\t},\n\n\t\"string-desc\": function ( x, y ) {\n\t\treturn ((x < y) ? 1 : ((x > y) ? -1 : 0));\n\t}\n} );\n\n\n// Numeric sorting types - order doesn't matter here\n_addNumericSort( '' );\n\n\n$.extend( true, DataTable.ext.renderer, {\n\theader: {\n\t\t_: function ( settings, cell, column, classes ) {\n\t\t\t// No additional mark-up required\n\t\t\t// Attach a sort listener to update on sort - note that using the\n\t\t\t// `DT` namespace will allow the event to be removed automatically\n\t\t\t// on destroy, while the `dt` namespaced event is the one we are\n\t\t\t// listening for\n\t\t\t$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {\n\t\t\t\tif ( settings !== ctx ) { // need to check this this is the host\n\t\t\t\t\treturn;               // table, not a nested one\n\t\t\t\t}\n\n\t\t\t\tvar colIdx = column.idx;\n\n\t\t\t\tcell\n\t\t\t\t\t.removeClass(\n\t\t\t\t\t\tclasses.sSortAsc +' '+\n\t\t\t\t\t\tclasses.sSortDesc\n\t\t\t\t\t)\n\t\t\t\t\t.addClass( columns[ colIdx ] == 'asc' ?\n\t\t\t\t\t\tclasses.sSortAsc : columns[ colIdx ] == 'desc' ?\n\t\t\t\t\t\t\tclasses.sSortDesc :\n\t\t\t\t\t\t\tcolumn.sSortingClass\n\t\t\t\t\t);\n\t\t\t} );\n\t\t},\n\n\t\tjqueryui: function ( settings, cell, column, classes ) {\n\t\t\t$('<div/>')\n\t\t\t\t.addClass( classes.sSortJUIWrapper )\n\t\t\t\t.append( cell.contents() )\n\t\t\t\t.append( $('<span/>')\n\t\t\t\t\t.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )\n\t\t\t\t)\n\t\t\t\t.appendTo( cell );\n\n\t\t\t// Attach a sort listener to update on sort\n\t\t\t$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {\n\t\t\t\tif ( settings !== ctx ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar colIdx = column.idx;\n\n\t\t\t\tcell\n\t\t\t\t\t.removeClass( classes.sSortAsc +\" \"+classes.sSortDesc )\n\t\t\t\t\t.addClass( columns[ colIdx ] == 'asc' ?\n\t\t\t\t\t\tclasses.sSortAsc : columns[ colIdx ] == 'desc' ?\n\t\t\t\t\t\t\tclasses.sSortDesc :\n\t\t\t\t\t\t\tcolumn.sSortingClass\n\t\t\t\t\t);\n\n\t\t\t\tcell\n\t\t\t\t\t.find( 'span.'+classes.sSortIcon )\n\t\t\t\t\t.removeClass(\n\t\t\t\t\t\tclasses.sSortJUIAsc +\" \"+\n\t\t\t\t\t\tclasses.sSortJUIDesc +\" \"+\n\t\t\t\t\t\tclasses.sSortJUI +\" \"+\n\t\t\t\t\t\tclasses.sSortJUIAscAllowed +\" \"+\n\t\t\t\t\t\tclasses.sSortJUIDescAllowed\n\t\t\t\t\t)\n\t\t\t\t\t.addClass( columns[ colIdx ] == 'asc' ?\n\t\t\t\t\t\tclasses.sSortJUIAsc : columns[ colIdx ] == 'desc' ?\n\t\t\t\t\t\t\tclasses.sSortJUIDesc :\n\t\t\t\t\t\t\tcolumn.sSortingClassJUI\n\t\t\t\t\t);\n\t\t\t} );\n\t\t}\n\t}\n} );\n\n/*\n * Public helper functions. These aren't used internally by DataTables, or\n * called by any of the options passed into DataTables, but they can be used\n * externally by developers working with DataTables. They are helper functions\n * to make working with DataTables a little bit easier.\n */\n\nvar __htmlEscapeEntities = function ( d ) {\n\tif (Array.isArray(d)) {\n\t\td = d.join(',');\n\t}\n\n\treturn typeof d === 'string' ?\n\t\td\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(/\"/g, '&quot;') :\n\t\td;\n};\n\n// Common logic for moment, luxon or a date action\nfunction __mld( dt, momentFn, luxonFn, dateFn, arg1 ) {\n\tif (window.moment) {\n\t\treturn dt[momentFn]( arg1 );\n\t}\n\telse if (window.luxon) {\n\t\treturn dt[luxonFn]( arg1 );\n\t}\n\t\n\treturn dateFn ? dt[dateFn]( arg1 ) : dt;\n}\n\n\nvar __mlWarning = false;\nfunction __mldObj (d, format, locale) {\n\tvar dt;\n\n\tif (window.moment) {\n\t\tdt = window.moment.utc( d, format, locale, true );\n\n\t\tif (! dt.isValid()) {\n\t\t\treturn null;\n\t\t}\n\t}\n\telse if (window.luxon) {\n\t\tdt = format && typeof d === 'string'\n\t\t\t? window.luxon.DateTime.fromFormat( d, format )\n\t\t\t: window.luxon.DateTime.fromISO( d );\n\n\t\tif (! dt.isValid) {\n\t\t\treturn null;\n\t\t}\n\n\t\tdt.setLocale(locale);\n\t}\n\telse if (! format) {\n\t\t// No format given, must be ISO\n\t\tdt = new Date(d);\n\t}\n\telse {\n\t\tif (! __mlWarning) {\n\t\t\talert('DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17');\n\t\t}\n\n\t\t__mlWarning = true;\n\t}\n\n\treturn dt;\n}\n\n// Wrapper for date, datetime and time which all operate the same way with the exception of\n// the output string for auto locale support\nfunction __mlHelper (localeString) {\n\treturn function ( from, to, locale, def ) {\n\t\t// Luxon and Moment support\n\t\t// Argument shifting\n\t\tif ( arguments.length === 0 ) {\n\t\t\tlocale = 'en';\n\t\t\tto = null; // means toLocaleString\n\t\t\tfrom = null; // means iso8601\n\t\t}\n\t\telse if ( arguments.length === 1 ) {\n\t\t\tlocale = 'en';\n\t\t\tto = from;\n\t\t\tfrom = null;\n\t\t}\n\t\telse if ( arguments.length === 2 ) {\n\t\t\tlocale = to;\n\t\t\tto = from;\n\t\t\tfrom = null;\n\t\t}\n\n\t\tvar typeName = 'datetime-' + to;\n\n\t\t// Add type detection and sorting specific to this date format - we need to be able to identify\n\t\t// date type columns as such, rather than as numbers in extensions. Hence the need for this.\n\t\tif (! DataTable.ext.type.order[typeName]) {\n\t\t\t// The renderer will give the value to type detect as the type!\n\t\t\tDataTable.ext.type.detect.unshift(function (d) {\n\t\t\t\treturn d === typeName ? typeName : false;\n\t\t\t});\n\n\t\t\t// The renderer gives us Moment, Luxon or Date obects for the sorting, all of which have a\n\t\t\t// `valueOf` which gives milliseconds epoch\n\t\t\tDataTable.ext.type.order[typeName + '-asc'] = function (a, b) {\n\t\t\t\tvar x = a.valueOf();\n\t\t\t\tvar y = b.valueOf();\n\n\t\t\t\treturn x === y\n\t\t\t\t\t? 0\n\t\t\t\t\t: x < y\n\t\t\t\t\t\t? -1\n\t\t\t\t\t\t: 1;\n\t\t\t}\n\n\t\t\tDataTable.ext.type.order[typeName + '-desc'] = function (a, b) {\n\t\t\t\tvar x = a.valueOf();\n\t\t\t\tvar y = b.valueOf();\n\n\t\t\t\treturn x === y\n\t\t\t\t\t? 0\n\t\t\t\t\t: x > y\n\t\t\t\t\t\t? -1\n\t\t\t\t\t\t: 1;\n\t\t\t}\n\t\t}\n\t\n\t\treturn function ( d, type ) {\n\t\t\t// Allow for a default value\n\t\t\tif (d === null || d === undefined) {\n\t\t\t\tif (def === '--now') {\n\t\t\t\t\t// We treat everything as UTC further down, so no changes are\n\t\t\t\t\t// made, as such need to get the local date / time as if it were\n\t\t\t\t\t// UTC\n\t\t\t\t\tvar local = new Date();\n\t\t\t\t\td = new Date( Date.UTC(\n\t\t\t\t\t\tlocal.getFullYear(), local.getMonth(), local.getDate(),\n\t\t\t\t\t\tlocal.getHours(), local.getMinutes(), local.getSeconds()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type === 'type') {\n\t\t\t\t// Typing uses the type name for fast matching\n\t\t\t\treturn typeName;\n\t\t\t}\n\n\t\t\tif (d === '') {\n\t\t\t\treturn type !== 'sort'\n\t\t\t\t\t? ''\n\t\t\t\t\t: __mldObj('0000-01-01 00:00:00', null, locale);\n\t\t\t}\n\n\t\t\t// Shortcut. If `from` and `to` are the same, we are using the renderer to\n\t\t\t// format for ordering, not display - its already in the display format.\n\t\t\tif ( to !== null && from === to && type !== 'sort' && type !== 'type' && ! (d instanceof Date) ) {\n\t\t\t\treturn d;\n\t\t\t}\n\n\t\t\tvar dt = __mldObj(d, from, locale);\n\n\t\t\tif (dt === null) {\n\t\t\t\treturn d;\n\t\t\t}\n\n\t\t\tif (type === 'sort') {\n\t\t\t\treturn dt;\n\t\t\t}\n\t\t\t\n\t\t\tvar formatted = to === null\n\t\t\t\t? __mld(dt, 'toDate', 'toJSDate', '')[localeString]()\n\t\t\t\t: __mld(dt, 'format', 'toFormat', 'toISOString', to);\n\n\t\t\t// XSS protection\n\t\t\treturn type === 'display' ?\n\t\t\t\t__htmlEscapeEntities( formatted ) :\n\t\t\t\tformatted;\n\t\t};\n\t}\n}\n\n// Based on locale, determine standard number formatting\n// Fallback for legacy browsers is US English\nvar __thousands = ',';\nvar __decimal = '.';\n\nif (Intl) {\n\ttry {\n\t\tvar num = new Intl.NumberFormat().formatToParts(100000.1);\n\t\n\t\tfor (var i=0 ; i<num.length ; i++) {\n\t\t\tif (num[i].type === 'group') {\n\t\t\t\t__thousands = num[i].value;\n\t\t\t}\n\t\t\telse if (num[i].type === 'decimal') {\n\t\t\t\t__decimal = num[i].value;\n\t\t\t}\n\t\t}\n\t}\n\tcatch (e) {\n\t\t// noop\n\t}\n}\n\n// Formatted date time detection - use by declaring the formats you are going to use\nDataTable.datetime = function ( format, locale ) {\n\tvar typeName = 'datetime-detect-' + format;\n\n\tif (! locale) {\n\t\tlocale = 'en';\n\t}\n\n\tif (! DataTable.ext.type.order[typeName]) {\n\t\tDataTable.ext.type.detect.unshift(function (d) {\n\t\t\tvar dt = __mldObj(d, format, locale);\n\t\t\treturn d === '' || dt ? typeName : false;\n\t\t});\n\n\t\tDataTable.ext.type.order[typeName + '-pre'] = function (d) {\n\t\t\treturn __mldObj(d, format, locale) || 0;\n\t\t}\n\t}\n}\n\n/**\n * Helpers for `columns.render`.\n *\n * The options defined here can be used with the `columns.render` initialisation\n * option to provide a display renderer. The following functions are defined:\n *\n * * `number` - Will format numeric data (defined by `columns.data`) for\n *   display, retaining the original unformatted data for sorting and filtering.\n *   It takes 5 parameters:\n *   * `string` - Thousands grouping separator\n *   * `string` - Decimal point indicator\n *   * `integer` - Number of decimal points to show\n *   * `string` (optional) - Prefix.\n *   * `string` (optional) - Postfix (/suffix).\n * * `text` - Escape HTML to help prevent XSS attacks. It has no optional\n *   parameters.\n *\n * @example\n *   // Column definition using the number renderer\n *   {\n *     data: \"salary\",\n *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\n *   }\n *\n * @namespace\n */\nDataTable.render = {\n\tdate: __mlHelper('toLocaleDateString'),\n\tdatetime: __mlHelper('toLocaleString'),\n\ttime: __mlHelper('toLocaleTimeString'),\n\tnumber: function ( thousands, decimal, precision, prefix, postfix ) {\n\t\t// Auto locale detection\n\t\tif (thousands === null || thousands === undefined) {\n\t\t\tthousands = __thousands;\n\t\t}\n\n\t\tif (decimal === null || decimal === undefined) {\n\t\t\tdecimal = __decimal;\n\t\t}\n\n\t\treturn {\n\t\t\tdisplay: function ( d ) {\n\t\t\t\tif ( typeof d !== 'number' && typeof d !== 'string' ) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\n\t\t\t\tif (d === '' || d === null) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\n\t\t\t\tvar negative = d < 0 ? '-' : '';\n\t\t\t\tvar flo = parseFloat( d );\n\n\t\t\t\t// If NaN then there isn't much formatting that we can do - just\n\t\t\t\t// return immediately, escaping any HTML (this was supposed to\n\t\t\t\t// be a number after all)\n\t\t\t\tif ( isNaN( flo ) ) {\n\t\t\t\t\treturn __htmlEscapeEntities( d );\n\t\t\t\t}\n\n\t\t\t\tflo = flo.toFixed( precision );\n\t\t\t\td = Math.abs( flo );\n\n\t\t\t\tvar intPart = parseInt( d, 10 );\n\t\t\t\tvar floatPart = precision ?\n\t\t\t\t\tdecimal+(d - intPart).toFixed( precision ).substring( 2 ):\n\t\t\t\t\t'';\n\n\t\t\t\t// If zero, then can't have a negative prefix\n\t\t\t\tif (intPart === 0 && parseFloat(floatPart) === 0) {\n\t\t\t\t\tnegative = '';\n\t\t\t\t}\n\n\t\t\t\treturn negative + (prefix||'') +\n\t\t\t\t\tintPart.toString().replace(\n\t\t\t\t\t\t/\\B(?=(\\d{3})+(?!\\d))/g, thousands\n\t\t\t\t\t) +\n\t\t\t\t\tfloatPart +\n\t\t\t\t\t(postfix||'');\n\t\t\t}\n\t\t};\n\t},\n\n\ttext: function () {\n\t\treturn {\n\t\t\tdisplay: __htmlEscapeEntities,\n\t\t\tfilter: __htmlEscapeEntities\n\t\t};\n\t}\n};\n\n\n/*\n * This is really a good bit rubbish this method of exposing the internal methods\n * publicly... - To be fixed in 2.0 using methods on the prototype\n */\n\n\n/**\n * Create a wrapper function for exporting an internal functions to an external API.\n *  @param {string} fn API function name\n *  @returns {function} wrapped function\n *  @memberof DataTable#internal\n */\nfunction _fnExternApiFunc (fn)\n{\n\treturn function() {\n\t\tvar args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(\n\t\t\tArray.prototype.slice.call(arguments)\n\t\t);\n\t\treturn DataTable.ext.internal[fn].apply( this, args );\n\t};\n}\n\n\n/**\n * Reference to internal functions for use by plug-in developers. Note that\n * these methods are references to internal functions and are considered to be\n * private. If you use these methods, be aware that they are liable to change\n * between versions.\n *  @namespace\n */\n$.extend( DataTable.ext.internal, {\n\t_fnExternApiFunc: _fnExternApiFunc,\n\t_fnBuildAjax: _fnBuildAjax,\n\t_fnAjaxUpdate: _fnAjaxUpdate,\n\t_fnAjaxParameters: _fnAjaxParameters,\n\t_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\n\t_fnAjaxDataSrc: _fnAjaxDataSrc,\n\t_fnAddColumn: _fnAddColumn,\n\t_fnColumnOptions: _fnColumnOptions,\n\t_fnAdjustColumnSizing: _fnAdjustColumnSizing,\n\t_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\n\t_fnColumnIndexToVisible: _fnColumnIndexToVisible,\n\t_fnVisbleColumns: _fnVisbleColumns,\n\t_fnGetColumns: _fnGetColumns,\n\t_fnColumnTypes: _fnColumnTypes,\n\t_fnApplyColumnDefs: _fnApplyColumnDefs,\n\t_fnHungarianMap: _fnHungarianMap,\n\t_fnCamelToHungarian: _fnCamelToHungarian,\n\t_fnLanguageCompat: _fnLanguageCompat,\n\t_fnBrowserDetect: _fnBrowserDetect,\n\t_fnAddData: _fnAddData,\n\t_fnAddTr: _fnAddTr,\n\t_fnNodeToDataIndex: _fnNodeToDataIndex,\n\t_fnNodeToColumnIndex: _fnNodeToColumnIndex,\n\t_fnGetCellData: _fnGetCellData,\n\t_fnSetCellData: _fnSetCellData,\n\t_fnSplitObjNotation: _fnSplitObjNotation,\n\t_fnGetObjectDataFn: _fnGetObjectDataFn,\n\t_fnSetObjectDataFn: _fnSetObjectDataFn,\n\t_fnGetDataMaster: _fnGetDataMaster,\n\t_fnClearTable: _fnClearTable,\n\t_fnDeleteIndex: _fnDeleteIndex,\n\t_fnInvalidate: _fnInvalidate,\n\t_fnGetRowElements: _fnGetRowElements,\n\t_fnCreateTr: _fnCreateTr,\n\t_fnBuildHead: _fnBuildHead,\n\t_fnDrawHead: _fnDrawHead,\n\t_fnDraw: _fnDraw,\n\t_fnReDraw: _fnReDraw,\n\t_fnAddOptionsHtml: _fnAddOptionsHtml,\n\t_fnDetectHeader: _fnDetectHeader,\n\t_fnGetUniqueThs: _fnGetUniqueThs,\n\t_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\n\t_fnFilterComplete: _fnFilterComplete,\n\t_fnFilterCustom: _fnFilterCustom,\n\t_fnFilterColumn: _fnFilterColumn,\n\t_fnFilter: _fnFilter,\n\t_fnFilterCreateSearch: _fnFilterCreateSearch,\n\t_fnEscapeRegex: _fnEscapeRegex,\n\t_fnFilterData: _fnFilterData,\n\t_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\n\t_fnUpdateInfo: _fnUpdateInfo,\n\t_fnInfoMacros: _fnInfoMacros,\n\t_fnInitialise: _fnInitialise,\n\t_fnInitComplete: _fnInitComplete,\n\t_fnLengthChange: _fnLengthChange,\n\t_fnFeatureHtmlLength: _fnFeatureHtmlLength,\n\t_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\n\t_fnPageChange: _fnPageChange,\n\t_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\n\t_fnProcessingDisplay: _fnProcessingDisplay,\n\t_fnFeatureHtmlTable: _fnFeatureHtmlTable,\n\t_fnScrollDraw: _fnScrollDraw,\n\t_fnApplyToChildren: _fnApplyToChildren,\n\t_fnCalculateColumnWidths: _fnCalculateColumnWidths,\n\t_fnThrottle: _fnThrottle,\n\t_fnConvertToWidth: _fnConvertToWidth,\n\t_fnGetWidestNode: _fnGetWidestNode,\n\t_fnGetMaxLenString: _fnGetMaxLenString,\n\t_fnStringToCss: _fnStringToCss,\n\t_fnSortFlatten: _fnSortFlatten,\n\t_fnSort: _fnSort,\n\t_fnSortAria: _fnSortAria,\n\t_fnSortListener: _fnSortListener,\n\t_fnSortAttachListener: _fnSortAttachListener,\n\t_fnSortingClasses: _fnSortingClasses,\n\t_fnSortData: _fnSortData,\n\t_fnSaveState: _fnSaveState,\n\t_fnLoadState: _fnLoadState,\n\t_fnImplementState: _fnImplementState,\n\t_fnSettingsFromNode: _fnSettingsFromNode,\n\t_fnLog: _fnLog,\n\t_fnMap: _fnMap,\n\t_fnBindAction: _fnBindAction,\n\t_fnCallbackReg: _fnCallbackReg,\n\t_fnCallbackFire: _fnCallbackFire,\n\t_fnLengthOverflow: _fnLengthOverflow,\n\t_fnRenderer: _fnRenderer,\n\t_fnDataSource: _fnDataSource,\n\t_fnRowAttributes: _fnRowAttributes,\n\t_fnExtend: _fnExtend,\n\t_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant\n\t                                // in 1.10, so this dead-end function is\n\t                                // added to prevent errors\n} );\n\n\n// jQuery access\n$.fn.dataTable = DataTable;\n\n// Provide access to the host jQuery object (circular reference)\nDataTable.$ = $;\n\n// Legacy aliases\n$.fn.dataTableSettings = DataTable.settings;\n$.fn.dataTableExt = DataTable.ext;\n\n// With a capital `D` we return a DataTables API instance rather than a\n// jQuery object\n$.fn.DataTable = function ( opts ) {\n\treturn $(this).dataTable( opts ).api();\n};\n\n// All properties that are available to $.fn.dataTable should also be\n// available on $.fn.DataTable\n$.each( DataTable, function ( prop, val ) {\n\t$.fn.DataTable[ prop ] = val;\n} );\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQvanMvanF1ZXJ5LmRhdGFUYWJsZXMubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUU0Qjs7QUFFNUI7QUFDQTtBQUNBLFFBQVEsbUNBQU07OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLEdBQUc7QUFDZixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdC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QkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixrQkFBa0IsT0FBTztBQUN6QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLDBCQUEwQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLEtBQUs7QUFDakIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksUUFBUTtBQUNwQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7O0FBR0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOzs7QUFHQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxRQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLElBQUksV0FBVztBQUNmLElBQUksV0FBVztBQUNmLElBQUksV0FBVztBQUNmLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0Msc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFFBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7Ozs7O0FBTUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QixLQUFLLFFBQVE7QUFDYixLQUFLLFFBQVEsdUJBQXVCLFFBQVE7QUFDNUMsS0FBSyxPQUFPO0FBQ1osS0FBSyxPQUFPO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsR0FBRztBQUNoQixhQUFhLGNBQWM7QUFDM0IsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxlQUFlLHdDQUF3QztBQUN2RCxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLHdDQUF3QztBQUN2RCxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQ0FBZ0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlDQUFpQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLHdCQUF3Qjs7O0FBR3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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eUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxLQUFLLGdDQUFnQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssaUNBQWlDO0FBQ3RDO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGlFQUFlLFNBQVMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC9qcy9qcXVlcnkuZGF0YVRhYmxlcy5tanM/MzI2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgRGF0YVRhYmxlcyAxLjEzLjRcbiAqIMKpMjAwOC0yMDIzIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuXG4vLyBEYXRhVGFibGVzIGNvZGUgdXNlcyAkIGludGVybmFsbHksIGJ1dCB3ZSB3YW50IHRvIGJlIGFibGUgdG9cbi8vIHJlYXNzaWduICQgd2l0aCB0aGUgYHVzZWAgbWV0aG9kLCBzbyBpdCBpcyBhIHJlZ3VsYXIgdmFyLlxubGV0ICQgPSBqUXVlcnk7XG5cblxudmFyIERhdGFUYWJsZSA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdGlvbnMgKVxue1xuXHQvLyBDaGVjayBpZiBjYWxsZWQgd2l0aCBhIHdpbmRvdyBvciBqUXVlcnkgb2JqZWN0IGZvciBET00gbGVzcyBhcHBsaWNhdGlvbnNcblx0Ly8gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0aWYgKERhdGFUYWJsZS5mYWN0b3J5KHNlbGVjdG9yLCBvcHRpb25zKSkge1xuXHRcdHJldHVybiBEYXRhVGFibGU7XG5cdH1cblxuXHQvLyBXaGVuIGNyZWF0aW5nIHdpdGggYG5ld2AsIGNyZWF0ZSBhIG5ldyBEYXRhVGFibGUsIHJldHVybmluZyB0aGUgQVBJIGluc3RhbmNlXG5cdGlmICh0aGlzIGluc3RhbmNlb2YgRGF0YVRhYmxlKSB7XG5cdFx0cmV0dXJuICQoc2VsZWN0b3IpLkRhdGFUYWJsZShvcHRpb25zKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBBcmd1bWVudCBzd2l0Y2hpbmdcblx0XHRvcHRpb25zID0gc2VsZWN0b3I7XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBhY3Rpb24gb24gdGhlIHRhYmxlJ3MgVFIgZWxlbWVudHMgKGZyb20gdGhlIHRib2R5KSBhbmRcblx0ICogcmV0dXJuIHRoZSByZXN1bHRpbmcgalF1ZXJ5IG9iamVjdC5cblx0ICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBzU2VsZWN0b3IgalF1ZXJ5IHNlbGVjdG9yIG9yIG5vZGUgY29sbGVjdGlvbiB0byBhY3Qgb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5maWx0ZXI9bm9uZV0gU2VsZWN0IFRSIGVsZW1lbnRzIHRoYXQgbWVldCB0aGUgY3VycmVudCBmaWx0ZXJcblx0ICogICAgY3JpdGVyaW9uIChcImFwcGxpZWRcIikgb3IgYWxsIFRSIGVsZW1lbnRzIChpLmUuIG5vIGZpbHRlcikuXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBUUiBlbGVtZW50cyBpbiB0aGUgcHJvY2Vzc2VkIGFycmF5LlxuXHQgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuXHQgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLnBhZ2U9YWxsXSBMaW1pdCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2Vcblx0ICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuXHQgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuXHQgKiAgQHJldHVybnMge29iamVjdH0galF1ZXJ5IG9iamVjdCwgZmlsdGVyZWQgYnkgdGhlIGdpdmVuIHNlbGVjdG9yLlxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiAgICAgIC8vIEhpZ2hsaWdodCBldmVyeSBzZWNvbmQgcm93XG5cdCAqICAgICAgb1RhYmxlLiQoJ3RyOm9kZCcpLmNzcygnYmFja2dyb3VuZENvbG9yJywgJ2JsdWUnKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqICAgICAgLy8gRmlsdGVyIHRvIHJvd3Mgd2l0aCAnV2Via2l0JyBpbiB0aGVtLCBhZGQgYSBiYWNrZ3JvdW5kIGNvbG91ciBhbmQgdGhlblxuXHQgKiAgICAgIC8vIHJlbW92ZSB0aGUgZmlsdGVyLCB0aHVzIGhpZ2hsaWdodGluZyB0aGUgJ1dlYmtpdCcgcm93cyBvbmx5LlxuXHQgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XG5cdCAqICAgICAgb1RhYmxlLiQoJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSkuY3NzKCdiYWNrZ3JvdW5kQ29sb3InLCAnYmx1ZScpO1xuXHQgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignJyk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuJCA9IGZ1bmN0aW9uICggc1NlbGVjdG9yLCBvT3B0cyApXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5hcGkodHJ1ZSkuJCggc1NlbGVjdG9yLCBvT3B0cyApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBBbG1vc3QgaWRlbnRpY2FsIHRvICQgaW4gb3BlcmF0aW9uLCBidXQgaW4gdGhpcyBjYXNlIHJldHVybnMgdGhlIGRhdGEgZm9yIHRoZSBtYXRjaGVkXG5cdCAqIHJvd3MgLSBhcyBzdWNoLCB0aGUgalF1ZXJ5IHNlbGVjdG9yIHVzZWQgc2hvdWxkIG1hdGNoIFRSIHJvdyBub2RlcyBvciBURC9USCBjZWxsIG5vZGVzXG5cdCAqIHJhdGhlciB0aGFuIGFueSBkZXNjZW5kYW50cywgc28gdGhlIGRhdGEgY2FuIGJlIG9idGFpbmVkIGZvciB0aGUgcm93L2NlbGwuIElmIG1hdGNoaW5nXG5cdCAqIHJvd3MgYXJlIGZvdW5kLCB0aGUgZGF0YSByZXR1cm5lZCBpcyB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheS9vYmplY3QgdGhhdCB3YXMgdXNlZCB0b1xuXHQgKiBjcmVhdGUgdGhlIHJvdyAob3IgYSBnZW5lcmF0ZWQgYXJyYXkgaWYgZnJvbSBhIERPTSBzb3VyY2UpLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvZnRlbiB1c2VmdWwgaW4tY29tYmluYXRpb24gd2l0aCAkIHdoZXJlIGJvdGggZnVuY3Rpb25zIGFyZSBnaXZlbiB0aGVcblx0ICogc2FtZSBwYXJhbWV0ZXJzIGFuZCB0aGUgYXJyYXkgaW5kZXhlcyB3aWxsIG1hdGNoIGlkZW50aWNhbGx5LlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IFtvT3B0c10gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgbW9kaWZ5aW5nIHRoZSByb3dzIHRvIGJlIGluY2x1ZGVkXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuXHQgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cblx0ICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMub3JkZXI9Y3VycmVudF0gT3JkZXIgb2YgdGhlIGRhdGEgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cblx0ICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3Jcblx0ICogICAgJ29yaWdpbmFsJyB3aGVyZWJ5IHRoZSBvcmlnaW5hbCBvcmRlciB0aGUgZGF0YSB3YXMgcmVhZCBpbnRvIHRoZSB0YWJsZSBpcyB1c2VkLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG5cdCAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcblx0ICogICAgJ2N1cnJlbnQnIGFuZCBmaWx0ZXIgaXMgJ2FwcGxpZWQnLCByZWdhcmRsZXNzIG9mIHdoYXQgdGhleSBtaWdodCBiZSBnaXZlbiBhcy5cblx0ICogIEByZXR1cm5zIHthcnJheX0gRGF0YSBmb3IgdGhlIG1hdGNoZWQgZWxlbWVudHMuIElmIGFueSBlbGVtZW50cywgYXMgYSByZXN1bHQgb2YgdGhlXG5cdCAqICAgIHNlbGVjdG9yLCB3ZXJlIG5vdCBUUiwgVEQgb3IgVEggZWxlbWVudHMgaW4gdGhlIERhdGFUYWJsZSwgdGhleSB3aWxsIGhhdmUgYSBudWxsXG5cdCAqICAgIGVudHJ5IGluIHRoZSBhcnJheS5cblx0ICogIEBkdG9wdCBBUElcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICpcblx0ICogICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZVxuXHQgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyOmZpcnN0Jyk7XG5cdCAqXG5cdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBkYXRhXG5cdCAqICAgICAgYWxlcnQoIFwiRmlyc3QgY2VsbCBpczogXCIrZGF0YVswXSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICpcblx0ICogICAgICAvLyBGaWx0ZXIgdG8gJ1dlYmtpdCcgYW5kIGdldCBhbGwgZGF0YSBmb3Jcblx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuXHQgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSk7XG5cdCAqXG5cdCAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGFcblx0ICogICAgICBhbGVydCggZGF0YS5sZW5ndGgrXCIgcm93cyBtYXRjaGVkIHRoZSBzZWFyY2hcIiApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR0aGlzLl8gPSBmdW5jdGlvbiAoIHNTZWxlY3Rvciwgb09wdHMgKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuYXBpKHRydWUpLnJvd3MoIHNTZWxlY3Rvciwgb09wdHMgKS5kYXRhKCk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIERhdGFUYWJsZXMgQXBpIGluc3RhbmNlLCB3aXRoIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFibGVzIGZvclxuXHQgKiB0aGUgQXBpJ3MgY29udGV4dC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbdHJhZGl0aW9uYWw9ZmFsc2VdIFNldCB0aGUgQVBJIGluc3RhbmNlJ3MgY29udGV4dCB0byBiZVxuXHQgKiAgIG9ubHkgdGhlIHRhYmxlIHJlZmVycmVkIHRvIGJ5IHRoZSBgRGF0YVRhYmxlLmV4dC5pQXBpSW5kZXhgIG9wdGlvbiwgYXMgd2FzXG5cdCAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxuXHQgKiAgIG9yIGlmIGFsbCB0YWJsZXMgY2FwdHVyZWQgaW4gdGhlIGpRdWVyeSBvYmplY3Qgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4ge0RhdGFUYWJsZXMuQXBpfVxuXHQgKi9cblx0dGhpcy5hcGkgPSBmdW5jdGlvbiAoIHRyYWRpdGlvbmFsIClcblx0e1xuXHRcdHJldHVybiB0cmFkaXRpb25hbCA/XG5cdFx0XHRuZXcgX0FwaShcblx0XHRcdFx0X2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1sgX2V4dC5pQXBpSW5kZXggXSApXG5cdFx0XHQpIDpcblx0XHRcdG5ldyBfQXBpKCB0aGlzICk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXG5cdCAqIHRoYXQgdGhpcyBpcyBzdWl0YWJsZSBmb3IgY2xpZW50LXNpZGUgcHJvY2Vzc2luZyBvbmx5IC0gaWYgeW91IGFyZSB1c2luZ1xuXHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIChpLmUuIFwiYlNlcnZlclNpZGVcIjogdHJ1ZSksIHRoZW4gdG8gYWRkIGRhdGEsIHlvdVxuXHQgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cblx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGJlIGFkZGVkIHRvIHRoZSB0YWJsZS4gVGhpcyBjYW4gYmU6XG5cdCAqICAgIDx1bD5cblx0ICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XG5cdCAqICAgICAgPGxpPjJEIGFycmF5IG9mIGFycmF5cyAtIGFkZCBtdWx0aXBsZSByb3dzIGluIGEgc2luZ2xlIGNhbGw8L2xpPlxuXHQgKiAgICAgIDxsaT5vYmplY3QgLSBkYXRhIG9iamVjdCB3aGVuIHVzaW5nIDxpPm1EYXRhPC9pPjwvbGk+XG5cdCAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxuXHQgKiAgICA8L3VsPlxuXHQgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxuXHQgKiAgICA8aT5hb0RhdGE8L2k+ICh7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9KSB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0b1xuXHQgKiAgICB0aGUgdGFibGUuXG5cdCAqICBAZHRvcHQgQVBJXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gR2xvYmFsIHZhciBmb3IgY291bnRlclxuXHQgKiAgICB2YXIgZ2lDb3VudCA9IDI7XG5cdCAqXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogICAgZnVuY3Rpb24gZm5DbGlja0FkZFJvdygpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xuXHQgKiAgICAgICAgZ2lDb3VudCtcIi4xXCIsXG5cdCAqICAgICAgICBnaUNvdW50K1wiLjJcIixcblx0ICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxuXHQgKiAgICAgICAgZ2lDb3VudCtcIi40XCIgXVxuXHQgKiAgICAgICk7XG5cdCAqXG5cdCAqICAgICAgZ2lDb3VudCsrO1xuXHQgKiAgICB9XG5cdCAqL1xuXHR0aGlzLmZuQWRkRGF0YSA9IGZ1bmN0aW9uKCBkYXRhLCByZWRyYXcgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFxuXHRcdC8qIENoZWNrIGlmIHdlIHdhbnQgdG8gYWRkIG11bHRpcGxlIHJvd3Mgb3Igbm90ICovXG5cdFx0dmFyIHJvd3MgPSBBcnJheS5pc0FycmF5KGRhdGEpICYmICggQXJyYXkuaXNBcnJheShkYXRhWzBdKSB8fCAkLmlzUGxhaW5PYmplY3QoZGF0YVswXSkgKSA/XG5cdFx0XHRhcGkucm93cy5hZGQoIGRhdGEgKSA6XG5cdFx0XHRhcGkucm93LmFkZCggZGF0YSApO1xuXHRcblx0XHRpZiAoIHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdyApIHtcblx0XHRcdGFwaS5kcmF3KCk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gcm93cy5mbGF0dGVuKCkudG9BcnJheSgpO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbWFrZSBEYXRhVGFibGVzIHJlY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6ZXMsIGJhc2VkIG9uIHRoZSBkYXRhXG5cdCAqIGNvbnRhaW5lZCBpbiB0aGUgdGFibGUgYW5kIHRoZSBzaXplcyBhcHBsaWVkIHRvIHRoZSBjb2x1bW5zIChpbiB0aGUgRE9NLCBDU1Mgb3Jcblx0ICogdGhyb3VnaCB0aGUgc1dpZHRoIHBhcmFtZXRlcikuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUnc1xuXHQgKiBwYXJlbnQgZWxlbWVudCBjaGFuZ2VzIChmb3IgZXhhbXBsZSBhIHdpbmRvdyByZXNpemUpLlxuXHQgKiAgQHBhcmFtIHtib29sZWFufSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdCwgeW91IHdpbGwgdHlwaWNhbGx5IHdhbnQgdG9cblx0ICogIEBkdG9wdCBBUElcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic1Njcm9sbFlcIjogXCIyMDBweFwiLFxuXHQgKiAgICAgICAgXCJiUGFnaW5hdGVcIjogZmFsc2Vcblx0ICogICAgICB9ICk7XG5cdCAqXG5cdCAqICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgICBvVGFibGUuZm5BZGp1c3RDb2x1bW5TaXppbmcoKTtcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5BZGp1c3RDb2x1bW5TaXppbmcgPSBmdW5jdGlvbiAoIGJSZWRyYXcgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHR2YXIgc2V0dGluZ3MgPSBhcGkuc2V0dGluZ3MoKVswXTtcblx0XHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0XG5cdFx0aWYgKCBiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdyApIHtcblx0XHRcdGFwaS5kcmF3KCBmYWxzZSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2Nyb2xsLnNYICE9PSBcIlwiIHx8IHNjcm9sbC5zWSAhPT0gXCJcIiApIHtcblx0XHRcdC8qIElmIG5vdCByZWRyYXdpbmcsIGJ1dCBzY3JvbGxpbmcsIHdlIHdhbnQgdG8gYXBwbHkgdGhlIG5ldyBjb2x1bW4gc2l6ZXMgYW55d2F5ICovXG5cdFx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHRcdH1cblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogUXVpY2tseSBhbmQgc2ltcGx5IGNsZWFyIGEgdGFibGVcblx0ICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3Rcblx0ICogIEBkdG9wdCBBUElcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICpcblx0ICogICAgICAvLyBJbW1lZGlhdGVseSAnbnVrZScgdGhlIGN1cnJlbnQgcm93cyAocGVyaGFwcyB3YWl0aW5nIGZvciBhbiBBamF4IGNhbGxiYWNrLi4uKVxuXHQgKiAgICAgIG9UYWJsZS5mbkNsZWFyVGFibGUoKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mbkNsZWFyVGFibGUgPSBmdW5jdGlvbiggYlJlZHJhdyApXG5cdHtcblx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5jbGVhcigpO1xuXHRcblx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0YXBpLmRyYXcoKTtcblx0XHR9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRoZSBleGFjdCBvcHBvc2l0ZSBvZiAnb3BlbmluZycgYSByb3csIHRoaXMgZnVuY3Rpb24gd2lsbCBjbG9zZSBhbnkgcm93cyB3aGljaFxuXHQgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cblx0ICogIEBwYXJhbSB7bm9kZX0gblRyIHRoZSB0YWJsZSByb3cgdG8gJ2Nsb3NlJ1xuXHQgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCBvciAxIGlmIGZhaWxlZCAoY2FuJ3QgZmluZCB0aGUgcm93KVxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGU7XG5cdCAqXG5cdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0ICogICAgICAgIH0gZWxzZSB7XG5cdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKlxuXHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5DbG9zZSA9IGZ1bmN0aW9uKCBuVHIgKVxuXHR7XG5cdFx0dGhpcy5hcGkoIHRydWUgKS5yb3coIG5UciApLmNoaWxkLmhpZGUoKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlIGEgcm93IGZvciB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7bWl4ZWR9IHRhcmdldCBUaGUgaW5kZXggb2YgdGhlIHJvdyBmcm9tIGFvRGF0YSB0byBiZSBkZWxldGVkLCBvclxuXHQgKiAgICB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudCB0byBkZWxldGVcblx0ICogIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gW2NhbGxCYWNrXSBDYWxsYmFjayBmdW5jdGlvblxuXHQgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7YXJyYXl9IFRoZSByb3cgdGhhdCB3YXMgZGVsZXRlZFxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgZmlyc3Qgcm93XG5cdCAqICAgICAgb1RhYmxlLmZuRGVsZXRlUm93KCAwICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5EZWxldGVSb3cgPSBmdW5jdGlvbiggdGFyZ2V0LCBjYWxsYmFjaywgcmVkcmF3IClcblx0e1xuXHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcdHZhciByb3dzID0gYXBpLnJvd3MoIHRhcmdldCApO1xuXHRcdHZhciBzZXR0aW5ncyA9IHJvd3Muc2V0dGluZ3MoKVswXTtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93c1swXVswXSBdO1xuXHRcblx0XHRyb3dzLnJlbW92ZSgpO1xuXHRcblx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpcywgc2V0dGluZ3MsIGRhdGEgKTtcblx0XHR9XG5cdFxuXHRcdGlmICggcmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3ICkge1xuXHRcdFx0YXBpLmRyYXcoKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXN0b3JlIHRoZSB0YWJsZSB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIGluIHRoZSBET00gYnkgcmVtb3ZpbmcgYWxsIG9mIERhdGFUYWJsZXNcblx0ICogZW5oYW5jZW1lbnRzLCBhbHRlcmF0aW9ucyB0byB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdGFibGUgYW5kIGV2ZW50IGxpc3RlbmVycy5cblx0ICogIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZT1mYWxzZV0gQ29tcGxldGVseSByZW1vdmUgdGhlIHRhYmxlIGZyb20gdGhlIERPTVxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIC8vIFRoaXMgZXhhbXBsZSBpcyBmYWlybHkgcG9pbnRsZXNzIGluIHJlYWxpdHksIGJ1dCBzaG93cyBob3cgZm5EZXN0cm95IGNhbiBiZSB1c2VkXG5cdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgICAgb1RhYmxlLmZuRGVzdHJveSgpO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR0aGlzLmZuRGVzdHJveSA9IGZ1bmN0aW9uICggcmVtb3ZlIClcblx0e1xuXHRcdHRoaXMuYXBpKCB0cnVlICkuZGVzdHJveSggcmVtb3ZlICk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlZHJhdyB0aGUgdGFibGVcblx0ICogIEBwYXJhbSB7Ym9vbH0gW2NvbXBsZXRlPXRydWVdIFJlLWZpbHRlciBhbmQgcmVzb3J0IChpZiBlbmFibGVkKSB0aGUgdGFibGUgYmVmb3JlIHRoZSBkcmF3LlxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiAgICAgIC8vIFJlLWRyYXcgdGhlIHRhYmxlIC0geW91IHdvdWxkbid0IHdhbnQgdG8gZG8gaXQgaGVyZSwgYnV0IGl0J3MgYW4gZXhhbXBsZSA6LSlcblx0ICogICAgICBvVGFibGUuZm5EcmF3KCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5EcmF3ID0gZnVuY3Rpb24oIGNvbXBsZXRlIClcblx0e1xuXHRcdC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGFuIGV4YWN0IG1hdGNoIHRvIHRoZSBvbGQgY2FsbCB0byBfZm5EcmF3IC0gaXQgdGFrZXNcblx0XHQvLyBpbnRvIGFjY291bnQgdGhlIG5ldyBkYXRhLCBidXQgY2FuIGhvbGQgcG9zaXRpb24uXG5cdFx0dGhpcy5hcGkoIHRydWUgKS5kcmF3KCBjb21wbGV0ZSApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBGaWx0ZXIgdGhlIGlucHV0IGJhc2VkIG9uIGRhdGFcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgU3RyaW5nIHRvIGZpbHRlciB0aGUgdGFibGUgb25cblx0ICogIEBwYXJhbSB7aW50fG51bGx9IFtpQ29sdW1uXSBDb2x1bW4gdG8gbGltaXQgZmlsdGVyaW5nIHRvXG5cdCAqICBAcGFyYW0ge2Jvb2x9IFtiUmVnZXg9ZmFsc2VdIFRyZWF0IGFzIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gW2JTbWFydD10cnVlXSBQZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3Rcblx0ICogIEBwYXJhbSB7Ym9vbH0gW2JTaG93R2xvYmFsPXRydWVdIFNob3cgdGhlIGlucHV0IGdsb2JhbCBmaWx0ZXIgaW4gaXQncyBpbnB1dCBib3goZXMpXG5cdCAqICBAcGFyYW0ge2Jvb2x9IFtiQ2FzZUluc2Vuc2l0aXZlPXRydWVdIERvIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG5cdCAqICBAZHRvcHQgQVBJXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqICAgICAgLy8gU29tZXRpbWUgbGF0ZXIgLSBmaWx0ZXIuLi5cblx0ICogICAgICBvVGFibGUuZm5GaWx0ZXIoICd0ZXN0IHN0cmluZycgKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mbkZpbHRlciA9IGZ1bmN0aW9uKCBzSW5wdXQsIGlDb2x1bW4sIGJSZWdleCwgYlNtYXJ0LCBiU2hvd0dsb2JhbCwgYkNhc2VJbnNlbnNpdGl2ZSApXG5cdHtcblx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKTtcblx0XG5cdFx0aWYgKCBpQ29sdW1uID09PSBudWxsIHx8IGlDb2x1bW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGFwaS5zZWFyY2goIHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRhcGkuY29sdW1uKCBpQ29sdW1uICkuc2VhcmNoKCBzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0fVxuXHRcblx0XHRhcGkuZHJhdygpO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB3aG9sZSB0YWJsZSwgYW4gaW5kaXZpZHVhbCByb3cgb3IgYW4gaW5kaXZpZHVhbCBjZWxsIGJhc2VkIG9uIHRoZVxuXHQgKiBwcm92aWRlZCBwYXJhbWV0ZXJzLlxuXHQgKiAgQHBhcmFtIHtpbnR8bm9kZX0gW3NyY10gQSBUUiByb3cgbm9kZSwgVEQvVEggY2VsbCBub2RlIG9yIGFuIGludGVnZXIuIElmIGdpdmVuIGFzXG5cdCAqICAgIGEgVFIgbm9kZSB0aGVuIHRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhXG5cdCAqICAgIFREL1RIIGNlbGwgbm9kZSB0aGVuIGlDb2wgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYW5kIHRoZSBkYXRhIGZvciB0aGVcblx0ICogICAgY2VsbCByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYW4gaW50ZWdlciwgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgdGhlIGFvRGF0YSBpbnRlcm5hbFxuXHQgKiAgICBkYXRhIGluZGV4IGZvciB0aGUgcm93IChzZWUgZm5HZXRQb3NpdGlvbikgYW5kIHRoZSBkYXRhIGZvciB0aGF0IHJvdyB1c2VkLlxuXHQgKiAgQHBhcmFtIHtpbnR9IFtjb2xdIE9wdGlvbmFsIGNvbHVtbiBpbmRleCB0aGF0IHlvdSB3YW50IHRoZSBkYXRhIG9mLlxuXHQgKiAgQHJldHVybnMge2FycmF5fG9iamVjdHxzdHJpbmd9IElmIG1Sb3cgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBkYXRhIGZvciBhbGwgcm93cyBpc1xuXHQgKiAgICByZXR1cm5lZC4gSWYgbVJvdyBpcyBkZWZpbmVkLCBqdXN0IGRhdGEgZm9yIHRoYXQgcm93LCBhbmQgaXMgaUNvbCBpc1xuXHQgKiAgICBkZWZpbmVkLCBvbmx5IGRhdGEgZm9yIHRoZSBkZXNpZ25hdGVkIGNlbGwgaXMgcmV0dXJuZWQuXG5cdCAqICBAZHRvcHQgQVBJXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gUm93IGRhdGFcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICpcblx0ICogICAgICBvVGFibGUuJCgndHInKS5jbGljayggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICAgdmFyIGRhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XG5cdCAqICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFycmF5IC8gb2JqZWN0IG9mIGRhdGEgZm9yIHRoZSByb3dcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIEluZGl2aWR1YWwgY2VsbCBkYXRhXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqICAgICAgb1RhYmxlLiQoJ3RkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAgIHZhciBzRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIHRoaXMgKTtcblx0ICogICAgICAgIGFsZXJ0KCAnVGhlIGNlbGwgY2xpY2tlZCBvbiBoYWQgdGhlIHZhbHVlIG9mICcrc0RhdGEgKTtcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5HZXREYXRhID0gZnVuY3Rpb24oIHNyYywgY29sIClcblx0e1xuXHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcblx0XHRpZiAoIHNyYyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFyIHR5cGUgPSBzcmMubm9kZU5hbWUgPyBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xuXHRcblx0XHRcdHJldHVybiBjb2wgIT09IHVuZGVmaW5lZCB8fCB0eXBlID09ICd0ZCcgfHwgdHlwZSA9PSAndGgnID9cblx0XHRcdFx0YXBpLmNlbGwoIHNyYywgY29sICkuZGF0YSgpIDpcblx0XHRcdFx0YXBpLnJvdyggc3JjICkuZGF0YSgpIHx8IG51bGw7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gYXBpLmRhdGEoKS50b0FycmF5KCk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCBhbiBhcnJheSBvZiB0aGUgVFIgbm9kZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUncyBib2R5LiBOb3RlIHRoYXQgeW91IHdpbGxcblx0ICogdHlwaWNhbGx5IHdhbnQgdG8gdXNlIHRoZSAnJCcgQVBJIG1ldGhvZCBpbiBwcmVmZXJlbmNlIHRvIHRoaXMgYXMgaXQgaXMgbW9yZVxuXHQgKiBmbGV4aWJsZS5cblx0ICogIEBwYXJhbSB7aW50fSBbaVJvd10gT3B0aW9uYWwgcm93IGluZGV4IGZvciB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudFxuXHQgKiAgQHJldHVybnMge2FycmF5fG5vZGV9IElmIGlSb3cgaXMgdW5kZWZpbmVkLCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBUUiBlbGVtZW50c1xuXHQgKiAgICBpbiB0aGUgdGFibGUncyBib2R5LCBvciBpUm93IGlzIGRlZmluZWQsIGp1c3QgdGhlIFRSIGVsZW1lbnQgcmVxdWVzdGVkLlxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiAgICAgIC8vIEdldCB0aGUgbm9kZXMgZnJvbSB0aGUgdGFibGVcblx0ICogICAgICB2YXIgbk5vZGVzID0gb1RhYmxlLmZuR2V0Tm9kZXMoICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5HZXROb2RlcyA9IGZ1bmN0aW9uKCBpUm93IClcblx0e1xuXHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApO1xuXHRcblx0XHRyZXR1cm4gaVJvdyAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGFwaS5yb3coIGlSb3cgKS5ub2RlKCkgOlxuXHRcdFx0YXBpLnJvd3MoKS5ub2RlcygpLmZsYXR0ZW4oKS50b0FycmF5KCk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEdldCB0aGUgYXJyYXkgaW5kZXhlcyBvZiBhIHBhcnRpY3VsYXIgY2VsbCBmcm9tIGl0J3MgRE9NIGVsZW1lbnRcblx0ICogYW5kIGNvbHVtbiBpbmRleCBpbmNsdWRpbmcgaGlkZGVuIGNvbHVtbnNcblx0ICogIEBwYXJhbSB7bm9kZX0gbm9kZSB0aGlzIGNhbiBlaXRoZXIgYmUgYSBUUiwgVEQgb3IgVEggaW4gdGhlIHRhYmxlJ3MgYm9keVxuXHQgKiAgQHJldHVybnMge2ludH0gSWYgbk5vZGUgaXMgZ2l2ZW4gYXMgYSBUUiwgdGhlbiBhIHNpbmdsZSBpbmRleCBpcyByZXR1cm5lZCwgb3Jcblx0ICogICAgaWYgZ2l2ZW4gYXMgYSBjZWxsLCBhbiBhcnJheSBvZiBbcm93IGluZGV4LCBjb2x1bW4gaW5kZXggKHZpc2libGUpLFxuXHQgKiAgICBjb2x1bW4gaW5kZXggKGFsbCldIGlzIGdpdmVuLlxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0YSBmcm9tIHRoZSBub2RlXG5cdCAqICAgICAgICB2YXIgYVBvcyA9IG9UYWJsZS5mbkdldFBvc2l0aW9uKCB0aGlzICk7XG5cdCAqXG5cdCAqICAgICAgICAvLyBHZXQgdGhlIGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdCAqICAgICAgICB2YXIgYURhdGEgPSBvVGFibGUuZm5HZXREYXRhKCBhUG9zWzBdICk7XG5cdCAqXG5cdCAqICAgICAgICAvLyBVcGRhdGUgdGhlIGRhdGEgYXJyYXkgYW5kIHJldHVybiB0aGUgdmFsdWVcblx0ICogICAgICAgIGFEYXRhWyBhUG9zWzFdIF0gPSAnY2xpY2tlZCc7XG5cdCAqICAgICAgICB0aGlzLmlubmVySFRNTCA9ICdjbGlja2VkJztcblx0ICogICAgICB9ICk7XG5cdCAqXG5cdCAqICAgICAgLy8gSW5pdCBEYXRhVGFibGVzXG5cdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mbkdldFBvc2l0aW9uID0gZnVuY3Rpb24oIG5vZGUgKVxuXHR7XG5cdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFx0dmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcblx0XHRpZiAoIG5vZGVOYW1lID09ICdUUicgKSB7XG5cdFx0XHRyZXR1cm4gYXBpLnJvdyggbm9kZSApLmluZGV4KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBub2RlTmFtZSA9PSAnVEQnIHx8IG5vZGVOYW1lID09ICdUSCcgKSB7XG5cdFx0XHR2YXIgY2VsbCA9IGFwaS5jZWxsKCBub2RlICkuaW5kZXgoKTtcblx0XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRjZWxsLnJvdyxcblx0XHRcdFx0Y2VsbC5jb2x1bW5WaXNpYmxlLFxuXHRcdFx0XHRjZWxsLmNvbHVtblxuXHRcdFx0XTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENoZWNrIHRvIHNlZSBpZiBhIHJvdyBpcyAnb3Blbicgb3Igbm90LlxuXHQgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byBjaGVja1xuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdyBpcyBjdXJyZW50bHkgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqICBAZHRvcHQgQVBJXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgdmFyIG9UYWJsZTtcblx0ICpcblx0ICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuXHQgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xuXHQgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuXHQgKiAgICAgICAgfSBlbHNlIHtcblx0ICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcblx0ICogICAgICAgIH1cblx0ICogICAgICB9ICk7XG5cdCAqXG5cdCAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mbklzT3BlbiA9IGZ1bmN0aW9uKCBuVHIgKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuYXBpKCB0cnVlICkucm93KCBuVHIgKS5jaGlsZC5pc1Nob3duKCk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XG5cdCAqIG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UsIHdpdGggdGhlIEhUTUwgY29udGVudHMgdGhhdCBpcyBwYXNzZWQgaW50byB0aGVcblx0ICogZnVuY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBhc2sgZm9yIGNvbmZpcm1hdGlvbiB0aGF0IGFcblx0ICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXG5cdCAqICBAcGFyYW0ge25vZGV9IG5UciBUaGUgdGFibGUgcm93IHRvICdvcGVuJ1xuXHQgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IG1IdG1sIFRoZSBIVE1MIHRvIHB1dCBpbnRvIHRoZSByb3dcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcblx0ICogIEByZXR1cm5zIHtub2RlfSBUaGUgcm93IG9wZW5lZC4gTm90ZSB0aGF0IGlmIHRoZSB0YWJsZSByb3cgcGFzc2VkIGluIGFzIHRoZVxuXHQgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIGlzIG5vdCBmb3VuZCBpbiB0aGUgdGFibGUsIHRoaXMgbWV0aG9kIHdpbGwgc2lsZW50bHlcblx0ICogICAgcmV0dXJuLlxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGU7XG5cdCAqXG5cdCAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cblx0ICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcblx0ICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcblx0ICogICAgICAgIH0gZWxzZSB7XG5cdCAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKlxuXHQgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5PcGVuID0gZnVuY3Rpb24oIG5UciwgbUh0bWwsIHNDbGFzcyApXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5hcGkoIHRydWUgKVxuXHRcdFx0LnJvdyggblRyIClcblx0XHRcdC5jaGlsZCggbUh0bWwsIHNDbGFzcyApXG5cdFx0XHQuc2hvdygpXG5cdFx0XHQuY2hpbGQoKVswXTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSBwYWdpbmF0aW9uIC0gcHJvdmlkZXMgdGhlIGludGVybmFsIGxvZ2ljIGZvciBwYWdpbmF0aW9uIGluIGEgc2ltcGxlIEFQSVxuXHQgKiBmdW5jdGlvbi4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gaGF2ZSBhIERhdGFUYWJsZXMgdGFibGUgZ28gdG8gdGhlIG5leHQsXG5cdCAqIHByZXZpb3VzLCBmaXJzdCBvciBsYXN0IHBhZ2VzLlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBtQWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsIFwibmV4dFwiIG9yIFwibGFzdFwiXG5cdCAqICAgIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpLCBub3RlIHRoYXQgcGFnZSAwIGlzIHRoZSBmaXJzdCBwYWdlLlxuXHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKiAgICAgIG9UYWJsZS5mblBhZ2VDaGFuZ2UoICduZXh0JyApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHR0aGlzLmZuUGFnZUNoYW5nZSA9IGZ1bmN0aW9uICggbUFjdGlvbiwgYlJlZHJhdyApXG5cdHtcblx0XHR2YXIgYXBpID0gdGhpcy5hcGkoIHRydWUgKS5wYWdlKCBtQWN0aW9uICk7XG5cdFxuXHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRhcGkuZHJhdyhmYWxzZSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBTaG93IGEgcGFydGljdWxhciBjb2x1bW5cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sIFRoZSBjb2x1bW4gd2hvc2UgZGlzcGxheSBzaG91bGQgYmUgY2hhbmdlZFxuXHQgKiAgQHBhcmFtIHtib29sfSBiU2hvdyBTaG93ICh0cnVlKSBvciBoaWRlIChmYWxzZSkgdGhlIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiAgICAgIC8vIEhpZGUgdGhlIHNlY29uZCBjb2x1bW4gYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0ICogICAgICBvVGFibGUuZm5TZXRDb2x1bW5WaXMoIDEsIGZhbHNlICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5TZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIGlDb2wsIGJTaG93LCBiUmVkcmF3IClcblx0e1xuXHRcdHZhciBhcGkgPSB0aGlzLmFwaSggdHJ1ZSApLmNvbHVtbiggaUNvbCApLnZpc2libGUoIGJTaG93ICk7XG5cdFxuXHRcdGlmICggYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcgKSB7XG5cdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKS5kcmF3KCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNldHRpbmdzIGZvciBhIHBhcnRpY3VsYXIgdGFibGUgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuXHQgKiAgQHJldHVybnMge29iamVjdH0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFNlZVxuXHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqICBAZHRvcHQgQVBJXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqICAgICAgdmFyIG9TZXR0aW5ncyA9IG9UYWJsZS5mblNldHRpbmdzKCk7XG5cdCAqXG5cdCAqICAgICAgLy8gU2hvdyBhbiBleGFtcGxlIHBhcmFtZXRlciBmcm9tIHRoZSBzZXR0aW5nc1xuXHQgKiAgICAgIGFsZXJ0KCBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mblNldHRpbmdzID0gZnVuY3Rpb24oKVxuXHR7XG5cdFx0cmV0dXJuIF9mblNldHRpbmdzRnJvbU5vZGUoIHRoaXNbX2V4dC5pQXBpSW5kZXhdICk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFNvcnQgdGhlIHRhYmxlIGJ5IGEgcGFydGljdWxhciBjb2x1bW5cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sIHRoZSBkYXRhIGluZGV4IHRvIHNvcnQgb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IG1hdGNoIHRoZVxuXHQgKiAgICAnZGlzcGxheSBpbmRleCcgaWYgeW91IGhhdmUgaGlkZGVuIGRhdGEgZW50cmllc1xuXHQgKiAgQGR0b3B0IEFQSVxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuXHQgKlxuXHQgKiAgICAgIC8vIFNvcnQgaW1tZWRpYXRlbHkgd2l0aCBjb2x1bW5zIDAgYW5kIDFcblx0ICogICAgICBvVGFibGUuZm5Tb3J0KCBbIFswLCdhc2MnXSwgWzEsJ2FzYyddIF0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mblNvcnQgPSBmdW5jdGlvbiggYWFTb3J0IClcblx0e1xuXHRcdHRoaXMuYXBpKCB0cnVlICkub3JkZXIoIGFhU29ydCApLmRyYXcoKTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuXHQgKiAgQHBhcmFtIHtub2RlfSBuTm9kZSB0aGUgZWxlbWVudCB0byBhdHRhY2ggdGhlIHNvcnQgbGlzdGVuZXIgdG9cblx0ICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cblx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFtmbkNhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG5cdCAqICBAZHRvcHQgQVBJXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG5cdCAqXG5cdCAqICAgICAgLy8gU29ydCBvbiBjb2x1bW4gMSwgd2hlbiAnc29ydGVyJyBpcyBjbGlja2VkIG9uXG5cdCAqICAgICAgb1RhYmxlLmZuU29ydExpc3RlbmVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29ydGVyJyksIDEgKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mblNvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApXG5cdHtcblx0XHR0aGlzLmFwaSggdHJ1ZSApLm9yZGVyLmxpc3RlbmVyKCBuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayApO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBVcGRhdGUgYSB0YWJsZSBjZWxsIG9yIHJvdyAtIHRoaXMgbWV0aG9kIHdpbGwgYWNjZXB0IGVpdGhlciBhIHNpbmdsZSB2YWx1ZSB0b1xuXHQgKiB1cGRhdGUgdGhlIGNlbGwgd2l0aCwgYW4gYXJyYXkgb2YgdmFsdWVzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggY29sdW1uIG9yXG5cdCAqIGFuIG9iamVjdCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlLiBUaGUgZnVuY3Rpb24gaXNcblx0ICogc2VsZi1yZWZlcmVuY2luZyBpbiBvcmRlciB0byBtYWtlIHRoZSBtdWx0aSBjb2x1bW4gdXBkYXRlcyBlYXNpZXIuXG5cdCAqICBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd9IG1EYXRhIERhdGEgdG8gdXBkYXRlIHRoZSBjZWxsL3JvdyB3aXRoXG5cdCAqICBAcGFyYW0ge25vZGV8aW50fSBtUm93IFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gdXBkYXRlIG9yIHRoZSBhb0RhdGEgaW5kZXhcblx0ICogIEBwYXJhbSB7aW50fSBbaUNvbHVtbl0gVGhlIGNvbHVtbiB0byB1cGRhdGUsIGdpdmUgYXMgbnVsbCBvciB1bmRlZmluZWQgdG9cblx0ICogICAgdXBkYXRlIGEgd2hvbGUgcm93LlxuXHQgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuXHQgKiAgQHBhcmFtIHtib29sfSBbYkFjdGlvbj10cnVlXSBQZXJmb3JtIHByZS1kcmF3IGFjdGlvbnMgb3Igbm90XG5cdCAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIDEgb24gZXJyb3Jcblx0ICogIEBkdG9wdCBBUElcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgICBvVGFibGUuZm5VcGRhdGUoICdFeGFtcGxlIHVwZGF0ZScsIDAsIDAgKTsgLy8gU2luZ2xlIGNlbGxcblx0ICogICAgICBvVGFibGUuZm5VcGRhdGUoIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sICQoJ3Rib2R5IHRyJylbMF0gKTsgLy8gUm93XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdHRoaXMuZm5VcGRhdGUgPSBmdW5jdGlvbiggbURhdGEsIG1Sb3csIGlDb2x1bW4sIGJSZWRyYXcsIGJBY3Rpb24gKVxuXHR7XG5cdFx0dmFyIGFwaSA9IHRoaXMuYXBpKCB0cnVlICk7XG5cdFxuXHRcdGlmICggaUNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGlDb2x1bW4gPT09IG51bGwgKSB7XG5cdFx0XHRhcGkucm93KCBtUm93ICkuZGF0YSggbURhdGEgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRhcGkuY2VsbCggbVJvdywgaUNvbHVtbiApLmRhdGEoIG1EYXRhICk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGJBY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBiQWN0aW9uICkge1xuXHRcdFx0YXBpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0fVxuXHRcblx0XHRpZiAoIGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3ICkge1xuXHRcdFx0YXBpLmRyYXcoKTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nIHVzZWQsIGluIG9yZGVyXG5cdCAqIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNWZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuIE5vdGUgdGhhdCB0aGVcblx0ICogICAgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgcmVxdWlyZWRcblx0ICogICAgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3Qgc3VpdGFibGVcblx0ICogIEBtZXRob2Rcblx0ICogIEBkdG9wdCBBUElcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0ICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcblx0ICogICAgICBhbGVydCggb1RhYmxlLmZuVmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0dGhpcy5mblZlcnNpb25DaGVjayA9IF9leHQuZm5WZXJzaW9uQ2hlY2s7XG5cdFxuXG5cdHZhciBfdGhhdCA9IHRoaXM7XG5cdHZhciBlbXB0eUluaXQgPSBvcHRpb25zID09PSB1bmRlZmluZWQ7XG5cdHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRpZiAoIGVtcHR5SW5pdCApIHtcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHR0aGlzLm9BcGkgPSB0aGlzLmludGVybmFsID0gX2V4dC5pbnRlcm5hbDtcblxuXHQvLyBFeHRlbmQgd2l0aCBvbGQgc3R5bGUgcGx1Zy1pbiBBUEkgbWV0aG9kc1xuXHRmb3IgKCB2YXIgZm4gaW4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCApIHtcblx0XHRpZiAoIGZuICkge1xuXHRcdFx0dGhpc1tmbl0gPSBfZm5FeHRlcm5BcGlGdW5jKGZuKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0Ly8gRm9yIGVhY2ggaW5pdGlhbGlzYXRpb24gd2Ugd2FudCB0byBnaXZlIGl0IGEgY2xlYW4gaW5pdGlhbGlzYXRpb25cblx0XHQvLyBvYmplY3QgdGhhdCBjYW4gYmUgYmFzaGVkIGFyb3VuZFxuXHRcdHZhciBvID0ge307XG5cdFx0dmFyIG9Jbml0ID0gbGVuID4gMSA/IC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIHRhYmxlIGNhc2Vcblx0XHRcdF9mbkV4dGVuZCggbywgb3B0aW9ucywgdHJ1ZSApIDpcblx0XHRcdG9wdGlvbnM7XG5cblx0XHQvKmdsb2JhbCBvSW5pdCxfdGhhdCxlbXB0eUluaXQqL1xuXHRcdHZhciBpPTAsIGlMZW4sIGosIGpMZW4sIGssIGtMZW47XG5cdFx0dmFyIHNJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0dmFyIGJJbml0SGFuZGVkT2ZmID0gZmFsc2U7XG5cdFx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xuXHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XG5cdFx0XG5cdFx0LyogU2FuaXR5IGNoZWNrICovXG5cdFx0aWYgKCB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJyApXG5cdFx0e1xuXHRcdFx0X2ZuTG9nKCBudWxsLCAwLCAnTm9uLXRhYmxlIG5vZGUgaW5pdGlhbGlzYXRpb24gKCcrdGhpcy5ub2RlTmFtZSsnKScsIDIgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBkZWZhdWx0cyAqL1xuXHRcdF9mbkNvbXBhdE9wdHMoIGRlZmF1bHRzICk7XG5cdFx0X2ZuQ29tcGF0Q29scyggZGVmYXVsdHMuY29sdW1uICk7XG5cdFx0XG5cdFx0LyogQ29udmVydCB0aGUgY2FtZWwtY2FzZSBkZWZhdWx0cyB0byBIdW5nYXJpYW4gKi9cblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgZGVmYXVsdHMsIHRydWUgKTtcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cy5jb2x1bW4sIGRlZmF1bHRzLmNvbHVtbiwgdHJ1ZSApO1xuXHRcdFxuXHRcdC8qIFNldHRpbmcgdXAgdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdCAqL1xuXHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCAkLmV4dGVuZCggb0luaXQsICR0aGlzLmRhdGEoKSApLCB0cnVlICk7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xuXHRcdHZhciBhbGxTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0XHRmb3IgKCBpPTAsIGlMZW49YWxsU2V0dGluZ3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgcyA9IGFsbFNldHRpbmdzW2ldO1xuXHRcdFxuXHRcdFx0LyogQmFzZSBjaGVjayBvbiB0YWJsZSBub2RlICovXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHMublRhYmxlID09IHRoaXMgfHxcblx0XHRcdFx0KHMublRIZWFkICYmIHMublRIZWFkLnBhcmVudE5vZGUgPT0gdGhpcykgfHxcblx0XHRcdFx0KHMublRGb290ICYmIHMublRGb290LnBhcmVudE5vZGUgPT0gdGhpcylcblx0XHRcdCkge1xuXHRcdFx0XHR2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG5cdFx0XHRcdHZhciBiRGVzdHJveSA9IG9Jbml0LmJEZXN0cm95ICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iRGVzdHJveSA6IGRlZmF1bHRzLmJEZXN0cm95O1xuXHRcdFxuXHRcdFx0XHRpZiAoIGVtcHR5SW5pdCB8fCBiUmV0cmlldmUgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHMub0luc3RhbmNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBiRGVzdHJveSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZm5Mb2coIHMsIDAsICdDYW5ub3QgcmVpbml0aWFsaXNlIERhdGFUYWJsZScsIDMgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcblx0XHRcdC8qIElmIHRoZSBlbGVtZW50IHdlIGFyZSBpbml0aWFsaXNpbmcgaGFzIHRoZSBzYW1lIElEIGFzIGEgdGFibGUgd2hpY2ggd2FzIHByZXZpb3VzbHlcblx0XHRcdCAqIGluaXRpYWxpc2VkLCBidXQgdGhlIHRhYmxlIG5vZGVzIGRvbid0IG1hdGNoIChmcm9tIGJlZm9yZSkgdGhlbiB3ZSBkZXN0cm95IHRoZSBvbGRcblx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0ICogZGVzdHJveWVkIGJ5IG90aGVyIG1ldGhvZHMuIEFueW9uZSB1c2luZyBub24taWQgc2VsZWN0b3JzIHdpbGwgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5XG5cdFx0XHQgKi9cblx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdHtcblx0XHRcdFx0YWxsU2V0dGluZ3Muc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiBFbnN1cmUgdGhlIHRhYmxlIGhhcyBhbiBJRCAtIHJlcXVpcmVkIGZvciBhY2Nlc3NpYmlsaXR5ICovXG5cdFx0aWYgKCBzSWQgPT09IG51bGwgfHwgc0lkID09PSBcIlwiIClcblx0XHR7XG5cdFx0XHRzSWQgPSBcIkRhdGFUYWJsZXNfVGFibGVfXCIrKERhdGFUYWJsZS5leHQuX3VuaXF1ZSsrKTtcblx0XHRcdHRoaXMuaWQgPSBzSWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIENyZWF0ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGlzIHRhYmxlIGFuZCBzZXQgc29tZSBvZiB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzICovXG5cdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFwic0Rlc3Ryb3lXaWR0aFwiOiAkdGhpc1swXS5zdHlsZS53aWR0aCxcblx0XHRcdFwic0luc3RhbmNlXCI6ICAgICBzSWQsXG5cdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkXG5cdFx0fSApO1xuXHRcdG9TZXR0aW5ncy5uVGFibGUgPSB0aGlzO1xuXHRcdG9TZXR0aW5ncy5vQXBpICAgPSBfdGhhdC5pbnRlcm5hbDtcblx0XHRvU2V0dGluZ3Mub0luaXQgID0gb0luaXQ7XG5cdFx0XG5cdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XG5cdFx0Ly8gTmVlZCB0byBhZGQgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIGFkZGVkXG5cdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRvU2V0dGluZ3Mub0luc3RhbmNlID0gKF90aGF0Lmxlbmd0aD09PTEpID8gX3RoYXQgOiAkdGhpcy5kYXRhVGFibGUoKTtcblx0XHRcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRfZm5Db21wYXRPcHRzKCBvSW5pdCApO1xuXHRcdF9mbkxhbmd1YWdlQ29tcGF0KCBvSW5pdC5vTGFuZ3VhZ2UgKTtcblx0XHRcblx0XHQvLyBJZiB0aGUgbGVuZ3RoIG1lbnUgaXMgZ2l2ZW4sIGJ1dCB0aGUgaW5pdCBkaXNwbGF5IGxlbmd0aCBpcyBub3QsIHVzZSB0aGUgbGVuZ3RoIG1lbnVcblx0XHRpZiAoIG9Jbml0LmFMZW5ndGhNZW51ICYmICEgb0luaXQuaURpc3BsYXlMZW5ndGggKVxuXHRcdHtcblx0XHRcdG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gQXJyYXkuaXNBcnJheSggb0luaXQuYUxlbmd0aE1lbnVbMF0gKSA/XG5cdFx0XHRcdG9Jbml0LmFMZW5ndGhNZW51WzBdWzBdIDogb0luaXQuYUxlbmd0aE1lbnVbMF07XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFwcGx5IHRoZSBkZWZhdWx0cyBhbmQgaW5pdCBvcHRpb25zIHRvIG1ha2UgYSBzaW5nbGUgaW5pdCBvYmplY3Qgd2lsbCBhbGxcblx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRvSW5pdCA9IF9mbkV4dGVuZCggJC5leHRlbmQoIHRydWUsIHt9LCBkZWZhdWx0cyApLCBvSW5pdCApO1xuXHRcdFxuXHRcdFxuXHRcdC8vIE1hcCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBvbnRvIHRoZSBzZXR0aW5ncyBvYmplY3Rcblx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vRmVhdHVyZXMsIG9Jbml0LCBbXG5cdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XCJiTGVuZ3RoQ2hhbmdlXCIsXG5cdFx0XHRcImJGaWx0ZXJcIixcblx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFwiYlNvcnRNdWx0aVwiLFxuXHRcdFx0XCJiSW5mb1wiLFxuXHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XCJiQXV0b1dpZHRoXCIsXG5cdFx0XHRcImJTb3J0Q2xhc3Nlc1wiLFxuXHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XCJiRGVmZXJSZW5kZXJcIlxuXHRcdF0gKTtcblx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFwiYXNTdHJpcGVDbGFzc2VzXCIsXG5cdFx0XHRcImFqYXhcIixcblx0XHRcdFwiZm5TZXJ2ZXJEYXRhXCIsXG5cdFx0XHRcImZuRm9ybWF0TnVtYmVyXCIsXG5cdFx0XHRcInNTZXJ2ZXJNZXRob2RcIixcblx0XHRcdFwiYWFTb3J0aW5nXCIsXG5cdFx0XHRcImFhU29ydGluZ0ZpeGVkXCIsXG5cdFx0XHRcImFMZW5ndGhNZW51XCIsXG5cdFx0XHRcInNQYWdpbmF0aW9uVHlwZVwiLFxuXHRcdFx0XCJzQWpheFNvdXJjZVwiLFxuXHRcdFx0XCJzQWpheERhdGFQcm9wXCIsXG5cdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcInNEb21cIixcblx0XHRcdFwiYlNvcnRDZWxsc1RvcFwiLFxuXHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiLFxuXHRcdFx0XCJmblN0YXRlU2F2ZUNhbGxiYWNrXCIsXG5cdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcInNlYXJjaERlbGF5XCIsXG5cdFx0XHRcInJvd0lkXCIsXG5cdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRbIFwib1NlYXJjaFwiLCBcIm9QcmV2aW91c1NlYXJjaFwiIF0sXG5cdFx0XHRbIFwiYW9TZWFyY2hDb2xzXCIsIFwiYW9QcmVTZWFyY2hDb2xzXCIgXSxcblx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF1cblx0XHRdICk7XG5cdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub1Njcm9sbCwgb0luaXQsIFtcblx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFsgXCJzU2Nyb2xsWElubmVyXCIsIFwic1hJbm5lclwiIF0sXG5cdFx0XHRbIFwic1Njcm9sbFlcIiwgXCJzWVwiIF0sXG5cdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdF0gKTtcblx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vTGFuZ3VhZ2UsIG9Jbml0LCBcImZuSW5mb0NhbGxiYWNrXCIgKTtcblx0XHRcblx0XHQvKiBDYWxsYmFjayBmdW5jdGlvbnMgd2hpY2ggYXJlIGFycmF5IGRyaXZlbiAqL1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICAgICAgIG9Jbml0LmZuRHJhd0NhbGxiYWNrLCAgICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICAgICAgIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAgICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlU2F2ZVBhcmFtcycsICAgIG9Jbml0LmZuU3RhdGVTYXZlUGFyYW1zLCAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICAgIG9Jbml0LmZuU3RhdGVMb2FkUGFyYW1zLCAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQsICAgICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgICAgICAgIG9Jbml0LmZuUm93Q2FsbGJhY2ssICAgICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG9Jbml0LmZuQ3JlYXRlZFJvdywgICAgICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuRm9vdGVyQ2FsbGJhY2ssICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsICAgICAgIG9Jbml0LmZuSW5pdENvbXBsZXRlLCAgICAgICd1c2VyJyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAgICd1c2VyJyApO1xuXHRcdFxuXHRcdG9TZXR0aW5ncy5yb3dJZEZuID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCBvSW5pdC5yb3dJZCApO1xuXHRcdFxuXHRcdC8qIEJyb3dzZXIgc3VwcG9ydCBkZXRlY3Rpb24gKi9cblx0XHRfZm5Ccm93c2VyRGV0ZWN0KCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XG5cdFx0JC5leHRlbmQoIG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0JHRoaXMuYWRkQ2xhc3MoIG9DbGFzc2VzLnNUYWJsZSApO1xuXHRcdFxuXHRcdFxuXHRcdGlmICggb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID09PSB1bmRlZmluZWQgKVxuXHRcdHtcblx0XHRcdC8qIERpc3BsYXkgc3RhcnQgcG9pbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHNhdmUgc2F2aW5nICovXG5cdFx0XHRvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xuXHRcdFx0b1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCBvSW5pdC5pRGVmZXJMb2FkaW5nICE9PSBudWxsIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyA9IHRydWU7XG5cdFx0XHR2YXIgdG1wID0gQXJyYXkuaXNBcnJheSggb0luaXQuaURlZmVyTG9hZGluZyApO1xuXHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzBdIDogb0luaXQuaURlZmVyTG9hZGluZztcblx0XHRcdG9TZXR0aW5ncy5faVJlY29yZHNUb3RhbCA9IHRtcCA/IG9Jbml0LmlEZWZlckxvYWRpbmdbMV0gOiBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuXHRcdH1cblx0XHRcblx0XHQvKiBMYW5ndWFnZSBkZWZpbml0aW9ucyAqL1xuXHRcdHZhciBvTGFuZ3VhZ2UgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFxuXHRcdGlmICggb0xhbmd1YWdlLnNVcmwgKVxuXHRcdHtcblx0XHRcdC8qIEdldCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgZnJvbSBhIGZpbGUgLSBiZWNhdXNlIHRoaXMgQWpheCBjYWxsIG1ha2VzIHRoZSBsYW5ndWFnZVxuXHRcdFx0ICogZ2V0IGFzeW5jIHRvIHRoZSByZW1haW5kZXIgb2YgdGhpcyBmdW5jdGlvbiB3ZSB1c2UgYkluaXRIYW5kZWRPZmYgdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0ICogX2ZuSW5pdGlhbGlzZSB3aWxsIGJlIGZpcmVkIGJ5IHRoZSByZXR1cm5lZCBBamF4IGhhbmRsZXIsIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvclxuXHRcdFx0ICovXG5cdFx0XHQkLmFqYXgoIHtcblx0XHRcdFx0ZGF0YVR5cGU6ICdqc29uJyxcblx0XHRcdFx0dXJsOiBvTGFuZ3VhZ2Uuc1VybCxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdF9mbkxhbmd1YWdlQ29tcGF0KCBqc29uICk7XG5cdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwganNvbiwgb1NldHRpbmdzLm9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFxuXHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnaTE4bicsIFtvU2V0dGluZ3NdKTtcblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBFcnJvciBvY2N1cnJlZCBsb2FkaW5nIGxhbmd1YWdlIGZpbGUsIGNvbnRpbnVlIG9uIGFzIGJlc3Qgd2UgY2FuXG5cdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGJJbml0SGFuZGVkT2ZmID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ2kxOG4nLCBbb1NldHRpbmdzXSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qXG5cdFx0ICogU3RyaXBlc1xuXHRcdCAqL1xuXHRcdGlmICggb0luaXQuYXNTdHJpcGVDbGFzc2VzID09PSBudWxsIClcblx0XHR7XG5cdFx0XHRvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzID1bXG5cdFx0XHRcdG9DbGFzc2VzLnNTdHJpcGVPZGQsXG5cdFx0XHRcdG9DbGFzc2VzLnNTdHJpcGVFdmVuXG5cdFx0XHRdO1xuXHRcdH1cblx0XHRcblx0XHQvKiBSZW1vdmUgcm93IHN0cmlwZSBjbGFzc2VzIGlmIHRoZXkgYXJlIGFscmVhZHkgb24gdGhlIHRhYmxlIHJvdyAqL1xuXHRcdHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcztcblx0XHR2YXIgcm93T25lID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5JykuZmluZCgndHInKS5lcSgwKTtcblx0XHRpZiAoICQuaW5BcnJheSggdHJ1ZSwgJC5tYXAoIHN0cmlwZUNsYXNzZXMsIGZ1bmN0aW9uKGVsLCBpKSB7XG5cdFx0XHRyZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcblx0XHR9ICkgKSAhPT0gLTEgKSB7XG5cdFx0XHQkKCd0Ym9keSB0cicsIHRoaXMpLnJlbW92ZUNsYXNzKCBzdHJpcGVDbGFzc2VzLmpvaW4oJyAnKSApO1xuXHRcdFx0b1NldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMgPSBzdHJpcGVDbGFzc2VzLnNsaWNlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qXG5cdFx0ICogQ29sdW1uc1xuXHRcdCAqIFNlZSBpZiB3ZSBzaG91bGQgbG9hZCBjb2x1bW5zIGF1dG9tYXRpY2FsbHkgb3IgdXNlIGRlZmluZWQgb25lc1xuXHRcdCAqL1xuXHRcdHZhciBhblRocyA9IFtdO1xuXHRcdHZhciBhb0NvbHVtbnNJbml0O1xuXHRcdHZhciBuVGhlYWQgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aGVhZCcpO1xuXHRcdGlmICggblRoZWFkLmxlbmd0aCAhPT0gMCApXG5cdFx0e1xuXHRcdFx0X2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MuYW9IZWFkZXIsIG5UaGVhZFswXSApO1xuXHRcdFx0YW5UaHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRcblx0XHQvKiBJZiBub3QgZ2l2ZW4gYSBjb2x1bW4gYXJyYXksIGdlbmVyYXRlIG9uZSB3aXRoIG51bGxzICovXG5cdFx0aWYgKCBvSW5pdC5hb0NvbHVtbnMgPT09IG51bGwgKVxuXHRcdHtcblx0XHRcdGFvQ29sdW1uc0luaXQgPSBbXTtcblx0XHRcdGZvciAoIGk9MCwgaUxlbj1hblRocy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRhb0NvbHVtbnNJbml0LnB1c2goIG51bGwgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGFvQ29sdW1uc0luaXQgPSBvSW5pdC5hb0NvbHVtbnM7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIEFkZCB0aGUgY29sdW1ucyAqL1xuXHRcdGZvciAoIGk9MCwgaUxlbj1hb0NvbHVtbnNJbml0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MsIGFuVGhzID8gYW5UaHNbaV0gOiBudWxsICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIEFwcGx5IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgKi9cblx0XHRfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgb0luaXQuYW9Db2x1bW5EZWZzLCBhb0NvbHVtbnNJbml0LCBmdW5jdGlvbiAoaUNvbCwgb0RlZikge1xuXHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvRGVmICk7XG5cdFx0fSApO1xuXHRcdFxuXHRcdC8qIEhUTUw1IGF0dHJpYnV0ZSBkZXRlY3Rpb24gLSBidWlsZCBhbiBtRGF0YSBvYmplY3QgYXV0b21hdGljYWxseSBpZiB0aGVcblx0XHQgKiBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuXHRcdCAqL1xuXHRcdGlmICggcm93T25lLmxlbmd0aCApIHtcblx0XHRcdHZhciBhID0gZnVuY3Rpb24gKCBjZWxsLCBuYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gY2VsbC5nZXRBdHRyaWJ1dGUoICdkYXRhLScrbmFtZSApICE9PSBudWxsID8gbmFtZSA6IG51bGw7XG5cdFx0XHR9O1xuXHRcdFxuXHRcdFx0JCggcm93T25lWzBdICkuY2hpbGRyZW4oJ3RoLCB0ZCcpLmVhY2goIGZ1bmN0aW9uIChpLCBjZWxsKSB7XG5cdFx0XHRcdHZhciBjb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xuXHRcdFxuXHRcdFx0XHRpZiAoISBjb2wpIHtcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0luY29ycmVjdCBjb2x1bW4gY291bnQnLCAxOCApO1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdGlmICggY29sLm1EYXRhID09PSBpICkge1xuXHRcdFx0XHRcdHZhciBzb3J0ID0gYSggY2VsbCwgJ3NvcnQnICkgfHwgYSggY2VsbCwgJ29yZGVyJyApO1xuXHRcdFx0XHRcdHZhciBmaWx0ZXIgPSBhKCBjZWxsLCAnZmlsdGVyJyApIHx8IGEoIGNlbGwsICdzZWFyY2gnICk7XG5cdFx0XG5cdFx0XHRcdFx0aWYgKCBzb3J0ICE9PSBudWxsIHx8IGZpbHRlciAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGNvbC5tRGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0XzogICAgICBpKycuZGlzcGxheScsXG5cdFx0XHRcdFx0XHRcdHNvcnQ6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiAgIHNvcnQgIT09IG51bGwgICA/IGkrJy5AZGF0YS0nK3NvcnQgICA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0ZmlsdGVyOiBmaWx0ZXIgIT09IG51bGwgPyBpKycuQGRhdGEtJytmaWx0ZXIgOiB1bmRlZmluZWRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRjb2wuX2lzQXJyYXlIb3N0ID0gdHJ1ZTtcblx0XHRcblx0XHRcdFx0XHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdHZhciBsb2FkZWRJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Lypcblx0XHRcdCAqIFNvcnRpbmdcblx0XHRcdCAqIEB0b2RvIEZvciBtb2R1bGFyaXNhdGlvbiAoMS4xMSkgdGhpcyBuZWVkcyB0byBkbyBpbnRvIGEgc29ydCBzdGFydCB1cCBoYW5kbGVyXG5cdFx0XHQgKi9cblx0XHRcblx0XHRcdC8vIElmIGFhU29ydGluZyBpcyBub3QgZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGluZGljYXRvciBpbiBhc1NvcnRpbmdcblx0XHRcdC8vIGluIGNhc2UgdGhhdCBoYXMgYmVlbiBhbHRlcmVkLCBzbyB0aGUgZGVmYXVsdCBzb3J0IHJlZmxlY3RzIHRoYXQgb3B0aW9uXG5cdFx0XHRpZiAoIG9Jbml0LmFhU29ydGluZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR2YXIgc29ydGluZyA9IG9TZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0XHRcdGZvciAoIGk9MCwgaUxlbj1zb3J0aW5nLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0XHRzb3J0aW5nW2ldWzFdID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaSBdLmFzU29ydGluZ1swXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFxuXHRcdFx0LyogRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cblx0XHRcdCAqIGFjY291bnQsIGFuZCBhbHNvIHdpbGwgYXBwbHkgc29ydGluZyBkaXNhYmxlZCBjbGFzc2VzIGlmIGRpc2FibGVkXG5cdFx0XHQgKi9cblx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHRcdGlmICggZmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkICkge1xuXHRcdFx0XHRcdFx0dmFyIGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdFx0dmFyIHNvcnRlZENvbHVtbnMgPSB7fTtcblx0XHRcblx0XHRcdFx0XHRcdCQuZWFjaCggYVNvcnQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHRcdFx0c29ydGVkQ29sdW1uc1sgdmFsLnNyYyBdID0gdmFsLmRpcjtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcblx0XHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydCwgc29ydGVkQ29sdW1uc10gKTtcblx0XHRcdFx0XHRcdF9mblNvcnRBcmlhKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCBvU2V0dGluZ3MuYlNvcnRlZCB8fCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PT0gJ3NzcCcgfHwgZmVhdHVyZXMuYkRlZmVyUmVuZGVyICkge1xuXHRcdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgJ3NjJyApO1xuXHRcdFxuXHRcdFxuXHRcdFx0Lypcblx0XHRcdCAqIEZpbmFsIGluaXRcblx0XHRcdCAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcblx0XHRcdCAqL1xuXHRcdFxuXHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xuXHRcdFx0dmFyIGNhcHRpb25zID0gJHRoaXMuY2hpbGRyZW4oJ2NhcHRpb24nKS5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuX2NhcHRpb25TaWRlID0gJCh0aGlzKS5jc3MoJ2NhcHRpb24tc2lkZScpO1xuXHRcdFx0fSApO1xuXHRcdFxuXHRcdFx0dmFyIHRoZWFkID0gJHRoaXMuY2hpbGRyZW4oJ3RoZWFkJyk7XG5cdFx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0dGhlYWQgPSAkKCc8dGhlYWQvPicpLmFwcGVuZFRvKCR0aGlzKTtcblx0XHRcdH1cblx0XHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcblx0XHRcdHZhciB0Ym9keSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpO1xuXHRcdFx0aWYgKCB0Ym9keS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdHRib2R5ID0gJCgnPHRib2R5Lz4nKS5pbnNlcnRBZnRlcih0aGVhZCk7XG5cdFx0XHR9XG5cdFx0XHRvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XG5cdFx0XG5cdFx0XHR2YXIgdGZvb3QgPSAkdGhpcy5jaGlsZHJlbigndGZvb3QnKTtcblx0XHRcdGlmICggdGZvb3QubGVuZ3RoID09PSAwICYmIGNhcHRpb25zLmxlbmd0aCA+IDAgJiYgKG9TZXR0aW5ncy5vU2Nyb2xsLnNYICE9PSBcIlwiIHx8IG9TZXR0aW5ncy5vU2Nyb2xsLnNZICE9PSBcIlwiKSApIHtcblx0XHRcdFx0Ly8gSWYgd2UgYXJlIGEgc2Nyb2xsaW5nIHRhYmxlLCBhbmQgbm8gZm9vdGVyIGhhcyBiZWVuIGdpdmVuLCB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlXG5cdFx0XHRcdC8vIGEgdGZvb3QgZWxlbWVudCBmb3IgdGhlIGNhcHRpb24gZWxlbWVudCB0byBiZSBhcHBlbmRlZCB0b1xuXHRcdFx0XHR0Zm9vdCA9ICQoJzx0Zm9vdC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKCB0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdCR0aGlzLmFkZENsYXNzKCBvQ2xhc3Nlcy5zTm9Gb290ZXIgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0Zm9vdC5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XG5cdFx0XHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvRm9vdGVyLCBvU2V0dGluZ3MublRGb290ICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvKiBDaGVjayBpZiB0aGVyZSBpcyBkYXRhIHBhc3NpbmcgaW50byB0aGUgY29uc3RydWN0b3IgKi9cblx0XHRcdGlmICggb0luaXQuYWFEYXRhICkge1xuXHRcdFx0XHRmb3IgKCBpPTAgOyBpPG9Jbml0LmFhRGF0YS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdFx0X2ZuQWRkRGF0YSggb1NldHRpbmdzLCBvSW5pdC5hYURhdGFbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgfHwgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ2RvbScgKSB7XG5cdFx0XHRcdC8qIEdyYWIgdGhlIGRhdGEgZnJvbSB0aGUgcGFnZSAtIG9ubHkgZG8gdGhpcyB3aGVuIGRlZmVycmVkIGxvYWRpbmcgb3Igbm8gQWpheFxuXHRcdFx0XHQgKiBzb3VyY2Ugc2luY2UgdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVhZGluZyB0aGUgRE9NIGRhdGEgaWYgd2UgYXJlIHRoZW4gZ29pbmdcblx0XHRcdFx0ICogdG8gcmVwbGFjZSBpdCB3aXRoIEFqYXggZGF0YVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0X2ZuQWRkVHIoIG9TZXR0aW5ncywgJChvU2V0dGluZ3MublRCb2R5KS5jaGlsZHJlbigndHInKSApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0LyogQ29weSB0aGUgZGF0YSBpbmRleCBhcnJheSAqL1xuXHRcdFx0b1NldHRpbmdzLmFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcblx0XHRcdC8qIEluaXRpYWxpc2F0aW9uIGNvbXBsZXRlIC0gdGFibGUgY2FuIGJlIGRyYXduICovXG5cdFx0XHRvU2V0dGluZ3MuYkluaXRpYWxpc2VkID0gdHJ1ZTtcblx0XHRcblx0XHRcdC8qIENoZWNrIGlmIHdlIG5lZWQgdG8gaW5pdGlhbGlzZSB0aGUgdGFibGUgKGl0IG1pZ2h0IG5vdCBoYXZlIGJlZW4gaGFuZGVkIG9mZiB0byB0aGVcblx0XHRcdCAqIGxhbmd1YWdlIHByb2Nlc3Nvcilcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBiSW5pdEhhbmRlZE9mZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0LyogTXVzdCBiZSBkb25lIGFmdGVyIGV2ZXJ5dGhpbmcgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0YXRlIHNhdmluZyEgKi9cblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBfZm5TYXZlU3RhdGUsICdzdGF0ZV9zYXZlJyApO1xuXHRcdFxuXHRcdGlmICggb0luaXQuYlN0YXRlU2F2ZSApXG5cdFx0e1xuXHRcdFx0ZmVhdHVyZXMuYlN0YXRlU2F2ZSA9IHRydWU7XG5cdFx0XHRfZm5Mb2FkU3RhdGUoIG9TZXR0aW5ncywgb0luaXQsIGxvYWRlZEluaXQgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsb2FkZWRJbml0KCk7XG5cdFx0fVxuXHRcdFxuXHR9ICk7XG5cdF90aGF0ID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qXG4gKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXG4gKiBEYXRhVGFibGVzIGZ1bmN0aW9ucyBjYW4gYWNjZXNzIHRoZW0gYW5kIHRoZXkgZG9uJ3QgbGVhayBpbnRvIGdsb2JhbCBzcGFjZS5cbiAqIEF0IHRoZSBzYW1lIHRpbWUgdGhlc2UgZnVuY3Rpb25zIGFyZSBvZnRlbiB1c2VmdWwgb3ZlciBtdWx0aXBsZSBmaWxlcyBpbiB0aGVcbiAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcbiAqIGJ5IERhdGFUYWJsZXMgYXMgcHJpdmF0ZSB2YXJpYWJsZXMgaGVyZS4gVGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBub1xuICogY2xhc2hpbmcgb2YgdmFyaWFibGUgbmFtZXMgYW5kIHRoYXQgdGhleSBjYW4gZWFzaWx5IHJlZmVyZW5jZWQgZm9yIHJldXNlLlxuICovXG5cblxuLy8gRGVmaW5lZCBlbHNlIHdoZXJlXG4vLyAgX3NlbGVjdG9yX3J1blxuLy8gIF9zZWxlY3Rvcl9vcHRzXG4vLyAgX3NlbGVjdG9yX2ZpcnN0XG4vLyAgX3NlbGVjdG9yX3Jvd19pbmRleGVzXG5cbnZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XG52YXIgX0FwaTsgLy8gRGF0YVRhYmxlLkFwaVxudmFyIF9hcGlfcmVnaXN0ZXI7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJcbnZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXG5cbnZhciBfcmVfZGljID0ge307XG52YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXFx1MjAyOF0vZztcbnZhciBfcmVfaHRtbCA9IC88Lio/Pi9nO1xuXG4vLyBUaGlzIGlzIG5vdCBzdHJpY3QgSVNPODYwMSAtIERhdGUucGFyc2UoKSBpcyBxdWl0ZSBsYXgsIGFsdGhvdWdoXG4vLyBpbXBsZW1lbnRhdGlvbnMgZGlmZmVyIGJldHdlZW4gYnJvd3NlcnMuXG52YXIgX3JlX2RhdGUgPSAvXlxcZHsyLDR9W1xcLlxcL1xcLV1cXGR7MSwyfVtcXC5cXC9cXC1dXFxkezEsMn0oW1QgXXsxfVxcZHsxLDJ9WzpcXC5dXFxkezJ9KFtcXC46XVxcZHsyfSk/KT8kLztcblxuLy8gRXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnNcbnZhciBfcmVfZXNjYXBlX3JlZ2V4ID0gbmV3IFJlZ0V4cCggJyhcXFxcJyArIFsgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnLCAnJCcsICdeJywgJy0nIF0uam9pbignfFxcXFwnKSArICcpJywgJ2cnICk7XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm9yZWlnbl9leGNoYW5nZV9tYXJrZXRcbi8vIC0gXFx1MjBCRCAtIFJ1c3NpYW4gcnVibGUuXG4vLyAtIFxcdTIwYTkgLSBTb3V0aCBLb3JlYW4gV29uXG4vLyAtIFxcdTIwQkEgLSBUdXJraXNoIExpcmFcbi8vIC0gXFx1MjBCOSAtIEluZGlhbiBSdXBlZVxuLy8gLSBSIC0gQnJhemlsIChSJCkgYW5kIFNvdXRoIEFmcmljYVxuLy8gLSBmciAtIFN3aXNzIEZyYW5jXG4vLyAtIGtyIC0gU3dlZGlzaCBrcm9uYSwgTm9yd2VnaWFuIGtyb25lIGFuZCBEYW5pc2gga3JvbmVcbi8vIC0gXFx1MjAwOSBpcyB0aGluIHNwYWNlIGFuZCBcXHUyMDJGIGlzIG5hcnJvdyBuby1icmVhayBzcGFjZSwgYm90aCB1c2VkIGluIG1hbnlcbi8vIC0gyYMgLSBCaXRjb2luXG4vLyAtIM6eIC0gRXRoZXJldW1cbi8vICAgc3RhbmRhcmRzIGFzIHRob3VzYW5kcyBzZXBhcmF0b3JzLlxudmFyIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyA9IC9bJ1xcdTAwQTAsJMKj4oKswqUlXFx1MjAwOVxcdTIwMkZcXHUyMEJEXFx1MjBhOVxcdTIwQkFyZmvJg86eXS9naTtcblxuXG52YXIgX2VtcHR5ID0gZnVuY3Rpb24gKCBkICkge1xuXHRyZXR1cm4gIWQgfHwgZCA9PT0gdHJ1ZSB8fCBkID09PSAnLScgPyB0cnVlIDogZmFsc2U7XG59O1xuXG5cbnZhciBfaW50VmFsID0gZnVuY3Rpb24gKCBzICkge1xuXHR2YXIgaW50ZWdlciA9IHBhcnNlSW50KCBzLCAxMCApO1xuXHRyZXR1cm4gIWlzTmFOKGludGVnZXIpICYmIGlzRmluaXRlKHMpID8gaW50ZWdlciA6IG51bGw7XG59O1xuXG4vLyBDb252ZXJ0IGZyb20gYSBmb3JtYXR0ZWQgbnVtYmVyIHdpdGggY2hhcmFjdGVycyBvdGhlciB0aGFuIGAuYCBhcyB0aGVcbi8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcbnZhciBfbnVtVG9EZWNpbWFsID0gZnVuY3Rpb24gKCBudW0sIGRlY2ltYWxQb2ludCApIHtcblx0Ly8gQ2FjaGUgY3JlYXRlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBzcGVlZCBhcyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvZnRlblxuXHRpZiAoICEgX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gKSB7XG5cdFx0X3JlX2RpY1sgZGVjaW1hbFBvaW50IF0gPSBuZXcgUmVnRXhwKCBfZm5Fc2NhcGVSZWdleCggZGVjaW1hbFBvaW50ICksICdnJyApO1xuXHR9XG5cdHJldHVybiB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBkZWNpbWFsUG9pbnQgIT09ICcuJyA/XG5cdFx0bnVtLnJlcGxhY2UoIC9cXC4vZywgJycgKS5yZXBsYWNlKCBfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSwgJy4nICkgOlxuXHRcdG51bTtcbn07XG5cblxudmFyIF9pc051bWJlciA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSB7XG5cdGxldCB0eXBlID0gdHlwZW9mIGQ7XG5cdHZhciBzdHJUeXBlID0gdHlwZSA9PT0gJ3N0cmluZyc7XG5cblx0aWYgKCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYmlnaW50Jykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSWYgZW1wdHkgcmV0dXJuIGltbWVkaWF0ZWx5IHNvIHRoZXJlIG11c3QgYmUgYSBudW1iZXIgaWYgaXQgaXMgYVxuXHQvLyBmb3JtYXR0ZWQgc3RyaW5nICh0aGlzIHN0b3BzIHRoZSBzdHJpbmcgXCJrXCIsIG9yIFwia3JcIiwgZXRjIGJlaW5nIGRldGVjdGVkXG5cdC8vIGFzIGEgZm9ybWF0dGVkIG51bWJlciBmb3IgY3VycmVuY3lcblx0aWYgKCBfZW1wdHkoIGQgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0ZCA9IF9udW1Ub0RlY2ltYWwoIGQsIGRlY2ltYWxQb2ludCApO1xuXHR9XG5cblx0aWYgKCBmb3JtYXR0ZWQgJiYgc3RyVHlwZSApIHtcblx0XHRkID0gZC5yZXBsYWNlKCBfcmVfZm9ybWF0dGVkX251bWVyaWMsICcnICk7XG5cdH1cblxuXHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KGQpICkgJiYgaXNGaW5pdGUoIGQgKTtcbn07XG5cblxuLy8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcbnZhciBfaXNIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xufTtcblxuXG52YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCApIHtcblx0aWYgKCBfZW1wdHkoIGQgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHZhciBodG1sID0gX2lzSHRtbCggZCApO1xuXHRyZXR1cm4gISBodG1sID9cblx0XHRudWxsIDpcblx0XHRfaXNOdW1iZXIoIF9zdHJpcEh0bWwoIGQgKSwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQgKSA/XG5cdFx0XHR0cnVlIDpcblx0XHRcdG51bGw7XG59O1xuXG5cbnZhciBfcGx1Y2sgPSBmdW5jdGlvbiAoIGEsIHByb3AsIHByb3AyICkge1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpPTAsIGllbj1hLmxlbmd0aDtcblxuXHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHQvLyBpcyBlc3NlbnRpYWwgaGVyZVxuXHRpZiAoIHByb3AyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYVtpXSAmJiBhW2ldWyBwcm9wIF0gKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBhW2ldWyBwcm9wIF1bIHByb3AyIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYVtpXSApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbi8vIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBfcGx1Y2ssIGJ1dCByYXRoZXIgdGhhbiBsb29waW5nIG92ZXIgYGFgIHdlIHVzZSBgb3JkZXJgXG4vLyBhcyB0aGUgaW5kZXhlcyB0byBwaWNrIGZyb20gYGFgXG52YXIgX3BsdWNrX29yZGVyID0gZnVuY3Rpb24gKCBhLCBvcmRlciwgcHJvcCwgcHJvcDIgKVxue1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpPTAsIGllbj1vcmRlci5sZW5ndGg7XG5cblx0Ly8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcblx0Ly8gaXMgZXNzZW50aWFsIGhlcmVcblx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbnZhciBfcmFuZ2UgPSBmdW5jdGlvbiAoIGxlbiwgc3RhcnQgKVxue1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBlbmQ7XG5cblx0aWYgKCBzdGFydCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHN0YXJ0ID0gMDtcblx0XHRlbmQgPSBsZW47XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZW5kID0gc3RhcnQ7XG5cdFx0c3RhcnQgPSBsZW47XG5cdH1cblxuXHRmb3IgKCB2YXIgaT1zdGFydCA7IGk8ZW5kIDsgaSsrICkge1xuXHRcdG91dC5wdXNoKCBpICk7XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG52YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKCBhIClcbntcblx0dmFyIG91dCA9IFtdO1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1hLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGlmICggYVtpXSApIHsgLy8gY2FyZWZ1bCAtIHdpbGwgcmVtb3ZlIGFsbCBmYWxzeSB2YWx1ZXMhXG5cdFx0XHRvdXQucHVzaCggYVtpXSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbnZhciBfc3RyaXBIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRyZXR1cm4gZC5yZXBsYWNlKCBfcmVfaHRtbCwgJycgKTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYWxsIHZhbHVlcyBpbiB0aGUgYXJyYXkgYXJlIHVuaXF1ZS4gVGhpcyBtZWFucyB3ZSBjYW4gc2hvcnRcbiAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuICogdG8gZWFzaWx5IGNoZWNrIHRoZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYWxsIHVuaXF1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfYXJlQWxsVW5pcXVlID0gZnVuY3Rpb24gKCBzcmMgKSB7XG5cdGlmICggc3JjLmxlbmd0aCA8IDIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHR2YXIgbGFzdCA9IHNvcnRlZFswXTtcblxuXHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGlmICggc29ydGVkW2ldID09PSBsYXN0ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGxhc3QgPSBzb3J0ZWRbaV07XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcbiAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcbiAqIEBpZ25vcmVcbiAqL1xudmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApXG57XG5cdGlmICggX2FyZUFsbFVuaXF1ZSggc3JjICkgKSB7XG5cdFx0cmV0dXJuIHNyYy5zbGljZSgpO1xuXHR9XG5cblx0Ly8gQSBmYXN0ZXIgdW5pcXVlIG1ldGhvZCBpcyB0byB1c2Ugb2JqZWN0IGtleXMgdG8gaWRlbnRpZnkgdXNlZCB2YWx1ZXMsXG5cdC8vIGJ1dCB0aGlzIGRvZXNuJ3Qgd29yayB3aXRoIGFycmF5cyBvciBvYmplY3RzLCB3aGljaCB3ZSBtdXN0IGFsc29cblx0Ly8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcblx0Ly8gaW5mb3JtYXRpb24uXG5cdHZhclxuXHRcdG91dCA9IFtdLFxuXHRcdHZhbCxcblx0XHRpLCBpZW49c3JjLmxlbmd0aCxcblx0XHRqLCBrPTA7XG5cblx0YWdhaW46IGZvciAoIGk9MCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHZhbCA9IHNyY1tpXTtcblxuXHRcdGZvciAoIGo9MCA7IGo8ayA7IGorKyApIHtcblx0XHRcdGlmICggb3V0W2pdID09PSB2YWwgKSB7XG5cdFx0XHRcdGNvbnRpbnVlIGFnYWluO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG91dC5wdXNoKCB2YWwgKTtcblx0XHRrKys7XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufTtcblxuLy8gU3VycHJpc2luZ2x5IHRoaXMgaXMgZmFzdGVyIHRoYW4gW10uY29uY2F0LmFwcGx5XG4vLyBodHRwczovL2pzcGVyZi5jb20vZmxhdHRlbi1hbi1hcnJheS1sb29wLXZzLXJlZHVjZS8yXG52YXIgX2ZsYXR0ZW4gPSBmdW5jdGlvbiAob3V0LCB2YWwpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdGZvciAodmFyIGk9MCA7IGk8dmFsLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0X2ZsYXR0ZW4ob3V0LCB2YWxbaV0pO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRvdXQucHVzaCh2YWwpO1xuXHR9XG4gIFxuXHRyZXR1cm4gb3V0O1xufVxuXG52YXIgX2luY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaCwgc3RhcnQpIHtcblx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcdFxufTtcblxuLy8gQXJyYXkuaXNBcnJheSBwb2x5ZmlsbC5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmlmICghIEFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xufVxuXG5pZiAoISBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpIHtcblx0QXJyYXkucHJvdG90eXBlLmluY2x1ZGVzID0gX2luY2x1ZGVzO1xufVxuXG4vLyAudHJpbSgpIHBvbHlmaWxsXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbVxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gIH07XG59XG5cbmlmICghIFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMpIHtcblx0U3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyA9IF9pbmNsdWRlcztcbn1cblxuLyoqXG4gKiBEYXRhVGFibGVzIHV0aWxpdHkgbWV0aG9kc1xuICogXG4gKiBUaGlzIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgbWV0aG9kcyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbnRlcm5hbGx5IHRvXG4gKiBjcmVhdGUgYSBEYXRhVGFibGUsIGJ1dCB3aGljaCBhcmUgbm90IGV4Y2x1c2l2ZWx5IHVzZWQgb25seSBmb3IgRGF0YVRhYmxlcy5cbiAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2ZcbiAqIGNvZGUuXG4gKlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLnV0aWwgPSB7XG5cdC8qKlxuXHQgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkXG5cdCAqIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBmcmVxIENhbGwgZnJlcXVlbmN5IGluIG1TXG5cdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdCAqL1xuXHR0aHJvdHRsZTogZnVuY3Rpb24gKCBmbiwgZnJlcSApIHtcblx0XHR2YXJcblx0XHRcdGZyZXF1ZW5jeSA9IGZyZXEgIT09IHVuZGVmaW5lZCA/IGZyZXEgOiAyMDAsXG5cdFx0XHRsYXN0LFxuXHRcdFx0dGltZXI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyXG5cdFx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRub3cgID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRcdGlmICggbGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5ICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHR9LCBmcmVxdWVuY3kgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsYXN0ID0gbm93O1xuXHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblxuXHQvKipcblx0ICogRXNjYXBlIGEgc3RyaW5nIHN1Y2ggdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuXHQgKlxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBzdHJpbmcgdG8gZXNjYXBlXG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xuXHQgKi9cblx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uICggdmFsICkge1xuXHRcdHJldHVybiB2YWwucmVwbGFjZSggX3JlX2VzY2FwZV9yZWdleCwgJ1xcXFwkMScgKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHdyaXRlIHRvIGEgbmVzdGVkIG9iamVjdCBvciBhcnJheVxuXHQgKiBAcGFyYW0geyp9IHNvdXJjZSBKU09OIG5vdGF0aW9uIHN0cmluZ1xuXHQgKiBAcmV0dXJucyBXcml0ZSBmdW5jdGlvblxuXHQgKi9cblx0c2V0OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggc291cmNlICkgKSB7XG5cdFx0XHQvKiBVbmxpa2UgZ2V0LCBvbmx5IHRoZSB1bmRlcnNjb3JlIChnbG9iYWwpIG9wdGlvbiBpcyB1c2VkIGZvciBmb3Jcblx0XHRcdCAqIHNldHRpbmcgZGF0YSBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIGhlcmUuIFRoaXMgaXMgd2h5IGFuIG9iamVjdFxuXHRcdFx0ICogb3B0aW9uIGlzIG5vdCBkb2N1bWVudGVkIGZvciBgbURhdGFgICh3aGljaCBpcyByZWFkL3dyaXRlKSwgYnV0IGl0IGlzXG5cdFx0XHQgKiBmb3IgYG1SZW5kZXJgIHdoaWNoIGlzIHJlYWQgb25seS5cblx0XHRcdCAqL1xuXHRcdFx0cmV0dXJuIERhdGFUYWJsZS51dGlsLnNldCggc291cmNlLl8gKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNvdXJjZSA9PT0gbnVsbCApIHtcblx0XHRcdC8vIE5vdGhpbmcgdG8gZG8gd2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsLCBtZXRhKSB7XG5cdFx0XHRcdHNvdXJjZSggZGF0YSwgJ3NldCcsIHZhbCwgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIChzb3VyY2UuaW5kZXhPZignLicpICE9PSAtMSB8fFxuXHRcdFx0XHQgIHNvdXJjZS5pbmRleE9mKCdbJykgIT09IC0xIHx8IHNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSApXG5cdFx0e1xuXHRcdFx0Ly8gTGlrZSB0aGUgZ2V0LCB3ZSBuZWVkIHRvIGdldCBkYXRhIGZyb20gYSBuZXN0ZWQgb2JqZWN0XG5cdFx0XHR2YXIgc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB2YWwsIHNyYykge1xuXHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApLCBiO1xuXHRcdFx0XHR2YXIgYUxhc3QgPSBhW2EubGVuZ3RoLTFdO1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvLCBpbm5lclNyYztcblx0XG5cdFx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGgtMSA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0XHQvLyBQcm90ZWN0IGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHRcdGlmIChhW2ldID09PSAnX19wcm90b19fJyB8fCBhW2ldID09PSAnY29uc3RydWN0b3InKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgcHJvdG90eXBlIHZhbHVlcycpO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhbiBhcnJheSBub3RhdGlvbiByZXF1ZXN0XG5cdFx0XHRcdFx0YXJyYXlOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUFycmF5KTtcblx0XHRcdFx0XHRmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cdFxuXHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApIHtcblx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSBbXTtcblx0XG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBzZXQgc28gd2UgY2FuIHJlY3Vyc2Vcblx0XHRcdFx0XHRcdGIgPSBhLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRiLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRpbm5lclNyYyA9IGIuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IHNldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPXZhbC5sZW5ndGggOyBqPGpMZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRcdFx0byA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdHNldERhdGEoIG8sIHZhbFtqXSwgaW5uZXJTcmMgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0ucHVzaCggbyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2UndmUgYmVlbiBhc2tlZCB0byBzYXZlIGRhdGEgdG8gYW4gYXJyYXksIGJ1dCBpdFxuXHRcdFx0XHRcdFx0XHQvLyBpc24ndCBhcnJheSBkYXRhIHRvIGJlIHNhdmVkLiBCZXN0IHRoYXQgY2FuIGJlIGRvbmVcblx0XHRcdFx0XHRcdFx0Ly8gaXMgdG8ganVzdCBzYXZlIHRoZSB2YWx1ZS5cblx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0gdmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdC8vIFRoZSBpbm5lciBjYWxsIHRvIHNldERhdGEgaGFzIGFscmVhZHkgdHJhdmVyc2VkIHRocm91Z2ggdGhlIHJlbWFpbmRlclxuXHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSBhbmQgaGFzIHNldCB0aGUgZGF0YSwgdGh1cyB3ZSBjYW4gZXhpdCBoZXJlXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVGbiwgJycpO1xuXHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXSggdmFsICk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBJZiB0aGUgbmVzdGVkIG9iamVjdCBkb2Vzbid0IGN1cnJlbnRseSBleGlzdCAtIHNpbmNlIHdlIGFyZVxuXHRcdFx0XHRcdC8vIHRyeWluZyB0byBzZXQgdGhlIHZhbHVlIC0gY3JlYXRlIGl0XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBhW2ldIF0gPT09IG51bGwgfHwgZGF0YVsgYVtpXSBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gTGFzdCBpdGVtIGluIHRoZSBpbnB1dCAtIGkuZSwgdGhlIGFjdHVhbCBzZXRcblx0XHRcdFx0aWYgKCBhTGFzdC5tYXRjaChfX3JlRm4gKSApIHtcblx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUZuLCAnJykgXSggdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHQvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxuXHRcdFx0XHRcdGRhdGFbIGFMYXN0LnJlcGxhY2UoX19yZUFycmF5LCAnJykgXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIHNldERhdGEoIGRhdGEsIHZhbCwgc291cmNlICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmdcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRkYXRhW3NvdXJjZV0gPSB2YWw7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlYWQgbmVzdGVkIG9iamVjdHMgZnJvbSBhcnJheXMsIGJhc2VkIG9uIEpTT04gbm90YXRpb25cblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgSlNPTiBub3RhdGlvbiBzdHJpbmdcblx0ICogQHJldHVybnMgVmFsdWUgcmVhZFxuXHQgKi9cblx0Z2V0OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggc291cmNlICkgKSB7XG5cdFx0XHQvLyBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsXG5cdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0JC5lYWNoKCBzb3VyY2UsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRvW2tleV0gPSBEYXRhVGFibGUudXRpbC5nZXQoIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0dmFyIHQgPSBvW3R5cGVdIHx8IG8uXztcblx0XHRcdFx0cmV0dXJuIHQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0dChkYXRhLCB0eXBlLCByb3csIG1ldGEpIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNvdXJjZSA9PT0gbnVsbCApIHtcblx0XHRcdC8vIEdpdmUgYW4gZW1wdHkgc3RyaW5nIGZvciByZW5kZXJpbmcgLyBzb3J0aW5nIGV0Y1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHR5cGUsIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xuXHRcdFx0XHRyZXR1cm4gc291cmNlKCBkYXRhLCB0eXBlLCByb3csIG1ldGEgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAoc291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcblx0XHRcdFx0ICBzb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBzb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkgKVxuXHRcdHtcblx0XHRcdC8qIElmIHRoZXJlIGlzIGEgLiBpbiB0aGUgc291cmNlIHN0cmluZyB0aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBpbiBhXG5cdFx0XHQgKiBuZXN0ZWQgb2JqZWN0IHNvIHdlIGxvb3Agb3ZlciB0aGUgZGF0YSBmb3IgZWFjaCBsZXZlbCB0byBnZXQgdGhlIG5leHRcblx0XHRcdCAqIGxldmVsIGRvd24uIE9uIGVhY2ggbG9vcCB3ZSB0ZXN0IGZvciB1bmRlZmluZWQsIGFuZCBpZiBmb3VuZCBpbW1lZGlhdGVseVxuXHRcdFx0ICogcmV0dXJuLiBUaGlzIGFsbG93cyBlbnRpcmUgb2JqZWN0cyB0byBiZSBtaXNzaW5nIGFuZCBzRGVmYXVsdENvbnRlbnQgdG9cblx0XHRcdCAqIGJlIHVzZWQgaWYgZGVmaW5lZCwgcmF0aGVyIHRoYW4gdGhyb3dpbmcgYW4gZXJyb3Jcblx0XHRcdCAqL1xuXHRcdFx0dmFyIGZldGNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCBzcmMpIHtcblx0XHRcdFx0dmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgb3V0LCBpbm5lclNyYztcblx0XG5cdFx0XHRcdGlmICggc3JjICE9PSBcIlwiICkge1xuXHRcdFx0XHRcdHZhciBhID0gX2ZuU3BsaXRPYmpOb3RhdGlvbiggc3JjICk7XG5cdFxuXHRcdFx0XHRcdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cblx0XHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0XHRmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCBhcnJheU5vdGF0aW9uICkge1xuXHRcdFx0XHRcdFx0XHQvLyBBcnJheSBub3RhdGlvblxuXHRcdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gQ29uZGl0aW9uIGFsbG93cyBzaW1wbHkgW10gdG8gYmUgcGFzc2VkIGluXG5cdFx0XHRcdFx0XHRcdGlmICggYVtpXSAhPT0gXCJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdG91dCA9IFtdO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gZ2V0XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKCAwLCBpKzEgKTtcblx0XHRcdFx0XHRcdFx0aW5uZXJTcmMgPSBhLmpvaW4oJy4nKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IGdldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXG5cdFx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49ZGF0YS5sZW5ndGggOyBqPGpMZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXQucHVzaCggZmV0Y2hEYXRhKCBkYXRhW2pdLCB0eXBlLCBpbm5lclNyYyApICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBJZiBhIHN0cmluZyBpcyBnaXZlbiBpbiBiZXR3ZWVuIHRoZSBhcnJheSBub3RhdGlvbiBpbmRpY2F0b3JzLCB0aGF0XG5cdFx0XHRcdFx0XHRcdC8vIGlzIHVzZWQgdG8gam9pbiB0aGUgc3RyaW5ncyB0b2dldGhlciwgb3RoZXJ3aXNlIGFuIGFycmF5IGlzIHJldHVybmVkXG5cdFx0XHRcdFx0XHRcdHZhciBqb2luID0gYXJyYXlOb3RhdGlvblswXS5zdWJzdHJpbmcoMSwgYXJyYXlOb3RhdGlvblswXS5sZW5ndGgtMSk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSAoam9pbj09PVwiXCIpID8gb3V0IDogb3V0LmpvaW4oam9pbik7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBUaGUgaW5uZXIgY2FsbCB0byBmZXRjaERhdGEgaGFzIGFscmVhZHkgdHJhdmVyc2VkIHRocm91Z2ggdGhlIHJlbWFpbmRlclxuXHRcdFx0XHRcdFx0XHQvLyBvZiB0aGUgc291cmNlIHJlcXVlc3RlZCwgc28gd2UgZXhpdCBmcm9tIHRoZSBsb29wXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIGZ1bmNOb3RhdGlvbiApIHtcblx0XHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVGbiwgJycpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdKCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdGlmICggZGF0YSA9PT0gbnVsbCB8fCBkYXRhWyBhW2ldIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGZldGNoRGF0YSggZGF0YSwgdHlwZSwgc291cmNlICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmdcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YVtzb3VyY2VdO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cbn07XG5cblxuXG4vKipcbiAqIENyZWF0ZSBhIG1hcHBpbmcgb2JqZWN0IHRoYXQgYWxsb3dzIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBiZSBsb29rZWQgdXBcbiAqIGZvciB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzLiBUaGUgbWFwcGluZyBpcyBzdG9yZWQgaW4gYSBwcml2YXRlXG4gKiBwYXJhbWV0ZXIgY2FsbGVkIGBfaHVuZ2FyaWFuTWFwYCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlIHNvdXJjZSBvYmplY3QuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuSHVuZ2FyaWFuTWFwICggbyApXG57XG5cdHZhclxuXHRcdGh1bmdhcmlhbiA9ICdhIGFhIGFpIGFvIGFzIGIgZm4gaSBtIG8gcyAnLFxuXHRcdG1hdGNoLFxuXHRcdG5ld0tleSxcblx0XHRtYXAgPSB7fTtcblxuXHQkLmVhY2goIG8sIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eKFteQS1aXSs/KShbQS1aXSkvKTtcblxuXHRcdGlmICggbWF0Y2ggJiYgaHVuZ2FyaWFuLmluZGV4T2YobWF0Y2hbMV0rJyAnKSAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdG5ld0tleSA9IGtleS5yZXBsYWNlKCBtYXRjaFswXSwgbWF0Y2hbMl0udG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0bWFwWyBuZXdLZXkgXSA9IGtleTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gJ28nIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBvW2tleV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHRvLl9odW5nYXJpYW5NYXAgPSBtYXA7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiwgYmFzZWQgb24gYSBIdW5nYXJpYW4gbWFwXG4gKiBjcmVhdGVkIGJ5IF9mbkh1bmdhcmlhbk1hcC5cbiAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcbiAqICAgIG1hcHBlZC5cbiAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cbiAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XG4gKiAgICB3b24ndCBiZS5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ2FtZWxUb0h1bmdhcmlhbiAoIHNyYywgdXNlciwgZm9yY2UgKVxue1xuXHRpZiAoICEgc3JjLl9odW5nYXJpYW5NYXAgKSB7XG5cdFx0X2ZuSHVuZ2FyaWFuTWFwKCBzcmMgKTtcblx0fVxuXG5cdHZhciBodW5nYXJpYW5LZXk7XG5cblx0JC5lYWNoKCB1c2VyLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRodW5nYXJpYW5LZXkgPSBzcmMuX2h1bmdhcmlhbk1hcFsga2V5IF07XG5cblx0XHRpZiAoIGh1bmdhcmlhbktleSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCB1c2VyW2h1bmdhcmlhbktleV0gPT09IHVuZGVmaW5lZCkgKVxuXHRcdHtcblx0XHRcdC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXG5cdFx0XHRpZiAoIGh1bmdhcmlhbktleS5jaGFyQXQoMCkgPT09ICdvJyApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxuXHRcdFx0XHRpZiAoICEgdXNlclsgaHVuZ2FyaWFuS2V5IF0gKSB7XG5cdFx0XHRcdFx0dXNlclsgaHVuZ2FyaWFuS2V5IF0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgdXNlcltodW5nYXJpYW5LZXldLCB1c2VyW2tleV0gKTtcblxuXHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBzcmNbaHVuZ2FyaWFuS2V5XSwgdXNlcltodW5nYXJpYW5LZXldLCBmb3JjZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5cbi8qKlxuICogTGFuZ3VhZ2UgY29tcGF0aWJpbGl0eSAtIHdoZW4gY2VydGFpbiBvcHRpb25zIGFyZSBnaXZlbiwgYW5kIG90aGVycyBhcmVuJ3QsIHdlXG4gKiBuZWVkIHRvIGR1cGxpY2F0ZSB0aGUgdmFsdWVzIG92ZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkZXIgbGFuZ3VhZ2UgZmlsZXMuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5MYW5ndWFnZUNvbXBhdCggbGFuZyApXG57XG5cdC8vIE5vdGUgdGhlIHVzZSBvZiB0aGUgSHVuZ2FyaWFuIG5vdGF0aW9uIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIG1ldGhvZCBhc1xuXHQvLyB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbWFwcGluZyBvZiBjYW1lbENhc2UgdG8gSHVuZ2FyaWFuXG5cdHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2U7XG5cblx0Ly8gRGVmYXVsdCBtYXBwaW5nXG5cdHZhciBkZWZhdWx0RGVjaW1hbCA9IGRlZmF1bHRzLnNEZWNpbWFsO1xuXHRpZiAoIGRlZmF1bHREZWNpbWFsICkge1xuXHRcdF9hZGROdW1lcmljU29ydCggZGVmYXVsdERlY2ltYWwgKTtcblx0fVxuXG5cdGlmICggbGFuZyApIHtcblx0XHR2YXIgemVyb1JlY29yZHMgPSBsYW5nLnNaZXJvUmVjb3JkcztcblxuXHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IC0gaWYgdGhlcmUgaXMgbm8gc0VtcHR5VGFibGUgZ2l2ZW4sIHRoZW4gdXNlIHRoZSBzYW1lIGFzXG5cdFx0Ly8gc1plcm9SZWNvcmRzIC0gYXNzdW1pbmcgdGhhdCBpcyBnaXZlbi5cblx0XHRpZiAoICEgbGFuZy5zRW1wdHlUYWJsZSAmJiB6ZXJvUmVjb3JkcyAmJlxuXHRcdFx0ZGVmYXVsdHMuc0VtcHR5VGFibGUgPT09IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIiApXG5cdFx0e1xuXHRcdFx0X2ZuTWFwKCBsYW5nLCBsYW5nLCAnc1plcm9SZWNvcmRzJywgJ3NFbXB0eVRhYmxlJyApO1xuXHRcdH1cblxuXHRcdC8vIExpa2V3aXNlIHdpdGggbG9hZGluZyByZWNvcmRzXG5cdFx0aWYgKCAhIGxhbmcuc0xvYWRpbmdSZWNvcmRzICYmIHplcm9SZWNvcmRzICYmXG5cdFx0XHRkZWZhdWx0cy5zTG9hZGluZ1JlY29yZHMgPT09IFwiTG9hZGluZy4uLlwiIClcblx0XHR7XG5cdFx0XHRfZm5NYXAoIGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0xvYWRpbmdSZWNvcmRzJyApO1xuXHRcdH1cblxuXHRcdC8vIE9sZCBwYXJhbWV0ZXIgbmFtZSBvZiB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvciBtYXBwZWQgb250byB0aGUgbmV3XG5cdFx0aWYgKCBsYW5nLnNJbmZvVGhvdXNhbmRzICkge1xuXHRcdFx0bGFuZy5zVGhvdXNhbmRzID0gbGFuZy5zSW5mb1Rob3VzYW5kcztcblx0XHR9XG5cblx0XHR2YXIgZGVjaW1hbCA9IGxhbmcuc0RlY2ltYWw7XG5cdFx0aWYgKCBkZWNpbWFsICYmIGRlZmF1bHREZWNpbWFsICE9PSBkZWNpbWFsICkge1xuXHRcdFx0X2FkZE51bWVyaWNTb3J0KCBkZWNpbWFsICk7XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcbiAqICBAcGFyYW0ge29iamVjdH0gbyBPYmplY3QgdG8gbWFwXG4gKiAgQHBhcmFtIHsqfSBrbmV3IFRoZSBuZXcgcGFyYW1ldGVyIG5hbWVcbiAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXG4gKi9cbnZhciBfZm5Db21wYXRNYXAgPSBmdW5jdGlvbiAoIG8sIGtuZXcsIG9sZCApIHtcblx0aWYgKCBvWyBrbmV3IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRvWyBvbGQgXSA9IG9bIGtuZXcgXTtcblx0fVxufTtcblxuXG4vKipcbiAqIFByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBtYWluIERUIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3XG4gKiBvcHRpb25zIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlXG4gKiBjaGFuZ2Ugb25seS5cbiAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMgKCBpbml0IClcbntcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJpbmcnLCAgICAgICdiU29ydCcgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJNdWx0aScsICAgICdiU29ydE11bHRpJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckNsYXNzZXMnLCAgJ2JTb3J0Q2xhc3NlcycgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDZWxsc1RvcCcsICdiU29ydENlbGxzVG9wJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcicsICAgICAgICAgJ2FhU29ydGluZycgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJGaXhlZCcsICAgICdhYVNvcnRpbmdGaXhlZCcgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nJywgICAgICAgICdiUGFnaW5hdGUnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZ1R5cGUnLCAgICAnc1BhZ2luYXRpb25UeXBlJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdwYWdlTGVuZ3RoJywgICAgJ2lEaXNwbGF5TGVuZ3RoJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdzZWFyY2hpbmcnLCAgICAgJ2JGaWx0ZXInICk7XG5cblx0Ly8gQm9vbGVhbiBpbml0aWFsaXNhdGlvbiBvZiB4LXNjcm9sbGluZ1xuXHRpZiAoIHR5cGVvZiBpbml0LnNTY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0aW5pdC5zU2Nyb2xsWCA9IGluaXQuc1Njcm9sbFggPyAnMTAwJScgOiAnJztcblx0fVxuXHRpZiAoIHR5cGVvZiBpbml0LnNjcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRpbml0LnNjcm9sbFggPSBpbml0LnNjcm9sbFggPyAnMTAwJScgOiAnJztcblx0fVxuXG5cdC8vIENvbHVtbiBzZWFyY2ggb2JqZWN0cyBhcmUgaW4gYW4gYXJyYXksIHNvIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuXHQvLyBlbGVtZW50IGJ5IGVsZW1lbnRcblx0dmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcblxuXHRpZiAoIHNlYXJjaENvbHMgKSB7XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNlYXJjaENvbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIHNlYXJjaENvbHNbaV0gKSB7XG5cdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1tpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgY29sdW1uIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3IG9wdGlvbnNcbiAqIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlIGNoYW5nZVxuICogb25seS5cbiAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbXBhdENvbHMgKCBpbml0IClcbntcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJhYmxlJywgICAgICdiU29ydGFibGUnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YScsICAgICAnYURhdGFTb3J0JyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlclNlcXVlbmNlJywgJ2FzU29ydGluZycgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJEYXRhVHlwZScsICdzb3J0RGF0YVR5cGUnICk7XG5cblx0Ly8gb3JkZXJEYXRhIGNhbiBiZSBnaXZlbiBhcyBhbiBpbnRlZ2VyXG5cdHZhciBkYXRhU29ydCA9IGluaXQuYURhdGFTb3J0O1xuXHRpZiAoIHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgISBBcnJheS5pc0FycmF5KCBkYXRhU29ydCApICkge1xuXHRcdGluaXQuYURhdGFTb3J0ID0gWyBkYXRhU29ydCBdO1xuXHR9XG59XG5cblxuLyoqXG4gKiBCcm93c2VyIGZlYXR1cmUgZGV0ZWN0aW9uIGZvciBjYXBhYmlsaXRpZXMsIHF1aXJrc1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Ccm93c2VyRGV0ZWN0KCBzZXR0aW5ncyApXG57XG5cdC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gdGhpcyBldmVyeSB0aW1lIERhdGFUYWJsZXMgaXMgY29uc3RydWN0ZWQsIHRoZSB2YWx1ZXNcblx0Ly8gY2FsY3VsYXRlZCBhcmUgc3BlY2lmaWMgdG8gdGhlIGJyb3dzZXIgYW5kIE9TIGNvbmZpZ3VyYXRpb24gd2hpY2ggd2Vcblx0Ly8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xuXHRpZiAoICEgRGF0YVRhYmxlLl9fYnJvd3NlciApIHtcblx0XHR2YXIgYnJvd3NlciA9IHt9O1xuXHRcdERhdGFUYWJsZS5fX2Jyb3dzZXIgPSBicm93c2VyO1xuXG5cdFx0Ly8gU2Nyb2xsaW5nIGZlYXR1cmUgLyBxdWlya3MgZGV0ZWN0aW9uXG5cdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0LmNzcygge1xuXHRcdFx0XHRwb3NpdGlvbjogJ2ZpeGVkJyxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpKi0xLCAvLyBhbGxvdyBmb3Igc2Nyb2xsaW5nXG5cdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0dG9wOiAxLFxuXHRcdFx0XHRcdFx0bGVmdDogMSxcblx0XHRcdFx0XHRcdHdpZHRoOiAxMDAsXG5cdFx0XHRcdFx0XHRvdmVyZmxvdzogJ3Njcm9sbCdcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAxMFxuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXG5cdFx0dmFyIG91dGVyID0gbi5jaGlsZHJlbigpO1xuXHRcdHZhciBpbm5lciA9IG91dGVyLmNoaWxkcmVuKCk7XG5cblx0XHQvLyBOdW1iZXJzIGJlbG93LCBpbiBvcmRlciwgYXJlOlxuXHRcdC8vIGlubmVyLm9mZnNldFdpZHRoLCBpbm5lci5jbGllbnRXaWR0aCwgb3V0ZXIub2Zmc2V0V2lkdGgsIG91dGVyLmNsaWVudFdpZHRoXG5cdFx0Ly9cblx0XHQvLyBJRTYgWFA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwIDEwMCAxMDAgIDgzXG5cdFx0Ly8gSUU3IFZpc3RhOiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCAxMDAgMTAwICA4M1xuXHRcdC8vIElFIDgrIFdpbmRvd3M6ICAgICAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcblx0XHQvLyBFdmVyZ3JlZW4gV2luZG93czogICAgICAgICAgICAgICAgIDgzICA4MyAxMDAgIDgzXG5cdFx0Ly8gRXZlcmdyZWVuIE1hYyB3aXRoIHNjcm9sbGJhcnM6ICAgICA4NSAgODUgMTAwICA4NVxuXHRcdC8vIEV2ZXJncmVlbiBNYWMgd2l0aG91dCBzY3JvbGxiYXJzOiAxMDAgMTAwIDEwMCAxMDBcblxuXHRcdC8vIEdldCBzY3JvbGxiYXIgd2lkdGhcblx0XHRicm93c2VyLmJhcldpZHRoID0gb3V0ZXJbMF0ub2Zmc2V0V2lkdGggLSBvdXRlclswXS5jbGllbnRXaWR0aDtcblxuXHRcdC8vIElFNi83IHdpbGwgb3ZlcnNpemUgYSB3aWR0aCAxMDAlIGVsZW1lbnQgaW5zaWRlIGEgc2Nyb2xsaW5nIGVsZW1lbnQsIHRvXG5cdFx0Ly8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhciwgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZW5zdXJlIHRoZSBpbm5lclxuXHRcdC8vIGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhvdXQgZm9yY2luZyBzY3JvbGxpbmdcblx0XHRicm93c2VyLmJTY3JvbGxPdmVyc2l6ZSA9IGlubmVyWzBdLm9mZnNldFdpZHRoID09PSAxMDAgJiYgb3V0ZXJbMF0uY2xpZW50V2lkdGggIT09IDEwMDtcblxuXHRcdC8vIEluIHJ0bCB0ZXh0IGxheW91dCwgc29tZSBicm93c2VycyAobW9zdCwgYnV0IG5vdCBhbGwpIHdpbGwgcGxhY2UgdGhlXG5cdFx0Ly8gc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0LCByYXRoZXIgdGhhbiB0aGUgcmlnaHQuXG5cdFx0YnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA9IE1hdGgucm91bmQoIGlubmVyLm9mZnNldCgpLmxlZnQgKSAhPT0gMTtcblxuXHRcdC8vIElFOC0gZG9uJ3QgcHJvdmlkZSBoZWlnaHQgYW5kIHdpZHRoIGZvciBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRicm93c2VyLmJCb3VuZGluZyA9IG5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0cnVlIDogZmFsc2U7XG5cblx0XHRuLnJlbW92ZSgpO1xuXHR9XG5cblx0JC5leHRlbmQoIHNldHRpbmdzLm9Ccm93c2VyLCBEYXRhVGFibGUuX19icm93c2VyICk7XG5cdHNldHRpbmdzLm9TY3JvbGwuaUJhcldpZHRoID0gRGF0YVRhYmxlLl9fYnJvd3Nlci5iYXJXaWR0aDtcbn1cblxuXG4vKipcbiAqIEFycmF5LnByb3RvdHlwZSByZWR1Y2VbUmlnaHRdIG1ldGhvZCwgdXNlZCBmb3IgYnJvd3NlcnMgd2hpY2ggZG9uJ3Qgc3VwcG9ydFxuICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5SZWR1Y2UgKCB0aGF0LCBmbiwgaW5pdCwgc3RhcnQsIGVuZCwgaW5jIClcbntcblx0dmFyXG5cdFx0aSA9IHN0YXJ0LFxuXHRcdHZhbHVlLFxuXHRcdGlzU2V0ID0gZmFsc2U7XG5cblx0aWYgKCBpbml0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dmFsdWUgPSBpbml0O1xuXHRcdGlzU2V0ID0gdHJ1ZTtcblx0fVxuXG5cdHdoaWxlICggaSAhPT0gZW5kICkge1xuXHRcdGlmICggISB0aGF0Lmhhc093blByb3BlcnR5KGkpICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSBpc1NldCA/XG5cdFx0XHRmbiggdmFsdWUsIHRoYXRbaV0sIGksIHRoYXQgKSA6XG5cdFx0XHR0aGF0W2ldO1xuXG5cdFx0aXNTZXQgPSB0cnVlO1xuXHRcdGkgKz0gaW5jO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEFkZCBhIGNvbHVtbiB0byB0aGUgbGlzdCB1c2VkIGZvciB0aGUgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge25vZGV9IG5UaCBUaGUgdGggZWxlbWVudCBmb3IgdGhpcyBjb2x1bW5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MsIG5UaCApXG57XG5cdC8vIEFkZCBjb2x1bW4gdG8gYW9Db2x1bW5zIGFycmF5XG5cdHZhciBvRGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uO1xuXHR2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHR2YXIgb0NvbCA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uLCBvRGVmYXVsdHMsIHtcblx0XHRcIm5UaFwiOiBuVGggPyBuVGggOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpLFxuXHRcdFwic1RpdGxlXCI6ICAgIG9EZWZhdWx0cy5zVGl0bGUgICAgPyBvRGVmYXVsdHMuc1RpdGxlICAgIDogblRoID8gblRoLmlubmVySFRNTCA6ICcnLFxuXHRcdFwiYURhdGFTb3J0XCI6IG9EZWZhdWx0cy5hRGF0YVNvcnQgPyBvRGVmYXVsdHMuYURhdGFTb3J0IDogW2lDb2xdLFxuXHRcdFwibURhdGFcIjogb0RlZmF1bHRzLm1EYXRhID8gb0RlZmF1bHRzLm1EYXRhIDogaUNvbCxcblx0XHRpZHg6IGlDb2xcblx0fSApO1xuXHRvU2V0dGluZ3MuYW9Db2x1bW5zLnB1c2goIG9Db2wgKTtcblxuXHQvLyBBZGQgc2VhcmNoIG9iamVjdCBmb3IgY29sdW1uIHNwZWNpZmljIHNlYXJjaC4gTm90ZSB0aGF0IHRoZSBgc2VhcmNoQ29sc1sgaUNvbCBdYFxuXHQvLyBwYXNzZWQgaW50byBleHRlbmQgY2FuIGJlIHVuZGVmaW5lZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZ2l2ZSBhIGRlZmF1bHRcblx0Ly8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XG5cdHZhciBzZWFyY2hDb2xzID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcblx0c2VhcmNoQ29sc1sgaUNvbCBdID0gJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbIGlDb2wgXSApO1xuXG5cdC8vIFVzZSB0aGUgZGVmYXVsdCBjb2x1bW4gb3B0aW9ucyBmdW5jdGlvbiB0byBpbml0aWFsaXNlIGNsYXNzZXMgZXRjXG5cdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgJChuVGgpLmRhdGEoKSApO1xufVxuXG5cbi8qKlxuICogQXBwbHkgb3B0aW9ucyBmb3IgYSBjb2x1bW5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9PcHRpb25zIG9iamVjdCB3aXRoIHNUeXBlLCBiVmlzaWJsZSBhbmQgYlNlYXJjaGFibGUgZXRjXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb09wdGlvbnMgKVxue1xuXHR2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbIGlDb2wgXTtcblx0dmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHR2YXIgdGggPSAkKG9Db2wublRoKTtcblxuXHQvLyBUcnkgdG8gZ2V0IHdpZHRoIGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gV2UgY2FuJ3QgZ2V0IGl0IGZyb20gQ1NTXG5cdC8vIGFzIHdlJ2QgbmVlZCB0byBwYXJzZSB0aGUgQ1NTIHN0eWxlc2hlZXQuIGB3aWR0aGAgb3B0aW9uIGNhbiBvdmVycmlkZVxuXHRpZiAoICEgb0NvbC5zV2lkdGhPcmlnICkge1xuXHRcdC8vIFdpZHRoIGF0dHJpYnV0ZVxuXHRcdG9Db2wuc1dpZHRoT3JpZyA9IHRoLmF0dHIoJ3dpZHRoJykgfHwgbnVsbDtcblxuXHRcdC8vIFN0eWxlIGF0dHJpYnV0ZVxuXHRcdHZhciB0ID0gKHRoLmF0dHIoJ3N0eWxlJykgfHwgJycpLm1hdGNoKC93aWR0aDpcXHMqKFxcZCtbcHhlbSVdKykvKTtcblx0XHRpZiAoIHQgKSB7XG5cdFx0XHRvQ29sLnNXaWR0aE9yaWcgPSB0WzFdO1xuXHRcdH1cblx0fVxuXG5cdC8qIFVzZXIgc3BlY2lmaWVkIGNvbHVtbiBvcHRpb25zICovXG5cdGlmICggb09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCApXG5cdHtcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdF9mbkNvbXBhdENvbHMoIG9PcHRpb25zICk7XG5cblx0XHQvLyBNYXAgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHNcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucywgdHJ1ZSApO1xuXG5cdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIG1EYXRhUHJvcCAqL1xuXHRcdGlmICggb09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhIClcblx0XHR7XG5cdFx0XHRvT3B0aW9ucy5tRGF0YSA9IG9PcHRpb25zLm1EYXRhUHJvcDtcblx0XHR9XG5cblx0XHRpZiAoIG9PcHRpb25zLnNUeXBlIClcblx0XHR7XG5cdFx0XHRvQ29sLl9zTWFudWFsVHlwZSA9IG9PcHRpb25zLnNUeXBlO1xuXHRcdH1cblxuXHRcdC8vIGBjbGFzc2AgaXMgYSByZXNlcnZlZCB3b3JkIGluIEphdmFzY3JpcHQsIHNvIHdlIG5lZWQgdG8gcHJvdmlkZVxuXHRcdC8vIHRoZSBhYmlsaXR5IHRvIHVzZSBhIHZhbGlkIG5hbWUgZm9yIHRoZSBjYW1lbCBjYXNlIGlucHV0XG5cdFx0aWYgKCBvT3B0aW9ucy5jbGFzc05hbWUgJiYgISBvT3B0aW9ucy5zQ2xhc3MgKVxuXHRcdHtcblx0XHRcdG9PcHRpb25zLnNDbGFzcyA9IG9PcHRpb25zLmNsYXNzTmFtZTtcblx0XHR9XG5cdFx0aWYgKCBvT3B0aW9ucy5zQ2xhc3MgKSB7XG5cdFx0XHR0aC5hZGRDbGFzcyggb09wdGlvbnMuc0NsYXNzICk7XG5cdFx0fVxuXG5cdFx0dmFyIG9yaWdDbGFzcyA9IG9Db2wuc0NsYXNzO1xuXG5cdFx0JC5leHRlbmQoIG9Db2wsIG9PcHRpb25zICk7XG5cdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJzV2lkdGhcIiwgXCJzV2lkdGhPcmlnXCIgKTtcblxuXHRcdC8vIE1lcmdlIGNsYXNzIGZyb20gcHJldmlvdXNseSBkZWZpbmVkIGNsYXNzZXMgd2l0aCB0aGlzIG9uZSwgcmF0aGVyIHRoYW4ganVzdFxuXHRcdC8vIG92ZXJ3cml0aW5nIGl0IGluIHRoZSBleHRlbmQgYWJvdmVcblx0XHRpZiAob3JpZ0NsYXNzICE9PSBvQ29sLnNDbGFzcykge1xuXHRcdFx0b0NvbC5zQ2xhc3MgPSBvcmlnQ2xhc3MgKyAnICcgKyBvQ29sLnNDbGFzcztcblx0XHR9XG5cblx0XHQvKiBpRGF0YVNvcnQgdG8gYmUgYXBwbGllZCAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLCBidXQgYURhdGFTb3J0IHdpbGwgdGFrZVxuXHRcdCAqIHByaW9yaXR5IGlmIGRlZmluZWRcblx0XHQgKi9cblx0XHRpZiAoIG9PcHRpb25zLmlEYXRhU29ydCAhPT0gdW5kZWZpbmVkIClcblx0XHR7XG5cdFx0XHRvQ29sLmFEYXRhU29ydCA9IFsgb09wdGlvbnMuaURhdGFTb3J0IF07XG5cdFx0fVxuXHRcdF9mbk1hcCggb0NvbCwgb09wdGlvbnMsIFwiYURhdGFTb3J0XCIgKTtcblx0fVxuXG5cdC8qIENhY2hlIHRoZSBkYXRhIGdldCBhbmQgc2V0IGZ1bmN0aW9ucyBmb3Igc3BlZWQgKi9cblx0dmFyIG1EYXRhU3JjID0gb0NvbC5tRGF0YTtcblx0dmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApO1xuXHR2YXIgbVJlbmRlciA9IG9Db2wubVJlbmRlciA/IF9mbkdldE9iamVjdERhdGFGbiggb0NvbC5tUmVuZGVyICkgOiBudWxsO1xuXG5cdHZhciBhdHRyVGVzdCA9IGZ1bmN0aW9uKCBzcmMgKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyYy5pbmRleE9mKCdAJykgIT09IC0xO1xuXHR9O1xuXHRvQ29sLl9iQXR0clNyYyA9ICQuaXNQbGFpbk9iamVjdCggbURhdGFTcmMgKSAmJiAoXG5cdFx0YXR0clRlc3QobURhdGFTcmMuc29ydCkgfHwgYXR0clRlc3QobURhdGFTcmMudHlwZSkgfHwgYXR0clRlc3QobURhdGFTcmMuZmlsdGVyKVxuXHQpO1xuXHRvQ29sLl9zZXR0ZXIgPSBudWxsO1xuXG5cdG9Db2wuZm5HZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHR5cGUsIG1ldGEpIHtcblx0XHR2YXIgaW5uZXJEYXRhID0gbURhdGEoIHJvd0RhdGEsIHR5cGUsIHVuZGVmaW5lZCwgbWV0YSApO1xuXG5cdFx0cmV0dXJuIG1SZW5kZXIgJiYgdHlwZSA/XG5cdFx0XHRtUmVuZGVyKCBpbm5lckRhdGEsIHR5cGUsIHJvd0RhdGEsIG1ldGEgKSA6XG5cdFx0XHRpbm5lckRhdGE7XG5cdH07XG5cdG9Db2wuZm5TZXREYXRhID0gZnVuY3Rpb24gKCByb3dEYXRhLCB2YWwsIG1ldGEgKSB7XG5cdFx0cmV0dXJuIF9mblNldE9iamVjdERhdGFGbiggbURhdGFTcmMgKSggcm93RGF0YSwgdmFsLCBtZXRhICk7XG5cdH07XG5cblx0Ly8gSW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBzaG91bGQgcmVhZCBET00gZGF0YSBhcyBhbiBvYmplY3Qgb3IgYXJyYXlcblx0Ly8gVXNlZCBpbiBfZm5HZXRSb3dFbGVtZW50c1xuXHRpZiAoIHR5cGVvZiBtRGF0YVNyYyAhPT0gJ251bWJlcicgJiYgISBvQ29sLl9pc0FycmF5SG9zdCApIHtcblx0XHRvU2V0dGluZ3MuX3Jvd1JlYWRPYmplY3QgPSB0cnVlO1xuXHR9XG5cblx0LyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cblx0aWYgKCAhb1NldHRpbmdzLm9GZWF0dXJlcy5iU29ydCApXG5cdHtcblx0XHRvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xuXHRcdHRoLmFkZENsYXNzKCBvQ2xhc3Nlcy5zU29ydGFibGVOb25lICk7IC8vIEhhdmUgdG8gYWRkIGNsYXNzIGhlcmUgYXMgb3JkZXIgZXZlbnQgaXNuJ3QgY2FsbGVkXG5cdH1cblxuXHQvKiBDaGVjayB0aGF0IHRoZSBjbGFzcyBhc3NpZ25tZW50IGlzIGNvcnJlY3QgZm9yIHNvcnRpbmcgKi9cblx0dmFyIGJBc2MgPSAkLmluQXJyYXkoJ2FzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdHZhciBiRGVzYyA9ICQuaW5BcnJheSgnZGVzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XG5cdGlmICggIW9Db2wuYlNvcnRhYmxlIHx8ICghYkFzYyAmJiAhYkRlc2MpIClcblx0e1xuXHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZU5vbmU7XG5cdFx0b0NvbC5zU29ydGluZ0NsYXNzSlVJID0gXCJcIjtcblx0fVxuXHRlbHNlIGlmICggYkFzYyAmJiAhYkRlc2MgKVxuXHR7XG5cdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlQXNjO1xuXHRcdG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZDtcblx0fVxuXHRlbHNlIGlmICggIWJBc2MgJiYgYkRlc2MgKVxuXHR7XG5cdFx0b0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlRGVzYztcblx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZTtcblx0XHRvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSTtcblx0fVxufVxuXG5cbi8qKlxuICogQWRqdXN0IHRoZSB0YWJsZSBjb2x1bW4gd2lkdGhzIGZvciBuZXcgZGF0YS4gTm90ZTogeW91IHdvdWxkIHByb2JhYmx5IHdhbnQgdG9cbiAqIGRvIGEgcmVkcmF3IGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiFcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRqdXN0Q29sdW1uU2l6aW5nICggc2V0dGluZ3MgKVxue1xuXHQvKiBOb3QgaW50ZXJlc3RlZCBpbiBkb2luZyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24gaWYgYXV0by13aWR0aCBpcyBkaXNhYmxlZCAqL1xuXHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iQXV0b1dpZHRoICE9PSBmYWxzZSApXG5cdHtcblx0XHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblxuXHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyggc2V0dGluZ3MgKTtcblx0XHRmb3IgKCB2YXIgaT0wICwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0Y29sdW1uc1tpXS5uVGguc3R5bGUud2lkdGggPSBjb2x1bW5zW2ldLnNXaWR0aDtcblx0XHR9XG5cdH1cblxuXHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0aWYgKCBzY3JvbGwuc1kgIT09ICcnIHx8IHNjcm9sbC5zWCAhPT0gJycpXG5cdHtcblx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHR9XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi1zaXppbmcnLCBbc2V0dGluZ3NdICk7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBpbmRleCBvZiBhIHZpc2libGUgY29sdW1uIHRvIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSAodGFrZSBhY2NvdW50XG4gKiBvZiBoaWRkZW4gY29sdW1ucylcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBWaXNpYmxlIGNvbHVtbiBpbmRleCB0byBsb29rdXBcbiAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlNYXRjaCApXG57XG5cdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXG5cdHJldHVybiB0eXBlb2YgYWlWaXNbaU1hdGNoXSA9PT0gJ251bWJlcicgP1xuXHRcdGFpVmlzW2lNYXRjaF0gOlxuXHRcdG51bGw7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuICogICBjb2x1bW4gaW5kZXggKHRha2UgYWNjb3VudCBvZiBoaWRkZW4gY29sdW1ucylcbiAqICBAcGFyYW0ge2ludH0gaU1hdGNoIENvbHVtbiBpbmRleCB0byBsb29rdXBcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggb1NldHRpbmdzLCBpTWF0Y2ggKVxue1xuXHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0dmFyIGlQb3MgPSAkLmluQXJyYXkoIGlNYXRjaCwgYWlWaXMgKTtcblxuXHRyZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBudW1iZXIgb2YgdmlzaWJsZSBjb2x1bW5zXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblZpc2JsZUNvbHVtbnMoIG9TZXR0aW5ncyApXG57XG5cdHZhciB2aXMgPSAwO1xuXG5cdC8vIE5vIHJlZHVjZSBpbiBJRTgsIHVzZSBhIGxvb3AgZm9yIG5vd1xuXHQkLmVhY2goIG9TZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggaSwgY29sICkge1xuXHRcdGlmICggY29sLmJWaXNpYmxlICYmICQoY29sLm5UaCkuY3NzKCdkaXNwbGF5JykgIT09ICdub25lJyApIHtcblx0XHRcdHZpcysrO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiB2aXM7XG59XG5cblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdGhhdCBtYXRjaCBhIGdpdmVuIHByb3BlcnR5XG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBzUGFyYW0gUGFyYW1ldGVyIGluIGFvQ29sdW1ucyB0byBsb29rIGZvciAtIHR5cGljYWxseVxuICogICAgYlZpc2libGUgb3IgYlNlYXJjaGFibGVcbiAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCBzUGFyYW0gKVxue1xuXHR2YXIgYSA9IFtdO1xuXG5cdCQubWFwKCBvU2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbih2YWwsIGkpIHtcblx0XHRpZiAoIHZhbFtzUGFyYW1dICkge1xuXHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIGE7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5UeXBlcyAoIHNldHRpbmdzIClcbntcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHR2YXIgdHlwZXMgPSBEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0O1xuXHR2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcblx0dmFyIGNvbCwgY2VsbCwgZGV0ZWN0ZWRUeXBlLCBjYWNoZTtcblxuXHQvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgXG5cdGZvciAoIGk9MCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0Y29sID0gY29sdW1uc1tpXTtcblx0XHRjYWNoZSA9IFtdO1xuXG5cdFx0aWYgKCAhIGNvbC5zVHlwZSAmJiBjb2wuX3NNYW51YWxUeXBlICkge1xuXHRcdFx0Y29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0Zm9yICggaj0wLCBqZW49dHlwZXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdGZvciAoIGs9MCwga2VuPWRhdGEubGVuZ3RoIDsgazxrZW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0Ly8gVXNlIGEgY2FjaGUgYXJyYXkgc28gd2Ugb25seSBuZWVkIHRvIGdldCB0aGUgdHlwZSBkYXRhXG5cdFx0XHRcdFx0Ly8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuXHRcdFx0XHRcdGlmICggY2FjaGVba10gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGNhY2hlW2tdID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBrLCBpLCAndHlwZScgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZXRlY3RlZFR5cGUgPSB0eXBlc1tqXSggY2FjaGVba10sIHNldHRpbmdzICk7XG5cblx0XHRcdFx0XHQvLyBJZiBudWxsLCB0aGVuIHRoaXMgdHlwZSBjYW4ndCBhcHBseSB0byB0aGlzIGNvbHVtbiwgc29cblx0XHRcdFx0XHQvLyByYXRoZXIgdGhhbiB0ZXN0aW5nIGFsbCBjZWxscywgYnJlYWsgb3V0LiBUaGVyZSBpcyBhblxuXHRcdFx0XHRcdC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cblx0XHRcdFx0XHQvLyBzY2FuIGFsbCByb3dzIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIG1peCBzdHJpbmcgYW5kIEhUTUxcblx0XHRcdFx0XHQvLyB0eXBlc1xuXHRcdFx0XHRcdGlmICggISBkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoLTEgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGEgc2luZ2xlIG1hdGNoIGlzIG5lZWRlZCBmb3IgaHRtbCB0eXBlIHNpbmNlIGl0IGlzXG5cdFx0XHRcdFx0Ly8gYm90dG9tIG9mIHRoZSBwaWxlIGFuZCB2ZXJ5IHNpbWlsYXIgdG8gc3RyaW5nIC0gYnV0IGl0XG5cdFx0XHRcdFx0Ly8gbXVzdCBub3QgYmUgZW1wdHlcblx0XHRcdFx0XHRpZiAoIGRldGVjdGVkVHlwZSA9PT0gJ2h0bWwnICYmICEgX2VtcHR5KGNhY2hlW2tdKSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgaXMgdmFsaWQgZm9yIGFsbCBkYXRhIHBvaW50cyBpbiB0aGUgY29sdW1uIC0gdXNlIHRoaXNcblx0XHRcdFx0Ly8gdHlwZVxuXHRcdFx0XHRpZiAoIGRldGVjdGVkVHlwZSApIHtcblx0XHRcdFx0XHRjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbCBiYWNrIC0gaWYgbm8gdHlwZSB3YXMgZGV0ZWN0ZWQsIGFsd2F5cyB1c2Ugc3RyaW5nXG5cdFx0XHRpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRjb2wuc1R5cGUgPSAnc3RyaW5nJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XG4gKiB0aGV5IHJlbGF0ZSB0byBjb2x1bW4gaW5kZXhlcy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgdGhlbiBhcHBseSB0aGVcbiAqIGRlZmluaXRpb24gZm91bmQgZm9yIGEgY29sdW1uIHRvIGEgc3VpdGFibGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7YXJyYXl9IGFvQ29sRGVmcyBUaGUgYW9Db2x1bW5EZWZzIGFycmF5IHRoYXQgaXMgdG8gYmUgYXBwbGllZFxuICogIEBwYXJhbSB7YXJyYXl9IGFvQ29scyBUaGUgYW9Db2x1bW5zIGFycmF5IHRoYXQgZGVmaW5lcyBjb2x1bW5zIGluZGl2aWR1YWxseVxuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXG4gKiAgICBjb2x1bW4gaW5kZXggYW5kIHRoZSBkZWZpbml0aW9uIGZvciB0aGF0IGNvbHVtbi5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBmbiApXG57XG5cdHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBkZWY7XG5cdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblxuXHQvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xuXHRpZiAoIGFvQ29sRGVmcyApXG5cdHtcblx0XHQvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xuXHRcdGZvciAoIGk9YW9Db2xEZWZzLmxlbmd0aC0xIDsgaT49MCA7IGktLSApXG5cdFx0e1xuXHRcdFx0ZGVmID0gYW9Db2xEZWZzW2ldO1xuXG5cdFx0XHQvKiBFYWNoIGRlZmluaXRpb24gY2FuIHRhcmdldCBtdWx0aXBsZSBjb2x1bW5zLCBhcyBpdCBpcyBhbiBhcnJheSAqL1xuXHRcdFx0dmFyIGFUYXJnZXRzID0gZGVmLnRhcmdldCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gZGVmLnRhcmdldFxuXHRcdFx0XHQ6IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IGRlZi50YXJnZXRzXG5cdFx0XHRcdFx0OiBkZWYuYVRhcmdldHM7XG5cblx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBhVGFyZ2V0cyApIClcblx0XHRcdHtcblx0XHRcdFx0YVRhcmdldHMgPSBbIGFUYXJnZXRzIF07XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGo9MCwgakxlbj1hVGFyZ2V0cy5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPj0gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvKiBBZGQgY29sdW1ucyB0aGF0IHdlIGRvbid0IHlldCBrbm93IGFib3V0ICovXG5cdFx0XHRcdFx0d2hpbGUoIGNvbHVtbnMubGVuZ3RoIDw9IGFUYXJnZXRzW2pdIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEludGVnZXIsIGJhc2ljIGluZGV4ICovXG5cdFx0XHRcdFx0Zm4oIGFUYXJnZXRzW2pdLCBkZWYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA8IDAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogTmVnYXRpdmUgaW50ZWdlciwgcmlnaHQgdG8gbGVmdCBjb2x1bW4gY291bnRpbmcgKi9cblx0XHRcdFx0XHRmbiggY29sdW1ucy5sZW5ndGgrYVRhcmdldHNbal0sIGRlZiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgYVRhcmdldHNbal0gPT09ICdzdHJpbmcnIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIENsYXNzIG5hbWUgbWF0Y2hpbmcgb24gVEggZWxlbWVudCAqL1xuXHRcdFx0XHRcdGZvciAoIGs9MCwga0xlbj1jb2x1bW5zLmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKCBhVGFyZ2V0c1tqXSA9PSBcIl9hbGxcIiB8fFxuXHRcdFx0XHRcdFx0ICAgICAkKGNvbHVtbnNba10ublRoKS5oYXNDbGFzcyggYVRhcmdldHNbal0gKSApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGZuKCBrLCBkZWYgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTdGF0aWNhbGx5IGRlZmluZWQgY29sdW1ucyBhcnJheVxuXHRpZiAoIGFvQ29scyApXG5cdHtcblx0XHRmb3IgKCBpPTAsIGlMZW49YW9Db2xzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0Zm4oIGksIGFvQ29sc1tpXSApO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEFkZCBhIGRhdGEgYXJyYXkgdG8gdGhlIHRhYmxlLCBjcmVhdGluZyBET00gbm9kZSBldGMuIFRoaXMgaXMgdGhlIHBhcmFsbGVsIHRvXG4gKiBfZm5HYXRoZXJEYXRhLCBidXQgZm9yIGFkZGluZyByb3dzIGZyb20gYSBKYXZhc2NyaXB0IHNvdXJjZSwgcmF0aGVyIHRoYW4gYVxuICogRE9NIHNvdXJjZS5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHthcnJheX0gYURhdGEgZGF0YSBhcnJheSB0byBiZSBhZGRlZFxuICogIEBwYXJhbSB7bm9kZX0gW25Ucl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcbiAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG4gKiAgICBpZiBuVHIgaXMuXG4gKiAgQHJldHVybnMge2ludH0gPj0wIGlmIHN1Y2Nlc3NmdWwgKGluZGV4IG9mIG5ldyBhb0RhdGEgZW50cnkpLCAtMSBpZiBmYWlsZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkRGF0YSAoIG9TZXR0aW5ncywgYURhdGFJbiwgblRyLCBhblRkcyApXG57XG5cdC8qIENyZWF0ZSB0aGUgb2JqZWN0IGZvciBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHJvdyAqL1xuXHR2YXIgaVJvdyA9IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoO1xuXHR2YXIgb0RhdGEgPSAkLmV4dGVuZCggdHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1Jvdywge1xuXHRcdHNyYzogblRyID8gJ2RvbScgOiAnZGF0YScsXG5cdFx0aWR4OiBpUm93XG5cdH0gKTtcblxuXHRvRGF0YS5fYURhdGEgPSBhRGF0YUluO1xuXHRvU2V0dGluZ3MuYW9EYXRhLnB1c2goIG9EYXRhICk7XG5cblx0LyogQ3JlYXRlIHRoZSBjZWxscyAqL1xuXHR2YXIgblRkLCBzVGhpc1R5cGU7XG5cdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblxuXHQvLyBJbnZhbGlkYXRlIHRoZSBjb2x1bW4gdHlwZXMgYXMgdGhlIG5ldyBkYXRhIG5lZWRzIHRvIGJlIHJldmFsaWRhdGVkXG5cdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHR7XG5cdFx0Y29sdW1uc1tpXS5zVHlwZSA9IG51bGw7XG5cdH1cblxuXHQvKiBBZGQgdG8gdGhlIGRpc3BsYXkgYXJyYXkgKi9cblx0b1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5wdXNoKCBpUm93ICk7XG5cblx0dmFyIGlkID0gb1NldHRpbmdzLnJvd0lkRm4oIGFEYXRhSW4gKTtcblx0aWYgKCBpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdG9TZXR0aW5ncy5hSWRzWyBpZCBdID0gb0RhdGE7XG5cdH1cblxuXHQvKiBDcmVhdGUgdGhlIERPTSBpbmZvcm1hdGlvbiwgb3IgcmVnaXN0ZXIgaXQgaWYgYWxyZWFkeSBwcmVzZW50ICovXG5cdGlmICggblRyIHx8ICEgb1NldHRpbmdzLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIgKVxuXHR7XG5cdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaVJvdywgblRyLCBhblRkcyApO1xuXHR9XG5cblx0cmV0dXJuIGlSb3c7XG59XG5cblxuLyoqXG4gKiBBZGQgb25lIG9yIG1vcmUgVFIgZWxlbWVudHMgdG8gdGhlIHRhYmxlLiBHZW5lcmFsbHkgd2UnZCBleHBlY3QgdG9cbiAqIHVzZSB0aGlzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBhIERPTSBzb3VyY2VkIHRhYmxlLCBidXQgaXQgY291bGQgYmVcbiAqIHVzZWQgZm9yIGFuIFRSIGVsZW1lbnQuIE5vdGUgdGhhdCBpZiBhIFRSIGlzIGdpdmVuLCBpdCBpcyB1c2VkIChpLmUuXG4gKiBpdCBpcyBub3QgY2xvbmVkKS5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2FycmF5fG5vZGV8alF1ZXJ5fSB0cnMgVGhlIFRSIGVsZW1lbnQocykgdG8gYWRkIHRvIHRoZSB0YWJsZVxuICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyBmb3IgdGhlIGFkZGVkIHJvd3NcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkVHIoIHNldHRpbmdzLCB0cnMgKVxue1xuXHR2YXIgcm93O1xuXG5cdC8vIEFsbG93IGFuIGluZGl2aWR1YWwgbm9kZSB0byBiZSBwYXNzZWQgaW5cblx0aWYgKCAhICh0cnMgaW5zdGFuY2VvZiAkKSApIHtcblx0XHR0cnMgPSAkKHRycyk7XG5cdH1cblxuXHRyZXR1cm4gdHJzLm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0cm93ID0gX2ZuR2V0Um93RWxlbWVudHMoIHNldHRpbmdzLCBlbCApO1xuXHRcdHJldHVybiBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93LmRhdGEsIGVsLCByb3cuY2VsbHMgKTtcblx0fSApO1xufVxuXG5cbi8qKlxuICogVGFrZSBhIFRSIGVsZW1lbnQgYW5kIGNvbnZlcnQgaXQgdG8gYW4gaW5kZXggaW4gYW9EYXRhXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7bm9kZX0gbiB0aGUgVFIgZWxlbWVudCB0byBmaW5kXG4gKiAgQHJldHVybnMge2ludH0gaW5kZXggaWYgdGhlIG5vZGUgaXMgZm91bmQsIG51bGwgaWYgbm90XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbk5vZGVUb0RhdGFJbmRleCggb1NldHRpbmdzLCBuIClcbntcblx0cmV0dXJuIChuLl9EVF9Sb3dJbmRleCE9PXVuZGVmaW5lZCkgPyBuLl9EVF9Sb3dJbmRleCA6IG51bGw7XG59XG5cblxuLyoqXG4gKiBUYWtlIGEgVEQgZWxlbWVudCBhbmQgY29udmVydCBpdCBpbnRvIGEgY29sdW1uIGRhdGEgaW5kZXggKG5vdCB0aGUgdmlzaWJsZSBpbmRleClcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBudW1iZXIgdGhlIFREL1RIIGNhbiBiZSBmb3VuZCBpblxuICogIEBwYXJhbSB7bm9kZX0gbiBUaGUgVEQvVEggZWxlbWVudCB0byBmaW5kXG4gKiAgQHJldHVybnMge2ludH0gaW5kZXggaWYgdGhlIG5vZGUgaXMgZm91bmQsIC0xIGlmIG5vdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Ob2RlVG9Db2x1bW5JbmRleCggb1NldHRpbmdzLCBpUm93LCBuIClcbntcblx0cmV0dXJuICQuaW5BcnJheSggbiwgb1NldHRpbmdzLmFvRGF0YVsgaVJvdyBdLmFuQ2VsbHMgKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgZGF0YSBmb3IgYSBnaXZlbiBjZWxsIGZyb20gdGhlIGludGVybmFsIGNhY2hlLCB0YWtpbmcgaW50byBhY2NvdW50IGRhdGEgbWFwcGluZ1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG4gKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcnxzZWFyY2gnICdzb3J0fG9yZGVyJylcbiAqICBAcmV0dXJucyB7Kn0gQ2VsbCBkYXRhXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHR5cGUgKVxue1xuXHRpZiAodHlwZSA9PT0gJ3NlYXJjaCcpIHtcblx0XHR0eXBlID0gJ2ZpbHRlcic7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ29yZGVyJykge1xuXHRcdHR5cGUgPSAnc29ydCc7XG5cdH1cblxuXHR2YXIgZHJhdyAgICAgICAgICAgPSBzZXR0aW5ncy5pRHJhdztcblx0dmFyIGNvbCAgICAgICAgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdHZhciByb3dEYXRhICAgICAgICA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcblx0dmFyIGRlZmF1bHRDb250ZW50ID0gY29sLnNEZWZhdWx0Q29udGVudDtcblx0dmFyIGNlbGxEYXRhICAgICAgID0gY29sLmZuR2V0RGF0YSggcm93RGF0YSwgdHlwZSwge1xuXHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdGNvbDogICAgICBjb2xJZHhcblx0fSApO1xuXG5cdGlmICggY2VsbERhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIHNldHRpbmdzLmlEcmF3RXJyb3IgIT0gZHJhdyAmJiBkZWZhdWx0Q29udGVudCA9PT0gbnVsbCApIHtcblx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiUmVxdWVzdGVkIHVua25vd24gcGFyYW1ldGVyIFwiK1xuXHRcdFx0XHQodHlwZW9mIGNvbC5tRGF0YT09J2Z1bmN0aW9uJyA/ICd7ZnVuY3Rpb259JyA6IFwiJ1wiK2NvbC5tRGF0YStcIidcIikrXG5cdFx0XHRcdFwiIGZvciByb3cgXCIrcm93SWR4K1wiLCBjb2x1bW4gXCIrY29sSWR4LCA0ICk7XG5cdFx0XHRzZXR0aW5ncy5pRHJhd0Vycm9yID0gZHJhdztcblx0XHR9XG5cdFx0cmV0dXJuIGRlZmF1bHRDb250ZW50O1xuXHR9XG5cblx0Ly8gV2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCBhbmQgYSBzcGVjaWZpYyBkYXRhIHR5cGUgaXMgcmVxdWVzdGVkIChpLmUuXG5cdC8vIG5vdCB0aGUgb3JpZ2luYWwgZGF0YSksIHdlIGNhbiB1c2UgZGVmYXVsdCBjb2x1bW4gZGF0YVxuXHRpZiAoIChjZWxsRGF0YSA9PT0gcm93RGF0YSB8fCBjZWxsRGF0YSA9PT0gbnVsbCkgJiYgZGVmYXVsdENvbnRlbnQgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNlbGxEYXRhID0gZGVmYXVsdENvbnRlbnQ7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBjZWxsRGF0YSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHQvLyBJZiB0aGUgZGF0YSBzb3VyY2UgaXMgYSBmdW5jdGlvbiwgdGhlbiB3ZSBydW4gaXQgYW5kIHVzZSB0aGUgcmV0dXJuLFxuXHRcdC8vIGV4ZWN1dGluZyBpbiB0aGUgc2NvcGUgb2YgdGhlIGRhdGEgb2JqZWN0IChmb3IgaW5zdGFuY2VzKVxuXHRcdHJldHVybiBjZWxsRGF0YS5jYWxsKCByb3dEYXRhICk7XG5cdH1cblxuXHRpZiAoIGNlbGxEYXRhID09PSBudWxsICYmIHR5cGUgPT09ICdkaXNwbGF5JyApIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRpZiAoIHR5cGUgPT09ICdmaWx0ZXInICkge1xuXHRcdHZhciBmb21hdHRlcnMgPSBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoO1xuXG5cdFx0aWYgKCBmb21hdHRlcnNbIGNvbC5zVHlwZSBdICkge1xuXHRcdFx0Y2VsbERhdGEgPSBmb21hdHRlcnNbIGNvbC5zVHlwZSBdKCBjZWxsRGF0YSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjZWxsRGF0YTtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc3BlY2lmaWMgY2VsbCwgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBjYWNoZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG4gKiAgQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gc2V0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHZhbCApXG57XG5cdHZhciBjb2wgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXG5cdGNvbC5mblNldERhdGEoIHJvd0RhdGEsIHZhbCwge1xuXHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdGNvbDogICAgICBjb2xJZHhcblx0fSAgKTtcbn1cblxuXG4vLyBQcml2YXRlIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBtYXRjaCBhY3Rpb24gc3ludGF4IGluIHRoZSBkYXRhIHByb3BlcnR5IG9iamVjdFxudmFyIF9fcmVBcnJheSA9IC9cXFsuKj9cXF0kLztcbnZhciBfX3JlRm4gPSAvXFwoXFwpJC87XG5cbi8qKlxuICogU3BsaXQgc3RyaW5nIG9uIHBlcmlvZHMsIHRha2luZyBpbnRvIGFjY291bnQgZXNjYXBlZCBwZXJpb2RzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXRcbiAqIEByZXR1cm4ge2FycmF5fSBTcGxpdCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gX2ZuU3BsaXRPYmpOb3RhdGlvbiggc3RyIClcbntcblx0cmV0dXJuICQubWFwKCBzdHIubWF0Y2goLyhcXFxcLnxbXlxcLl0pKy9nKSB8fCBbJyddLCBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0cmV0dXJuIHMucmVwbGFjZSgvXFxcXFxcLi9nLCAnLicpO1xuXHR9ICk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGdldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcbiAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcbiAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG4gKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIGdldCBmdW5jdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG52YXIgX2ZuR2V0T2JqZWN0RGF0YUZuID0gRGF0YVRhYmxlLnV0aWwuZ2V0O1xuXG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG4gKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG4gKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBzZXQgZnVuY3Rpb25cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xudmFyIF9mblNldE9iamVjdERhdGFGbiA9IERhdGFUYWJsZS51dGlsLnNldDtcblxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBmdWxsIHRhYmxlIGRhdGFcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyICggc2V0dGluZ3MgKVxue1xuXHRyZXR1cm4gX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdfYURhdGEnICk7XG59XG5cblxuLyoqXG4gKiBOdWtlIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKVxue1xuXHRzZXR0aW5ncy5hb0RhdGEubGVuZ3RoID0gMDtcblx0c2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aCA9IDA7XG5cdHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuXHRzZXR0aW5ncy5hSWRzID0ge307XG59XG5cblxuIC8qKlxuICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3RcbiAqIHRoZSBrZXkhKVxuICogIEBwYXJhbSB7YXJyYXl9IGEgSW5kZXggYXJyYXkgdG8gdGFyZ2V0XG4gKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5EZWxldGVJbmRleCggYSwgaVRhcmdldCwgc3BsaWNlIClcbntcblx0dmFyIGlUYXJnZXRJbmRleCA9IC0xO1xuXG5cdGZvciAoIHZhciBpPTAsIGlMZW49YS5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHR7XG5cdFx0aWYgKCBhW2ldID09IGlUYXJnZXQgKVxuXHRcdHtcblx0XHRcdGlUYXJnZXRJbmRleCA9IGk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhW2ldID4gaVRhcmdldCApXG5cdFx0e1xuXHRcdFx0YVtpXS0tO1xuXHRcdH1cblx0fVxuXG5cdGlmICggaVRhcmdldEluZGV4ICE9IC0xICYmIHNwbGljZSA9PT0gdW5kZWZpbmVkIClcblx0e1xuXHRcdGEuc3BsaWNlKCBpVGFyZ2V0SW5kZXgsIDEgKTtcblx0fVxufVxuXG5cbi8qKlxuICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG4gKiB0aGUgY2FjaGVkIGRhdGEgaXMgbmV4dCByZXF1ZXN0ZWQuIEFsc28gdXBkYXRlIGZyb20gdGhlIGRhdGEgc291cmNlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7aW50fSAgICByb3dJZHggICBSb3cgaW5kZXggdG8gaW52YWxpZGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdICAgIFNvdXJjZSB0byBpbnZhbGlkYXRlIGZyb206IHVuZGVmaW5lZCwgJ2F1dG8nLCAnZG9tJ1xuICogICAgIG9yICdkYXRhJ1xuICogQHBhcmFtIHtpbnR9ICAgIFtjb2xJZHhdIENvbHVtbiBpbmRleCB0byBpbnZhbGlkYXRlLiBJZiB1bmRlZmluZWQgdGhlIHdob2xlXG4gKiAgICAgcm93IHdpbGwgYmUgaW52YWxpZGF0ZWRcbiAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICpcbiAqIEB0b2RvIEZvciB0aGUgbW9kdWxhcmlzYXRpb24gb2YgdjEuMTEgdGhpcyB3aWxsIG5lZWQgdG8gYmVjb21lIGEgY2FsbGJhY2ssIHNvXG4gKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcbiAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBmb3Igc29ydGluZywgd2hpY2ggaXMgd2h5IGl0IGlzIG5vdCBhbHJlYWR5IGJha2VkIGluXG4gKi9cbmZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcbntcblx0dmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVsgcm93SWR4IF07XG5cdHZhciBpLCBpZW47XG5cdHZhciBjZWxsV3JpdGUgPSBmdW5jdGlvbiAoIGNlbGwsIGNvbCApIHtcblx0XHQvLyBUaGlzIGlzIHZlcnkgZnJ1c3RyYXRpbmcsIGJ1dCBpbiBJRSBpZiB5b3UganVzdCB3cml0ZSBkaXJlY3RseVxuXHRcdC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcblx0XHQvLyBldmVuIGlmIHRoZXJlIGlzIGEgcmVmZXJlbmNlIHRvIHRoZW0gZWxzZXdoZXJlXG5cdFx0d2hpbGUgKCBjZWxsLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0Y2VsbC5yZW1vdmVDaGlsZCggY2VsbC5maXJzdENoaWxkICk7XG5cdFx0fVxuXG5cdFx0Y2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sLCAnZGlzcGxheScgKTtcblx0fTtcblxuXHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRpZiAoIHNyYyA9PT0gJ2RvbScgfHwgKCghIHNyYyB8fCBzcmMgPT09ICdhdXRvJykgJiYgcm93LnNyYyA9PT0gJ2RvbScpICkge1xuXHRcdC8vIFJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgRE9NXG5cdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRzZXR0aW5ncywgcm93LCBjb2xJZHgsIGNvbElkeCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcm93Ll9hRGF0YVxuXHRcdFx0KVxuXHRcdFx0LmRhdGE7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdHZhciBjZWxscyA9IHJvdy5hbkNlbGxzO1xuXG5cdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdGlmICggY29sSWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGNlbGxXcml0ZSggY2VsbHNbY29sSWR4XSwgY29sSWR4ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm9yICggaT0wLCBpZW49Y2VsbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2VsbFdyaXRlKCBjZWxsc1tpXSwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuXHQvLyBmaWx0ZXJpbmcgaXMgbnVsbGVkIG91dFxuXHRyb3cuX2FTb3J0RGF0YSA9IG51bGw7XG5cdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXG5cdC8vIEludmFsaWRhdGUgdGhlIHR5cGUgZm9yIGEgc3BlY2lmaWMgY29sdW1uIChpZiBnaXZlbikgb3IgYWxsIGNvbHVtbnMgc2luY2Vcblx0Ly8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRpZiAoIGNvbElkeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNvbHNbIGNvbElkeCBdLnNUeXBlID0gbnVsbDtcblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sc1tpXS5zVHlwZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIERhdGFUYWJsZXMgc3BlY2lhbCBgRFRfKmAgYXR0cmlidXRlcyBmb3IgdGhlIHJvd1xuXHRcdF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKTtcblx0fVxufVxuXG5cbi8qKlxuICogQnVpbGQgYSBkYXRhIHNvdXJjZSBvYmplY3QgZnJvbSBhbiBIVE1MIHJvdywgcmVhZGluZyB0aGUgY29udGVudHMgb2YgdGhlXG4gKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcbiAqICAgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmUtcmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBjZWxsc1xuICogQHBhcmFtIHtpbnR9IFtjb2xJZHhdIE9wdGlvbmFsIGNvbHVtbiBpbmRleFxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xuICogICBwYXJhbWV0ZXIgc2hvdWxkIGFsc28gYmUgZ2l2ZW4gYW5kIHdpbGwgYmUgdXNlZCB0byB3cml0ZSB0aGUgZGF0YSBpbnRvLlxuICogICBPbmx5IHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gd2lsbCBiZSB3cml0dGVuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXG4gKiAgIGRvY3VtZW50IG9yZGVyLCBhbmQgYGNlbGxzYCBhbmQgYXJyYXkgb2Ygbm9kZXMgKHRoZXkgY2FuIGJlIHVzZWZ1bCB0byB0aGVcbiAqICAgY2FsbGVyLCBzbyByYXRoZXIgdGhhbiBuZWVkaW5nIGEgc2Vjb25kIHRyYXZlcnNhbCB0byBnZXQgdGhlbSwganVzdCByZXR1cm5cbiAqICAgdGhlbSBmcm9tIGhlcmUpLlxuICogQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQgKVxue1xuXHR2YXJcblx0XHR0ZHMgPSBbXSxcblx0XHR0ZCA9IHJvdy5maXJzdENoaWxkLFxuXHRcdG5hbWUsIGNvbCwgbywgaT0wLCBjb250ZW50cyxcblx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdG9iamVjdFJlYWQgPSBzZXR0aW5ncy5fcm93UmVhZE9iamVjdDtcblxuXHQvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3Rcblx0ZCA9IGQgIT09IHVuZGVmaW5lZCA/XG5cdFx0ZCA6XG5cdFx0b2JqZWN0UmVhZCA/XG5cdFx0XHR7fSA6XG5cdFx0XHRbXTtcblxuXHR2YXIgYXR0ciA9IGZ1bmN0aW9uICggc3RyLCB0ZCAgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyApIHtcblx0XHRcdHZhciBpZHggPSBzdHIuaW5kZXhPZignQCcpO1xuXG5cdFx0XHRpZiAoIGlkeCAhPT0gLTEgKSB7XG5cdFx0XHRcdHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyggaWR4KzEgKTtcblx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggc3RyICk7XG5cdFx0XHRcdHNldHRlciggZCwgdGQuZ2V0QXR0cmlidXRlKCBhdHRyICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gUmVhZCBkYXRhIGZyb20gYSBjZWxsIGFuZCBzdG9yZSBpbnRvIHRoZSBkYXRhIG9iamVjdFxuXHR2YXIgY2VsbFByb2Nlc3MgPSBmdW5jdGlvbiAoIGNlbGwgKSB7XG5cdFx0aWYgKCBjb2xJZHggPT09IHVuZGVmaW5lZCB8fCBjb2xJZHggPT09IGkgKSB7XG5cdFx0XHRjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdFx0Y29udGVudHMgPSAoY2VsbC5pbm5lckhUTUwpLnRyaW0oKTtcblxuXHRcdFx0aWYgKCBjb2wgJiYgY29sLl9iQXR0clNyYyApIHtcblx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhLl8gKTtcblx0XHRcdFx0c2V0dGVyKCBkLCBjb250ZW50cyApO1xuXG5cdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5zb3J0LCBjZWxsICk7XG5cdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS50eXBlLCBjZWxsICk7XG5cdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5maWx0ZXIsIGNlbGwgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBEZXBlbmRpbmcgb24gdGhlIGBkYXRhYCBvcHRpb24gZm9yIHRoZSBjb2x1bW5zIHRoZSBkYXRhIGNhblxuXHRcdFx0XHQvLyBiZSByZWFkIHRvIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuXG5cdFx0XHRcdGlmICggb2JqZWN0UmVhZCApIHtcblx0XHRcdFx0XHRpZiAoICEgY29sLl9zZXR0ZXIgKSB7XG5cdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRjb2wuX3NldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbC5fc2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGRbaV0gPSBjb250ZW50cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGkrKztcblx0fTtcblxuXHRpZiAoIHRkICkge1xuXHRcdC8vIGB0cmAgZWxlbWVudCB3YXMgcGFzc2VkIGluXG5cdFx0d2hpbGUgKCB0ZCApIHtcblx0XHRcdG5hbWUgPSB0ZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG5hbWUgPT0gXCJURFwiIHx8IG5hbWUgPT0gXCJUSFwiICkge1xuXHRcdFx0XHRjZWxsUHJvY2VzcyggdGQgKTtcblx0XHRcdFx0dGRzLnB1c2goIHRkICk7XG5cdFx0XHR9XG5cblx0XHRcdHRkID0gdGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXG5cdFx0dGRzID0gcm93LmFuQ2VsbHM7XG5cblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGRzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0Y2VsbFByb2Nlc3MoIHRkc1tqXSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlYWQgdGhlIElEIGZyb20gdGhlIERPTSBpZiBwcmVzZW50XG5cdHZhciByb3dOb2RlID0gcm93LmZpcnN0Q2hpbGQgPyByb3cgOiByb3cublRyO1xuXG5cdGlmICggcm93Tm9kZSApIHtcblx0XHR2YXIgaWQgPSByb3dOb2RlLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXG5cdFx0aWYgKCBpZCApIHtcblx0XHRcdF9mblNldE9iamVjdERhdGFGbiggc2V0dGluZ3Mucm93SWQgKSggZCwgaWQgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IGQsXG5cdFx0Y2VsbHM6IHRkc1xuXHR9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVFIgZWxlbWVudCAoYW5kIGl0J3MgVEQgY2hpbGRyZW4pIGZvciBhIHJvd1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gaVJvdyBSb3cgdG8gY29uc2lkZXJcbiAqICBAcGFyYW0ge25vZGV9IFtuVHJJbl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcbiAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG4gKiAgICBpZiBuVHIgaXMuXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNyZWF0ZVRyICggb1NldHRpbmdzLCBpUm93LCBuVHJJbiwgYW5UZHMgKVxue1xuXHR2YXJcblx0XHRyb3cgPSBvU2V0dGluZ3MuYW9EYXRhW2lSb3ddLFxuXHRcdHJvd0RhdGEgPSByb3cuX2FEYXRhLFxuXHRcdGNlbGxzID0gW10sXG5cdFx0blRyLCBuVGQsIG9Db2wsXG5cdFx0aSwgaUxlbiwgY3JlYXRlO1xuXG5cdGlmICggcm93Lm5UciA9PT0gbnVsbCApXG5cdHtcblx0XHRuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG5cdFx0cm93Lm5UciA9IG5Ucjtcblx0XHRyb3cuYW5DZWxscyA9IGNlbGxzO1xuXG5cdFx0LyogVXNlIGEgcHJpdmF0ZSBwcm9wZXJ0eSBvbiB0aGUgbm9kZSB0byBhbGxvdyByZXNlcnZlIG1hcHBpbmcgZnJvbSB0aGUgbm9kZVxuXHRcdCAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxuXHRcdCAqL1xuXHRcdG5Uci5fRFRfUm93SW5kZXggPSBpUm93O1xuXG5cdFx0LyogU3BlY2lhbCBwYXJhbWV0ZXJzIGNhbiBiZSBnaXZlbiBieSB0aGUgZGF0YSBzb3VyY2UgdG8gYmUgdXNlZCBvbiB0aGUgcm93ICovXG5cdFx0X2ZuUm93QXR0cmlidXRlcyggb1NldHRpbmdzLCByb3cgKTtcblxuXHRcdC8qIFByb2Nlc3MgZWFjaCBjb2x1bW4gKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49b1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xuXHRcdFx0Y3JlYXRlID0gblRySW4gPyBmYWxzZSA6IHRydWU7XG5cblx0XHRcdG5UZCA9IGNyZWF0ZSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIG9Db2wuc0NlbGxUeXBlICkgOiBhblRkc1tpXTtcblxuXHRcdFx0aWYgKCEgblRkKSB7XG5cdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW5jb3JyZWN0IGNvbHVtbiBjb3VudCcsIDE4ICk7XG5cdFx0XHR9XG5cblx0XHRcdG5UZC5fRFRfQ2VsbEluZGV4ID0ge1xuXHRcdFx0XHRyb3c6IGlSb3csXG5cdFx0XHRcdGNvbHVtbjogaVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y2VsbHMucHVzaCggblRkICk7XG5cblx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIHRoZSBIVE1MIGlmIG5ldywgb3IgaWYgYSByZW5kZXJpbmcgZnVuY3Rpb24gaXMgZGVmaW5lZFxuXHRcdFx0aWYgKCBjcmVhdGUgfHwgKChvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcblx0XHRcdFx0ICghJC5pc1BsYWluT2JqZWN0KG9Db2wubURhdGEpIHx8IG9Db2wubURhdGEuXyAhPT0gaSsnLmRpc3BsYXknKVxuXHRcdFx0KSkge1xuXHRcdFx0XHRuVGQuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSwgJ2Rpc3BsYXknICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIEFkZCB1c2VyIGRlZmluZWQgY2xhc3MgKi9cblx0XHRcdGlmICggb0NvbC5zQ2xhc3MgKVxuXHRcdFx0e1xuXHRcdFx0XHRuVGQuY2xhc3NOYW1lICs9ICcgJytvQ29sLnNDbGFzcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gVmlzaWJpbGl0eSAtIGFkZCBvciByZW1vdmUgYXMgcmVxdWlyZWRcblx0XHRcdGlmICggb0NvbC5iVmlzaWJsZSAmJiAhIG5UckluIClcblx0XHRcdHtcblx0XHRcdFx0blRyLmFwcGVuZENoaWxkKCBuVGQgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIG9Db2wuYlZpc2libGUgJiYgblRySW4gKVxuXHRcdFx0e1xuXHRcdFx0XHRuVGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggblRkICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb0NvbC5mbkNyZWF0ZWRDZWxsIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbC5mbkNyZWF0ZWRDZWxsLmNhbGwoIG9TZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRcdFx0blRkLCBfZm5HZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpICksIHJvd0RhdGEsIGlSb3csIGlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgbnVsbCwgW25Uciwgcm93RGF0YSwgaVJvdywgY2VsbHNdICk7XG5cdH1cbn1cblxuXG4vKipcbiAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxuICogc291cmNlIG9iamVjdC5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKVxue1xuXHR2YXIgdHIgPSByb3cublRyO1xuXHR2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cblx0aWYgKCB0ciApIHtcblx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhICk7XG5cblx0XHRpZiAoIGlkICkge1xuXHRcdFx0dHIuaWQgPSBpZDtcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuRFRfUm93Q2xhc3MgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYW55IGNsYXNzZXMgYWRkZWQgYnkgRFRfUm93Q2xhc3MgYmVmb3JlXG5cdFx0XHR2YXIgYSA9IGRhdGEuRFRfUm93Q2xhc3Muc3BsaXQoJyAnKTtcblx0XHRcdHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cblx0XHRcdFx0X3VuaXF1ZSggcm93Ll9fcm93Yy5jb25jYXQoIGEgKSApIDpcblx0XHRcdFx0YTtcblxuXHRcdFx0JCh0cilcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCByb3cuX19yb3djLmpvaW4oJyAnKSApXG5cdFx0XHRcdC5hZGRDbGFzcyggZGF0YS5EVF9Sb3dDbGFzcyApO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YS5EVF9Sb3dBdHRyICkge1xuXHRcdFx0JCh0cikuYXR0ciggZGF0YS5EVF9Sb3dBdHRyICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLkRUX1Jvd0RhdGEgKSB7XG5cdFx0XHQkKHRyKS5kYXRhKCBkYXRhLkRUX1Jvd0RhdGEgKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQnVpbGRIZWFkKCBvU2V0dGluZ3MgKVxue1xuXHR2YXIgaSwgaWVuLCBjZWxsLCByb3csIGNvbHVtbjtcblx0dmFyIHRoZWFkID0gb1NldHRpbmdzLm5USGVhZDtcblx0dmFyIHRmb290ID0gb1NldHRpbmdzLm5URm9vdDtcblx0dmFyIGNyZWF0ZUhlYWRlciA9ICQoJ3RoLCB0ZCcsIHRoZWFkKS5sZW5ndGggPT09IDA7XG5cdHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHR2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0aWYgKCBjcmVhdGVIZWFkZXIgKSB7XG5cdFx0cm93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdGhlYWQgKTtcblx0fVxuXG5cdGZvciAoIGk9MCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0Y29sdW1uID0gY29sdW1uc1tpXTtcblx0XHRjZWxsID0gJCggY29sdW1uLm5UaCApLmFkZENsYXNzKCBjb2x1bW4uc0NsYXNzICk7XG5cblx0XHRpZiAoIGNyZWF0ZUhlYWRlciApIHtcblx0XHRcdGNlbGwuYXBwZW5kVG8oIHJvdyApO1xuXHRcdH1cblxuXHRcdC8vIDEuMTEgbW92ZSBpbnRvIHNvcnRpbmdcblx0XHRpZiAoIG9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0XHRjZWxsLmFkZENsYXNzKCBjb2x1bW4uc1NvcnRpbmdDbGFzcyApO1xuXG5cdFx0XHRpZiAoIGNvbHVtbi5iU29ydGFibGUgIT09IGZhbHNlICkge1xuXHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0LmF0dHIoICd0YWJpbmRleCcsIG9TZXR0aW5ncy5pVGFiSW5kZXggKVxuXHRcdFx0XHRcdC5hdHRyKCAnYXJpYS1jb250cm9scycsIG9TZXR0aW5ncy5zVGFibGVJZCApO1xuXG5cdFx0XHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lciggb1NldHRpbmdzLCBjb2x1bW4ublRoLCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBjb2x1bW4uc1RpdGxlICE9IGNlbGxbMF0uaW5uZXJIVE1MICkge1xuXHRcdFx0Y2VsbC5odG1sKCBjb2x1bW4uc1RpdGxlICk7XG5cdFx0fVxuXG5cdFx0X2ZuUmVuZGVyZXIoIG9TZXR0aW5ncywgJ2hlYWRlcicgKShcblx0XHRcdG9TZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzXG5cdFx0KTtcblx0fVxuXG5cdGlmICggY3JlYXRlSGVhZGVyICkge1xuXHRcdF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCApO1xuXHR9XG5cblx0LyogRGVhbCB3aXRoIHRoZSBmb290ZXIgLSBhZGQgY2xhc3NlcyBpZiByZXF1aXJlZCAqL1xuXHQkKHRoZWFkKS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJykuYWRkQ2xhc3MoIGNsYXNzZXMuc0hlYWRlclRIICk7XG5cdCQodGZvb3QpLmNoaWxkcmVuKCd0cicpLmNoaWxkcmVuKCd0aCwgdGQnKS5hZGRDbGFzcyggY2xhc3Nlcy5zRm9vdGVyVEggKTtcblxuXHQvLyBDYWNoZSB0aGUgZm9vdGVyIGNlbGxzLiBOb3RlIHRoYXQgd2Ugb25seSB0YWtlIHRoZSBjZWxscyBmcm9tIHRoZSBmaXJzdFxuXHQvLyByb3cgaW4gdGhlIGZvb3Rlci4gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSByb3cgdGhlIHVzZXIgd2FudHMgdG9cblx0Ly8gaW50ZXJhY3Qgd2l0aCwgdGhleSBuZWVkIHRvIHVzZSB0aGUgdGFibGUoKS5mb290KCkgbWV0aG9kLiBOb3RlIGFsc28gdGhpc1xuXHQvLyBhbGxvd3MgY2VsbHMgdG8gYmUgdXNlZCBmb3IgbXVsdGlwbGUgY29sdW1ucyB1c2luZyBjb2xzcGFuXG5cdGlmICggdGZvb3QgIT09IG51bGwgKSB7XG5cdFx0dmFyIGNlbGxzID0gb1NldHRpbmdzLmFvRm9vdGVyWzBdO1xuXG5cdFx0Zm9yICggaT0wLCBpZW49Y2VsbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXG5cdFx0XHRpZiAoY29sdW1uKSB7XG5cdFx0XHRcdGNvbHVtbi5uVGYgPSBjZWxsc1tpXS5jZWxsO1xuXHRcblx0XHRcdFx0aWYgKCBjb2x1bW4uc0NsYXNzICkge1xuXHRcdFx0XHRcdCQoY29sdW1uLm5UZikuYWRkQ2xhc3MoIGNvbHVtbi5zQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW5jb3JyZWN0IGNvbHVtbiBjb3VudCcsIDE4ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBEcmF3IHRoZSBoZWFkZXIgKG9yIGZvb3RlcikgZWxlbWVudCBiYXNlZCBvbiB0aGUgY29sdW1uIHZpc2liaWxpdHkgc3RhdGVzLiBUaGVcbiAqIG1ldGhvZG9sb2d5IGhlcmUgaXMgdG8gdXNlIHRoZSBsYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXIsIG1vZGlmaWVkIGZvclxuICogdGhlIGluc3RhbnRhbmVvdXMgY29sdW1uIHZpc2liaWxpdHksIHRvIGNvbnN0cnVjdCB0aGUgbmV3IGxheW91dC4gVGhlIGdyaWQgaXNcbiAqIHRyYXZlcnNlZCBvdmVyIGNlbGwgYXQgYSB0aW1lIGluIGEgcm93cyB4IGNvbHVtbnMgZ3JpZCBmYXNoaW9uLCBhbHRob3VnaCBlYWNoXG4gKiBjZWxsIGluc2VydCBjYW4gY292ZXIgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIGdyaWQgLSB3aGljaCBpcyB0cmFja3MgdXNpbmcgdGhlXG4gKiBhQXBwbGllZCBhcnJheS4gQ2VsbCBpbnNlcnRzIGluIHRoZSBncmlkIHdpbGwgb25seSBvY2N1ciB3aGVyZSB0aGVyZSBpc24ndFxuICogYWxyZWFkeSBhIGNlbGwgaW4gdGhhdCBwb3NpdGlvbi5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIGFycmF5IHtvYmplY3RzfSBhb1NvdXJjZSBMYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXJcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFtiSW5jbHVkZUhpZGRlbj1mYWxzZV0gSWYgdHJ1ZSB0aGVuIGluY2x1ZGUgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBjYWxjLFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5EcmF3SGVhZCggb1NldHRpbmdzLCBhb1NvdXJjZSwgYkluY2x1ZGVIaWRkZW4gKVxue1xuXHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgbiwgbkxvY2FsVHI7XG5cdHZhciBhb0xvY2FsID0gW107XG5cdHZhciBhQXBwbGllZCA9IFtdO1xuXHR2YXIgaUNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcblx0dmFyIGlSb3dzcGFuLCBpQ29sc3BhbjtcblxuXHRpZiAoICEgYW9Tb3VyY2UgKVxuXHR7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCAgYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCApXG5cdHtcblx0XHRiSW5jbHVkZUhpZGRlbiA9IGZhbHNlO1xuXHR9XG5cblx0LyogTWFrZSBhIGNvcHkgb2YgdGhlIG1hc3RlciBsYXlvdXQgYXJyYXksIGJ1dCB3aXRob3V0IHRoZSB2aXNpYmxlIGNvbHVtbnMgaW4gaXQgKi9cblx0Zm9yICggaT0wLCBpTGVuPWFvU291cmNlLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdHtcblx0XHRhb0xvY2FsW2ldID0gYW9Tb3VyY2VbaV0uc2xpY2UoKTtcblx0XHRhb0xvY2FsW2ldLm5UciA9IGFvU291cmNlW2ldLm5UcjtcblxuXHRcdC8qIFJlbW92ZSBhbnkgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGhpZGRlbiAqL1xuXHRcdGZvciAoIGo9aUNvbHVtbnMtMSA7IGo+PTAgOyBqLS0gKVxuXHRcdHtcblx0XHRcdGlmICggIW9TZXR0aW5ncy5hb0NvbHVtbnNbal0uYlZpc2libGUgJiYgIWJJbmNsdWRlSGlkZGVuIClcblx0XHRcdHtcblx0XHRcdFx0YW9Mb2NhbFtpXS5zcGxpY2UoIGosIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBQcmVwIHRoZSBhcHBsaWVkIGFycmF5IC0gaXQgbmVlZHMgYW4gZWxlbWVudCBmb3IgZWFjaCByb3cgKi9cblx0XHRhQXBwbGllZC5wdXNoKCBbXSApO1xuXHR9XG5cblx0Zm9yICggaT0wLCBpTGVuPWFvTG9jYWwubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0e1xuXHRcdG5Mb2NhbFRyID0gYW9Mb2NhbFtpXS5uVHI7XG5cblx0XHQvKiBBbGwgY2VsbHMgYXJlIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBzbyBlbXB0eSBvdXQgdGhlIHJvdyAqL1xuXHRcdGlmICggbkxvY2FsVHIgKVxuXHRcdHtcblx0XHRcdHdoaWxlKCAobiA9IG5Mb2NhbFRyLmZpcnN0Q2hpbGQpIClcblx0XHRcdHtcblx0XHRcdFx0bkxvY2FsVHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCBqPTAsIGpMZW49YW9Mb2NhbFtpXS5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdHtcblx0XHRcdGlSb3dzcGFuID0gMTtcblx0XHRcdGlDb2xzcGFuID0gMTtcblxuXHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuXHRcdFx0ICogaW5zZXJ0IHBvaW50LiBJZiB0aGVyZSBpcywgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLlxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQgKVxuXHRcdFx0e1xuXHRcdFx0XHRuTG9jYWxUci5hcHBlbmRDaGlsZCggYW9Mb2NhbFtpXVtqXS5jZWxsICk7XG5cdFx0XHRcdGFBcHBsaWVkW2ldW2pdID0gMTtcblxuXHRcdFx0XHQvKiBFeHBhbmQgdGhlIGNlbGwgdG8gY292ZXIgYXMgbWFueSByb3dzIGFzIG5lZWRlZCAqL1xuXHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaStpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2kraVJvd3NwYW5dW2pdLmNlbGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YUFwcGxpZWRbaStpUm93c3Bhbl1bal0gPSAxO1xuXHRcdFx0XHRcdGlSb3dzcGFuKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBFeHBhbmQgdGhlIGNlbGwgdG8gY292ZXIgYXMgbWFueSBjb2x1bW5zIGFzIG5lZWRlZCAqL1xuXHRcdFx0XHR3aGlsZSAoIGFvTG9jYWxbaV1baitpQ29sc3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2ldW2oraUNvbHNwYW5dLmNlbGwgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogTXVzdCB1cGRhdGUgdGhlIGFwcGxpZWQgYXJyYXkgb3ZlciB0aGUgcm93cyBmb3IgdGhlIGNvbHVtbnMgKi9cblx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPGlSb3dzcGFuIDsgaysrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhQXBwbGllZFtpK2tdW2oraUNvbHNwYW5dID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aUNvbHNwYW4rKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIERvIHRoZSBhY3R1YWwgZXhwYW5zaW9uIGluIHRoZSBET00gKi9cblx0XHRcdFx0JChhb0xvY2FsW2ldW2pdLmNlbGwpXG5cdFx0XHRcdFx0LmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3Bhbilcblx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIGlDb2xzcGFuKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIGFqYXhDb21wbGV0ZSB0cnVlIGFmdGVyIGFqYXggY2FsbCB0byBjb21wbGV0ZSByZW5kZXJpbmdcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRHJhdyggb1NldHRpbmdzLCBhamF4Q29tcGxldGUgKVxue1xuXHQvLyBBbGxvdyBmb3Igc3RhdGUgc2F2aW5nIGFuZCBhIGN1c3RvbSBzdGFydCBwb3NpdGlvblxuXHRfZm5TdGFydCggb1NldHRpbmdzICk7XG5cblx0LyogUHJvdmlkZSBhIHByZS1jYWxsYmFjayBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcgaXMgZmFsc2UgaXMgcmV0dXJuZWQgKi9cblx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0aWYgKCAkLmluQXJyYXkoIGZhbHNlLCBhUHJlRHJhdyApICE9PSAtMSApXG5cdHtcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBhblJvd3MgPSBbXTtcblx0dmFyIGlSb3dDb3VudCA9IDA7XG5cdHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xuXHR2YXIgaVN0cmlwZXMgPSBhc1N0cmlwZUNsYXNzZXMubGVuZ3RoO1xuXHR2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0dmFyIGFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXk7XG5cdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHR2YXIgaURpc3BsYXlFbmQgPSBvU2V0dGluZ3MuZm5EaXNwbGF5RW5kKCk7XG5cblx0b1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcblxuXHQvKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGRyYXcgaW50ZXJjZXB0ICovXG5cdGlmICggb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgKVxuXHR7XG5cdFx0b1NldHRpbmdzLmJEZWZlckxvYWRpbmcgPSBmYWxzZTtcblx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHR9XG5cdGVsc2UgaWYgKCAhYlNlcnZlclNpZGUgKVxuXHR7XG5cdFx0b1NldHRpbmdzLmlEcmF3Kys7XG5cdH1cblx0ZWxzZSBpZiAoICFvU2V0dGluZ3MuYkRlc3Ryb3lpbmcgJiYgIWFqYXhDb21wbGV0ZSlcblx0e1xuXHRcdF9mbkFqYXhVcGRhdGUoIG9TZXR0aW5ncyApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggYWlEaXNwbGF5Lmxlbmd0aCAhPT0gMCApXG5cdHtcblx0XHR2YXIgaVN0YXJ0ID0gYlNlcnZlclNpZGUgPyAwIDogaURpc3BsYXlTdGFydDtcblx0XHR2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcblxuXHRcdGZvciAoIHZhciBqPWlTdGFydCA7IGo8aUVuZCA7IGorKyApXG5cdFx0e1xuXHRcdFx0dmFyIGlEYXRhSW5kZXggPSBhaURpc3BsYXlbal07XG5cdFx0XHR2YXIgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YVsgaURhdGFJbmRleCBdO1xuXHRcdFx0aWYgKCBhb0RhdGEublRyID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaURhdGFJbmRleCApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgblJvdyA9IGFvRGF0YS5uVHI7XG5cblx0XHRcdC8qIFJlbW92ZSB0aGUgb2xkIHN0cmlwaW5nIGNsYXNzZXMgYW5kIHRoZW4gYWRkIHRoZSBuZXcgb25lICovXG5cdFx0XHRpZiAoIGlTdHJpcGVzICE9PSAwIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIHNTdHJpcGUgPSBhc1N0cmlwZUNsYXNzZXNbIGlSb3dDb3VudCAlIGlTdHJpcGVzIF07XG5cdFx0XHRcdGlmICggYW9EYXRhLl9zUm93U3RyaXBlICE9IHNTdHJpcGUgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0JChuUm93KS5yZW1vdmVDbGFzcyggYW9EYXRhLl9zUm93U3RyaXBlICkuYWRkQ2xhc3MoIHNTdHJpcGUgKTtcblx0XHRcdFx0XHRhb0RhdGEuX3NSb3dTdHJpcGUgPSBzU3RyaXBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xuXHRcdFx0Ly8gaVJvd0NvdW50IGFuZCBqIGFyZSBub3QgY3VycmVudGx5IGRvY3VtZW50ZWQuIEFyZSB0aGV5IGF0IGFsbFxuXHRcdFx0Ly8gdXNlZnVsP1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgbnVsbCxcblx0XHRcdFx0W25Sb3csIGFvRGF0YS5fYURhdGEsIGlSb3dDb3VudCwgaiwgaURhdGFJbmRleF0gKTtcblxuXHRcdFx0YW5Sb3dzLnB1c2goIG5Sb3cgKTtcblx0XHRcdGlSb3dDb3VudCsrO1xuXHRcdH1cblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXQgKi9cblx0XHR2YXIgc1plcm8gPSBvTGFuZy5zWmVyb1JlY29yZHM7XG5cdFx0aWYgKCBvU2V0dGluZ3MuaURyYXcgPT0gMSAmJiAgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT0gJ2FqYXgnIClcblx0XHR7XG5cdFx0XHRzWmVybyA9IG9MYW5nLnNMb2FkaW5nUmVjb3Jkcztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9MYW5nLnNFbXB0eVRhYmxlICYmIG9TZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwIClcblx0XHR7XG5cdFx0XHRzWmVybyA9IG9MYW5nLnNFbXB0eVRhYmxlO1xuXHRcdH1cblxuXHRcdGFuUm93c1sgMCBdID0gJCggJzx0ci8+JywgeyAnY2xhc3MnOiBpU3RyaXBlcyA/IGFzU3RyaXBlQ2xhc3Nlc1swXSA6ICcnIH0gKVxuXHRcdFx0LmFwcGVuZCggJCgnPHRkIC8+Jywge1xuXHRcdFx0XHQndmFsaWduJzogICd0b3AnLFxuXHRcdFx0XHQnY29sU3Bhbic6IF9mblZpc2JsZUNvbHVtbnMoIG9TZXR0aW5ncyApLFxuXHRcdFx0XHQnY2xhc3MnOiAgIG9TZXR0aW5ncy5vQ2xhc3Nlcy5zUm93RW1wdHlcblx0XHRcdH0gKS5odG1sKCBzWmVybyApIClbMF07XG5cdH1cblxuXHQvKiBIZWFkZXIgYW5kIGZvb3RlciBjYWxsYmFja3MgKi9cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFsgJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcblx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFsgJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcblx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cblx0dmFyIGJvZHkgPSAkKG9TZXR0aW5ncy5uVEJvZHkpO1xuXG5cdGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0Ym9keS5hcHBlbmQoICQoYW5Sb3dzKSApO1xuXG5cdC8qIENhbGwgYWxsIHJlcXVpcmVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGVuZCBvZiBhIGRyYXcgKi9cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10gKTtcblxuXHQvKiBEcmF3IGlzIGNvbXBsZXRlLCBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgbXVzdCBiZSBhcyB3ZWxsICovXG5cdG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XG5cdG9TZXR0aW5ncy5iRmlsdGVyZWQgPSBmYWxzZTtcblx0b1NldHRpbmdzLmJEcmF3aW5nID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtib29sZWFufSBbaG9sZFBvc2l0aW9uXSBLZWVwIHRoZSBjdXJyZW50IHBhZ2luZyBwb3NpdGlvbi4gQnkgZGVmYXVsdFxuICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKVxue1xuXHR2YXJcblx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRzb3J0ICAgICA9IGZlYXR1cmVzLmJTb3J0LFxuXHRcdGZpbHRlciAgID0gZmVhdHVyZXMuYkZpbHRlcjtcblxuXHRpZiAoIHNvcnQgKSB7XG5cdFx0X2ZuU29ydCggc2V0dGluZ3MgKTtcblx0fVxuXG5cdGlmICggZmlsdGVyICkge1xuXHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gTm8gZmlsdGVyaW5nLCBzbyB3ZSB3YW50IHRvIGp1c3QgdXNlIHRoZSBkaXNwbGF5IG1hc3RlclxuXHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHR9XG5cblx0aWYgKCBob2xkUG9zaXRpb24gIT09IHRydWUgKSB7XG5cdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHR9XG5cblx0Ly8gTGV0IGFueSBtb2R1bGVzIGtub3cgYWJvdXQgdGhlIGRyYXcgaG9sZCBwb3NpdGlvbiBzdGF0ZSAodXNlZCBieVxuXHQvLyBzY3JvbGxpbmcgaW50ZXJuYWxseSlcblx0c2V0dGluZ3MuX2RyYXdIb2xkID0gaG9sZFBvc2l0aW9uO1xuXG5cdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cblx0c2V0dGluZ3MuX2RyYXdIb2xkID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBBZGQgdGhlIG9wdGlvbnMgdG8gdGhlIHBhZ2UgSFRNTCBmb3IgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BZGRPcHRpb25zSHRtbCAoIG9TZXR0aW5ncyApXG57XG5cdHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHR2YXIgdGFibGUgPSAkKG9TZXR0aW5ncy5uVGFibGUpO1xuXHR2YXIgaG9sZGluZyA9ICQoJzxkaXYvPicpLmluc2VydEJlZm9yZSggdGFibGUgKTsgLy8gSG9sZGluZyBlbGVtZW50IGZvciBzcGVlZFxuXHR2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xuXG5cdC8vIEFsbCBEYXRhVGFibGVzIGFyZSB3cmFwcGVkIGluIGEgZGl2XG5cdHZhciBpbnNlcnQgPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0aWQ6ICAgICAgb1NldHRpbmdzLnNUYWJsZUlkKydfd3JhcHBlcicsXG5cdFx0J2NsYXNzJzogY2xhc3Nlcy5zV3JhcHBlciArIChvU2V0dGluZ3MublRGb290ID8gJycgOiAnICcrY2xhc3Nlcy5zTm9Gb290ZXIpXG5cdH0gKTtcblxuXHRvU2V0dGluZ3MubkhvbGRpbmcgPSBob2xkaW5nWzBdO1xuXHRvU2V0dGluZ3MublRhYmxlV3JhcHBlciA9IGluc2VydFswXTtcblx0b1NldHRpbmdzLm5UYWJsZVJlaW5zZXJ0QmVmb3JlID0gb1NldHRpbmdzLm5UYWJsZS5uZXh0U2libGluZztcblxuXHQvKiBMb29wIG92ZXIgdGhlIHVzZXIgc2V0IHBvc2l0aW9uaW5nIGFuZCBwbGFjZSB0aGUgZWxlbWVudHMgYXMgbmVlZGVkICovXG5cdHZhciBhRG9tID0gb1NldHRpbmdzLnNEb20uc3BsaXQoJycpO1xuXHR2YXIgZmVhdHVyZU5vZGUsIGNPcHRpb24sIG5OZXdOb2RlLCBjTmV4dCwgc0F0dHIsIGo7XG5cdGZvciAoIHZhciBpPTAgOyBpPGFEb20ubGVuZ3RoIDsgaSsrIClcblx0e1xuXHRcdGZlYXR1cmVOb2RlID0gbnVsbDtcblx0XHRjT3B0aW9uID0gYURvbVtpXTtcblxuXHRcdGlmICggY09wdGlvbiA9PSAnPCcgKVxuXHRcdHtcblx0XHRcdC8qIE5ldyBjb250YWluZXIgZGl2ICovXG5cdFx0XHRuTmV3Tm9kZSA9ICQoJzxkaXYvPicpWzBdO1xuXG5cdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIGFwcGVuZCBhbiBpZCBhbmQvb3IgYSBjbGFzcyBuYW1lIHRvIHRoZSBjb250YWluZXIgKi9cblx0XHRcdGNOZXh0ID0gYURvbVtpKzFdO1xuXHRcdFx0aWYgKCBjTmV4dCA9PSBcIidcIiB8fCBjTmV4dCA9PSAnXCInIClcblx0XHRcdHtcblx0XHRcdFx0c0F0dHIgPSBcIlwiO1xuXHRcdFx0XHRqID0gMjtcblx0XHRcdFx0d2hpbGUgKCBhRG9tW2kral0gIT0gY05leHQgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c0F0dHIgKz0gYURvbVtpK2pdO1xuXHRcdFx0XHRcdGorKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIFJlcGxhY2UgalF1ZXJ5IFVJIGNvbnN0YW50cyBAdG9kbyBkZXByZWNpYXRlZCAqL1xuXHRcdFx0XHRpZiAoIHNBdHRyID09IFwiSFwiIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNBdHRyID0gY2xhc3Nlcy5zSlVJSGVhZGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBzQXR0ciA9PSBcIkZcIiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzQXR0ciA9IGNsYXNzZXMuc0pVSUZvb3Rlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIFRoZSBhdHRyaWJ1dGUgY2FuIGJlIGluIHRoZSBmb3JtYXQgb2YgXCIjaWQuY2xhc3NcIiwgXCIjaWRcIiBvciBcImNsYXNzXCIgVGhpcyBsb2dpY1xuXHRcdFx0XHQgKiBicmVha3MgdGhlIHN0cmluZyBpbnRvIHBhcnRzIGFuZCBhcHBsaWVzIHRoZW0gYXMgbmVlZGVkXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIHNBdHRyLmluZGV4T2YoJy4nKSAhPSAtMSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgYVNwbGl0ID0gc0F0dHIuc3BsaXQoJy4nKTtcblx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IGFTcGxpdFswXS5zdWJzdHIoMSwgYVNwbGl0WzBdLmxlbmd0aC0xKTtcblx0XHRcdFx0XHRuTmV3Tm9kZS5jbGFzc05hbWUgPSBhU3BsaXRbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHNBdHRyLmNoYXJBdCgwKSA9PSBcIiNcIiApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuTmV3Tm9kZS5pZCA9IHNBdHRyLnN1YnN0cigxLCBzQXR0ci5sZW5ndGgtMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bk5ld05vZGUuY2xhc3NOYW1lID0gc0F0dHI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGo7IC8qIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5ICovXG5cdFx0XHR9XG5cblx0XHRcdGluc2VydC5hcHBlbmQoIG5OZXdOb2RlICk7XG5cdFx0XHRpbnNlcnQgPSAkKG5OZXdOb2RlKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJz4nIClcblx0XHR7XG5cdFx0XHQvKiBFbmQgY29udGFpbmVyIGRpdiAqL1xuXHRcdFx0aW5zZXJ0ID0gaW5zZXJ0LnBhcmVudCgpO1xuXHRcdH1cblx0XHQvLyBAdG9kbyBNb3ZlIG9wdGlvbnMgaW50byB0aGVpciBvd24gcGx1Z2lucz9cblx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAnbCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlICYmIGZlYXR1cmVzLmJMZW5ndGhDaGFuZ2UgKVxuXHRcdHtcblx0XHRcdC8qIExlbmd0aCAqL1xuXHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbExlbmd0aCggb1NldHRpbmdzICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBjT3B0aW9uID09ICdmJyAmJiBmZWF0dXJlcy5iRmlsdGVyIClcblx0XHR7XG5cdFx0XHQvKiBGaWx0ZXIgKi9cblx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIoIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAncicgJiYgZmVhdHVyZXMuYlByb2Nlc3NpbmcgKVxuXHRcdHtcblx0XHRcdC8qIHBSb2Nlc3NpbmcgKi9cblx0XHRcdGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gJ3QnIClcblx0XHR7XG5cdFx0XHQvKiBUYWJsZSAqL1xuXHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFRhYmxlKCBvU2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGNPcHRpb24gPT0gICdpJyAmJiBmZWF0dXJlcy5iSW5mbyApXG5cdFx0e1xuXHRcdFx0LyogSW5mbyAqL1xuXHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbEluZm8oIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggY09wdGlvbiA9PSAncCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlIClcblx0XHR7XG5cdFx0XHQvKiBQYWdpbmF0aW9uICovXG5cdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUoIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCApXG5cdFx0e1xuXHRcdFx0LyogUGx1Zy1pbiBmZWF0dXJlcyAqL1xuXHRcdFx0dmFyIGFvRmVhdHVyZXMgPSBEYXRhVGFibGUuZXh0LmZlYXR1cmU7XG5cdFx0XHRmb3IgKCB2YXIgaz0wLCBrTGVuPWFvRmVhdHVyZXMubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCBjT3B0aW9uID09IGFvRmVhdHVyZXNba10uY0ZlYXR1cmUgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBhb0ZlYXR1cmVzW2tdLmZuSW5pdCggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBBZGQgdG8gdGhlIDJEIGZlYXR1cmVzIGFycmF5ICovXG5cdFx0aWYgKCBmZWF0dXJlTm9kZSApXG5cdFx0e1xuXHRcdFx0dmFyIGFhbkZlYXR1cmVzID0gb1NldHRpbmdzLmFhbkZlYXR1cmVzO1xuXG5cdFx0XHRpZiAoICEgYWFuRmVhdHVyZXNbY09wdGlvbl0gKVxuXHRcdFx0e1xuXHRcdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRhYW5GZWF0dXJlc1tjT3B0aW9uXS5wdXNoKCBmZWF0dXJlTm9kZSApO1xuXHRcdFx0aW5zZXJ0LmFwcGVuZCggZmVhdHVyZU5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBCdWlsdCBvdXIgRE9NIHN0cnVjdHVyZSAtIHJlcGxhY2UgdGhlIGhvbGRpbmcgZGl2IHdpdGggd2hhdCB3ZSB3YW50ICovXG5cdGhvbGRpbmcucmVwbGFjZVdpdGgoIGluc2VydCApO1xuXHRvU2V0dGluZ3MubkhvbGRpbmcgPSBudWxsO1xufVxuXG5cbi8qKlxuICogVXNlIHRoZSBET00gc291cmNlIHRvIGNyZWF0ZSB1cCBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbHMuIFRoZSBpZGVhIGhlcmUgaXMgdG9cbiAqIGNyZWF0ZSBhIGxheW91dCBncmlkIChhcnJheSkgb2Ygcm93cyB4IGNvbHVtbnMsIHdoaWNoIGNvbnRhaW5zIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcbiAqIGFueSBjb2x1bW4gLyByb3cgY291bGQgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBncmlkIGNvbnN0cnVjdGVkXG4gKiAgQHBhcmFtIGFycmF5IHtvYmplY3R9IGFMYXlvdXQgQXJyYXkgdG8gc3RvcmUgdGhlIGNhbGN1bGF0ZWQgbGF5b3V0IGluXG4gKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlciAoIGFMYXlvdXQsIG5UaGVhZCApXG57XG5cdHZhciBuVHJzID0gJChuVGhlYWQpLmNoaWxkcmVuKCd0cicpO1xuXHR2YXIgblRyLCBuQ2VsbDtcblx0dmFyIGksIGssIGwsIGlMZW4sIGpMZW4sIGlDb2xTaGlmdGVkLCBpQ29sdW1uLCBpQ29sc3BhbiwgaVJvd3NwYW47XG5cdHZhciBiVW5pcXVlO1xuXHR2YXIgZm5TaGlmdENvbCA9IGZ1bmN0aW9uICggYSwgaSwgaiApIHtcblx0XHR2YXIgayA9IGFbaV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBrW2pdICkge1xuXHRcdFx0aisrO1xuXHRcdH1cblx0XHRyZXR1cm4gajtcblx0fTtcblxuXHRhTGF5b3V0LnNwbGljZSggMCwgYUxheW91dC5sZW5ndGggKTtcblxuXHQvKiBXZSBrbm93IGhvdyBtYW55IHJvd3MgdGhlcmUgYXJlIGluIHRoZSBsYXlvdXQgLSBzbyBwcmVwIGl0ICovXG5cdGZvciAoIGk9MCwgaUxlbj1uVHJzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdHtcblx0XHRhTGF5b3V0LnB1c2goIFtdICk7XG5cdH1cblxuXHQvKiBDYWxjdWxhdGUgYSBsYXlvdXQgYXJyYXkgKi9cblx0Zm9yICggaT0wLCBpTGVuPW5UcnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0e1xuXHRcdG5UciA9IG5UcnNbaV07XG5cdFx0aUNvbHVtbiA9IDA7XG5cblx0XHQvKiBGb3IgZXZlcnkgY2VsbCBpbiB0aGUgcm93Li4uICovXG5cdFx0bkNlbGwgPSBuVHIuZmlyc3RDaGlsZDtcblx0XHR3aGlsZSAoIG5DZWxsICkge1xuXHRcdFx0aWYgKCBuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVERcIiB8fFxuXHRcdFx0ICAgICBuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVEhcIiApXG5cdFx0XHR7XG5cdFx0XHRcdC8qIEdldCB0aGUgY29sIGFuZCByb3dzcGFuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgRE9NIGFuZCBzYW5pdGlzZSB0aGVtICovXG5cdFx0XHRcdGlDb2xzcGFuID0gbkNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykgKiAxO1xuXHRcdFx0XHRpUm93c3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcblx0XHRcdFx0aUNvbHNwYW4gPSAoIWlDb2xzcGFuIHx8IGlDb2xzcGFuPT09MCB8fCBpQ29sc3Bhbj09PTEpID8gMSA6IGlDb2xzcGFuO1xuXHRcdFx0XHRpUm93c3BhbiA9ICghaVJvd3NwYW4gfHwgaVJvd3NwYW49PT0wIHx8IGlSb3dzcGFuPT09MSkgPyAxIDogaVJvd3NwYW47XG5cblx0XHRcdFx0LyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XG5cdFx0XHRcdCAqIGFjY29yZGluZ2x5XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woIGFMYXlvdXQsIGksIGlDb2x1bW4gKTtcblxuXHRcdFx0XHQvKiBDYWNoZSBjYWxjdWxhdGlvbiBmb3IgdW5pcXVlIGNvbHVtbnMgKi9cblx0XHRcdFx0YlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdFx0XHRcdC8qIElmIHRoZXJlIGlzIGNvbCAvIHJvd3NwYW4sIGNvcHkgdGhlIGluZm9ybWF0aW9uIGludG8gdGhlIGxheW91dCBncmlkICovXG5cdFx0XHRcdGZvciAoIGw9MCA7IGw8aUNvbHNwYW4gOyBsKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yICggaz0wIDsgazxpUm93c3BhbiA7IGsrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YUxheW91dFtpK2tdW2lDb2xTaGlmdGVkK2xdID0ge1xuXHRcdFx0XHRcdFx0XHRcImNlbGxcIjogbkNlbGwsXG5cdFx0XHRcdFx0XHRcdFwidW5pcXVlXCI6IGJVbmlxdWVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRhTGF5b3V0W2kra10ublRyID0gblRyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bkNlbGwgPSBuQ2VsbC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiB1bmlxdWUgdGggZWxlbWVudHMsIG9uZSBmb3IgZWFjaCBjb2x1bW5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtub2RlfSBuSGVhZGVyIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBsYXlvdXQgZnJvbSB0aGlzIG5vZGUgLSBvcHRpb25hbFxuICogIEBwYXJhbSB7YXJyYXl9IGFMYXlvdXQgdGhlYWQvdGZvb3QgbGF5b3V0IGZyb20gX2ZuRGV0ZWN0SGVhZGVyIC0gb3B0aW9uYWxcbiAqICBAcmV0dXJucyBhcnJheSB7bm9kZX0gYVJldHVybiBsaXN0IG9mIHVuaXF1ZSB0aCdzXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldFVuaXF1ZVRocyAoIG9TZXR0aW5ncywgbkhlYWRlciwgYUxheW91dCApXG57XG5cdHZhciBhUmV0dXJuID0gW107XG5cdGlmICggIWFMYXlvdXQgKVxuXHR7XG5cdFx0YUxheW91dCA9IG9TZXR0aW5ncy5hb0hlYWRlcjtcblx0XHRpZiAoIG5IZWFkZXIgKVxuXHRcdHtcblx0XHRcdGFMYXlvdXQgPSBbXTtcblx0XHRcdF9mbkRldGVjdEhlYWRlciggYUxheW91dCwgbkhlYWRlciApO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoIHZhciBpPTAsIGlMZW49YUxheW91dC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHR7XG5cdFx0Zm9yICggdmFyIGo9MCwgakxlbj1hTGF5b3V0W2ldLmxlbmd0aCA7IGo8akxlbiA7IGorKyApXG5cdFx0e1xuXHRcdFx0aWYgKCBhTGF5b3V0W2ldW2pdLnVuaXF1ZSAmJlxuXHRcdFx0XHQgKCFhUmV0dXJuW2pdIHx8ICFvU2V0dGluZ3MuYlNvcnRDZWxsc1RvcCkgKVxuXHRcdFx0e1xuXHRcdFx0XHRhUmV0dXJuW2pdID0gYUxheW91dFtpXVtqXS5jZWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhUmV0dXJuO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gZm9yIGRyYXdcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9mblN0YXJ0KCBvU2V0dGluZ3MgKVxue1xuXHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0dmFyIGlJbml0RGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXG5cdC8vIENoZWNrIGFuZCBzZWUgaWYgd2UgaGF2ZSBhbiBpbml0aWFsIGRyYXcgcG9zaXRpb24gZnJvbSBzdGF0ZSBzYXZpbmdcblx0aWYgKCBpSW5pdERpc3BsYXlTdGFydCAhPT0gdW5kZWZpbmVkICYmIGlJbml0RGlzcGxheVN0YXJ0ICE9PSAtMSApXG5cdHtcblx0XHRvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBiU2VydmVyU2lkZSA/XG5cdFx0XHRpSW5pdERpc3BsYXlTdGFydCA6XG5cdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0MCA6XG5cdFx0XHRcdGlJbml0RGlzcGxheVN0YXJ0O1xuXG5cdFx0b1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gLTE7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcbiAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxuICogICAgIERhdGFUYWJsZXMgLSBtYXkgYmUgYXVnbWVudGVkIGJ5IGRldmVsb3BlciBjYWxsYmFja3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcbiAqL1xuZnVuY3Rpb24gX2ZuQnVpbGRBamF4KCBvU2V0dGluZ3MsIGRhdGEsIGZuIClcbntcblx0Ly8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0sIGFsbG93IGZuU2VydmVyRGF0YSBhbmQgZXZlbnQgdG8gbWFuaXB1bGF0ZVxuXHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvU2VydmVyUGFyYW1zJywgJ3NlcnZlclBhcmFtcycsIFtkYXRhXSApO1xuXG5cdC8vIENvbnZlcnQgdG8gb2JqZWN0IGJhc2VkIGZvciAxLjEwKyBpZiB1c2luZyB0aGUgb2xkIGFycmF5IHNjaGVtZSB3aGljaCBjYW5cblx0Ly8gY29tZSBmcm9tIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgb3Igc2VydmVyUGFyYW1zXG5cdGlmICggZGF0YSAmJiBBcnJheS5pc0FycmF5KGRhdGEpICkge1xuXHRcdHZhciB0bXAgPSB7fTtcblx0XHR2YXIgcmJyYWNrZXQgPSAvKC4qPylcXFtcXF0kLztcblxuXHRcdCQuZWFjaCggZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSB2YWwubmFtZS5tYXRjaChyYnJhY2tldCk7XG5cblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5c1xuXHRcdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzBdO1xuXG5cdFx0XHRcdGlmICggISB0bXBbIG5hbWUgXSApIHtcblx0XHRcdFx0XHR0bXBbIG5hbWUgXSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcFsgbmFtZSBdLnB1c2goIHZhbC52YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRtcFt2YWwubmFtZV0gPSB2YWwudmFsdWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdGRhdGEgPSB0bXA7XG5cdH1cblxuXHR2YXIgYWpheERhdGE7XG5cdHZhciBhamF4ID0gb1NldHRpbmdzLmFqYXg7XG5cdHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XG5cdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHR2YXIgc3RhdHVzID0gb1NldHRpbmdzLmpxWEhSXG5cdFx0XHQ/IG9TZXR0aW5ncy5qcVhIUi5zdGF0dXNcblx0XHRcdDogbnVsbDtcblxuXHRcdGlmICgganNvbiA9PT0gbnVsbCB8fCAodHlwZW9mIHN0YXR1cyA9PT0gJ251bWJlcicgJiYgc3RhdHVzID09IDIwNCApICkge1xuXHRcdFx0anNvbiA9IHt9O1xuXHRcdFx0X2ZuQWpheERhdGFTcmMoIG9TZXR0aW5ncywganNvbiwgW10gKTtcblx0XHR9XG5cblx0XHR2YXIgZXJyb3IgPSBqc29uLmVycm9yIHx8IGpzb24uc0Vycm9yO1xuXHRcdGlmICggZXJyb3IgKSB7XG5cdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgZXJyb3IgKTtcblx0XHR9XG5cblx0XHRvU2V0dGluZ3MuanNvbiA9IGpzb247XG5cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIGpzb24sIG9TZXR0aW5ncy5qcVhIUl0gKTtcblx0XHRmbigganNvbiApO1xuXHR9O1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCBhamF4ICkgJiYgYWpheC5kYXRhIClcblx0e1xuXHRcdGFqYXhEYXRhID0gYWpheC5kYXRhO1xuXG5cdFx0dmFyIG5ld0RhdGEgPSB0eXBlb2YgYWpheERhdGEgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0YWpheERhdGEoIGRhdGEsIG9TZXR0aW5ncyApIDogIC8vIGZuIGNhbiBtYW5pcHVsYXRlIGRhdGEgb3IgcmV0dXJuXG5cdFx0XHRhamF4RGF0YTsgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9iamVjdCBvciBhcnJheSB0byBtZXJnZVxuXG5cdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZywgdXNlIHRoYXQgYWxvbmVcblx0XHRkYXRhID0gdHlwZW9mIGFqYXhEYXRhID09PSAnZnVuY3Rpb24nICYmIG5ld0RhdGEgP1xuXHRcdFx0bmV3RGF0YSA6XG5cdFx0XHQkLmV4dGVuZCggdHJ1ZSwgZGF0YSwgbmV3RGF0YSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcblx0XHQvLyBqUXVlcnkgdG8gZG8gaXQgYWdhaW4gKGl0IGlzIHJlc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uKVxuXHRcdGRlbGV0ZSBhamF4LmRhdGE7XG5cdH1cblxuXHR2YXIgYmFzZUFqYXggPSB7XG5cdFx0XCJkYXRhXCI6IGRhdGEsXG5cdFx0XCJzdWNjZXNzXCI6IGNhbGxiYWNrLFxuXHRcdFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0XCJjYWNoZVwiOiBmYWxzZSxcblx0XHRcInR5cGVcIjogb1NldHRpbmdzLnNTZXJ2ZXJNZXRob2QsXG5cdFx0XCJlcnJvclwiOiBmdW5jdGlvbiAoeGhyLCBlcnJvciwgdGhyb3duKSB7XG5cdFx0XHR2YXIgcmV0ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBudWxsLCBvU2V0dGluZ3MuanFYSFJdICk7XG5cblx0XHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCByZXQgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGlmICggZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiICkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW52YWxpZCBKU09OIHJlc3BvbnNlJywgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0FqYXggZXJyb3InLCA3ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gU3RvcmUgdGhlIGRhdGEgc3VibWl0dGVkIGZvciB0aGUgQVBJXG5cdG9TZXR0aW5ncy5vQWpheERhdGEgPSBkYXRhO1xuXG5cdC8vIEFsbG93IHBsdWctaW5zIGFuZCBleHRlcm5hbCBwcm9jZXNzZXMgdG8gbW9kaWZ5IHRoZSBkYXRhXG5cdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAncHJlWGhyJywgW29TZXR0aW5ncywgZGF0YV0gKTtcblxuXHRpZiAoIG9TZXR0aW5ncy5mblNlcnZlckRhdGEgKVxuXHR7XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcblx0XHRvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhLmNhbGwoIGluc3RhbmNlLFxuXHRcdFx0b1NldHRpbmdzLnNBamF4U291cmNlLFxuXHRcdFx0JC5tYXAoIGRhdGEsIGZ1bmN0aW9uICh2YWwsIGtleSkgeyAvLyBOZWVkIHRvIGNvbnZlcnQgYmFjayB0byAxLjkgdHJhZCBmb3JtYXRcblx0XHRcdFx0cmV0dXJuIHsgbmFtZToga2V5LCB2YWx1ZTogdmFsIH07XG5cdFx0XHR9ICksXG5cdFx0XHRjYWxsYmFjayxcblx0XHRcdG9TZXR0aW5nc1xuXHRcdCk7XG5cdH1cblx0ZWxzZSBpZiAoIG9TZXR0aW5ncy5zQWpheFNvdXJjZSB8fCB0eXBlb2YgYWpheCA9PT0gJ3N0cmluZycgKVxuXHR7XG5cdFx0Ly8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcblx0XHRvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoICQuZXh0ZW5kKCBiYXNlQWpheCwge1xuXHRcdFx0dXJsOiBhamF4IHx8IG9TZXR0aW5ncy5zQWpheFNvdXJjZVxuXHRcdH0gKSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgYWpheCA9PT0gJ2Z1bmN0aW9uJyApXG5cdHtcblx0XHQvLyBJcyBhIGZ1bmN0aW9uIC0gbGV0IHRoZSBjYWxsZXIgZGVmaW5lIHdoYXQgbmVlZHMgdG8gYmUgZG9uZVxuXHRcdG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbCggaW5zdGFuY2UsIGRhdGEsIGNhbGxiYWNrLCBvU2V0dGluZ3MgKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvLyBPYmplY3QgdG8gZXh0ZW5kIHRoZSBiYXNlIHNldHRpbmdzXG5cdFx0b1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCAkLmV4dGVuZCggYmFzZUFqYXgsIGFqYXggKSApO1xuXG5cdFx0Ly8gUmVzdG9yZSBmb3IgbmV4dCB0aW1lIGFyb3VuZFxuXHRcdGFqYXguZGF0YSA9IGFqYXhEYXRhO1xuXHR9XG59XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHRhYmxlIHVzaW5nIGFuIEFqYXggY2FsbFxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtib29sZWFufSBCbG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZSggc2V0dGluZ3MgKVxue1xuXHRzZXR0aW5ncy5pRHJhdysrO1xuXHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRfZm5CdWlsZEFqYXgoXG5cdFx0c2V0dGluZ3MsXG5cdFx0X2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzICksXG5cdFx0ZnVuY3Rpb24oanNvbikge1xuXHRcdFx0X2ZuQWpheFVwZGF0ZURyYXcoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0fVxuXHQpO1xufVxuXG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIHBhcmFtZXRlcnMgaW4gYW4gb2JqZWN0IG5lZWRlZCBmb3IgYSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG4gKiByZXF1ZXN0LiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkgZG9uZSB0d2ljZSwgaXMgZGlmZmVyZW50IHdheXMgLSBhIG1vZGVyblxuICogbWV0aG9kIHdoaWNoIGlzIHVzZWQgYnkgZGVmYXVsdCBpbiBEYXRhVGFibGVzIDEuMTAgd2hpY2ggdXNlcyBvYmplY3RzIGFuZFxuICogYXJyYXlzLCBvciB0aGUgMS45LSBtZXRob2Qgd2l0aCBpcyBuYW1lIC8gdmFsdWUgcGFpcnMuIDEuOSBtZXRob2QgaXMgdXNlZCBpZlxuICogdGhlIHNBamF4U291cmNlIG9wdGlvbiBpcyB1c2VkIGluIHRoZSBpbml0aWFsaXNhdGlvbiwgb3IgdGhlIGxlZ2FjeUFqYXhcbiAqIG9wdGlvbiBpcyBzZXQuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzIClcbntcblx0dmFyXG5cdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoLFxuXHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdHByZVNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCxcblx0XHRwcmVDb2xTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHMsXG5cdFx0aSwgZGF0YSA9IFtdLCBkYXRhUHJvcCwgY29sdW1uLCBjb2x1bW5TZWFyY2gsXG5cdFx0c29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApLFxuXHRcdGRpc3BsYXlTdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGRpc3BsYXlMZW5ndGggPSBmZWF0dXJlcy5iUGFnaW5hdGUgIT09IGZhbHNlID9cblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHQtMTtcblxuXHR2YXIgcGFyYW0gPSBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXHRcdGRhdGEucHVzaCggeyAnbmFtZSc6IG5hbWUsICd2YWx1ZSc6IHZhbHVlIH0gKTtcblx0fTtcblxuXHQvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJsZSBtZXRob2Rcblx0cGFyYW0oICdzRWNobycsICAgICAgICAgIHNldHRpbmdzLmlEcmF3ICk7XG5cdHBhcmFtKCAnaUNvbHVtbnMnLCAgICAgICBjb2x1bW5Db3VudCApO1xuXHRwYXJhbSggJ3NDb2x1bW5zJywgICAgICAgX3BsdWNrKCBjb2x1bW5zLCAnc05hbWUnICkuam9pbignLCcpICk7XG5cdHBhcmFtKCAnaURpc3BsYXlTdGFydCcsICBkaXNwbGF5U3RhcnQgKTtcblx0cGFyYW0oICdpRGlzcGxheUxlbmd0aCcsIGRpc3BsYXlMZW5ndGggKTtcblxuXHQvLyBEYXRhVGFibGVzIDEuMTArIG1ldGhvZFxuXHR2YXIgZCA9IHtcblx0XHRkcmF3OiAgICBzZXR0aW5ncy5pRHJhdyxcblx0XHRjb2x1bW5zOiBbXSxcblx0XHRvcmRlcjogICBbXSxcblx0XHRzdGFydDogICBkaXNwbGF5U3RhcnQsXG5cdFx0bGVuZ3RoOiAgZGlzcGxheUxlbmd0aCxcblx0XHRzZWFyY2g6ICB7XG5cdFx0XHR2YWx1ZTogcHJlU2VhcmNoLnNTZWFyY2gsXG5cdFx0XHRyZWdleDogcHJlU2VhcmNoLmJSZWdleFxuXHRcdH1cblx0fTtcblxuXHRmb3IgKCBpPTAgOyBpPGNvbHVtbkNvdW50IDsgaSsrICkge1xuXHRcdGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cdFx0Y29sdW1uU2VhcmNoID0gcHJlQ29sU2VhcmNoW2ldO1xuXHRcdGRhdGFQcm9wID0gdHlwZW9mIGNvbHVtbi5tRGF0YT09XCJmdW5jdGlvblwiID8gJ2Z1bmN0aW9uJyA6IGNvbHVtbi5tRGF0YSA7XG5cblx0XHRkLmNvbHVtbnMucHVzaCgge1xuXHRcdFx0ZGF0YTogICAgICAgZGF0YVByb3AsXG5cdFx0XHRuYW1lOiAgICAgICBjb2x1bW4uc05hbWUsXG5cdFx0XHRzZWFyY2hhYmxlOiBjb2x1bW4uYlNlYXJjaGFibGUsXG5cdFx0XHRvcmRlcmFibGU6ICBjb2x1bW4uYlNvcnRhYmxlLFxuXHRcdFx0c2VhcmNoOiAgICAge1xuXHRcdFx0XHR2YWx1ZTogY29sdW1uU2VhcmNoLnNTZWFyY2gsXG5cdFx0XHRcdHJlZ2V4OiBjb2x1bW5TZWFyY2guYlJlZ2V4XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0cGFyYW0oIFwibURhdGFQcm9wX1wiK2ksIGRhdGFQcm9wICk7XG5cblx0XHRpZiAoIGZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRwYXJhbSggJ3NTZWFyY2hfJytpLCAgICAgY29sdW1uU2VhcmNoLnNTZWFyY2ggKTtcblx0XHRcdHBhcmFtKCAnYlJlZ2V4XycraSwgICAgICBjb2x1bW5TZWFyY2guYlJlZ2V4ICk7XG5cdFx0XHRwYXJhbSggJ2JTZWFyY2hhYmxlXycraSwgY29sdW1uLmJTZWFyY2hhYmxlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBmZWF0dXJlcy5iU29ydCApIHtcblx0XHRcdHBhcmFtKCAnYlNvcnRhYmxlXycraSwgY29sdW1uLmJTb3J0YWJsZSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggZmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRwYXJhbSggJ3NTZWFyY2gnLCBwcmVTZWFyY2guc1NlYXJjaCApO1xuXHRcdHBhcmFtKCAnYlJlZ2V4JywgcHJlU2VhcmNoLmJSZWdleCApO1xuXHR9XG5cblx0aWYgKCBmZWF0dXJlcy5iU29ydCApIHtcblx0XHQkLmVhY2goIHNvcnQsIGZ1bmN0aW9uICggaSwgdmFsICkge1xuXHRcdFx0ZC5vcmRlci5wdXNoKCB7IGNvbHVtbjogdmFsLmNvbCwgZGlyOiB2YWwuZGlyIH0gKTtcblxuXHRcdFx0cGFyYW0oICdpU29ydENvbF8nK2ksIHZhbC5jb2wgKTtcblx0XHRcdHBhcmFtKCAnc1NvcnREaXJfJytpLCB2YWwuZGlyICk7XG5cdFx0fSApO1xuXG5cdFx0cGFyYW0oICdpU29ydGluZ0NvbHMnLCBzb3J0Lmxlbmd0aCApO1xuXHR9XG5cblx0Ly8gSWYgdGhlIGxlZ2FjeS5hamF4IHBhcmFtZXRlciBpcyBudWxsLCB0aGVuIHdlIGF1dG9tYXRpY2FsbHkgZGVjaWRlIHdoaWNoXG5cdC8vIGZvcm0gdG8gdXNlLCBiYXNlZCBvbiBzQWpheFNvdXJjZVxuXHR2YXIgbGVnYWN5ID0gRGF0YVRhYmxlLmV4dC5sZWdhY3kuYWpheDtcblx0aWYgKCBsZWdhY3kgPT09IG51bGwgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzLnNBamF4U291cmNlID8gZGF0YSA6IGQ7XG5cdH1cblxuXHQvLyBPdGhlcndpc2UsIGlmIGxlZ2FjeSBoYXMgYmVlbiBzcGVjaWZpZWQgdGhlbiB3ZSB1c2UgdGhhdCB0byBkZWNpZGUgb24gdGhlXG5cdC8vIGZvcm1cblx0cmV0dXJuIGxlZ2FjeSA/IGRhdGEgOiBkO1xufVxuXG5cbi8qKlxuICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0ganNvbiBqc29uIGRhdGEgcmV0dXJuIGZyb20gdGhlIHNlcnZlci5cbiAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXG4gKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsUmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIG5vdCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcbiAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxEaXNwbGF5UmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtqc29uLnNDb2x1bW5zXSBDb2x1bW4gb3JkZXJpbmcgKHNOYW1lLCBjb21tYSBzZXBhcmF0ZWQpXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFqYXhVcGRhdGVEcmF3ICggc2V0dGluZ3MsIGpzb24gKVxue1xuXHQvLyB2MS4xMCB1c2VzIGNhbWVsQ2FzZSB2YXJpYWJsZXMsIHdoaWxlIDEuOSB1c2VzIEh1bmdhcmlhbiBub3RhdGlvbi5cblx0Ly8gU3VwcG9ydCBib3RoXG5cdHZhciBjb21wYXQgPSBmdW5jdGlvbiAoIG9sZCwgbW9kZXJuICkge1xuXHRcdHJldHVybiBqc29uW29sZF0gIT09IHVuZGVmaW5lZCA/IGpzb25bb2xkXSA6IGpzb25bbW9kZXJuXTtcblx0fTtcblxuXHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHR2YXIgZHJhdyAgICAgICAgICAgID0gY29tcGF0KCAnc0VjaG8nLCAgICAgICAgICAgICAgICAnZHJhdycgKTtcblx0dmFyIHJlY29yZHNUb3RhbCAgICA9IGNvbXBhdCggJ2lUb3RhbFJlY29yZHMnLCAgICAgICAgJ3JlY29yZHNUb3RhbCcgKTtcblx0dmFyIHJlY29yZHNGaWx0ZXJlZCA9IGNvbXBhdCggJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcgKTtcblxuXHRpZiAoIGRyYXcgIT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBQcm90ZWN0IGFnYWluc3Qgb3V0IG9mIHNlcXVlbmNlIHJldHVybnNcblx0XHRpZiAoIGRyYXcqMSA8IHNldHRpbmdzLmlEcmF3ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzZXR0aW5ncy5pRHJhdyA9IGRyYXcgKiAxO1xuXHR9XG5cblx0Ly8gTm8gZGF0YSBpbiByZXR1cm5lZCBvYmplY3QsIHNvIHJhdGhlciB0aGFuIGFuIGFycmF5LCB3ZSBzaG93IGFuIGVtcHR5IHRhYmxlXG5cdGlmICggISBkYXRhICkge1xuXHRcdGRhdGEgPSBbXTtcblx0fVxuXG5cdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cdHNldHRpbmdzLl9pUmVjb3Jkc1RvdGFsICAgPSBwYXJzZUludChyZWNvcmRzVG90YWwsIDEwKTtcblx0c2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHBhcnNlSW50KHJlY29yZHNGaWx0ZXJlZCwgMTApO1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdF9mbkFkZERhdGEoIHNldHRpbmdzLCBkYXRhW2ldICk7XG5cdH1cblx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cblx0X2ZuRHJhdyggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRpZiAoICEgc2V0dGluZ3MuX2JJbml0Q29tcGxldGUgKSB7XG5cdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncywganNvbiApO1xuXHR9XG5cblx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIEpTT04gZGF0YSBzb3VyY2UgdG8gdXNlIGZvciBkcmF3aW5nIGEgdGFibGUuIFVzaW5nXG4gKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXG4gKiBzb3VyY2Ugb2JqZWN0LCBvciBmcm9tIGEgcHJvY2Vzc2luZyBmdW5jdGlvbi5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxuICogIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiBkYXRhIHRvIHVzZVxuICovXG4gZnVuY3Rpb24gX2ZuQWpheERhdGFTcmMgKCBvU2V0dGluZ3MsIGpzb24sIHdyaXRlIClcbiB7XG5cdHZhciBkYXRhU3JjID0gJC5pc1BsYWluT2JqZWN0KCBvU2V0dGluZ3MuYWpheCApICYmIG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgIT09IHVuZGVmaW5lZCA/XG5cdFx0b1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XG5cdFx0b1NldHRpbmdzLnNBamF4RGF0YVByb3A7IC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLlxuXG5cdGlmICggISB3cml0ZSApIHtcblx0XHRpZiAoIGRhdGFTcmMgPT09ICdkYXRhJyApIHtcblx0XHRcdC8vIElmIHRoZSBkZWZhdWx0LCB0aGVuIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydCB0aGUgb2xkIHN0eWxlLCBhbmQgc2FmZWx5IGlnbm9yZVxuXHRcdFx0Ly8gaXQgaWYgcG9zc2libGVcblx0XHRcdHJldHVybiBqc29uLmFhRGF0YSB8fCBqc29uW2RhdGFTcmNdO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhU3JjICE9PSBcIlwiID9cblx0XHRcdF9mbkdldE9iamVjdERhdGFGbiggZGF0YVNyYyApKCBqc29uICkgOlxuXHRcdFx0anNvbjtcblx0fVxuXG5cdC8vIHNldFxuXHRfZm5TZXRPYmplY3REYXRhRm4oIGRhdGFTcmMgKSgganNvbiwgd3JpdGUgKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZmlsdGVyaW5nIHRleHRcbiAqICBAcmV0dXJucyB7bm9kZX0gRmlsdGVyIGNvbnRyb2wgZWxlbWVudFxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIgKCBzZXR0aW5ncyApXG57XG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdHZhciB0YWJsZUlkID0gc2V0dGluZ3Muc1RhYmxlSWQ7XG5cdHZhciBsYW5ndWFnZSA9IHNldHRpbmdzLm9MYW5ndWFnZTtcblx0dmFyIHByZXZpb3VzU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xuXHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcztcblx0dmFyIGlucHV0ID0gJzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInK2NsYXNzZXMuc0ZpbHRlcklucHV0KydcIi8+JztcblxuXHR2YXIgc3RyID0gbGFuZ3VhZ2Uuc1NlYXJjaDtcblx0c3RyID0gc3RyLm1hdGNoKC9fSU5QVVRfLykgP1xuXHRcdHN0ci5yZXBsYWNlKCdfSU5QVVRfJywgaW5wdXQpIDpcblx0XHRzdHIraW5wdXQ7XG5cblx0dmFyIGZpbHRlciA9ICQoJzxkaXYvPicsIHtcblx0XHRcdCdpZCc6ICEgZmVhdHVyZXMuZiA/IHRhYmxlSWQrJ19maWx0ZXInIDogbnVsbCxcblx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc0ZpbHRlclxuXHRcdH0gKVxuXHRcdC5hcHBlbmQoICQoJzxsYWJlbC8+JyApLmFwcGVuZCggc3RyICkgKTtcblxuXHR2YXIgc2VhcmNoRm4gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdC8qIFVwZGF0ZSBhbGwgb3RoZXIgZmlsdGVyIGlucHV0IGVsZW1lbnRzIGZvciB0aGUgbmV3IGRpc3BsYXkgKi9cblx0XHR2YXIgbiA9IGZlYXR1cmVzLmY7XG5cdFx0dmFyIHZhbCA9ICF0aGlzLnZhbHVlID8gXCJcIiA6IHRoaXMudmFsdWU7IC8vIG1lbnRhbCBJRTggZml4IDotKFxuXHRcdGlmKHByZXZpb3VzU2VhcmNoLnJldHVybiAmJiBldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvKiBOb3cgZG8gdGhlIGZpbHRlciAqL1xuXHRcdGlmICggdmFsICE9IHByZXZpb3VzU2VhcmNoLnNTZWFyY2ggKSB7XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHtcblx0XHRcdFx0XCJzU2VhcmNoXCI6IHZhbCxcblx0XHRcdFx0XCJiUmVnZXhcIjogcHJldmlvdXNTZWFyY2guYlJlZ2V4LFxuXHRcdFx0XHRcImJTbWFydFwiOiBwcmV2aW91c1NlYXJjaC5iU21hcnQgLFxuXHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogcHJldmlvdXNTZWFyY2guYkNhc2VJbnNlbnNpdGl2ZSxcblx0XHRcdFx0XCJyZXR1cm5cIjogcHJldmlvdXNTZWFyY2gucmV0dXJuXG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIE5lZWQgdG8gcmVkcmF3LCB3aXRob3V0IHJlc29ydGluZ1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuXHRcdHNldHRpbmdzLnNlYXJjaERlbGF5IDpcblx0XHRfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09PSAnc3NwJyA/XG5cdFx0XHQ0MDAgOlxuXHRcdFx0MDtcblxuXHR2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcblx0XHQudmFsKCBwcmV2aW91c1NlYXJjaC5zU2VhcmNoIClcblx0XHQuYXR0ciggJ3BsYWNlaG9sZGVyJywgbGFuZ3VhZ2Uuc1NlYXJjaFBsYWNlaG9sZGVyIClcblx0XHQub24oXG5cdFx0XHQna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXG5cdFx0XHRzZWFyY2hEZWxheSA/XG5cdFx0XHRcdF9mblRocm90dGxlKCBzZWFyY2hGbiwgc2VhcmNoRGVsYXkgKSA6XG5cdFx0XHRcdHNlYXJjaEZuXG5cdFx0KVxuXHRcdC5vbiggJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBFZGdlIGZpeCEgRWRnZSAxNyBkb2VzIG5vdCB0cmlnZ2VyIGFueXRoaW5nIG90aGVyIHRoYW4gbW91c2UgZXZlbnRzIHdoZW4gY2xpY2tpbmdcblx0XHRcdC8vIG9uIHRoZSBjbGVhciBpY29uIChFZGdlIGJ1ZyAxNzU4NDUxNSkuIFRoaXMgaXMgc2FmZSBpbiBvdGhlciBicm93c2VycyBhcyBgc2VhcmNoRm5gXG5cdFx0XHQvLyBjaGVja3MgdGhlIHZhbHVlIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZC4gSW4gb3RoZXIgYnJvd3NlcnMgaXQgd29uJ3QgaGF2ZS5cblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VhcmNoRm4uY2FsbChqcUZpbHRlclswXSwgZSk7XG5cdFx0XHR9LCAxMCk7XG5cdFx0fSApXG5cdFx0Lm9uKCAna2V5cHJlc3MuRFQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHQvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xuXHRcdFx0aWYgKCBlLmtleUNvZGUgPT0gMTMgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IClcblx0XHQuYXR0cignYXJpYS1jb250cm9scycsIHRhYmxlSWQpO1xuXG5cdC8vIFVwZGF0ZSB0aGUgaW5wdXQgZWxlbWVudHMgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIGZpbHRlcmVkXG5cdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ3NlYXJjaC5kdC5EVCcsIGZ1bmN0aW9uICggZXYsIHMgKSB7XG5cdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4uLlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCBqcUZpbHRlclswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCApIHtcblx0XHRcdFx0XHRqcUZpbHRlci52YWwoIHByZXZpb3VzU2VhcmNoLnNTZWFyY2ggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKCBlICkge31cblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gZmlsdGVyWzBdO1xufVxuXG5cbi8qKlxuICogRmlsdGVyIHRoZSB0YWJsZSB1c2luZyBib3RoIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBjb2x1bW4gYmFzZWQgZmlsdGVyaW5nXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2VhcmNoIHNlYXJjaCBpbmZvcm1hdGlvblxuICogIEBwYXJhbSB7aW50fSBbaUZvcmNlXSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckNvbXBsZXRlICggb1NldHRpbmdzLCBvSW5wdXQsIGlGb3JjZSApXG57XG5cdHZhciBvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG5cdHZhciBhb1ByZXZTZWFyY2ggPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHR2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKCBvRmlsdGVyICkge1xuXHRcdC8qIFNhdmUgdGhlIGZpbHRlcmluZyB2YWx1ZXMgKi9cblx0XHRvUHJldlNlYXJjaC5zU2VhcmNoID0gb0ZpbHRlci5zU2VhcmNoO1xuXHRcdG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xuXHRcdG9QcmV2U2VhcmNoLmJTbWFydCA9IG9GaWx0ZXIuYlNtYXJ0O1xuXHRcdG9QcmV2U2VhcmNoLmJDYXNlSW5zZW5zaXRpdmUgPSBvRmlsdGVyLmJDYXNlSW5zZW5zaXRpdmU7XG5cdFx0b1ByZXZTZWFyY2gucmV0dXJuID0gb0ZpbHRlci5yZXR1cm47XG5cdH07XG5cdHZhciBmblJlZ2V4ID0gZnVuY3Rpb24gKCBvICkge1xuXHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGJFc2NhcGVSZWdleCBvcHRpb25cblx0XHRyZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuXHR9O1xuXG5cdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0Ly8gQHRvZG8gQXMgcGVyIHNvcnQgLSBjYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGFuIGV2ZW50IGhhbmRsZXI/XG5cdF9mbkNvbHVtblR5cGVzKCBvU2V0dGluZ3MgKTtcblxuXHQvKiBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGFsbCBmaWx0ZXJpbmcgaXMgZG9uZSBieSB0aGUgc2VydmVyLCBzbyBubyBwb2ludCBoYW5naW5nIGFyb3VuZCBoZXJlICovXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgIT0gJ3NzcCcgKVxuXHR7XG5cdFx0LyogR2xvYmFsIGZpbHRlciAqL1xuXHRcdF9mbkZpbHRlciggb1NldHRpbmdzLCBvSW5wdXQuc1NlYXJjaCwgaUZvcmNlLCBmblJlZ2V4KG9JbnB1dCksIG9JbnB1dC5iU21hcnQsIG9JbnB1dC5iQ2FzZUluc2Vuc2l0aXZlLCBvSW5wdXQucmV0dXJuICk7XG5cdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblxuXHRcdC8qIE5vdyBkbyB0aGUgaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVyICovXG5cdFx0Zm9yICggdmFyIGk9MCA7IGk8YW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0e1xuXHRcdFx0X2ZuRmlsdGVyQ29sdW1uKCBvU2V0dGluZ3MsIGFvUHJldlNlYXJjaFtpXS5zU2VhcmNoLCBpLCBmblJlZ2V4KGFvUHJldlNlYXJjaFtpXSksXG5cdFx0XHRcdGFvUHJldlNlYXJjaFtpXS5iU21hcnQsIGFvUHJldlNlYXJjaFtpXS5iQ2FzZUluc2Vuc2l0aXZlICk7XG5cdFx0fVxuXG5cdFx0LyogQ3VzdG9tIGZpbHRlcmluZyAqL1xuXHRcdF9mbkZpbHRlckN1c3RvbSggb1NldHRpbmdzICk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Zm5TYXZlRmlsdGVyKCBvSW5wdXQgKTtcblx0fVxuXG5cdC8qIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gd2UgaGF2ZSBiZWVuIGZpbHRlcmluZyAqL1xuXHRvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdzZWFyY2gnLCBbb1NldHRpbmdzXSApO1xufVxuXG5cbi8qKlxuICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckN1c3RvbSggc2V0dGluZ3MgKVxue1xuXHR2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xuXHR2YXIgZGlzcGxheVJvd3MgPSBzZXR0aW5ncy5haURpc3BsYXk7XG5cdHZhciByb3csIHJvd0lkeDtcblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49ZmlsdGVycy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHR2YXIgcm93cyA9IFtdO1xuXG5cdFx0Ly8gTG9vcCBvdmVyIGVhY2ggcm93IGFuZCBzZWUgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdFx0Zm9yICggdmFyIGo9MCwgamVuPWRpc3BsYXlSb3dzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0cm93SWR4ID0gZGlzcGxheVJvd3NbIGogXTtcblx0XHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVsgcm93SWR4IF07XG5cblx0XHRcdGlmICggZmlsdGVyc1tpXSggc2V0dGluZ3MsIHJvdy5fYUZpbHRlckRhdGEsIHJvd0lkeCwgcm93Ll9hRGF0YSwgaiApICkge1xuXHRcdFx0XHRyb3dzLnB1c2goIHJvd0lkeCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNvIHRoZSBhcnJheSByZWZlcmVuY2UgZG9lc24ndCBicmVhayBzZXQgdGhlIHJlc3VsdHMgaW50byB0aGVcblx0XHQvLyBleGlzdGluZyBhcnJheVxuXHRcdGRpc3BsYXlSb3dzLmxlbmd0aCA9IDA7XG5cdFx0JC5tZXJnZSggZGlzcGxheVJvd3MsIHJvd3MgKTtcblx0fVxufVxuXG5cbi8qKlxuICogRmlsdGVyIHRoZSB0YWJsZSBvbiBhIHBlci1jb2x1bW4gYmFzaXNcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXG4gKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gY29sdW1uIHRvIGZpbHRlclxuICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IHNlYXJjaCBzdHJpbmcgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiU21hcnQgdXNlIHNtYXJ0IGZpbHRlcmluZyBvciBub3RcbiAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnNpdGl2ZSBtYXRjaGluZyBvciBub3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRmlsdGVyQ29sdW1uICggc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG57XG5cdGlmICggc2VhcmNoU3RyID09PSAnJyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgZGF0YTtcblx0dmFyIG91dCA9IFtdO1xuXHR2YXIgZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0dmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBzZWFyY2hTdHIsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlICk7XG5cblx0Zm9yICggdmFyIGk9MCA7IGk8ZGlzcGxheS5sZW5ndGggOyBpKysgKSB7XG5cdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9hRmlsdGVyRGF0YVsgY29sSWR4IF07XG5cblx0XHRpZiAoIHJwU2VhcmNoLnRlc3QoIGRhdGEgKSApIHtcblx0XHRcdG91dC5wdXNoKCBkaXNwbGF5W2ldICk7XG5cdFx0fVxuXHR9XG5cblx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gb3V0O1xufVxuXG5cbi8qKlxuICogRmlsdGVyIHRoZSBkYXRhIHRhYmxlIGJhc2VkIG9uIHVzZXIgaW5wdXQgYW5kIGRyYXcgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtzdHJpbmd9IGlucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cbiAqICBAcGFyYW0ge2ludH0gZm9yY2Ugb3B0aW9uYWwgLSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXG4gKiAgQHBhcmFtIHtib29sfSByZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcbiAqICBAcGFyYW0ge2Jvb2x9IHNtYXJ0IHBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuICogIEBwYXJhbSB7Ym9vbH0gY2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlciggc2V0dGluZ3MsIGlucHV0LCBmb3JjZSwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUgKVxue1xuXHR2YXIgcnBTZWFyY2ggPSBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApO1xuXHR2YXIgcHJldlNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoO1xuXHR2YXIgZGlzcGxheU1hc3RlciA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlcjtcblx0dmFyIGRpc3BsYXksIGludmFsaWRhdGVkLCBpO1xuXHR2YXIgZmlsdGVyZWQgPSBbXTtcblxuXHQvLyBOZWVkIHRvIHRha2UgYWNjb3VudCBvZiBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9ucyAtIGFsd2F5cyBmaWx0ZXJcblx0aWYgKCBEYXRhVGFibGUuZXh0LnNlYXJjaC5sZW5ndGggIT09IDAgKSB7XG5cdFx0Zm9yY2UgPSB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYW55IG9mIHRoZSByb3dzIHdlcmUgaW52YWxpZGF0ZWRcblx0aW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKCBzZXR0aW5ncyApO1xuXG5cdC8vIElmIHRoZSBpbnB1dCBpcyBibGFuayAtIHdlIGp1c3Qgd2FudCB0aGUgZnVsbCBkYXRhIHNldFxuXHRpZiAoIGlucHV0Lmxlbmd0aCA8PSAwICkge1xuXHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBOZXcgc2VhcmNoIC0gc3RhcnQgZnJvbSB0aGUgbWFzdGVyIGFycmF5XG5cdFx0aWYgKCBpbnZhbGlkYXRlZCB8fFxuXHRcdFx0IGZvcmNlIHx8XG5cdFx0XHQgcmVnZXggfHxcblx0XHRcdCBwcmV2U2VhcmNoLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCB8fFxuXHRcdFx0IGlucHV0LmluZGV4T2YocHJldlNlYXJjaCkgIT09IDAgfHxcblx0XHRcdCBzZXR0aW5ncy5iU29ydGVkIC8vIE9uIHJlc29ydCwgdGhlIGRpc3BsYXkgbWFzdGVyIG5lZWRzIHRvIGJlXG5cdFx0XHQgICAgICAgICAgICAgICAgICAvLyByZS1maWx0ZXJlZCBzaW5jZSBpbmRleGVzIHdpbGwgaGF2ZSBjaGFuZ2VkXG5cdFx0KSB7XG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VhcmNoIHRoZSBkaXNwbGF5IGFycmF5XG5cdFx0ZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcblxuXHRcdGZvciAoIGk9MCA7IGk8ZGlzcGxheS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRpZiAoIHJwU2VhcmNoLnRlc3QoIHNldHRpbmdzLmFvRGF0YVsgZGlzcGxheVtpXSBdLl9zRmlsdGVyUm93ICkgKSB7XG5cdFx0XHRcdGZpbHRlcmVkLnB1c2goIGRpc3BsYXlbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBmaWx0ZXJlZDtcblx0fVxufVxuXG5cbi8qKlxuICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxuICogIEBwYXJhbSB7c3RyaW5nfSBzU2VhcmNoIHN0cmluZyB0byBzZWFyY2ggZm9yXG4gKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG4gKiAgQHJldHVybnMge1JlZ0V4cH0gY29uc3RydWN0ZWQgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSApXG57XG5cdHNlYXJjaCA9IHJlZ2V4ID9cblx0XHRzZWFyY2ggOlxuXHRcdF9mbkVzY2FwZVJlZ2V4KCBzZWFyY2ggKTtcblx0XG5cdGlmICggc21hcnQgKSB7XG5cdFx0LyogRm9yIHNtYXJ0IGZpbHRlcmluZyB3ZSB3YW50IHRvIGFsbG93IHRoZSBzZWFyY2ggdG8gd29yayByZWdhcmRsZXNzIG9mXG5cdFx0ICogd29yZCBvcmRlci4gV2UgYWxzbyB3YW50IGRvdWJsZSBxdW90ZWQgdGV4dCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdvcmRcblx0XHQgKiBvcmRlciBpcyBpbXBvcnRhbnQgLSBhIGxhIGdvb2dsZS4gU28gdGhpcyBpcyB3aGF0IHdlIHdhbnQgdG9cblx0XHQgKiBnZW5lcmF0ZTpcblx0XHQgKiBcblx0XHQgKiBeKD89Lio/XFxib25lXFxiKSg/PS4qP1xcYnR3byB0aHJlZVxcYikoPz0uKj9cXGJmb3VyXFxiKS4qJFxuXHRcdCAqL1xuXHRcdHZhciBhID0gJC5tYXAoIHNlYXJjaC5tYXRjaCggL1wiW15cIl0rXCJ8W14gXSsvZyApIHx8IFsnJ10sIGZ1bmN0aW9uICggd29yZCApIHtcblx0XHRcdGlmICggd29yZC5jaGFyQXQoMCkgPT09ICdcIicgKSB7XG5cdFx0XHRcdHZhciBtID0gd29yZC5tYXRjaCggL15cIiguKilcIiQvICk7XG5cdFx0XHRcdHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3b3JkLnJlcGxhY2UoJ1wiJywgJycpO1xuXHRcdH0gKTtcblxuXHRcdHNlYXJjaCA9ICdeKD89Lio/JythLmpvaW4oICcpKD89Lio/JyApKycpLiokJztcblx0fVxuXG5cdHJldHVybiBuZXcgUmVnRXhwKCBzZWFyY2gsIGNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnICk7XG59XG5cblxuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHNWYWwgc3RyaW5nIHRvIGVzY2FwZVxuICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbnZhciBfZm5Fc2NhcGVSZWdleCA9IERhdGFUYWJsZS51dGlsLmVzY2FwZVJlZ2V4O1xuXG52YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcbnZhciBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgPSBfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZDtcblxuLy8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxuZnVuY3Rpb24gX2ZuRmlsdGVyRGF0YSAoIHNldHRpbmdzIClcbntcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBjb2x1bW47XG5cdHZhciBpLCBqLCBpZW4sIGplbiwgZmlsdGVyRGF0YSwgY2VsbERhdGEsIHJvdztcblx0dmFyIHdhc0ludmFsaWRhdGVkID0gZmFsc2U7XG5cblx0Zm9yICggaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblxuXHRcdGlmICggISByb3cuX2FGaWx0ZXJEYXRhICkge1xuXHRcdFx0ZmlsdGVyRGF0YSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBqPTAsIGplbj1jb2x1bW5zLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2pdO1xuXG5cdFx0XHRcdGlmICggY29sdW1uLmJTZWFyY2hhYmxlICkge1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBqLCAnZmlsdGVyJyApO1xuXG5cdFx0XHRcdFx0Ly8gU2VhcmNoIGluIERhdGFUYWJsZXMgMS4xMCBpcyBzdHJpbmcgYmFzZWQuIEluIDEuMTEgdGhpc1xuXHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXG5cdFx0XHRcdFx0aWYgKCBjZWxsRGF0YSA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gJyc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgY2VsbERhdGEgIT09ICdzdHJpbmcnICYmIGNlbGxEYXRhLnRvU3RyaW5nICkge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgaXQgbG9va3MgbGlrZSB0aGVyZSBpcyBhbiBIVE1MIGVudGl0eSBpbiB0aGUgc3RyaW5nLFxuXHRcdFx0XHQvLyBhdHRlbXB0IHRvIGRlY29kZSBpdCBzbyBzb3J0aW5nIHdvcmtzIGFzIGV4cGVjdGVkLiBOb3RlIHRoYXRcblx0XHRcdFx0Ly8gd2UgY291bGQgdXNlIGEgc2luZ2xlIGxpbmUgb2YgalF1ZXJ5IHRvIGRvIHRoaXMsIGJ1dCB0aGUgRE9NXG5cdFx0XHRcdC8vIG1ldGhvZCB1c2VkIGhlcmUgaXMgbXVjaCBmYXN0ZXIgaHR0cDovL2pzcGVyZi5jb20vaHRtbC1kZWNvZGVcblx0XHRcdFx0aWYgKCBjZWxsRGF0YS5pbmRleE9mICYmIGNlbGxEYXRhLmluZGV4T2YoJyYnKSAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID9cblx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCA6XG5cdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJUZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjZWxsRGF0YS5yZXBsYWNlICkge1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEucmVwbGFjZSgvW1xcclxcblxcdTIwMjhdL2csICcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpbHRlckRhdGEucHVzaCggY2VsbERhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0cm93Ll9hRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG5cdFx0XHRyb3cuX3NGaWx0ZXJSb3cgPSBmaWx0ZXJEYXRhLmpvaW4oJyAgJyk7XG5cdFx0XHR3YXNJbnZhbGlkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHdhc0ludmFsaWRhdGVkO1xufVxuXG5cbi8qKlxuICogQ29udmVydCBmcm9tIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4gbm90YXRpb24gdG8gY2FtZWxDYXNlIGZvciBleHRlcm5hbFxuICogaW50ZXJhY3Rpb25cbiAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG4gKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNlYXJjaFRvQ2FtZWwgKCBvYmogKVxue1xuXHRyZXR1cm4ge1xuXHRcdHNlYXJjaDogICAgICAgICAgb2JqLnNTZWFyY2gsXG5cdFx0c21hcnQ6ICAgICAgICAgICBvYmouYlNtYXJ0LFxuXHRcdHJlZ2V4OiAgICAgICAgICAgb2JqLmJSZWdleCxcblx0XHRjYXNlSW5zZW5zaXRpdmU6IG9iai5iQ2FzZUluc2Vuc2l0aXZlXG5cdH07XG59XG5cblxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW1lbENhc2Ugbm90YXRpb24gdG8gdGhlIGludGVybmFsIEh1bmdhcmlhbi4gV2UgY291bGQgdXNlIHRoZVxuICogSHVuZ2FyaWFuIGNvbnZlcnQgZnVuY3Rpb24gaGVyZSwgYnV0IHRoaXMgaXMgY2xlYW5lclxuICogIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGNvbnZlcnRcbiAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU2VhcmNoVG9IdW5nICggb2JqIClcbntcblx0cmV0dXJuIHtcblx0XHRzU2VhcmNoOiAgICAgICAgICBvYmouc2VhcmNoLFxuXHRcdGJTbWFydDogICAgICAgICAgIG9iai5zbWFydCxcblx0XHRiUmVnZXg6ICAgICAgICAgICBvYmoucmVnZXgsXG5cdFx0YkNhc2VJbnNlbnNpdGl2ZTogb2JqLmNhc2VJbnNlbnNpdGl2ZVxuXHR9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgaW5mbyBkaXNwbGF5XG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtub2RlfSBJbmZvcm1hdGlvbiBlbGVtZW50XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sSW5mbyAoIHNldHRpbmdzIClcbntcblx0dmFyXG5cdFx0dGlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0bm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pLFxuXHRcdG4gPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcblx0XHRcdCdpZCc6ICEgbm9kZXMgPyB0aWQrJ19pbmZvJyA6IG51bGxcblx0XHR9ICk7XG5cblx0aWYgKCAhIG5vZGVzICkge1xuXHRcdC8vIFVwZGF0ZSBkaXNwbGF5IG9uIGVhY2ggZHJhd1xuXHRcdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goIHtcblx0XHRcdFwiZm5cIjogX2ZuVXBkYXRlSW5mbyxcblx0XHRcdFwic05hbWVcIjogXCJpbmZvcm1hdGlvblwiXG5cdFx0fSApO1xuXG5cdFx0blxuXHRcdFx0LmF0dHIoICdyb2xlJywgJ3N0YXR1cycgKVxuXHRcdFx0LmF0dHIoICdhcmlhLWxpdmUnLCAncG9saXRlJyApO1xuXG5cdFx0Ly8gVGFibGUgaXMgZGVzY3JpYmVkIGJ5IG91ciBpbmZvIGRpdlxuXHRcdCQoc2V0dGluZ3MublRhYmxlKS5hdHRyKCAnYXJpYS1kZXNjcmliZWRieScsIHRpZCsnX2luZm8nICk7XG5cdH1cblxuXHRyZXR1cm4gblswXTtcbn1cblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudHMgaW4gdGhlIGRpc3BsYXlcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuVXBkYXRlSW5mbyAoIHNldHRpbmdzIClcbntcblx0LyogU2hvdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUgKi9cblx0dmFyIG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaTtcblx0aWYgKCBub2Rlcy5sZW5ndGggPT09IDAgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyXG5cdFx0bGFuZyAgPSBzZXR0aW5ncy5vTGFuZ3VhZ2UsXG5cdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCsxLFxuXHRcdGVuZCAgID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0bWF4ICAgPSBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdHRvdGFsID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdG91dCAgID0gdG90YWwgP1xuXHRcdFx0bGFuZy5zSW5mbyA6XG5cdFx0XHRsYW5nLnNJbmZvRW1wdHk7XG5cblx0aWYgKCB0b3RhbCAhPT0gbWF4ICkge1xuXHRcdC8qIFJlY29yZCBzZXQgYWZ0ZXIgZmlsdGVyaW5nICovXG5cdFx0b3V0ICs9ICcgJyArIGxhbmcuc0luZm9GaWx0ZXJlZDtcblx0fVxuXG5cdC8vIENvbnZlcnQgdGhlIG1hY3Jvc1xuXHRvdXQgKz0gbGFuZy5zSW5mb1Bvc3RGaXg7XG5cdG91dCA9IF9mbkluZm9NYWNyb3MoIHNldHRpbmdzLCBvdXQgKTtcblxuXHR2YXIgY2FsbGJhY2sgPSBsYW5nLmZuSW5mb0NhbGxiYWNrO1xuXHRpZiAoIGNhbGxiYWNrICE9PSBudWxsICkge1xuXHRcdG91dCA9IGNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBvdXRcblx0XHQpO1xuXHR9XG5cblx0JChub2RlcykuaHRtbCggb3V0ICk7XG59XG5cblxuZnVuY3Rpb24gX2ZuSW5mb01hY3JvcyAoIHNldHRpbmdzLCBzdHIgKVxue1xuXHQvLyBXaGVuIGluZmluaXRlIHNjcm9sbGluZywgd2UgYXJlIGFsd2F5cyBzdGFydGluZyBhdCAxLiBfaURpc3BsYXlTdGFydCBpcyB1c2VkIG9ubHlcblx0Ly8gaW50ZXJuYWxseVxuXHR2YXJcblx0XHRmb3JtYXR0ZXIgID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIsXG5cdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0KzEsXG5cdFx0bGVuICAgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHR2aXMgICAgICAgID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXG5cdHJldHVybiBzdHIuXG5cdFx0cmVwbGFjZSgvX1NUQVJUXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHN0YXJ0ICkgKS5cblx0XHRyZXBsYWNlKC9fRU5EXy9nLCAgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkgKSApLlxuXHRcdHJlcGxhY2UoL19NQVhfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpICkgKS5cblx0XHRyZXBsYWNlKC9fVE9UQUxfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgdmlzICkgKS5cblx0XHRyZXBsYWNlKC9fUEFHRV8vZywgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbCggc3RhcnQgLyBsZW4gKSApICkuXG5cdFx0cmVwbGFjZSgvX1BBR0VTXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpcyAvIGxlbiApICkgKTtcbn1cblxuXG5cbi8qKlxuICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkluaXRpYWxpc2UgKCBzZXR0aW5ncyApXG57XG5cdHZhciBpLCBpTGVuLCBpQWpheFN0YXJ0PXNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucywgY29sdW1uO1xuXHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG5cdHZhciBkZWZlckxvYWRpbmcgPSBzZXR0aW5ncy5iRGVmZXJMb2FkaW5nOyAvLyB2YWx1ZSBtb2RpZmllZCBieSB0aGUgZHJhd1xuXG5cdC8qIEVuc3VyZSB0aGF0IHRoZSB0YWJsZSBkYXRhIGlzIGZ1bGx5IGluaXRpYWxpc2VkICovXG5cdGlmICggISBzZXR0aW5ncy5iSW5pdGlhbGlzZWQgKSB7XG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgX2ZuSW5pdGlhbGlzZSggc2V0dGluZ3MgKTsgfSwgMjAwICk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0LyogU2hvdyB0aGUgZGlzcGxheSBIVE1MIG9wdGlvbnMgKi9cblx0X2ZuQWRkT3B0aW9uc0h0bWwoIHNldHRpbmdzICk7XG5cblx0LyogQnVpbGQgYW5kIGRyYXcgdGhlIGhlYWRlciAvIGZvb3RlciBmb3IgdGhlIHRhYmxlICovXG5cdF9mbkJ1aWxkSGVhZCggc2V0dGluZ3MgKTtcblx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyICk7XG5cblx0LyogT2theSB0byBzaG93IHRoYXQgc29tZXRoaW5nIGlzIGdvaW5nIG9uIG5vdyAqL1xuXHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHQvKiBDYWxjdWxhdGUgc2l6ZXMgZm9yIGNvbHVtbnMgKi9cblx0aWYgKCBmZWF0dXJlcy5iQXV0b1dpZHRoICkge1xuXHRcdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyggc2V0dGluZ3MgKTtcblx0fVxuXG5cdGZvciAoIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXG5cdFx0aWYgKCBjb2x1bW4uc1dpZHRoICkge1xuXHRcdFx0Y29sdW1uLm5UaC5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoICk7XG5cdFx0fVxuXHR9XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3ByZUluaXQnLCBbc2V0dGluZ3NdICk7XG5cblx0Ly8gSWYgdGhlcmUgaXMgZGVmYXVsdCBzb3J0aW5nIHJlcXVpcmVkIC0gbGV0J3MgZG8gaXQuIFRoZSBzb3J0IGZ1bmN0aW9uXG5cdC8vIHdpbGwgZG8gdGhlIGRyYXdpbmcgZm9yIHVzLiBPdGhlcndpc2Ugd2UgZHJhdyB0aGUgdGFibGUgcmVnYXJkbGVzcyBvZiB0aGVcblx0Ly8gQWpheCBzb3VyY2UgLSB0aGlzIGFsbG93cyB0aGUgdGFibGUgdG8gbG9vayBpbml0aWFsaXNlZCBmb3IgQWpheCBzb3VyY2luZ1xuXHQvLyBkYXRhIChzaG93ICdsb2FkaW5nJyBtZXNzYWdlIHBvc3NpYmx5KVxuXHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cblx0Ly8gU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBpbml0IGNvbXBsZXRlIGlzIGRvbmUgYnkgX2ZuQWpheFVwZGF0ZURyYXdcblx0dmFyIGRhdGFTcmMgPSBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApO1xuXHRpZiAoIGRhdGFTcmMgIT0gJ3NzcCcgfHwgZGVmZXJMb2FkaW5nICkge1xuXHRcdC8vIGlmIHRoZXJlIGlzIGFuIGFqYXggc291cmNlIGxvYWQgdGhlIGRhdGFcblx0XHRpZiAoIGRhdGFTcmMgPT0gJ2FqYXgnICkge1xuXHRcdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywgW10sIGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdFx0dmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cblx0XHRcdFx0Ly8gR290IHRoZSBkYXRhIC0gYWRkIGl0IHRvIHRoZSB0YWJsZVxuXHRcdFx0XHRmb3IgKCBpPTAgOyBpPGFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgYURhdGFbaV0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc2V0IHRoZSBpbml0IGRpc3BsYXkgZm9yIGNvb2tpZSBzYXZpbmcuIFdlJ3ZlIGFscmVhZHkgZG9uZVxuXHRcdFx0XHQvLyBhIGZpbHRlciwgYW5kIHRoZXJlZm9yZSBjbGVhcmVkIGl0IGJlZm9yZS4gU28gd2UgbmVlZCB0byBtYWtlXG5cdFx0XHRcdC8vIGl0IGFwcGVhciAnZnJlc2gnXG5cdFx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gaUFqYXhTdGFydDtcblxuXHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cblx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0XHR9LCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gW2pzb25dIEpTT04gZnJvbSB0aGUgc2VydmVyIHRoYXQgY29tcGxldGVkIHRoZSB0YWJsZSwgaWYgdXNpbmcgQWpheCBzb3VyY2VcbiAqICAgIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZyAob3B0aW9uYWwpXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkluaXRDb21wbGV0ZSAoIHNldHRpbmdzLCBqc29uIClcbntcblx0c2V0dGluZ3MuX2JJbml0Q29tcGxldGUgPSB0cnVlO1xuXG5cdC8vIFdoZW4gZGF0YSB3YXMgYWRkZWQgYWZ0ZXIgdGhlIGluaXRpYWxpc2F0aW9uIChkYXRhIG9yIEFqYXgpIHdlIG5lZWQgdG9cblx0Ly8gY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6aW5nXG5cdGlmICgganNvbiB8fCBzZXR0aW5ncy5vSW5pdC5hYURhdGEgKSB7XG5cdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXHR9XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3BsdWdpbi1pbml0JywgW3NldHRpbmdzLCBqc29uXSApO1xuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIFtzZXR0aW5ncywganNvbl0gKTtcbn1cblxuXG5mdW5jdGlvbiBfZm5MZW5ndGhDaGFuZ2UgKCBzZXR0aW5ncywgdmFsIClcbntcblx0dmFyIGxlbiA9IHBhcnNlSW50KCB2YWwsIDEwICk7XG5cdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IGxlbjtcblxuXHRfZm5MZW5ndGhPdmVyZmxvdyggc2V0dGluZ3MgKTtcblxuXHQvLyBGaXJlIGxlbmd0aCBjaGFuZ2UgZXZlbnRcblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2xlbmd0aCcsIFtzZXR0aW5ncywgbGVuXSApO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHVzZXIgZGlzcGxheSBsZW5ndGggY2hhbmdpbmdcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7bm9kZX0gRGlzcGxheSBsZW5ndGggZmVhdHVyZSBub2RlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sTGVuZ3RoICggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRjbGFzc2VzICA9IHNldHRpbmdzLm9DbGFzc2VzLFxuXHRcdHRhYmxlSWQgID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0bWVudSAgICAgPSBzZXR0aW5ncy5hTGVuZ3RoTWVudSxcblx0XHRkMiAgICAgICA9IEFycmF5LmlzQXJyYXkoIG1lbnVbMF0gKSxcblx0XHRsZW5ndGhzICA9IGQyID8gbWVudVswXSA6IG1lbnUsXG5cdFx0bGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXG5cdHZhciBzZWxlY3QgPSAkKCc8c2VsZWN0Lz4nLCB7XG5cdFx0J25hbWUnOiAgICAgICAgICB0YWJsZUlkKydfbGVuZ3RoJyxcblx0XHQnYXJpYS1jb250cm9scyc6IHRhYmxlSWQsXG5cdFx0J2NsYXNzJzogICAgICAgICBjbGFzc2VzLnNMZW5ndGhTZWxlY3Rcblx0fSApO1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1sZW5ndGhzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHNlbGVjdFswXVsgaSBdID0gbmV3IE9wdGlvbihcblx0XHRcdHR5cGVvZiBsYW5ndWFnZVtpXSA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHRzZXR0aW5ncy5mbkZvcm1hdE51bWJlciggbGFuZ3VhZ2VbaV0gKSA6XG5cdFx0XHRcdGxhbmd1YWdlW2ldLFxuXHRcdFx0bGVuZ3Roc1tpXVxuXHRcdCk7XG5cdH1cblxuXHR2YXIgZGl2ID0gJCgnPGRpdj48bGFiZWwvPjwvZGl2PicpLmFkZENsYXNzKCBjbGFzc2VzLnNMZW5ndGggKTtcblx0aWYgKCAhIHNldHRpbmdzLmFhbkZlYXR1cmVzLmwgKSB7XG5cdFx0ZGl2WzBdLmlkID0gdGFibGVJZCsnX2xlbmd0aCc7XG5cdH1cblxuXHRkaXYuY2hpbGRyZW4oKS5hcHBlbmQoXG5cdFx0c2V0dGluZ3Mub0xhbmd1YWdlLnNMZW5ndGhNZW51LnJlcGxhY2UoICdfTUVOVV8nLCBzZWxlY3RbMF0ub3V0ZXJIVE1MIClcblx0KTtcblxuXHQvLyBDYW4ndCB1c2UgYHNlbGVjdGAgdmFyaWFibGUgYXMgdXNlciBtaWdodCBwcm92aWRlIHRoZWlyIG93biBhbmQgdGhlXG5cdC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcblx0JCgnc2VsZWN0JywgZGl2KVxuXHRcdC52YWwoIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCApXG5cdFx0Lm9uKCAnY2hhbmdlLkRUJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0X2ZuTGVuZ3RoQ2hhbmdlKCBzZXR0aW5ncywgJCh0aGlzKS52YWwoKSApO1xuXHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9ICk7XG5cblx0Ly8gVXBkYXRlIG5vZGUgdmFsdWUgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcyB0aGUgdGFibGUncyBsZW5ndGhcblx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnbGVuZ3RoLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIGxlbikge1xuXHRcdGlmICggc2V0dGluZ3MgPT09IHMgKSB7XG5cdFx0XHQkKCdzZWxlY3QnLCBkaXYpLnZhbCggbGVuICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIGRpdlswXTtcbn1cblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBOb3RlIHRoYXQgbW9zdCBvZiB0aGUgcGFnaW5nIGxvZ2ljIGlzIGRvbmUgaW5cbiAqIERhdGFUYWJsZS5leHQucGFnZXJcbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBkZWZhdWx0IHBhZ2luYXRpb25cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge25vZGV9IFBhZ2luYXRpb24gZmVhdHVyZSBub2RlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUgKCBzZXR0aW5ncyApXG57XG5cdHZhclxuXHRcdHR5cGUgICA9IHNldHRpbmdzLnNQYWdpbmF0aW9uVHlwZSxcblx0XHRwbHVnaW4gPSBEYXRhVGFibGUuZXh0LnBhZ2VyWyB0eXBlIF0sXG5cdFx0bW9kZXJuID0gdHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRyZWRyYXcgPSBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdH0sXG5cdFx0bm9kZSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCBzZXR0aW5ncy5vQ2xhc3Nlcy5zUGFnaW5nICsgdHlwZSApWzBdLFxuXHRcdGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cblx0aWYgKCAhIG1vZGVybiApIHtcblx0XHRwbHVnaW4uZm5Jbml0KCBzZXR0aW5ncywgbm9kZSwgcmVkcmF3ICk7XG5cdH1cblxuXHQvKiBBZGQgYSBkcmF3IGNhbGxiYWNrIGZvciB0aGUgcGFnaW5hdGlvbiBvbiBmaXJzdCBpbnN0YW5jZSwgdG8gdXBkYXRlIHRoZSBwYWdpbmcgZGlzcGxheSAqL1xuXHRpZiAoICEgZmVhdHVyZXMucCApXG5cdHtcblx0XHRub2RlLmlkID0gc2V0dGluZ3Muc1RhYmxlSWQrJ19wYWdpbmF0ZSc7XG5cblx0XHRzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKCB7XG5cdFx0XHRcImZuXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHRcdFx0aWYgKCBtb2Rlcm4gKSB7XG5cdFx0XHRcdFx0dmFyXG5cdFx0XHRcdFx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRcdFx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdFx0XHRcdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRcdFx0XHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xLFxuXHRcdFx0XHRcdFx0cGFnZSA9IGFsbCA/IDAgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICksXG5cdFx0XHRcdFx0XHRwYWdlcyA9IGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpc1JlY29yZHMgLyBsZW4gKSxcblx0XHRcdFx0XHRcdGJ1dHRvbnMgPSBwbHVnaW4ocGFnZSwgcGFnZXMpLFxuXHRcdFx0XHRcdFx0aSwgaWVuO1xuXG5cdFx0XHRcdFx0Zm9yICggaT0wLCBpZW49ZmVhdHVyZXMucC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdF9mblJlbmRlcmVyKCBzZXR0aW5ncywgJ3BhZ2VCdXR0b24nICkoXG5cdFx0XHRcdFx0XHRcdHNldHRpbmdzLCBmZWF0dXJlcy5wW2ldLCBpLCBidXR0b25zLCBwYWdlLCBwYWdlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cGx1Z2luLmZuVXBkYXRlKCBzZXR0aW5ncywgcmVkcmF3ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRcInNOYW1lXCI6IFwicGFnaW5hdGlvblwiXG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIG5vZGU7XG59XG5cblxuLyoqXG4gKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2VcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IGFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLFxuICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcbiAqICBAcGFyYW0gW2Jvb2xdIHJlZHJhdyBBdXRvbWF0aWNhbGx5IGRyYXcgdGhlIHVwZGF0ZSBvciBub3RcbiAqICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBwYWdlIGhhcyBjaGFuZ2VkLCBmYWxzZSAtIG5vIGNoYW5nZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5QYWdlQ2hhbmdlICggc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3IClcbntcblx0dmFyXG5cdFx0c3RhcnQgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdHJlY29yZHMgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKTtcblxuXHRpZiAoIHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSApXG5cdHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBhY3Rpb24gPT09IFwibnVtYmVyXCIgKVxuXHR7XG5cdFx0c3RhcnQgPSBhY3Rpb24gKiBsZW47XG5cblx0XHRpZiAoIHN0YXJ0ID4gcmVjb3JkcyApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09IFwiZmlyc3RcIiApXG5cdHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcInByZXZpb3VzXCIgKVxuXHR7XG5cdFx0c3RhcnQgPSBsZW4gPj0gMCA/XG5cdFx0XHRzdGFydCAtIGxlbiA6XG5cdFx0XHQwO1xuXG5cdFx0aWYgKCBzdGFydCA8IDAgKVxuXHRcdHtcblx0XHQgIHN0YXJ0ID0gMDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcIm5leHRcIiApXG5cdHtcblx0XHRpZiAoIHN0YXJ0ICsgbGVuIDwgcmVjb3JkcyApXG5cdFx0e1xuXHRcdFx0c3RhcnQgKz0gbGVuO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09IFwibGFzdFwiIClcblx0e1xuXHRcdHN0YXJ0ID0gTWF0aC5mbG9vciggKHJlY29yZHMtMSkgLyBsZW4pICogbGVuO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIithY3Rpb24sIDUgKTtcblx0fVxuXG5cdHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xuXHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXG5cdGlmICggY2hhbmdlZCApIHtcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGFnZScsIFtzZXR0aW5nc10gKTtcblxuXHRcdGlmICggcmVkcmF3ICkge1xuXHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gTm8gY2hhbmdlIGV2ZW50IC0gcGFnaW5nIHdhcyBjYWxsZWQsIGJ1dCBubyBjaGFuZ2Vcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncGFnZS1uYycsIFtzZXR0aW5nc10gKTtcblx0fVxuXG5cdHJldHVybiBjaGFuZ2VkO1xufVxuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtub2RlfSBQcm9jZXNzaW5nIGVsZW1lbnRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nICggc2V0dGluZ3MgKVxue1xuXHRyZXR1cm4gJCgnPGRpdi8+Jywge1xuXHRcdFx0J2lkJzogISBzZXR0aW5ncy5hYW5GZWF0dXJlcy5yID8gc2V0dGluZ3Muc1RhYmxlSWQrJ19wcm9jZXNzaW5nJyA6IG51bGwsXG5cdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zUHJvY2Vzc2luZyxcblx0XHRcdCdyb2xlJzogJ3N0YXR1cydcblx0XHR9IClcblx0XHQuaHRtbCggc2V0dGluZ3Mub0xhbmd1YWdlLnNQcm9jZXNzaW5nIClcblx0XHQuYXBwZW5kKCc8ZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PC9kaXY+Jylcblx0XHQuaW5zZXJ0QmVmb3JlKCBzZXR0aW5ncy5uVGFibGUgKVswXTtcbn1cblxuXG4vKipcbiAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3JcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2Jvb2x9IHNob3cgU2hvdyB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3IgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblByb2Nlc3NpbmdEaXNwbGF5ICggc2V0dGluZ3MsIHNob3cgKVxue1xuXHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZyApIHtcblx0XHQkKHNldHRpbmdzLmFhbkZlYXR1cmVzLnIpLmNzcyggJ2Rpc3BsYXknLCBzaG93ID8gJ2Jsb2NrJyA6ICdub25lJyApO1xuXHR9XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3Byb2Nlc3NpbmcnLCBbc2V0dGluZ3MsIHNob3ddICk7XG59XG5cbi8qKlxuICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge25vZGV9IE5vZGUgdG8gYWRkIHRvIHRoZSBET01cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxUYWJsZSAoIHNldHRpbmdzIClcbntcblx0dmFyIHRhYmxlID0gJChzZXR0aW5ncy5uVGFibGUpO1xuXG5cdC8vIFNjcm9sbGluZyBmcm9tIGhlcmUgb24gaW5cblx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cblx0aWYgKCBzY3JvbGwuc1ggPT09ICcnICYmIHNjcm9sbC5zWSA9PT0gJycgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzLm5UYWJsZTtcblx0fVxuXG5cdHZhciBzY3JvbGxYID0gc2Nyb2xsLnNYO1xuXHR2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0dmFyIGNhcHRpb24gPSB0YWJsZS5jaGlsZHJlbignY2FwdGlvbicpO1xuXHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcblx0dmFyIGhlYWRlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHR2YXIgZm9vdGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcblx0dmFyIF9kaXYgPSAnPGRpdi8+Jztcblx0dmFyIHNpemUgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0cmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKCBzICk7XG5cdH07XG5cblx0aWYgKCAhIGZvb3Rlci5sZW5ndGggKSB7XG5cdFx0Zm9vdGVyID0gbnVsbDtcblx0fVxuXG5cdC8qXG5cdCAqIFRoZSBIVE1MIHN0cnVjdHVyZSB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaW4gdGhpcyBmdW5jdGlvbiBpczpcblx0ICogIGRpdiAtIHNjcm9sbGVyXG5cdCAqICAgIGRpdiAtIHNjcm9sbCBoZWFkXG5cdCAqICAgICAgZGl2IC0gc2Nyb2xsIGhlYWQgaW5uZXJcblx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcblx0ICogICAgICAgICAgdGhlYWQgLSB0aGVhZFxuXHQgKiAgICBkaXYgLSBzY3JvbGwgYm9keVxuXHQgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcblx0ICogICAgICAgIHRoZWFkIC0gdGhlYWQgY2xvbmUgZm9yIHNpemluZ1xuXHQgKiAgICAgICAgdGJvZHkgLSB0Ym9keVxuXHQgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxuXHQgKiAgICAgIGRpdiAtIHNjcm9sbCBmb290IGlubmVyXG5cdCAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBmb290IHRhYmxlXG5cdCAqICAgICAgICAgIHRmb290IC0gdGZvb3Rcblx0ICovXG5cdHZhciBzY3JvbGxlciA9ICQoIF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsV3JhcHBlciB9IClcblx0XHQuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEhlYWQgfSApXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0gKVxuXHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHQnYm94LXNpemluZyc6ICdjb250ZW50LWJveCcsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGwuc1hJbm5lciB8fCAnMTAwJSdcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0aGVhZGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdC5jc3MoICdtYXJnaW4tbGVmdCcsIDAgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFibGUuY2hpbGRyZW4oJ3RoZWFkJylcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHQpXG5cdFx0LmFwcGVuZChcblx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxCb2R5IH0gKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdFx0XHRcdFx0b3ZlcmZsb3c6ICdhdXRvJyxcblx0XHRcdFx0XHR3aWR0aDogc2l6ZSggc2Nyb2xsWCApXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYXBwZW5kKCB0YWJsZSApXG5cdFx0KTtcblxuXHRpZiAoIGZvb3RlciApIHtcblx0XHRzY3JvbGxlci5hcHBlbmQoXG5cdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdCB9IClcblx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0XHRib3JkZXI6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IHNjcm9sbFggPyBzaXplKHNjcm9sbFgpIDogJzEwMCUnXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290SW5uZXIgfSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRmb290ZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICdib3R0b20nID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHR2YXIgY2hpbGRyZW4gPSBzY3JvbGxlci5jaGlsZHJlbigpO1xuXHR2YXIgc2Nyb2xsSGVhZCA9IGNoaWxkcmVuWzBdO1xuXHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHR2YXIgc2Nyb2xsRm9vdCA9IGZvb3RlciA/IGNoaWxkcmVuWzJdIDogbnVsbDtcblxuXHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0aWYgKCBzY3JvbGxYICkge1xuXHRcdCQoc2Nyb2xsQm9keSkub24oICdzY3JvbGwuRFQnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cblx0XHRcdHNjcm9sbEhlYWQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cblx0XHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0XHRzY3JvbGxGb290LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxuXG5cdCQoc2Nyb2xsQm9keSkuY3NzKCdtYXgtaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdGlmICghIHNjcm9sbC5iQ29sbGFwc2UpIHtcblx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdH1cblxuXHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdHNldHRpbmdzLm5TY3JvbGxCb2R5ID0gc2Nyb2xsQm9keTtcblx0c2V0dGluZ3MublNjcm9sbEZvb3QgPSBzY3JvbGxGb290O1xuXG5cdC8vIE9uIHJlZHJhdyAtIGFsaWduIGNvbHVtbnNcblx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCgge1xuXHRcdFwiZm5cIjogX2ZuU2Nyb2xsRHJhdyxcblx0XHRcInNOYW1lXCI6IFwic2Nyb2xsaW5nXCJcblx0fSApO1xuXG5cdHJldHVybiBzY3JvbGxlclswXTtcbn1cblxuXG5cbi8qKlxuICogVXBkYXRlIHRoZSBoZWFkZXIsIGZvb3RlciBhbmQgYm9keSB0YWJsZXMgZm9yIHJlc2l6aW5nIC0gaS5lLiBjb2x1bW5cbiAqIGFsaWdubWVudC5cbiAqXG4gKiBXZWxjb21lIHRvIHRoZSBtb3N0IGhvcnJpYmxlIGZ1bmN0aW9uIERhdGFUYWJsZXMuIFRoZSBwcm9jZXNzIHRoYXQgdGhpc1xuICogZnVuY3Rpb24gZm9sbG93cyBpcyBiYXNpY2FsbHk6XG4gKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XG4gKiAgIDIuIFRha2UgbGl2ZSBtZWFzdXJlbWVudHMgZnJvbSB0aGUgRE9NXG4gKiAgIDMuIEFwcGx5IHRoZSBtZWFzdXJlbWVudHMgdG8gYWxpZ24gdGhlIGNvbHVtbnNcbiAqICAgNC4gQ2xlYW4gdXBcbiAqXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNjcm9sbERyYXcgKCBzZXR0aW5ncyApXG57XG5cdC8vIEdpdmVuIHRoYXQgdGhpcyBpcyBzdWNoIGEgbW9uc3RlciBmdW5jdGlvbiwgYSBsb3Qgb2YgdmFyaWFibGVzIGFyZSB1c2Vcblx0Ly8gdG8gdHJ5IGFuZCBrZWVwIHRoZSBtaW5pbWlzZWQgc2l6ZSBhcyBzbWFsbCBhcyBwb3NzaWJsZVxuXHR2YXJcblx0XHRzY3JvbGwgICAgICAgICA9IHNldHRpbmdzLm9TY3JvbGwsXG5cdFx0c2Nyb2xsWCAgICAgICAgPSBzY3JvbGwuc1gsXG5cdFx0c2Nyb2xsWElubmVyICAgPSBzY3JvbGwuc1hJbm5lcixcblx0XHRzY3JvbGxZICAgICAgICA9IHNjcm9sbC5zWSxcblx0XHRiYXJXaWR0aCAgICAgICA9IHNjcm9sbC5pQmFyV2lkdGgsXG5cdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRkaXZIZWFkZXJTdHlsZSA9IGRpdkhlYWRlclswXS5zdHlsZSxcblx0XHRkaXZIZWFkZXJJbm5lciA9IGRpdkhlYWRlci5jaGlsZHJlbignZGl2JyksXG5cdFx0ZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxuXHRcdGRpdkhlYWRlclRhYmxlID0gZGl2SGVhZGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0ZGl2Qm9keUVsICAgICAgPSBzZXR0aW5ncy5uU2Nyb2xsQm9keSxcblx0XHRkaXZCb2R5ICAgICAgICA9ICQoZGl2Qm9keUVsKSxcblx0XHRkaXZCb2R5U3R5bGUgICA9IGRpdkJvZHlFbC5zdHlsZSxcblx0XHRkaXZGb290ZXIgICAgICA9ICQoc2V0dGluZ3MublNjcm9sbEZvb3QpLFxuXHRcdGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRkaXZGb290ZXJUYWJsZSA9IGRpdkZvb3RlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxuXHRcdGhlYWRlciAgICAgICAgID0gJChzZXR0aW5ncy5uVEhlYWQpLFxuXHRcdHRhYmxlICAgICAgICAgID0gJChzZXR0aW5ncy5uVGFibGUpLFxuXHRcdHRhYmxlRWwgICAgICAgID0gdGFibGVbMF0sXG5cdFx0dGFibGVTdHlsZSAgICAgPSB0YWJsZUVsLnN0eWxlLFxuXHRcdGZvb3RlciAgICAgICAgID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcblx0XHRicm93c2VyICAgICAgICA9IHNldHRpbmdzLm9Ccm93c2VyLFxuXHRcdGllNjcgICAgICAgICAgID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUsXG5cdFx0ZHRIZWFkZXJDZWxscyAgPSBfcGx1Y2soIHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcgKSxcblx0XHRoZWFkZXJUcmdFbHMsIGZvb3RlclRyZ0Vscyxcblx0XHRoZWFkZXJTcmNFbHMsIGZvb3RlclNyY0Vscyxcblx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5LFxuXHRcdGhlYWRlcldpZHRocz1bXSwgZm9vdGVyV2lkdGhzPVtdLFxuXHRcdGhlYWRlckNvbnRlbnQ9W10sIGZvb3RlckNvbnRlbnQ9W10sXG5cdFx0aWR4LCBjb3JyZWN0aW9uLCBzYW5pdHlXaWR0aCxcblx0XHR6ZXJvT3V0ID0gZnVuY3Rpb24oblNpemVyKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBuU2l6ZXIuc3R5bGU7XG5cdFx0XHRzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG5cdFx0XHRzdHlsZS5wYWRkaW5nQm90dG9tID0gXCIwXCI7XG5cdFx0XHRzdHlsZS5ib3JkZXJUb3BXaWR0aCA9IFwiMFwiO1xuXHRcdFx0c3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcblx0XHRcdHN0eWxlLmhlaWdodCA9IDA7XG5cdFx0fTtcblxuXHQvLyBJZiB0aGUgc2Nyb2xsYmFyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgZnJvbSB0aGUgbGFzdCBkcmF3LCB3ZSBuZWVkIHRvXG5cdC8vIGFkanVzdCB0aGUgY29sdW1uIHNpemVzIGFzIHRoZSB0YWJsZSB3aWR0aCB3aWxsIGhhdmUgY2hhbmdlZCB0byBhY2NvdW50XG5cdC8vIGZvciB0aGUgc2Nyb2xsYmFyXG5cdHZhciBzY3JvbGxCYXJWaXMgPSBkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodDtcblx0XG5cdGlmICggc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSBzY3JvbGxCYXJWaXMgJiYgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHRyZXR1cm47IC8vIGFkanVzdCBjb2x1bW4gc2l6aW5nIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluXG5cdH1cblx0ZWxzZSB7XG5cdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHR9XG5cblx0Lypcblx0ICogMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcblx0ICovXG5cblx0Ly8gUmVtb3ZlIHRoZSBvbGQgbWluaW1pc2VkIHRoZWFkIGFuZCB0Zm9vdCBlbGVtZW50cyBpbiB0aGUgaW5uZXIgdGFibGVcblx0dGFibGUuY2hpbGRyZW4oJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdGZvb3RlckNvcHkgPSBmb290ZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0Zm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXG5cdFx0Zm9vdGVyU3JjRWxzID0gZm9vdGVyQ29weS5maW5kKCd0cicpO1xuXHRcdGZvb3RlckNvcHkuZmluZCgnW2lkXScpLnJlbW92ZUF0dHIoJ2lkJyk7XG5cdH1cblxuXHQvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxuXHRoZWFkZXJDb3B5ID0gaGVhZGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRoZWFkZXJUcmdFbHMgPSBoZWFkZXIuZmluZCgndHInKTsgLy8gb3JpZ2luYWwgaGVhZGVyIGlzIGluIGl0cyBvd24gdGFibGVcblx0aGVhZGVyU3JjRWxzID0gaGVhZGVyQ29weS5maW5kKCd0cicpO1xuXHRoZWFkZXJDb3B5LmZpbmQoJ3RoLCB0ZCcpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG5cdGhlYWRlckNvcHkuZmluZCgnW2lkXScpLnJlbW92ZUF0dHIoJ2lkJyk7XG5cblxuXHQvKlxuXHQgKiAyLiBUYWtlIGxpdmUgbWVhc3VyZW1lbnRzIGZyb20gdGhlIERPTSAtIGRvIG5vdCBhbHRlciB0aGUgRE9NIGl0c2VsZiFcblx0ICovXG5cblx0Ly8gUmVtb3ZlIG9sZCBzaXppbmcgYW5kIGFwcGx5IHRoZSBjYWxjdWxhdGVkIGNvbHVtbiB3aWR0aHNcblx0Ly8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxuXHQvLyBjYWxjdWxhdGVkIHNpemVzIHRvIHRoaXMgaGVhZGVyXG5cdGlmICggISBzY3JvbGxYIClcblx0e1xuXHRcdGRpdkJvZHlTdHlsZS53aWR0aCA9ICcxMDAlJztcblx0XHRkaXZIZWFkZXJbMF0uc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdH1cblxuXHQkLmVhY2goIF9mbkdldFVuaXF1ZVRocyggc2V0dGluZ3MsIGhlYWRlckNvcHkgKSwgZnVuY3Rpb24gKCBpLCBlbCApIHtcblx0XHRpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGkgKTtcblx0XHRlbC5zdHlsZS53aWR0aCA9IHNldHRpbmdzLmFvQ29sdW1uc1tpZHhdLnNXaWR0aDtcblx0fSApO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24obikge1xuXHRcdFx0bi5zdHlsZS53aWR0aCA9IFwiXCI7XG5cdFx0fSwgZm9vdGVyU3JjRWxzICk7XG5cdH1cblxuXHQvLyBTaXplIHRoZSB0YWJsZSBhcyBhIHdob2xlXG5cdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHRpZiAoIHNjcm9sbFggPT09IFwiXCIgKSB7XG5cdFx0Ly8gTm8geCBzY3JvbGxpbmdcblx0XHR0YWJsZVN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cblx0XHQvLyBJRTcgd2lsbCBtYWtlIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgd2hlbiAxMDAlIGluY2x1ZGUgdGhlIHNjcm9sbGJhclxuXHRcdC8vIC0gd2hpY2ggaXMgc2hvdWxkbid0LiBXaGVuIHRoZXJlIGlzIGEgc2Nyb2xsYmFyIHdlIG5lZWQgdG8gdGFrZSB0aGlzXG5cdFx0Ly8gaW50byBhY2NvdW50LlxuXHRcdGlmICggaWU2NyAmJiAodGFibGUuZmluZCgndGJvZHknKS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHxcblx0XHRcdGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcblx0XHQpIHtcblx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggdGFibGUub3V0ZXJXaWR0aCgpIC0gYmFyV2lkdGgpO1xuXHRcdH1cblxuXHRcdC8vIFJlY2FsY3VsYXRlIHRoZSBzYW5pdHkgd2lkdGhcblx0XHRzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0fVxuXHRlbHNlIGlmICggc2Nyb2xsWElubmVyICE9PSBcIlwiICkge1xuXHRcdC8vIGxlZ2FjeSB4IHNjcm9sbCBpbm5lciBoYXMgYmVlbiBnaXZlbiAtIHVzZSBpdFxuXHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzY3JvbGxYSW5uZXIpO1xuXG5cdFx0Ly8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuXHRcdHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXHR9XG5cblx0Ly8gSGlkZGVuIGhlYWRlciBzaG91bGQgaGF2ZSB6ZXJvIGhlaWdodCwgc28gcmVtb3ZlIHBhZGRpbmcgYW5kIGJvcmRlcnMuIFRoZW5cblx0Ly8gc2V0IHRoZSB3aWR0aCBiYXNlZCBvbiB0aGUgcmVhbCBoZWFkZXJzXG5cblx0Ly8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xuXHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGhlYWRlclNyY0VscyApO1xuXG5cdC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3Ncblx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHR2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/XG5cdFx0XHR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuU2l6ZXIpLndpZHRoIDpcblx0XHRcdF9mblN0cmluZ1RvQ3NzKCAkKG5TaXplcikud2lkdGgoKSApO1xuXG5cdFx0aGVhZGVyQ29udGVudC5wdXNoKCBuU2l6ZXIuaW5uZXJIVE1MICk7XG5cdFx0aGVhZGVyV2lkdGhzLnB1c2goIHN0eWxlICk7XG5cdH0sIGhlYWRlclNyY0VscyApO1xuXG5cdC8vIEFwcGx5IGFsbCB3aWR0aHMgaW4gZmluYWwgcGFzc1xuXHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5Ub1NpemUsIGkpIHtcblx0XHRuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHR9LCBoZWFkZXJUcmdFbHMgKTtcblxuXHQkKGhlYWRlclNyY0VscykuY3NzKCdoZWlnaHQnLCAwKTtcblxuXHQvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xuXHRpZiAoIGZvb3RlciApXG5cdHtcblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIHplcm9PdXQsIGZvb3RlclNyY0VscyApO1xuXG5cdFx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIpIHtcblx0XHRcdGZvb3RlckNvbnRlbnQucHVzaCggblNpemVyLmlubmVySFRNTCApO1xuXHRcdFx0Zm9vdGVyV2lkdGhzLnB1c2goIF9mblN0cmluZ1RvQ3NzKCAkKG5TaXplcikuY3NzKCd3aWR0aCcpICkgKTtcblx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblxuXHRcdF9mbkFwcGx5VG9DaGlsZHJlbiggZnVuY3Rpb24oblRvU2l6ZSwgaSkge1xuXHRcdFx0blRvU2l6ZS5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHR9LCBmb290ZXJUcmdFbHMgKTtcblxuXHRcdCQoZm9vdGVyU3JjRWxzKS5oZWlnaHQoMCk7XG5cdH1cblxuXG5cdC8qXG5cdCAqIDMuIEFwcGx5IHRoZSBtZWFzdXJlbWVudHNcblx0ICovXG5cblx0Ly8gXCJIaWRlXCIgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRoYXQgd2UgdXNlZCBmb3IgdGhlIHNpemluZy4gV2UgbmVlZCB0byBrZWVwXG5cdC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxuXHQvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcblx0Ly8gd2lkdGggdG8gd2hhdCB0aGV5IGN1cnJlbnRseSBhcmVcblx0X2ZuQXBwbHlUb0NoaWxkcmVuKCBmdW5jdGlvbihuU2l6ZXIsIGkpIHtcblx0XHRuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicraGVhZGVyQ29udGVudFtpXSsnPC9kaXY+Jztcblx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcblx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0blNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuXHR9LCBoZWFkZXJTcmNFbHMgKTtcblxuXHRpZiAoIGZvb3RlciApXG5cdHtcblx0XHRfZm5BcHBseVRvQ2hpbGRyZW4oIGZ1bmN0aW9uKG5TaXplciwgaSkge1xuXHRcdFx0blNpemVyLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiZGF0YVRhYmxlc19zaXppbmdcIj4nK2Zvb3RlckNvbnRlbnRbaV0rJzwvZGl2Pic7XG5cdFx0XHRuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcblx0XHRcdG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRcdG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcblx0XHR9LCBmb290ZXJTcmNFbHMgKTtcblx0fVxuXG5cdC8vIFNhbml0eSBjaGVjayB0aGF0IHRoZSB0YWJsZSBpcyBvZiBhIHNlbnNpYmxlIHdpZHRoLiBJZiBub3QgdGhlbiB3ZSBhcmUgZ29pbmcgdG8gZ2V0XG5cdC8vIG1pc2FsaWdubWVudCAtIHRyeSB0byBwcmV2ZW50IHRoaXMgYnkgbm90IGFsbG93aW5nIHRoZSB0YWJsZSB0byBzaHJpbmsgYmVsb3cgaXRzIG1pbiB3aWR0aFxuXHRpZiAoIE1hdGgucm91bmQodGFibGUub3V0ZXJXaWR0aCgpKSA8IE1hdGgucm91bmQoc2FuaXR5V2lkdGgpIClcblx0e1xuXHRcdC8vIFRoZSBtaW4gd2lkdGggZGVwZW5kcyB1cG9uIGlmIHdlIGhhdmUgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgdmlzaWJsZSBvciBub3QgKi9cblx0XHRjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuXHRcdFx0ZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKSkgP1xuXHRcdFx0XHRzYW5pdHlXaWR0aCtiYXJXaWR0aCA6XG5cdFx0XHRcdHNhbml0eVdpZHRoO1xuXG5cdFx0Ly8gSUU2LzcgYXJlIGEgbGF3IHVudG8gdGhlbXNlbHZlcy4uLlxuXHRcdGlmICggaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XG5cdFx0XHRkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8IGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcblx0XHQpIHtcblx0XHRcdHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbi1iYXJXaWR0aCApO1xuXHRcdH1cblxuXHRcdC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXG5cdFx0aWYgKCBzY3JvbGxYID09PSBcIlwiIHx8IHNjcm9sbFhJbm5lciAhPT0gXCJcIiApIHtcblx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDEsICdQb3NzaWJsZSBjb2x1bW4gbWlzYWxpZ25tZW50JywgNiApO1xuXHRcdH1cblx0fVxuXHRlbHNlXG5cdHtcblx0XHRjb3JyZWN0aW9uID0gJzEwMCUnO1xuXHR9XG5cblx0Ly8gQXBwbHkgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50c1xuXHRkaXZCb2R5U3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHRkaXZIZWFkZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBjb3JyZWN0aW9uICk7XG5cblx0aWYgKCBmb290ZXIgKSB7XG5cdFx0c2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggY29ycmVjdGlvbiApO1xuXHR9XG5cblxuXHQvKlxuXHQgKiA0LiBDbGVhbiB1cFxuXHQgKi9cblx0aWYgKCAhIHNjcm9sbFkgKSB7XG5cdFx0LyogSUU3PCBwdXRzIGEgdmVydGljYWwgc2Nyb2xsYmFyIGluIHBsYWNlICh3aGVuIGl0IHNob3VsZG4ndCBiZSkgZHVlIHRvIHN1YnRyYWN0aW5nXG5cdFx0ICogdGhlIHNjcm9sbGJhciBoZWlnaHQgZnJvbSB0aGUgdmlzaWJsZSBkaXNwbGF5LCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgb24uIFdlIG5lZWQgdG9cblx0XHQgKiBzZXQgdGhlIGhlaWdodCBpbiBvcmRlciB0byBzb3J0IHRoaXMuIERvbid0IHdhbnQgdG8gZG8gaXQgaW4gYW55IG90aGVyIGJyb3dzZXJzLlxuXHRcdCAqL1xuXHRcdGlmICggaWU2NyApIHtcblx0XHRcdGRpdkJvZHlTdHlsZS5oZWlnaHQgPSBfZm5TdHJpbmdUb0NzcyggdGFibGVFbC5vZmZzZXRIZWlnaHQrYmFyV2lkdGggKTtcblx0XHR9XG5cdH1cblxuXHQvKiBGaW5hbGx5IHNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzICovXG5cdHZhciBpT3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblx0ZGl2SGVhZGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggaU91dGVyV2lkdGggKTtcblx0ZGl2SGVhZGVySW5uZXJTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXG5cdC8vIEZpZ3VyZSBvdXQgaWYgdGhlcmUgYXJlIHNjcm9sbGJhciBwcmVzZW50IC0gaWYgc28gdGhlbiB3ZSBuZWVkIGEgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRvXG5cdC8vIHByb3ZpZGUgYSBiaXQgbW9yZSBzcGFjZSB0byBhbGxvdyBcIm92ZXJmbG93XCIgc2Nyb2xsaW5nIChpLmUuIHBhc3QgdGhlIHNjcm9sbGJhcilcblx0dmFyIGJTY3JvbGxpbmcgPSB0YWJsZS5oZWlnaHQoKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHR2YXIgcGFkZGluZyA9ICdwYWRkaW5nJyArIChicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID8gJ0xlZnQnIDogJ1JpZ2h0JyApO1xuXHRkaXZIZWFkZXJJbm5lclN0eWxlWyBwYWRkaW5nIF0gPSBiU2Nyb2xsaW5nID8gYmFyV2lkdGgrXCJweFwiIDogXCIwcHhcIjtcblxuXHRpZiAoIGZvb3RlciApIHtcblx0XHRkaXZGb290ZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBpT3V0ZXJXaWR0aCApO1xuXHRcdGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGlPdXRlcldpZHRoICk7XG5cdFx0ZGl2Rm9vdGVySW5uZXJbMF0uc3R5bGVbcGFkZGluZ10gPSBiU2Nyb2xsaW5nID8gYmFyV2lkdGgrXCJweFwiIDogXCIwcHhcIjtcblx0fVxuXG5cdC8vIENvcnJlY3QgRE9NIG9yZGVyaW5nIGZvciBjb2xncm91cCAtIGNvbWVzIGJlZm9yZSB0aGUgdGhlYWRcblx0dGFibGUuY2hpbGRyZW4oJ2NvbGdyb3VwJykuaW5zZXJ0QmVmb3JlKCB0YWJsZS5jaGlsZHJlbigndGhlYWQnKSApO1xuXG5cdC8qIEFkanVzdCB0aGUgcG9zaXRpb24gb2YgdGhlIGhlYWRlciBpbiBjYXNlIHdlIGxvb3NlIHRoZSB5LXNjcm9sbGJhciAqL1xuXHRkaXZCb2R5LnRyaWdnZXIoJ3Njcm9sbCcpO1xuXG5cdC8vIElmIHNvcnRpbmcgb3IgZmlsdGVyaW5nIGhhcyBvY2N1cnJlZCwganVtcCB0aGUgc2Nyb2xsaW5nIGJhY2sgdG8gdGhlIHRvcFxuXHQvLyBvbmx5IGlmIHdlIGFyZW4ndCBob2xkaW5nIHRoZSBwb3NpdGlvblxuXHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0ZGl2Qm9keUVsLnNjcm9sbFRvcCA9IDA7XG5cdH1cbn1cblxuXG5cbi8qKlxuICogQXBwbHkgYSBnaXZlbiBmdW5jdGlvbiB0byB0aGUgZGlzcGxheSBjaGlsZCBub2RlcyBvZiBhbiBlbGVtZW50IGFycmF5ICh0eXBpY2FsbHlcbiAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3NcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBNZXRob2QgdG8gYXBwbHkgdG8gdGhlIG9iamVjdHNcbiAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjEgTGlzdCBvZiBlbGVtZW50cyB0byBsb29rIHRocm91Z2ggZm9yIGRpc3BsYXkgY2hpbGRyZW5cbiAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oIGZuLCBhbjEsIGFuMiApXG57XG5cdHZhciBpbmRleD0wLCBpPTAsIGlMZW49YW4xLmxlbmd0aDtcblx0dmFyIG5Ob2RlMSwgbk5vZGUyO1xuXG5cdHdoaWxlICggaSA8IGlMZW4gKSB7XG5cdFx0bk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XG5cdFx0bk5vZGUyID0gYW4yID8gYW4yW2ldLmZpcnN0Q2hpbGQgOiBudWxsO1xuXG5cdFx0d2hpbGUgKCBuTm9kZTEgKSB7XG5cdFx0XHRpZiAoIG5Ob2RlMS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0aWYgKCBhbjIgKSB7XG5cdFx0XHRcdFx0Zm4oIG5Ob2RlMSwgbk5vZGUyLCBpbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGZuKCBuTm9kZTEsIGluZGV4ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XG5cdFx0XHRuTm9kZTIgPSBhbjIgPyBuTm9kZTIubmV4dFNpYmxpbmcgOiBudWxsO1xuXHRcdH1cblxuXHRcdGkrKztcblx0fVxufVxuXG5cblxudmFyIF9fcmVfaHRtbF9yZW1vdmUgPSAvPC4qPz4vZztcblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgY29sdW1ucyBmb3IgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBvU2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHR0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG5cdFx0Y29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0c2Nyb2xsID0gb1NldHRpbmdzLm9TY3JvbGwsXG5cdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRzY3JvbGxYID0gc2Nyb2xsLnNYLFxuXHRcdHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxuXHRcdGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG5cdFx0dmlzaWJsZUNvbHVtbnMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKSxcblx0XHRoZWFkZXJDZWxscyA9ICQoJ3RoJywgb1NldHRpbmdzLm5USGVhZCksXG5cdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHR0YWJsZUNvbnRhaW5lciA9IHRhYmxlLnBhcmVudE5vZGUsXG5cdFx0dXNlcklucHV0cyA9IGZhbHNlLFxuXHRcdGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aCxcblx0XHRicm93c2VyID0gb1NldHRpbmdzLm9Ccm93c2VyLFxuXHRcdGllNjcgPSBicm93c2VyLmJTY3JvbGxPdmVyc2l6ZTtcblxuXHR2YXIgc3R5bGVXaWR0aCA9IHRhYmxlLnN0eWxlLndpZHRoO1xuXHRpZiAoIHN0eWxlV2lkdGggJiYgc3R5bGVXaWR0aC5pbmRleE9mKCclJykgIT09IC0xICkge1xuXHRcdHRhYmxlV2lkdGhBdHRyID0gc3R5bGVXaWR0aDtcblx0fVxuXG5cdC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuXHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXG5cdFx0aWYgKCBjb2x1bW4uc1dpZHRoICE9PSBudWxsICkge1xuXHRcdFx0Y29sdW1uLnNXaWR0aCA9IF9mbkNvbnZlcnRUb1dpZHRoKCBjb2x1bW4uc1dpZHRoT3JpZywgdGFibGVDb250YWluZXIgKTtcblxuXHRcdFx0dXNlcklucHV0cyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0LyogSWYgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBET00gZXF1YWxzIHRoZSBudW1iZXIgdGhhdCB3ZSBoYXZlIHRvXG5cdCAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcblx0ICogdGhlIHdlYi0gYnJvd3Nlci4gTm8gY3VzdG9tIHNpemVzIGNhbiBiZSBzZXQgaW4gb3JkZXIgZm9yIHRoaXMgdG8gaGFwcGVuLFxuXHQgKiBub3Igc2Nyb2xsaW5nIHVzZWRcblx0ICovXG5cdGlmICggaWU2NyB8fCAhIHVzZXJJbnB1dHMgJiYgISBzY3JvbGxYICYmICEgc2Nyb2xsWSAmJlxuXHQgICAgIGNvbHVtbkNvdW50ID09IF9mblZpc2JsZUNvbHVtbnMoIG9TZXR0aW5ncyApICYmXG5cdCAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG5cdCkge1xuXHRcdGZvciAoIGk9MCA7IGk8Y29sdW1uQ291bnQgOyBpKysgKSB7XG5cdFx0XHR2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIG9TZXR0aW5ncywgaSApO1xuXG5cdFx0XHRpZiAoIGNvbElkeCAhPT0gbnVsbCApIHtcblx0XHRcdFx0Y29sdW1uc1sgY29sSWR4IF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGhlYWRlckNlbGxzLmVxKGkpLndpZHRoKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Ly8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxuXHRcdC8vIG5vZGUgaW4gdGhlIGRhdGEsIGFzc2lnbiBhbnkgdXNlciBkZWZpbmVkIHdpZHRocywgdGhlbiBpbnNlcnQgaXQgaW50b1xuXHRcdC8vIHRoZSBET00gYW5kIGFsbG93IHRoZSBicm93c2VyIHRvIGRvIGFsbCB0aGUgaGFyZCB3b3JrIG9mIGNhbGN1bGF0aW5nXG5cdFx0Ly8gdGFibGUgd2lkdGhzXG5cdFx0dmFyIHRtcFRhYmxlID0gJCh0YWJsZSkuY2xvbmUoKSAvLyBkb24ndCB1c2UgY2xvbmVOb2RlIC0gSUU4IHdpbGwgcmVtb3ZlIGV2ZW50cyBvbiB0aGUgbWFpbiB0YWJsZVxuXHRcdFx0LmNzcyggJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyApXG5cdFx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIHRhYmxlIGJvZHlcblx0XHR0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLnJlbW92ZSgpO1xuXHRcdHZhciB0ciA9ICQoJzx0ci8+JykuYXBwZW5kVG8oIHRtcFRhYmxlLmZpbmQoJ3Rib2R5JykgKTtcblxuXHRcdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0Ly8gZnJvbSB0aGUgY2xvbmVkIHRhYmxlLCBzaW5jZSBpZiBzY3JvbGxpbmcgaXMgYWN0aXZlLCB0aGUgdGFibGUnc1xuXHRcdC8vIHJlYWwgaGVhZGVyIGFuZCBmb290ZXIgYXJlIGNvbnRhaW5lZCBpbiBkaWZmZXJlbnQgdGFibGUgdGFnc1xuXHRcdHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXHRcdHRtcFRhYmxlXG5cdFx0XHQuYXBwZW5kKCAkKG9TZXR0aW5ncy5uVEhlYWQpLmNsb25lKCkgKVxuXHRcdFx0LmFwcGVuZCggJChvU2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cblx0XHQvLyBSZW1vdmUgYW55IGFzc2lnbmVkIHdpZHRocyBmcm9tIHRoZSBmb290ZXIgKGZyb20gc2Nyb2xsaW5nKVxuXHRcdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cblx0XHQvLyBBcHBseSBjdXN0b20gc2l6aW5nIHRvIHRoZSBjbG9uZWQgaGVhZGVyXG5cdFx0aGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMoIG9TZXR0aW5ncywgdG1wVGFibGUuZmluZCgndGhlYWQnKVswXSApO1xuXG5cdFx0Zm9yICggaT0wIDsgaTx2aXNpYmxlQ29sdW1ucy5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRjb2x1bW4gPSBjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdO1xuXG5cdFx0XHRoZWFkZXJDZWxsc1tpXS5zdHlsZS53aWR0aCA9IGNvbHVtbi5zV2lkdGhPcmlnICE9PSBudWxsICYmIGNvbHVtbi5zV2lkdGhPcmlnICE9PSAnJyA/XG5cdFx0XHRcdF9mblN0cmluZ1RvQ3NzKCBjb2x1bW4uc1dpZHRoT3JpZyApIDpcblx0XHRcdFx0Jyc7XG5cblx0XHRcdC8vIEZvciBzY3JvbGxYIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGNvbHVtbiB3aWR0aCBvdGhlcndpc2UgdGhlXG5cdFx0XHQvLyBicm93c2VyIHdpbGwgY29sbGFwc2UgaXQuIElmIHRoaXMgd2lkdGggaXMgc21hbGxlciB0aGFuIHRoZVxuXHRcdFx0Ly8gd2lkdGggdGhlIGNvbHVtbiByZXF1aXJlcywgdGhlbiBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0XG5cdFx0XHRpZiAoIGNvbHVtbi5zV2lkdGhPcmlnICYmIHNjcm9sbFggKSB7XG5cdFx0XHRcdCQoIGhlYWRlckNlbGxzW2ldICkuYXBwZW5kKCAkKCc8ZGl2Lz4nKS5jc3MoIHtcblx0XHRcdFx0XHR3aWR0aDogY29sdW1uLnNXaWR0aE9yaWcsXG5cdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdHBhZGRpbmc6IDAsXG5cdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHR9ICkgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaW5kIHRoZSB3aWRlc3QgY2VsbCBmb3IgZWFjaCBjb2x1bW4gYW5kIHB1dCBpdCBpbnRvIHRoZSB0YWJsZVxuXHRcdGlmICggb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0Y29sdW1uSWR4ID0gdmlzaWJsZUNvbHVtbnNbaV07XG5cdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXG5cdFx0XHRcdCQoIF9mbkdldFdpZGVzdE5vZGUoIG9TZXR0aW5ncywgY29sdW1uSWR4ICkgKVxuXHRcdFx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0XHRcdC5hcHBlbmQoIGNvbHVtbi5zQ29udGVudFBhZGRpbmcgKVxuXHRcdFx0XHRcdC5hcHBlbmRUbyggdHIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHRcdC8vIGR1cGxpY2F0ZWQgaW4gdGhlIGRvbSAocmFkaW8gZWxlbWVudHMgZm9yIGV4YW1wbGUpXG5cdFx0JCgnW25hbWVdJywgdG1wVGFibGUpLnJlbW92ZUF0dHIoJ25hbWUnKTtcblxuXHRcdC8vIFRhYmxlIGhhcyBiZWVuIGJ1aWx0LCBhdHRhY2ggdG8gdGhlIGRvY3VtZW50IHNvIHdlIGNhbiB3b3JrIHdpdGggaXQuXG5cdFx0Ly8gQSBob2xkaW5nIGVsZW1lbnQgaXMgdXNlZCwgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mIHRoZSBjb250YWluZXJcblx0XHQvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuXHRcdC8vIG9yIG5vdC4gT3RoZXJ3aXNlIGl0IG1pZ2h0IHRyaWdnZXIgc2Nyb2xsaW5nIHdoZW4gaXQgYWN0dWFsbHkgaXNuJ3Rcblx0XHQvLyBuZWVkZWRcblx0XHR2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKCBzY3JvbGxYIHx8IHNjcm9sbFkgP1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0e31cblx0XHRcdClcblx0XHRcdC5hcHBlbmQoIHRtcFRhYmxlIClcblx0XHRcdC5hcHBlbmRUbyggdGFibGVDb250YWluZXIgKTtcblxuXHRcdC8vIFdoZW4gc2Nyb2xsaW5nIChYIG9yIFkpIHdlIHdhbnQgdG8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgYXMgXG5cdFx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0XHQvLyBpcy4gVGhpcyByZXN1bHRzIGluIHNsaWdodGx5IGRpZmZlcmVudCwgYnV0IEkgdGhpbmsgY29ycmVjdCBiZWhhdmlvdXJcblx0XHRpZiAoIHNjcm9sbFggJiYgc2Nyb2xsWElubmVyICkge1xuXHRcdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2Nyb2xsWCApIHtcblx0XHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0XHR0bXBUYWJsZS5yZW1vdmVBdHRyKCd3aWR0aCcpO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0XHQvLyBjb2xsYXBzZVxuXHRcdFx0aWYgKCB0bXBUYWJsZS53aWR0aCgpIDwgdGFibGVDb250YWluZXIuY2xpZW50V2lkdGggJiYgdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHRcdHRtcFRhYmxlLndpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0bXBUYWJsZS53aWR0aCggdGFibGVXaWR0aEF0dHIgKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggY29sdW1uIGluIHRoZSBjb25zdHJ1Y3RlZCB0YWJsZSAtIHdlIG5lZWQgdG9cblx0XHQvLyBrbm93IHRoZSBpbm5lciB3aWR0aCAoc28gaXQgY2FuIGJlIGFzc2lnbmVkIHRvIHRoZSBvdGhlciB0YWJsZSdzXG5cdFx0Ly8gY2VsbHMpIGFuZCB0aGUgb3V0ZXIgd2lkdGggc28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgZnVsbCB3aWR0aCBvZiB0aGVcblx0XHQvLyB0YWJsZS4gVGhpcyBpcyBzYWZlIHNpbmNlIERhdGFUYWJsZXMgcmVxdWlyZXMgYSB1bmlxdWUgY2VsbCBmb3IgZWFjaFxuXHRcdC8vIGNvbHVtbiwgYnV0IGlmIGV2ZXIgYSBoZWFkZXIgY2FuIHNwYW4gbXVsdGlwbGUgY29sdW1ucywgdGhpcyB3aWxsXG5cdFx0Ly8gbmVlZCB0byBiZSBtb2RpZmllZC5cblx0XHR2YXIgdG90YWwgPSAwO1xuXHRcdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0dmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcblx0XHRcdHZhciBib3JkZXIgPSBjZWxsLm91dGVyV2lkdGgoKSAtIGNlbGwud2lkdGgoKTtcblxuXHRcdFx0Ly8gVXNlIGdldEJvdW5kaW5nLi4uIHdoZXJlIHBvc3NpYmxlIChub3QgSUU4LSkgYmVjYXVzZSBpdCBjYW4gZ2l2ZVxuXHRcdFx0Ly8gc3ViLXBpeGVsIGFjY3VyYWN5LCB3aGljaCB3ZSB0aGVuIHdhbnQgdG8gcm91bmQgdXAhXG5cdFx0XHR2YXIgYm91bmRpbmcgPSBicm93c2VyLmJCb3VuZGluZyA/XG5cdFx0XHRcdE1hdGguY2VpbCggaGVhZGVyQ2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA6XG5cdFx0XHRcdGNlbGwub3V0ZXJXaWR0aCgpO1xuXG5cdFx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdFx0Ly8gb2YgdGhlIHRhYmxlIG1pZ2h0IG5vdCBlcXVhbCB0aGUgdG90YWwgZ2l2ZW4gaGVyZSAoSUUhKS5cblx0XHRcdHRvdGFsICs9IGJvdW5kaW5nO1xuXG5cdFx0XHQvLyBXaWR0aCBmb3IgZWFjaCBjb2x1bW4gdG8gdXNlXG5cdFx0XHRjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdLnNXaWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBib3VuZGluZyAtIGJvcmRlciApO1xuXHRcdH1cblxuXHRcdHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRvdGFsICk7XG5cblx0XHQvLyBGaW5pc2hlZCB3aXRoIHRoZSB0YWJsZSAtIGRpdGNoIGl0XG5cdFx0aG9sZGVyLnJlbW92ZSgpO1xuXHR9XG5cblx0Ly8gSWYgdGhlcmUgaXMgYSB3aWR0aCBhdHRyLCB3ZSB3YW50IHRvIGF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB3aGljaFxuXHQvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcblx0Ly8gcmVzaXplZC4gVXNlIHRoZSB3aWR0aCBhdHRyIHJhdGhlciB0aGFuIENTUywgc2luY2Ugd2UgY2FuJ3Qga25vdyBpZiB0aGVcblx0Ly8gQ1NTIGlzIGEgcmVsYXRpdmUgdmFsdWUgb3IgYWJzb2x1dGUgLSBET00gcmVhZCBpcyBhbHdheXMgcHguXG5cdGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0dGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggdGFibGVXaWR0aEF0dHIgKTtcblx0fVxuXG5cdGlmICggKHRhYmxlV2lkdGhBdHRyIHx8IHNjcm9sbFgpICYmICEgb1NldHRpbmdzLl9yZXN6RXZ0ICkge1xuXHRcdHZhciBiaW5kUmVzaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytvU2V0dGluZ3Muc0luc3RhbmNlLCBfZm5UaHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIG9TZXR0aW5ncyApO1xuXHRcdFx0fSApICk7XG5cdFx0fTtcblxuXHRcdC8vIElFNi83IHdpbGwgY3Jhc2ggaWYgd2UgYmluZCBhIHJlc2l6ZSBldmVudCBoYW5kbGVyIG9uIHBhZ2UgbG9hZC5cblx0XHQvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuXHRcdGlmICggaWU2NyApIHtcblx0XHRcdHNldFRpbWVvdXQoIGJpbmRSZXNpemUsIDEwMDAgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRiaW5kUmVzaXplKCk7XG5cdFx0fVxuXG5cdFx0b1NldHRpbmdzLl9yZXN6RXZ0ID0gdHJ1ZTtcblx0fVxufVxuXG5cbi8qKlxuICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZCBmb3JcbiAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAqICBAcGFyYW0ge2ludH0gW2ZyZXE9MjAwXSBjYWxsIGZyZXF1ZW5jeSBpbiBtU1xuICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG52YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBDU1MgdW5pdCB3aWR0aCB0byBwaXhlbHMgKGUuZy4gMmVtKVxuICogIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCB3aWR0aCB0byBiZSBjb252ZXJ0ZWRcbiAqICBAcGFyYW0ge25vZGV9IHBhcmVudCBwYXJlbnQgdG8gZ2V0IHRoZSB3aXRoIGZvciAocmVxdWlyZWQgZm9yIHJlbGF0aXZlIHdpZHRocykgLSBvcHRpb25hbFxuICogIEByZXR1cm5zIHtpbnR9IHdpZHRoIGluIHBpeGVsc1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Db252ZXJ0VG9XaWR0aCAoIHdpZHRoLCBwYXJlbnQgKVxue1xuXHRpZiAoICEgd2lkdGggKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHR2YXIgbiA9ICQoJzxkaXYvPicpXG5cdFx0LmNzcyggJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIHdpZHRoICkgKVxuXHRcdC5hcHBlbmRUbyggcGFyZW50IHx8IGRvY3VtZW50LmJvZHkgKTtcblxuXHR2YXIgdmFsID0gblswXS5vZmZzZXRXaWR0aDtcblx0bi5yZW1vdmUoKTtcblxuXHRyZXR1cm4gdmFsO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB3aWRlc3Qgbm9kZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG4gKiAgQHJldHVybnMge25vZGV9IHdpZGVzdCB0YWJsZSBub2RlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldFdpZGVzdE5vZGUoIHNldHRpbmdzLCBjb2xJZHggKVxue1xuXHR2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4ICk7XG5cdGlmICggaWR4IDwgMCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhWyBpZHggXTtcblx0cmV0dXJuICEgZGF0YS5uVHIgPyAvLyBNaWdodCBub3QgaGF2ZSBiZWVuIGNyZWF0ZWQgd2hlbiBkZWZlcnJlZCByZW5kZXJpbmdcblx0XHQkKCc8dGQvPicpLmh0bWwoIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaWR4LCBjb2xJZHgsICdkaXNwbGF5JyApIClbMF0gOlxuXHRcdGRhdGEuYW5DZWxsc1sgY29sSWR4IF07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gc3RybGVuIGZvciBlYWNoIGRhdGEgY29sdW1uXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3RcbiAqICBAcmV0dXJucyB7c3RyaW5nfSBtYXggc3RyaW5nIGxlbmd0aCBmb3IgZWFjaCBjb2x1bW5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4IClcbntcblx0dmFyIHMsIG1heD0tMSwgbWF4SWR4ID0gLTE7XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRzID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JyApKycnO1xuXHRcdHMgPSBzLnJlcGxhY2UoIF9fcmVfaHRtbF9yZW1vdmUsICcnICk7XG5cdFx0cyA9IHMucmVwbGFjZSggLyZuYnNwOy9nLCAnICcgKTtcblxuXHRcdGlmICggcy5sZW5ndGggPiBtYXggKSB7XG5cdFx0XHRtYXggPSBzLmxlbmd0aDtcblx0XHRcdG1heElkeCA9IGk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1heElkeDtcbn1cblxuXG4vKipcbiAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuICogIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0byBjc3MtaWZ5XG4gKiAgQHJldHVybnMge3N0cmluZ30gdmFsdWUgd2l0aCBjc3MgdW5pdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TdHJpbmdUb0NzcyggcyApXG57XG5cdGlmICggcyA9PT0gbnVsbCApIHtcblx0XHRyZXR1cm4gJzBweCc7XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBzID09ICdudW1iZXInICkge1xuXHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHQnMHB4JyA6XG5cdFx0XHRzKydweCc7XG5cdH1cblxuXHQvLyBDaGVjayBpdCBoYXMgYSB1bml0IGNoYXJhY3RlciBhbHJlYWR5XG5cdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdHMrJ3B4JyA6XG5cdFx0cztcbn1cblxuXG5cbmZ1bmN0aW9uIF9mblNvcnRGbGF0dGVuICggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRpLCBpTGVuLCBrLCBrTGVuLFxuXHRcdGFTb3J0ID0gW10sXG5cdFx0YWlPcmlnID0gW10sXG5cdFx0YW9Db2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdGFEYXRhU29ydCwgaUNvbCwgc1R5cGUsIHNyY0NvbCxcblx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdGZpeGVkT2JqID0gJC5pc1BsYWluT2JqZWN0KCBmaXhlZCApLFxuXHRcdG5lc3RlZFNvcnQgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRpZiAoIGEubGVuZ3RoICYmICEgQXJyYXkuaXNBcnJheSggYVswXSApICkge1xuXHRcdFx0XHQvLyAxRCBhcnJheVxuXHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2goIGEgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyAyRCBhcnJheVxuXHRcdFx0XHQkLm1lcmdlKCBuZXN0ZWRTb3J0LCBhICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHQvLyBCdWlsZCB0aGUgc29ydCBhcnJheSwgd2l0aCBwcmUtZml4IGFuZCBwb3N0LWZpeCBvcHRpb25zIGlmIHRoZXkgaGF2ZSBiZWVuXG5cdC8vIHNwZWNpZmllZFxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGZpeGVkICkgKSB7XG5cdFx0YWRkKCBmaXhlZCApO1xuXHR9XG5cblx0aWYgKCBmaXhlZE9iaiAmJiBmaXhlZC5wcmUgKSB7XG5cdFx0YWRkKCBmaXhlZC5wcmUgKTtcblx0fVxuXG5cdGFkZCggc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cblx0aWYgKGZpeGVkT2JqICYmIGZpeGVkLnBvc3QgKSB7XG5cdFx0YWRkKCBmaXhlZC5wb3N0ICk7XG5cdH1cblxuXHRmb3IgKCBpPTAgOyBpPG5lc3RlZFNvcnQubGVuZ3RoIDsgaSsrIClcblx0e1xuXHRcdHNyY0NvbCA9IG5lc3RlZFNvcnRbaV1bMF07XG5cdFx0YURhdGFTb3J0ID0gYW9Db2x1bW5zWyBzcmNDb2wgXS5hRGF0YVNvcnQ7XG5cblx0XHRmb3IgKCBrPTAsIGtMZW49YURhdGFTb3J0Lmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0e1xuXHRcdFx0aUNvbCA9IGFEYXRhU29ydFtrXTtcblx0XHRcdHNUeXBlID0gYW9Db2x1bW5zWyBpQ29sIF0uc1R5cGUgfHwgJ3N0cmluZyc7XG5cblx0XHRcdGlmICggbmVzdGVkU29ydFtpXS5faWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG5lc3RlZFNvcnRbaV0uX2lkeCA9ICQuaW5BcnJheSggbmVzdGVkU29ydFtpXVsxXSwgYW9Db2x1bW5zW2lDb2xdLmFzU29ydGluZyApO1xuXHRcdFx0fVxuXG5cdFx0XHRhU29ydC5wdXNoKCB7XG5cdFx0XHRcdHNyYzogICAgICAgc3JjQ29sLFxuXHRcdFx0XHRjb2w6ICAgICAgIGlDb2wsXG5cdFx0XHRcdGRpcjogICAgICAgbmVzdGVkU29ydFtpXVsxXSxcblx0XHRcdFx0aW5kZXg6ICAgICBuZXN0ZWRTb3J0W2ldLl9pZHgsXG5cdFx0XHRcdHR5cGU6ICAgICAgc1R5cGUsXG5cdFx0XHRcdGZvcm1hdHRlcjogRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyWyBzVHlwZStcIi1wcmVcIiBdXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGFTb3J0O1xufVxuXG4vKipcbiAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICogIEB0b2RvIFRoaXMgcmVhbGx5IG5lZWRzIHNwbGl0IHVwIVxuICovXG5mdW5jdGlvbiBfZm5Tb3J0ICggb1NldHRpbmdzIClcbntcblx0dmFyXG5cdFx0aSwgaWVuLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLFxuXHRcdHNEYXRhVHlwZSwgblRoLFxuXHRcdGFpT3JpZyA9IFtdLFxuXHRcdG9FeHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxuXHRcdGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGEsXG5cdFx0YW9Db2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRhRGF0YVNvcnQsIGRhdGEsIGlDb2wsIHNUeXBlLCBvU29ydCxcblx0XHRmb3JtYXR0ZXJzID0gMCxcblx0XHRzb3J0Q29sLFxuXHRcdGRpc3BsYXlNYXN0ZXIgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLFxuXHRcdGFTb3J0O1xuXG5cdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0Ly8gQHRvZG8gQ2FuIHRoaXMgYmUgbW92ZWQgaW50byBhICdkYXRhLXJlYWR5JyBoYW5kbGVyIHdoaWNoIGlzIGNhbGxlZCB3aGVuXG5cdC8vICAgZGF0YSBpcyBnb2luZyB0byBiZSB1c2VkIGluIHRoZSB0YWJsZT9cblx0X2ZuQ29sdW1uVHlwZXMoIG9TZXR0aW5ncyApO1xuXG5cdGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oIG9TZXR0aW5ncyApO1xuXG5cdGZvciAoIGk9MCwgaWVuPWFTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHNvcnRDb2wgPSBhU29ydFtpXTtcblxuXHRcdC8vIFRyYWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZhc3Qgc29ydCBhbGdvcml0aG1cblx0XHRpZiAoIHNvcnRDb2wuZm9ybWF0dGVyICkge1xuXHRcdFx0Zm9ybWF0dGVycysrO1xuXHRcdH1cblxuXHRcdC8vIExvYWQgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgc29ydCwgZm9yIGVhY2ggY2VsbFxuXHRcdF9mblNvcnREYXRhKCBvU2V0dGluZ3MsIHNvcnRDb2wuY29sICk7XG5cdH1cblxuXHQvKiBObyBzb3J0aW5nIHJlcXVpcmVkIGlmIHNlcnZlci1zaWRlIG9yIG5vIHNvcnRpbmcgYXJyYXkgKi9cblx0aWYgKCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDAgKVxuXHR7XG5cdFx0Ly8gQ3JlYXRlIGEgdmFsdWUgLSBrZXkgYXJyYXkgb2YgdGhlIGN1cnJlbnQgcm93IHBvc2l0aW9ucyBzdWNoIHRoYXQgd2UgY2FuIHVzZSB0aGVpclxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gZHVyaW5nIHRoZSBzb3J0LCBpZiB2YWx1ZXMgbWF0Y2gsIGluIG9yZGVyIHRvIHBlcmZvcm0gc3RhYmxlIHNvcnRpbmdcblx0XHRmb3IgKCBpPTAsIGlMZW49ZGlzcGxheU1hc3Rlci5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRhaU9yaWdbIGRpc3BsYXlNYXN0ZXJbaV0gXSA9IGk7XG5cdFx0fVxuXG5cdFx0LyogRG8gdGhlIHNvcnQgLSBoZXJlIHdlIHdhbnQgbXVsdGktY29sdW1uIHNvcnRpbmcgYmFzZWQgb24gYSBnaXZlbiBkYXRhIHNvdXJjZSAoY29sdW1uKVxuXHRcdCAqIGFuZCBzb3J0aW5nIGZ1bmN0aW9uIChmcm9tIG9Tb3J0KSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBJdCdzIHJlYXNvbmFibHkgY29tcGxleCB0b1xuXHRcdCAqIGZvbGxvdyBvbiBpdCdzIG93biwgYnV0IHRoaXMgaXMgd2hhdCB3ZSB3YW50IChleGFtcGxlIHR3byBjb2x1bW4gc29ydGluZyk6XG5cdFx0ICogIGZuTG9jYWxTb3J0aW5nID0gZnVuY3Rpb24oYSxiKXtcblx0XHQgKiAgICB2YXIgaVRlc3Q7XG5cdFx0ICogICAgaVRlc3QgPSBvU29ydFsnc3RyaW5nLWFzYyddKCdkYXRhMTEnLCAnZGF0YTEyJyk7XG5cdFx0ICogICAgICBpZiAoaVRlc3QgIT09IDApXG5cdFx0ICogICAgICAgIHJldHVybiBpVGVzdDtcblx0XHQgKiAgICBpVGVzdCA9IG9Tb3J0WydudW1lcmljLWRlc2MnXSgnZGF0YTIxJywgJ2RhdGEyMicpO1xuXHRcdCAqICAgIGlmIChpVGVzdCAhPT0gMClcblx0XHQgKiAgICAgIHJldHVybiBpVGVzdDtcblx0XHQgKiAgICByZXR1cm4gb1NvcnRbJ251bWVyaWMtYXNjJ10oIGFpT3JpZ1thXSwgYWlPcmlnW2JdICk7XG5cdFx0ICogIH1cblx0XHQgKiBCYXNpY2FsbHkgd2UgaGF2ZSBhIHRlc3QgZm9yIGVhY2ggc29ydGluZyBjb2x1bW4sIGlmIHRoZSBkYXRhIGluIHRoYXQgY29sdW1uIGlzIGVxdWFsLFxuXHRcdCAqIHRlc3QgdGhlIG5leHQgY29sdW1uLiBJZiBhbGwgY29sdW1ucyBtYXRjaCwgdGhlbiB3ZSB1c2UgYSBudW1lcmljIHNvcnQgb24gdGhlIHJvd1xuXHRcdCAqIHBvc2l0aW9ucyBpbiB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheSB0byBwcm92aWRlIGEgc3RhYmxlIHNvcnQuXG5cdFx0ICpcblx0XHQgKiBOb3RlIC0gSSBrbm93IGl0IHNlZW1zIGV4Y2Vzc2l2ZSB0byBoYXZlIHR3byBzb3J0aW5nIG1ldGhvZHMsIGJ1dCB0aGUgZmlyc3QgaXMgYXJvdW5kXG5cdFx0ICogMTUlIGZhc3Rlciwgc28gdGhlIHNlY29uZCBpcyBvbmx5IG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggc29ydGluZ1xuXHRcdCAqIG1ldGhvZHMgd2hpY2ggZG8gbm90IGhhdmUgYSBwcmUtc29ydCBmb3JtYXR0aW5nIGZ1bmN0aW9uLlxuXHRcdCAqL1xuXHRcdGlmICggZm9ybWF0dGVycyA9PT0gYVNvcnQubGVuZ3RoICkge1xuXHRcdFx0Ly8gQWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uc1xuXHRcdFx0ZGlzcGxheU1hc3Rlci5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRcdHgsIHksIGssIHRlc3QsIHNvcnQsXG5cdFx0XHRcdFx0bGVuPWFTb3J0Lmxlbmd0aCxcblx0XHRcdFx0XHRkYXRhQSA9IGFvRGF0YVthXS5fYVNvcnREYXRhLFxuXHRcdFx0XHRcdGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cblx0XHRcdFx0Zm9yICggaz0wIDsgazxsZW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXG5cdFx0XHRcdFx0eCA9IGRhdGFBWyBzb3J0LmNvbCBdO1xuXHRcdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblxuXHRcdFx0XHRcdHRlc3QgPSB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXHRcdFx0XHRcdGlmICggdGVzdCAhPT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBzb3J0LmRpciA9PT0gJ2FzYycgPyB0ZXN0IDogLXRlc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eCA9IGFpT3JpZ1thXTtcblx0XHRcdFx0eSA9IGFpT3JpZ1tiXTtcblx0XHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gRGVwcmVjaWF0ZWQgLSByZW1vdmUgaW4gMS4xMSAocHJvdmlkaW5nIGEgcGx1Zy1pbiBvcHRpb24pXG5cdFx0XHQvLyBOb3QgYWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIG1ldGhvZHMsIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGVpciBzb3J0aW5nXG5cdFx0XHQvLyBtZXRob2RzLlxuXHRcdFx0ZGlzcGxheU1hc3Rlci5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0XHRcdHZhclxuXHRcdFx0XHRcdHgsIHksIGssIGwsIHRlc3QsIHNvcnQsIGZuLFxuXHRcdFx0XHRcdGxlbj1hU29ydC5sZW5ndGgsXG5cdFx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0XHRkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXG5cdFx0XHRcdGZvciAoIGs9MCA7IGs8bGVuIDsgaysrICkge1xuXHRcdFx0XHRcdHNvcnQgPSBhU29ydFtrXTtcblxuXHRcdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0XHR5ID0gZGF0YUJbIHNvcnQuY29sIF07XG5cblx0XHRcdFx0XHRmbiA9IG9FeHRTb3J0WyBzb3J0LnR5cGUrXCItXCIrc29ydC5kaXIgXSB8fCBvRXh0U29ydFsgXCJzdHJpbmctXCIrc29ydC5kaXIgXTtcblx0XHRcdFx0XHR0ZXN0ID0gZm4oIHgsIHkgKTtcblx0XHRcdFx0XHRpZiAoIHRlc3QgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR4ID0gYWlPcmlnW2FdO1xuXHRcdFx0XHR5ID0gYWlPcmlnW2JdO1xuXHRcdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblxuXHQvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgd2UgaGF2ZSBzb3J0ZWQgdGhlIGRhdGEgKi9cblx0b1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIF9mblNvcnRBcmlhICggc2V0dGluZ3MgKVxue1xuXHR2YXIgbGFiZWw7XG5cdHZhciBuZXh0U29ydDtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHR2YXIgb0FyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWE7XG5cblx0Ly8gQVJJQSBhdHRyaWJ1dGVzIC0gbmVlZCB0byBsb29wIGFsbCBjb2x1bW5zLCB0byB1cGRhdGUgYWxsIChyZW1vdmluZyBvbGRcblx0Ly8gYXR0cmlidXRlcyBhcyBuZWVkZWQpXG5cdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHR7XG5cdFx0dmFyIGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0dmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XG5cdFx0dmFyIHNUaXRsZSA9IGNvbC5hcmlhVGl0bGUgfHwgY29sLnNUaXRsZS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApO1xuXHRcdHZhciB0aCA9IGNvbC5uVGg7XG5cblx0XHQvLyBJRTcgaXMgdGhyb3dpbmcgYW4gZXJyb3Igd2hlbiBzZXR0aW5nIHRoZXNlIHByb3BlcnRpZXMgd2l0aCBqUXVlcnknc1xuXHRcdC8vIGF0dHIoKSBhbmQgcmVtb3ZlQXR0cigpIG1ldGhvZHMuLi5cblx0XHR0aC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc29ydCcpO1xuXG5cdFx0LyogSW4gQVJJQSBvbmx5IHRoZSBmaXJzdCBzb3J0aW5nIGNvbHVtbiBjYW4gYmUgbWFya2VkIGFzIHNvcnRpbmcgLSBubyBtdWx0aS1zb3J0IG9wdGlvbiAqL1xuXHRcdGlmICggY29sLmJTb3J0YWJsZSApIHtcblx0XHRcdGlmICggYVNvcnQubGVuZ3RoID4gMCAmJiBhU29ydFswXS5jb2wgPT0gaSApIHtcblx0XHRcdFx0dGguc2V0QXR0cmlidXRlKCdhcmlhLXNvcnQnLCBhU29ydFswXS5kaXI9PVwiYXNjXCIgPyBcImFzY2VuZGluZ1wiIDogXCJkZXNjZW5kaW5nXCIgKTtcblx0XHRcdFx0bmV4dFNvcnQgPSBhc1NvcnRpbmdbIGFTb3J0WzBdLmluZGV4KzEgXSB8fCBhc1NvcnRpbmdbMF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bmV4dFNvcnQgPSBhc1NvcnRpbmdbMF07XG5cdFx0XHR9XG5cblx0XHRcdGxhYmVsID0gc1RpdGxlICsgKCBuZXh0U29ydCA9PT0gXCJhc2NcIiA/XG5cdFx0XHRcdG9BcmlhLnNTb3J0QXNjZW5kaW5nIDpcblx0XHRcdFx0b0FyaWEuc1NvcnREZXNjZW5kaW5nXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGxhYmVsID0gc1RpdGxlO1xuXHRcdH1cblxuXHRcdHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcblx0fVxufVxuXG5cbi8qKlxuICogRnVuY3Rpb24gdG8gcnVuIG9uIHVzZXIgc29ydCByZXF1ZXN0XG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFthcHBlbmQ9ZmFsc2VdIEFwcGVuZCB0aGUgcmVxdWVzdGVkIHNvcnQgdG8gdGhlIGV4aXN0aW5nXG4gKiAgICBzb3J0IGlmIHRydWUgKGkuZS4gbXVsdGktY29sdW1uIHNvcnQpXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Tb3J0TGlzdGVuZXIgKCBzZXR0aW5ncywgY29sSWR4LCBhcHBlbmQsIGNhbGxiYWNrIClcbntcblx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdHZhciBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nO1xuXHR2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcblx0dmFyIG5leHRTb3J0SWR4O1xuXHR2YXIgbmV4dCA9IGZ1bmN0aW9uICggYSwgb3ZlcmZsb3cgKSB7XG5cdFx0dmFyIGlkeCA9IGEuX2lkeDtcblx0XHRpZiAoIGlkeCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWR4ID0gJC5pbkFycmF5KCBhWzFdLCBhc1NvcnRpbmcgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaWR4KzEgPCBhc1NvcnRpbmcubGVuZ3RoID9cblx0XHRcdGlkeCsxIDpcblx0XHRcdG92ZXJmbG93ID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdDA7XG5cdH07XG5cblx0Ly8gQ29udmVydCB0byAyRCBhcnJheSBpZiBuZWVkZWRcblx0aWYgKCB0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicgKSB7XG5cdFx0c29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZyA9IFsgc29ydGluZyBdO1xuXHR9XG5cblx0Ly8gSWYgYXBwZW5kaW5nIHRoZSBzb3J0IHRoZW4gd2UgYXJlIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdGlmICggYXBwZW5kICYmIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydE11bHRpICkge1xuXHRcdC8vIEFyZSB3ZSBhbHJlYWR5IGRvaW5nIHNvbWUga2luZCBvZiBzb3J0IG9uIHRoaXMgY29sdW1uP1xuXHRcdHZhciBzb3J0SWR4ID0gJC5pbkFycmF5KCBjb2xJZHgsIF9wbHVjayhzb3J0aW5nLCAnMCcpICk7XG5cblx0XHRpZiAoIHNvcnRJZHggIT09IC0xICkge1xuXHRcdFx0Ly8gWWVzLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRcdG5leHRTb3J0SWR4ID0gbmV4dCggc29ydGluZ1tzb3J0SWR4XSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICYmIHNvcnRpbmcubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRuZXh0U29ydElkeCA9IDA7IC8vIGNhbid0IHJlbW92ZSBzb3J0aW5nIGNvbXBsZXRlbHlcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCApIHtcblx0XHRcdFx0c29ydGluZy5zcGxpY2UoIHNvcnRJZHgsIDEgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdFx0XHRzb3J0aW5nW3NvcnRJZHhdLl9pZHggPSBuZXh0U29ydElkeDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldFxuXHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdLCAwIF0gKTtcblx0XHRcdHNvcnRpbmdbc29ydGluZy5sZW5ndGgtMV0uX2lkeCA9IDA7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCBzb3J0aW5nLmxlbmd0aCAmJiBzb3J0aW5nWzBdWzBdID09IGNvbElkeCApIHtcblx0XHQvLyBTaW5nbGUgY29sdW1uIC0gYWxyZWFkeSBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbMF0gKTtcblxuXHRcdHNvcnRpbmcubGVuZ3RoID0gMTtcblx0XHRzb3J0aW5nWzBdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdHNvcnRpbmdbMF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBzb3J0IG9ubHkgb24gdGhpcyBjb2x1bW5cblx0XHRzb3J0aW5nLmxlbmd0aCA9IDA7XG5cdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdIF0gKTtcblx0XHRzb3J0aW5nWzBdLl9pZHggPSAwO1xuXHR9XG5cblx0Ly8gUnVuIHRoZSBzb3J0IGJ5IGNhbGxpbmcgYSBmdWxsIHJlZHJhd1xuXHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cblx0Ly8gY2FsbGJhY2sgdXNlZCBmb3IgYXN5bmMgdXNlciBpbnRlcmFjdGlvblxuXHRpZiAoIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICkge1xuXHRcdGNhbGxiYWNrKCBzZXR0aW5ncyApO1xuXHR9XG59XG5cblxuLyoqXG4gKiBBdHRhY2ggYSBzb3J0IGhhbmRsZXIgKGNsaWNrKSB0byBhIG5vZGVcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU29ydEF0dGFjaExpc3RlbmVyICggc2V0dGluZ3MsIGF0dGFjaFRvLCBjb2xJZHgsIGNhbGxiYWNrIClcbntcblx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cblx0X2ZuQmluZEFjdGlvbiggYXR0YWNoVG8sIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdC8qIElmIHRoZSBjb2x1bW4gaXMgbm90IHNvcnRhYmxlIC0gZG9uJ3QgdG8gYW55dGhpbmcgKi9cblx0XHRpZiAoIGNvbC5iU29ydGFibGUgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHByb2Nlc3NpbmcgaXMgZW5hYmxlZCB1c2UgYSB0aW1lb3V0IHRvIGFsbG93IHRoZSBwcm9jZXNzaW5nXG5cdFx0Ly8gZGlzcGxheSB0byBiZSBzaG93biAtIG90aGVyd2lzZSB0byBpdCBzeW5jaHJvbm91c2x5XG5cdFx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF9mblNvcnRMaXN0ZW5lciggc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2sgKTtcblxuXHRcdFx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCB0aGUgZHJhdyBjYWxsYmFjayB3aWxsIHJlbW92ZSB0aGVcblx0XHRcdFx0Ly8gcHJvY2Vzc2luZyBkaXNwbGF5XG5cdFx0XHRcdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSAhPT0gJ3NzcCcgKSB7XG5cdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAwICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuU29ydExpc3RlbmVyKCBzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSApO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuICogd2hlbiBiU29ydCBhbmQgYlNvcnRDbGFzc2VzIGFyZSBmYWxzZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzIClcbntcblx0dmFyIG9sZFNvcnQgPSBzZXR0aW5ncy5hTGFzdFNvcnQ7XG5cdHZhciBzb3J0Q2xhc3MgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5zU29ydENvbHVtbjtcblx0dmFyIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHR2YXIgaSwgaWVuLCBjb2xJZHg7XG5cblx0aWYgKCBmZWF0dXJlcy5iU29ydCAmJiBmZWF0dXJlcy5iU29ydENsYXNzZXMgKSB7XG5cdFx0Ly8gUmVtb3ZlIG9sZCBzb3J0aW5nIGNsYXNzZXNcblx0XHRmb3IgKCBpPTAsIGllbj1vbGRTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sSWR4ID0gb2xkU29ydFtpXS5zcmM7XG5cblx0XHRcdC8vIFJlbW92ZSBjb2x1bW4gc29ydGluZ1xuXHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBuZXcgY29sdW1uIHNvcnRpbmdcblx0XHRmb3IgKCBpPTAsIGllbj1zb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sSWR4ID0gc29ydFtpXS5zcmM7XG5cblx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0LmFkZENsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHR9XG5cdH1cblxuXHRzZXR0aW5ncy5hTGFzdFNvcnQgPSBzb3J0O1xufVxuXG5cbi8vIEdldCB0aGUgZGF0YSB0byBzb3J0IGEgY29sdW1uLCBiZSBpdCBmcm9tIGNhY2hlLCBmcmVzaCAocG9wdWxhdGluZyB0aGVcbi8vIGNhY2hlKSwgb3IgZnJvbSBhIHNvcnQgZm9ybWF0dGVyXG5mdW5jdGlvbiBfZm5Tb3J0RGF0YSggc2V0dGluZ3MsIGlkeCApXG57XG5cdC8vIEN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uIC0gcHJvdmlkZWQgYnkgdGhlIHNvcnQgZGF0YSB0eXBlXG5cdHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGlkeCBdO1xuXHR2YXIgY3VzdG9tU29ydCA9IERhdGFUYWJsZS5leHQub3JkZXJbIGNvbHVtbi5zU29ydERhdGFUeXBlIF07XG5cdHZhciBjdXN0b21EYXRhO1xuXG5cdGlmICggY3VzdG9tU29ydCApIHtcblx0XHRjdXN0b21EYXRhID0gY3VzdG9tU29ydC5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBpZHgsXG5cdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGlkeCApXG5cdFx0KTtcblx0fVxuXG5cdC8vIFVzZSAvIHBvcHVsYXRlIGNhY2hlXG5cdHZhciByb3csIGNlbGxEYXRhO1xuXHR2YXIgZm9ybWF0dGVyID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyWyBjb2x1bW4uc1R5cGUrXCItcHJlXCIgXTtcblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblxuXHRcdGlmICggISByb3cuX2FTb3J0RGF0YSApIHtcblx0XHRcdHJvdy5fYVNvcnREYXRhID0gW107XG5cdFx0fVxuXG5cdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhW2lkeF0gfHwgY3VzdG9tU29ydCApIHtcblx0XHRcdGNlbGxEYXRhID0gY3VzdG9tU29ydCA/XG5cdFx0XHRcdGN1c3RvbURhdGFbaV0gOiAvLyBJZiB0aGVyZSB3YXMgYSBjdXN0b20gc29ydCBmdW5jdGlvbiwgdXNlIGRhdGEgZnJvbSB0aGVyZVxuXHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIGksIGlkeCwgJ3NvcnQnICk7XG5cblx0XHRcdHJvdy5fYVNvcnREYXRhWyBpZHggXSA9IGZvcm1hdHRlciA/XG5cdFx0XHRcdGZvcm1hdHRlciggY2VsbERhdGEgKSA6XG5cdFx0XHRcdGNlbGxEYXRhO1xuXHRcdH1cblx0fVxufVxuXG5cblxuLyoqXG4gKiBTYXZlIHRoZSBzdGF0ZSBvZiBhIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TYXZlU3RhdGUgKCBzZXR0aW5ncyApXG57XG5cdGlmIChzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8qIFN0b3JlIHRoZSBpbnRlcmVzdGluZyB2YXJpYWJsZXMgKi9cblx0dmFyIHN0YXRlID0ge1xuXHRcdHRpbWU6ICAgICtuZXcgRGF0ZSgpLFxuXHRcdHN0YXJ0OiAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbmd0aDogIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRvcmRlcjogICAkLmV4dGVuZCggdHJ1ZSwgW10sIHNldHRpbmdzLmFhU29ydGluZyApLFxuXHRcdHNlYXJjaDogIF9mblNlYXJjaFRvQ2FtZWwoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCApLFxuXHRcdGNvbHVtbnM6ICQubWFwKCBzZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uICggY29sLCBpICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dmlzaWJsZTogY29sLmJWaXNpYmxlLFxuXHRcdFx0XHRzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoIHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSApXG5cdFx0XHR9O1xuXHRcdH0gKVxuXHR9O1xuXG5cdHNldHRpbmdzLm9TYXZlZFN0YXRlID0gc3RhdGU7XG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIiwgJ3N0YXRlU2F2ZVBhcmFtcycsIFtzZXR0aW5ncywgc3RhdGVdICk7XG5cdFxuXHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlICYmICFzZXR0aW5ncy5iRGVzdHJveWluZyApXG5cdHtcblx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlICk7XG5cdH1cdFxufVxuXG5cbi8qKlxuICogQXR0ZW1wdCB0byBsb2FkIGEgc2F2ZWQgdGFibGUgc3RhdGVcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtvYmplY3R9IG9Jbml0IERhdGFUYWJsZXMgaW5pdCBvYmplY3Qgc28gd2UgY2FuIG92ZXJyaWRlIHNldHRpbmdzXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTG9hZFN0YXRlICggc2V0dGluZ3MsIG9Jbml0LCBjYWxsYmFjayApXG57XG5cdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSApIHtcblx0XHRjYWxsYmFjaygpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBsb2FkZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdF9mbkltcGxlbWVudFN0YXRlKHNldHRpbmdzLCBzdGF0ZSwgY2FsbGJhY2spO1xuXHR9XG5cblx0dmFyIHN0YXRlID0gc2V0dGluZ3MuZm5TdGF0ZUxvYWRDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBsb2FkZWQgKTtcblxuXHRpZiAoIHN0YXRlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0X2ZuSW1wbGVtZW50U3RhdGUoIHNldHRpbmdzLCBzdGF0ZSwgY2FsbGJhY2sgKTtcblx0fVxuXHQvLyBvdGhlcndpc2UsIHdhaXQgZm9yIHRoZSBsb2FkZWQgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2ZuSW1wbGVtZW50U3RhdGUgKCBzZXR0aW5ncywgcywgY2FsbGJhY2spIHtcblx0dmFyIGksIGllbjtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gdHJ1ZTtcblxuXHQvLyBXaGVuIFN0YXRlUmVzdG9yZSB3YXMgaW50cm9kdWNlZCB0aGUgc3RhdGUgY291bGQgbm93IGJlIGltcGxlbWVudGVkIGF0IGFueSB0aW1lXG5cdC8vIE5vdCBqdXN0IGluaXRpYWxpc2F0aW9uLiBUbyBkbyB0aGlzIGFuIGFwaSBpbnN0YW5jZSBpcyByZXF1aXJlZCBpbiBzb21lIHBsYWNlc1xuXHR2YXIgYXBpID0gc2V0dGluZ3MuX2JJbml0Q29tcGxldGUgPyBuZXcgRGF0YVRhYmxlLkFwaShzZXR0aW5ncykgOiBudWxsO1xuXG5cdGlmICggISBzIHx8ICEgcy50aW1lICkge1xuXHRcdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdFx0Y2FsbGJhY2soKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBBbGxvdyBjdXN0b20gYW5kIHBsdWctaW4gbWFuaXB1bGF0aW9uIGZ1bmN0aW9ucyB0byBhbHRlciB0aGUgc2F2ZWQgZGF0YSBzZXQgYW5kXG5cdC8vIGNhbmNlbGxpbmcgb2YgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2Vcblx0dmFyIGFiU3RhdGVMb2FkID0gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc10gKTtcblx0aWYgKCAkLmluQXJyYXkoIGZhbHNlLCBhYlN0YXRlTG9hZCApICE9PSAtMSApIHtcblx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVqZWN0IG9sZCBkYXRhXG5cdHZhciBkdXJhdGlvbiA9IHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uO1xuXHRpZiAoIGR1cmF0aW9uID4gMCAmJiBzLnRpbWUgPCArbmV3IERhdGUoKSAtIChkdXJhdGlvbioxMDAwKSApIHtcblx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gTnVtYmVyIG9mIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIC0gYWxsIGJldHMgYXJlIG9mZiwgbm8gcmVzdG9yZSBvZiBzZXR0aW5nc1xuXHRpZiAoIHMuY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCAhPT0gcy5jb2x1bW5zLmxlbmd0aCApIHtcblx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3RvcmUgdGhlIHNhdmVkIHN0YXRlIHNvIGl0IG1pZ2h0IGJlIGFjY2Vzc2VkIGF0IGFueSB0aW1lXG5cdHNldHRpbmdzLm9Mb2FkZWRTdGF0ZSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgcyApO1xuXG5cdC8vIFBhZ2UgTGVuZ3RoXG5cdGlmICggcy5sZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBJZiBhbHJlYWR5IGluaXRpYWxpc2VkIGp1c3Qgc2V0IHRoZSB2YWx1ZSBkaXJlY3RseSBzbyB0aGF0IHRoZSBzZWxlY3QgZWxlbWVudCBpcyBhbHNvIHVwZGF0ZWRcblx0XHRpZiAoYXBpKSB7XG5cdFx0XHRhcGkucGFnZS5sZW4ocy5sZW5ndGgpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoICAgPSBzLmxlbmd0aDtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXN0b3JlIGtleSBmZWF0dXJlcyAtIHRvZG8gLSBmb3IgMS4xMSB0aGlzIG5lZWRzIHRvIGJlIGRvbmUgYnlcblx0Ly8gc3Vic2NyaWJlZCBldmVudHNcblx0aWYgKCBzLnN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0aWYoYXBpID09PSBudWxsKSB7XG5cdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCAgICA9IHMuc3RhcnQ7XG5cdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IHMuc3RhcnQ7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuUGFnZUNoYW5nZShzZXR0aW5ncywgcy5zdGFydC9zZXR0aW5ncy5faURpc3BsYXlMZW5ndGgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIE9yZGVyXG5cdGlmICggcy5vcmRlciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdCQuZWFjaCggcy5vcmRlciwgZnVuY3Rpb24gKCBpLCBjb2wgKSB7XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcucHVzaCggY29sWzBdID49IGNvbHVtbnMubGVuZ3RoID9cblx0XHRcdFx0WyAwLCBjb2xbMV0gXSA6XG5cdFx0XHRcdGNvbFxuXHRcdFx0KTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTZWFyY2hcblx0aWYgKCBzLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIF9mblNlYXJjaFRvSHVuZyggcy5zZWFyY2ggKSApO1xuXHR9XG5cblx0Ly8gQ29sdW1uc1xuXHRpZiAoIHMuY29sdW1ucyApIHtcblx0XHRmb3IgKCBpPTAsIGllbj1zLmNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR2YXIgY29sID0gcy5jb2x1bW5zW2ldO1xuXG5cdFx0XHQvLyBWaXNpYmlsaXR5XG5cdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBhcGkgaXMgZGVmaW5lZCwgdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkIHNvIHdlIG5lZWQgdG8gdXNlIGl0IHJhdGhlciB0aGFuIGludGVybmFsIHNldHRpbmdzXG5cdFx0XHRcdGlmIChhcGkpIHtcblx0XHRcdFx0XHQvLyBEb24ndCByZWRyYXcgdGhlIGNvbHVtbnMgb24gZXZlcnkgaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCwgd2Ugd2lsbCBkbyB0aGlzIGF0IHRoZSBlbmQgaW5zdGVhZFxuXHRcdFx0XHRcdGFwaS5jb2x1bW4oaSkudmlzaWJsZShjb2wudmlzaWJsZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNvbHVtbnNbaV0uYlZpc2libGUgPSBjb2wudmlzaWJsZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWFyY2hcblx0XHRcdGlmICggY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQkLmV4dGVuZCggc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldLCBfZm5TZWFyY2hUb0h1bmcoIGNvbC5zZWFyY2ggKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBJZiB0aGUgYXBpIGlzIGRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgY29sdW1ucyBvbmNlIHRoZSB2aXNpYmlsaXR5IGhhcyBiZWVuIGNoYW5nZWRcblx0XHRpZiAoYXBpKSB7XG5cdFx0XHRhcGkuY29sdW1ucy5hZGp1c3QoKTtcblx0XHR9XG5cdH1cblxuXHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsICdzdGF0ZUxvYWRlZCcsIFtzZXR0aW5ncywgc10gKTtcblx0Y2FsbGJhY2soKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlXG4gKiAgQHBhcmFtIHtub2RlfSB0YWJsZSB0YWJsZSB3ZSBhcmUgdXNpbmcgYXMgYSBkYXRhVGFibGVcbiAqICBAcmV0dXJucyB7b2JqZWN0fSBTZXR0aW5ncyBvYmplY3QgLSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TZXR0aW5nc0Zyb21Ob2RlICggdGFibGUgKVxue1xuXHR2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdHZhciBpZHggPSAkLmluQXJyYXkoIHRhYmxlLCBfcGx1Y2soIHNldHRpbmdzLCAnblRhYmxlJyApICk7XG5cblx0cmV0dXJuIGlkeCAhPT0gLTEgP1xuXHRcdHNldHRpbmdzWyBpZHggXSA6XG5cdFx0bnVsbDtcbn1cblxuXG4vKipcbiAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXG4gKiAgQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtpbnR9IHRuIFRlY2huaWNhbCBub3RlIGlkIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTG9nKCBzZXR0aW5ncywgbGV2ZWwsIG1zZywgdG4gKVxue1xuXHRtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnK1xuXHRcdChzZXR0aW5ncyA/ICd0YWJsZSBpZD0nK3NldHRpbmdzLnNUYWJsZUlkKycgLSAnIDogJycpK21zZztcblxuXHRpZiAoIHRuICkge1xuXHRcdG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcrXG5cdFx0J2h0dHA6Ly9kYXRhdGFibGVzLm5ldC90bi8nK3RuO1xuXHR9XG5cblx0aWYgKCAhIGxldmVsICApIHtcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcmUgMS4xMFxuXHRcdHZhciBleHQgPSBEYXRhVGFibGUuZXh0O1xuXHRcdHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xuXG5cdFx0aWYgKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdlcnJvcicsIFsgc2V0dGluZ3MsIHRuLCBtc2cgXSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PSAnYWxlcnQnICkge1xuXHRcdFx0YWxlcnQoIG1zZyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZSA9PSAndGhyb3cnICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dHlwZSggc2V0dGluZ3MsIHRuLCBtc2cgKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nICkge1xuXHRcdGNvbnNvbGUubG9nKCBtc2cgKTtcblx0fVxufVxuXG5cbi8qKlxuICogU2VlIGlmIGEgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiBvbmUgb2JqZWN0LCBpZiBzbyBhc3NpZ24gaXQgdG8gdGhlIG90aGVyIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSByZXQgdGFyZ2V0IG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgc291cmNlIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHByb3BlcnR5XG4gKiAgQHBhcmFtIHtzdHJpbmd9IFttYXBwZWROYW1lXSBuYW1lIHRvIG1hcCB0b28gLSBvcHRpb25hbCwgbmFtZSB1c2VkIGlmIG5vdCBnaXZlblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5NYXAoIHJldCwgc3JjLCBuYW1lLCBtYXBwZWROYW1lIClcbntcblx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0JC5lYWNoKCBuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWxbMF0sIHZhbFsxXSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mbk1hcCggcmV0LCBzcmMsIHZhbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggbWFwcGVkTmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdG1hcHBlZE5hbWUgPSBuYW1lO1xuXHR9XG5cblx0aWYgKCBzcmNbbmFtZV0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXRbbWFwcGVkTmFtZV0gPSBzcmNbbmFtZV07XG5cdH1cbn1cblxuXG4vKipcbiAqIEV4dGVuZCBvYmplY3RzIC0gdmVyeSBzaW1pbGFyIHRvIGpRdWVyeS5leHRlbmQsIGJ1dCBkZWVwIGNvcHkgb2JqZWN0cywgYW5kXG4gKiBzaGFsbG93IGNvcHkgYXJyYXlzLiBUaGUgcmVhc29uIHdlIG5lZWQgdG8gZG8gdGhpcywgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvXG4gKiBkZWVwIGNvcHkgYXJyYXkgaW5pdCB2YWx1ZXMgKHN1Y2ggYXMgYWFTb3J0aW5nKSBzaW5jZSB0aGUgZGV2IHdvdWxkbid0IGJlXG4gKiBhYmxlIHRvIG92ZXJyaWRlIHRoZW0sIGJ1dCB3ZSBkbyB3YW50IHRvIGRlZXAgY29weSBhcnJheXMuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG91dCBPYmplY3QgdG8gZXh0ZW5kXG4gKiAgQHBhcmFtIHtvYmplY3R9IGV4dGVuZGVyIE9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXBwbGllZCB0b1xuICogICAgICBvdXRcbiAqICBAcGFyYW0ge2Jvb2xlYW59IGJyZWFrUmVmcyBJZiB0cnVlLCB0aGVuIGFycmF5cyB3aWxsIGJlIHNsaWNlZCB0byB0YWtlIGFuXG4gKiAgICAgIGluZGVwZW5kZW50IGNvcHkgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBgZGF0YWAgb3IgYGFhRGF0YWAgcGFyYW1ldGVyc1xuICogICAgICBpZiB0aGV5IGFyZSBwcmVzZW50LiBUaGlzIGlzIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNvbGxlY3Rpb24gdG9cbiAqICAgICAgRGF0YVRhYmxlcyBhbmQgaGF2ZSB0aGF0IHVzZWQgYXMgeW91ciBkYXRhIHNvdXJjZSB3aXRob3V0IGJyZWFraW5nIHRoZVxuICogICAgICByZWZlcmVuY2VzXG4gKiAgQHJldHVybnMge29iamVjdH0gb3V0IFJlZmVyZW5jZSwganVzdCBmb3IgY29udmVuaWVuY2UgLSBvdXQgPT09IHRoZSByZXR1cm4uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKiAgQHRvZG8gVGhpcyBkb2Vzbid0IHRha2UgYWNjb3VudCBvZiBhcnJheXMgaW5zaWRlIHRoZSBkZWVwIGNvcGllZCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBfZm5FeHRlbmQoIG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcyApXG57XG5cdHZhciB2YWw7XG5cblx0Zm9yICggdmFyIHByb3AgaW4gZXh0ZW5kZXIgKSB7XG5cdFx0aWYgKCBleHRlbmRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSApIHtcblx0XHRcdHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xuXG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgKSB7XG5cdFx0XHRcdGlmICggISAkLmlzUGxhaW5PYmplY3QoIG91dFtwcm9wXSApICkge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvdXRbcHJvcF0sIHZhbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgQXJyYXkuaXNBcnJheSh2YWwpICkge1xuXHRcdFx0XHRvdXRbcHJvcF0gPSB2YWwuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRvdXRbcHJvcF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuXG4vKipcbiAqIEJpbmQgYW4gZXZlbnQgaGFuZGVycyB0byBhbGxvdyBhIGNsaWNrIG9yIHJldHVybiBrZXkgdG8gYWN0aXZhdGUgdGhlIGNhbGxiYWNrLlxuICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXG4gKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXG4gKiAgQHBhcmFtIHtlbGVtZW50fSBuIEVsZW1lbnQgdG8gYmluZCB0aGUgYWN0aW9uIHRvXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9EYXRhIERhdGEgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQmluZEFjdGlvbiggbiwgb0RhdGEsIGZuIClcbntcblx0JChuKVxuXHRcdC5vbiggJ2NsaWNrLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdCQobikudHJpZ2dlcignYmx1cicpOyAvLyBSZW1vdmUgZm9jdXMgb3V0bGluZSBmb3IgbW91c2UgdXNlcnNcblx0XHRcdFx0Zm4oZSk7XG5cdFx0XHR9IClcblx0XHQub24oICdrZXlwcmVzcy5EVCcsIG9EYXRhLCBmdW5jdGlvbiAoZSl7XG5cdFx0XHRcdGlmICggZS53aGljaCA9PT0gMTMgKSB7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGZuKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHQub24oICdzZWxlY3RzdGFydC5EVCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0LyogVGFrZSB0aGUgYnJ1dGFsIGFwcHJvYWNoIHRvIGNhbmNlbGxpbmcgdGV4dCBzZWxlY3Rpb24gKi9cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSApO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG4gKiBhbiBhcnJheSBzdG9yZSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBjYW4gdGhlbiBhbGwgYmUgY2FsbGVkIHRvZ2V0aGVyLlxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ30gc1N0b3JlIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW4gb1NldHRpbmdzXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJhY2tcbiAqICBAcGFyYW0ge3N0cmluZ30gc05hbWUgSWRlbnRpZnlpbmcgbmFtZSBmb3IgdGhlIGNhbGxiYWNrIChpLmUuIGEgbGFiZWwpXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsIHNTdG9yZSwgZm4sIHNOYW1lIClcbntcblx0aWYgKCBmbiApXG5cdHtcblx0XHRvU2V0dGluZ3Nbc1N0b3JlXS5wdXNoKCB7XG5cdFx0XHRcImZuXCI6IGZuLFxuXHRcdFx0XCJzTmFtZVwiOiBzTmFtZVxuXHRcdH0gKTtcblx0fVxufVxuXG5cbi8qKlxuICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcbiAqIGNhbGxiYWNrIGFycmF5IHN0b3JlIGlzIGRvbmUgYmFja3dhcmRzISBGdXJ0aGVyIG5vdGUgdGhhdCB5b3UgZG8gbm90IHdhbnQgdG9cbiAqIGZpcmUgb2ZmIHRyaWdnZXJzIGluIHRpbWUgc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyAoZm9yIGV4YW1wbGUgY2VsbCBjcmVhdGlvbilcbiAqIGFzIGl0cyBzbG93LlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBjYWxsYmFja0FyciBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluXG4gKiAgICAgIG9TZXR0aW5nc1xuICogIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiB0aGUgalF1ZXJ5IGN1c3RvbSBldmVudCB0byB0cmlnZ2VyLiBJZlxuICogICAgICBudWxsIG5vIHRyaWdnZXIgaXMgZmlyZWRcbiAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXG4gKiAgICAgIHRyaWdnZXJcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgY2FsbGJhY2tBcnIsIGV2ZW50TmFtZSwgYXJncyApXG57XG5cdHZhciByZXQgPSBbXTtcblxuXHRpZiAoIGNhbGxiYWNrQXJyICkge1xuXHRcdHJldCA9ICQubWFwKCBzZXR0aW5nc1tjYWxsYmFja0Fycl0uc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uICh2YWwsIGkpIHtcblx0XHRcdHJldHVybiB2YWwuZm4uYXBwbHkoIHNldHRpbmdzLm9JbnN0YW5jZSwgYXJncyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggZXZlbnROYW1lICE9PSBudWxsICkge1xuXHRcdHZhciBlID0gJC5FdmVudCggZXZlbnROYW1lKycuZHQnICk7XG5cdFx0dmFyIHRhYmxlID0gJChzZXR0aW5ncy5uVGFibGUpO1xuXG5cdFx0dGFibGUudHJpZ2dlciggZSwgYXJncyApO1xuXG5cdFx0Ly8gSWYgbm90IHlldCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHRyaWdnZXIgdGhlIGV2ZW50XG5cdFx0Ly8gb24gdGhlIGJvZHkgZGlyZWN0bHkgdG8gc29ydCBvZiBzaW11bGF0ZSB0aGUgYnViYmxlXG5cdFx0aWYgKHRhYmxlLnBhcmVudHMoJ2JvZHknKS5sZW5ndGggPT09IDApIHtcblx0XHRcdCQoJ2JvZHknKS50cmlnZ2VyKCBlLCBhcmdzICk7XG5cdFx0fVxuXG5cdFx0cmV0LnB1c2goIGUucmVzdWx0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIF9mbkxlbmd0aE92ZXJmbG93ICggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aDtcblxuXHQvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG5cdGlmICggc3RhcnQgPj0gZW5kIClcblx0e1xuXHRcdHN0YXJ0ID0gZW5kIC0gbGVuO1xuXHR9XG5cblx0Ly8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0c3RhcnQgLT0gKHN0YXJ0ICUgbGVuKTtcblxuXHRpZiAoIGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwIClcblx0e1xuXHRcdHN0YXJ0ID0gMDtcblx0fVxuXG5cdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG59XG5cblxuZnVuY3Rpb24gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCB0eXBlIClcbntcblx0dmFyIHJlbmRlcmVyID0gc2V0dGluZ3MucmVuZGVyZXI7XG5cdHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVuZGVyZXIgKSAmJiByZW5kZXJlclt0eXBlXSApIHtcblx0XHQvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG5cdFx0Ly8gdGhlIGRlZmF1bHQuXG5cdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIHJlbmRlcmVyID09PSAnc3RyaW5nJyApIHtcblx0XHQvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxuXHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gaG9zdFtyZW5kZXJlcl0gfHwgaG9zdC5fO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBkZWZhdWx0XG5cdHJldHVybiBob3N0Ll87XG59XG5cblxuLyoqXG4gKiBEZXRlY3QgdGhlIGRhdGEgc291cmNlIGJlaW5nIHVzZWQgZm9yIHRoZSB0YWJsZS4gVXNlZCB0byBzaW1wbGlmeSB0aGUgY29kZVxuICogYSBsaXR0bGUgKGFqYXgpIGFuZCB0byBtYWtlIGl0IGNvbXByZXNzIGEgbGl0dGxlIHNtYWxsZXIuXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtzdHJpbmd9IERhdGEgc291cmNlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRhdGFTb3VyY2UgKCBzZXR0aW5ncyApXG57XG5cdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdHJldHVybiAnc3NwJztcblx0fVxuXHRlbHNlIGlmICggc2V0dGluZ3MuYWpheCB8fCBzZXR0aW5ncy5zQWpheFNvdXJjZSApIHtcblx0XHRyZXR1cm4gJ2FqYXgnO1xuXHR9XG5cdHJldHVybiAnZG9tJztcbn1cblxuXG5cblxuLyoqXG4gKiBDb21wdXRlZCBzdHJ1Y3R1cmUgb2YgdGhlIERhdGFUYWJsZXMgQVBJLCBkZWZpbmVkIGJ5IHRoZSBvcHRpb25zIHBhc3NlZCB0b1xuICogYERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoKWAgd2hlbiBidWlsZGluZyB0aGUgQVBJLlxuICpcbiAqIFRoZSBzdHJ1Y3R1cmUgaXMgYnVpbHQgaW4gb3JkZXIgdG8gc3BlZWQgY3JlYXRpb24gYW5kIGV4dGVuc2lvbiBvZiB0aGUgQXBpXG4gKiBvYmplY3RzIHNpbmNlIHRoZSBleHRlbnNpb25zIGFyZSBlZmZlY3RpdmVseSBwcmUtcGFyc2VkLlxuICpcbiAqIFRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUsIHdoZXJlIHRoaXNcbiAqIGJhc2UgYXJyYXkgcmVwcmVzZW50cyB0aGUgQXBpIHByb3RvdHlwZSBiYXNlOlxuICpcbiAqICAgICBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuICogICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LCAgICAgICAtLSBmdW5jdGlvbiAtIEFwaSBtZXRob2QgKG9yIHVuZGVmaW5lZCBpZiBqdXN0IGFuIG9iamVjdFxuICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG4gKiAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICBuYW1lOiAgICAgJ3JvdydcbiAqICAgICAgICAgdmFsOiAgICAgICB7fSxcbiAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuICogICAgICAgICBwcm9wRXh0OiAgIFtcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuICogICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcbiAqICAgICAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcbiAqICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIF1cbiAqICAgICAgIH1cbiAqICAgICBdXG4gKlxuICogQHR5cGUge0FycmF5fVxuICogQGlnbm9yZVxuICovXG52YXIgX19hcGlTdHJ1Y3QgPSBbXTtcblxuXG4vKipcbiAqIGBBcnJheS5wcm90b3R5cGVgIHJlZmVyZW5jZS5cbiAqXG4gKiBAdHlwZSBvYmplY3RcbiAqIEBpZ25vcmVcbiAqL1xudmFyIF9fYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBgY29udGV4dGAgcGFyYW1ldGVyIG9mIHRoZSBgQXBpYCBjb25zdHJ1Y3RvciB0byBhbGxvdyBpdCB0b1xuICogdGFrZSBzZXZlcmFsIGRpZmZlcmVudCBmb3JtcyBmb3IgZWFzZSBvZiB1c2UuXG4gKlxuICogRWFjaCBvZiB0aGUgaW5wdXQgcGFyYW1ldGVyIHR5cGVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgRGF0YVRhYmxlcyBzZXR0aW5nc1xuICogb2JqZWN0IHdoZXJlIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xub2RlfGpRdWVyeXxvYmplY3R9IG1peGVkIERhdGFUYWJsZSBpZGVudGlmaWVyLiBDYW4gYmUgb25lXG4gKiAgIG9mOlxuICpcbiAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXG4gKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG4gKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cbiAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgICogYERhdGFUYWJsZXMuQXBpYCAtIEFQSSBpbnN0YW5jZVxuICogQHJldHVybiB7YXJyYXl8bnVsbH0gTWF0Y2hpbmcgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLiBgbnVsbGAgb3JcbiAqICAgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgaWYgbm8gbWF0Y2hpbmcgRGF0YVRhYmxlIGlzIGZvdW5kLlxuICogQGlnbm9yZVxuICovXG52YXIgX3RvU2V0dGluZ3MgPSBmdW5jdGlvbiAoIG1peGVkIClcbntcblx0dmFyIGlkeCwganE7XG5cdHZhciBzZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0dmFyIHRhYmxlcyA9ICQubWFwKCBzZXR0aW5ncywgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0fSApO1xuXG5cdGlmICggISBtaXhlZCApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0ZWxzZSBpZiAoIG1peGVkLm5UYWJsZSAmJiBtaXhlZC5vQXBpICkge1xuXHRcdC8vIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0cmV0dXJuIFsgbWl4ZWQgXTtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQubm9kZU5hbWUgJiYgbWl4ZWQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYmxlJyApIHtcblx0XHQvLyBUYWJsZSBub2RlXG5cdFx0aWR4ID0gJC5pbkFycmF5KCBtaXhlZCwgdGFibGVzICk7XG5cdFx0cmV0dXJuIGlkeCAhPT0gLTEgPyBbIHNldHRpbmdzW2lkeF0gXSA6IG51bGw7XG5cdH1cblx0ZWxzZSBpZiAoIG1peGVkICYmIHR5cGVvZiBtaXhlZC5zZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4gbWl4ZWQuc2V0dGluZ3MoKS50b0FycmF5KCk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0Ly8galF1ZXJ5IHNlbGVjdG9yXG5cdFx0anEgPSAkKG1peGVkKTtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQgaW5zdGFuY2VvZiAkICkge1xuXHRcdC8vIGpRdWVyeSBvYmplY3QgKGFsc28gRGF0YVRhYmxlcyBpbnN0YW5jZSlcblx0XHRqcSA9IG1peGVkO1xuXHR9XG5cblx0aWYgKCBqcSApIHtcblx0XHRyZXR1cm4ganEubWFwKCBmdW5jdGlvbihpKSB7XG5cdFx0XHRpZHggPSAkLmluQXJyYXkoIHRoaXMsIHRhYmxlcyApO1xuXHRcdFx0cmV0dXJuIGlkeCAhPT0gLTEgPyBzZXR0aW5nc1tpZHhdIDogbnVsbDtcblx0XHR9ICkudG9BcnJheSgpO1xuXHR9XG59O1xuXG5cbi8qKlxuICogRGF0YVRhYmxlcyBBUEkgY2xhc3MgLSB1c2VkIHRvIGNvbnRyb2wgYW5kIGludGVyZmFjZSB3aXRoICBvbmUgb3IgbW9yZVxuICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXG4gKlxuICogVGhlIEFQSSBjbGFzcyBpcyBoZWF2aWx5IGJhc2VkIG9uIGpRdWVyeSwgcHJlc2VudGluZyBhIGNoYWluYWJsZSBpbnRlcmZhY2VcbiAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcbiAqIGEgXCJjb250ZXh0XCIgLSBpLmUuIHRoZSB0YWJsZXMgdGhhdCBpdCB3aWxsIG9wZXJhdGUgb24uIFRoaXMgY291bGQgYmUgYSBzaW5nbGVcbiAqIHRhYmxlLCBhbGwgdGFibGVzIG9uIGEgcGFnZSBvciBhIHN1Yi1zZXQgdGhlcmVvZi5cbiAqXG4gKiBBZGRpdGlvbmFsbHkgdGhlIEFQSSBpcyBkZXNpZ25lZCB0byBhbGxvdyB5b3UgdG8gZWFzaWx5IHdvcmsgd2l0aCB0aGUgZGF0YSBpblxuICogdGhlIHRhYmxlcywgcmV0cmlldmluZyBhbmQgbWFuaXB1bGF0aW5nIGl0IGFzIHJlcXVpcmVkLiBUaGlzIGlzIGRvbmUgYnlcbiAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxuICogYXJyYXkgZGVwZW5kIHVwb24gdGhlIGFjdGlvbnMgcmVxdWVzdGVkIGJ5IGVhY2ggbWV0aG9kIChmb3IgZXhhbXBsZVxuICogYHJvd3MoKS5ub2RlcygpYCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBub2Rlcywgd2hpbGUgYHJvd3MoKS5kYXRhKClgIHdpbGxcbiAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3NcbiAqIGNvbmZpZ3VyYXRpb24pLiBUaGUgQVBJIG9iamVjdCBoYXMgYSBudW1iZXIgb2YgYXJyYXkgbGlrZSBtZXRob2RzIChgcHVzaGAsXG4gKiBgcG9wYCwgYHJldmVyc2VgIGV0YykgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIChgZWFjaGAsIGBwbHVja2AsXG4gKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXG4gKlxuICogTW9zdCBtZXRob2RzICh0aG9zZSB3aGljaCByZXR1cm4gYW4gQXBpIGluc3RhbmNlKSBhcmUgY2hhaW5hYmxlLCB3aGljaCBtZWFuc1xuICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxuICogdG9wIGxldmVsIG9iamVjdCBoYWQuIEZvciBleGFtcGxlLCB0aGVzZSB0d28gY2FsbHMgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAgIC8vIE5vdCBjaGFpbmVkXG4gKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICk7XG4gKiAgICAgYXBpLmRyYXcoKTtcbiAqXG4gKiAgICAgLy8gQ2hhaW5lZFxuICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApLmRyYXcoKTtcbiAqXG4gKiBAY2xhc3MgRGF0YVRhYmxlLkFwaVxuICogQHBhcmFtIHthcnJheXxvYmplY3R8c3RyaW5nfGpRdWVyeX0gY29udGV4dCBEYXRhVGFibGUgaWRlbnRpZmllci4gVGhpcyBpc1xuICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXG4gKiAgIENhbiBiZSBvbmUgb2Y6XG4gKlxuICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG4gKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cbiAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cbiAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7YXJyYXl9IFtkYXRhXSBEYXRhIHRvIGluaXRpYWxpc2UgdGhlIEFwaSBpbnN0YW5jZSB3aXRoLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIERpcmVjdCBpbml0aWFsaXNhdGlvbiBkdXJpbmcgRGF0YVRhYmxlcyBjb25zdHJ1Y3Rpb25cbiAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3RcbiAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCkuYXBpKCk7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gSW5pdGlhbGlzYXRpb24gYXMgYSBjb25zdHJ1Y3RvclxuICogICB2YXIgYXBpID0gbmV3ICQuZm4uRGF0YVRhYmxlLkFwaSggJ3RhYmxlLmRhdGFUYWJsZScgKTtcbiAqL1xuX0FwaSA9IGZ1bmN0aW9uICggY29udGV4dCwgZGF0YSApXG57XG5cdGlmICggISAodGhpcyBpbnN0YW5jZW9mIF9BcGkpICkge1xuXHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgZGF0YSApO1xuXHR9XG5cblx0dmFyIHNldHRpbmdzID0gW107XG5cdHZhciBjdHhTZXR0aW5ncyA9IGZ1bmN0aW9uICggbyApIHtcblx0XHR2YXIgYSA9IF90b1NldHRpbmdzKCBvICk7XG5cdFx0aWYgKCBhICkge1xuXHRcdFx0c2V0dGluZ3MucHVzaC5hcHBseSggc2V0dGluZ3MsIGEgKTtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dFtpXSApO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRjdHhTZXR0aW5ncyggY29udGV4dCApO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0dGhpcy5jb250ZXh0ID0gX3VuaXF1ZSggc2V0dGluZ3MgKTtcblxuXHQvLyBJbml0aWFsIGRhdGFcblx0aWYgKCBkYXRhICkge1xuXHRcdCQubWVyZ2UoIHRoaXMsIGRhdGEgKTtcblx0fVxuXG5cdC8vIHNlbGVjdG9yXG5cdHRoaXMuc2VsZWN0b3IgPSB7XG5cdFx0cm93czogbnVsbCxcblx0XHRjb2xzOiBudWxsLFxuXHRcdG9wdHM6IG51bGxcblx0fTtcblxuXHRfQXBpLmV4dGVuZCggdGhpcywgdGhpcywgX19hcGlTdHJ1Y3QgKTtcbn07XG5cbkRhdGFUYWJsZS5BcGkgPSBfQXBpO1xuXG4vLyBEb24ndCBkZXN0cm95IHRoZSBleGlzdGluZyBwcm90b3R5cGUsIGp1c3QgZXh0ZW5kIGl0LiBSZXF1aXJlZCBmb3IgalF1ZXJ5IDInc1xuLy8gaXNQbGFpbk9iamVjdC5cbiQuZXh0ZW5kKCBfQXBpLnByb3RvdHlwZSwge1xuXHRhbnk6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5jb3VudCgpICE9PSAwO1xuXHR9LFxuXG5cblx0Y29uY2F0OiAgX19hcnJheVByb3RvLmNvbmNhdCxcblxuXG5cdGNvbnRleHQ6IFtdLCAvLyBhcnJheSBvZiB0YWJsZSBzZXR0aW5ncyBvYmplY3RzXG5cblxuXHRjb3VudDogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmZsYXR0ZW4oKS5sZW5ndGg7XG5cdH0sXG5cblxuXHRlYWNoOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuOyBpKysgKSB7XG5cdFx0XHRmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblxuXHRlcTogZnVuY3Rpb24gKCBpZHggKVxuXHR7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRcdHJldHVybiBjdHgubGVuZ3RoID4gaWR4ID9cblx0XHRcdG5ldyBfQXBpKCBjdHhbaWR4XSwgdGhpc1tpZHhdICkgOlxuXHRcdFx0bnVsbDtcblx0fSxcblxuXG5cdGZpbHRlcjogZnVuY3Rpb24gKCBmbiApXG5cdHtcblx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0aWYgKCBfX2FycmF5UHJvdG8uZmlsdGVyICkge1xuXHRcdFx0YSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCggdGhpcywgZm4sIHRoaXMgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGZuLmNhbGwoIHRoaXMsIHRoaXNbaV0sIGksIHRoaXMgKSApIHtcblx0XHRcdFx0XHRhLnB1c2goIHRoaXNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhICk7XG5cdH0sXG5cblxuXHRmbGF0dGVuOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYS5jb25jYXQuYXBwbHkoIGEsIHRoaXMudG9BcnJheSgpICkgKTtcblx0fSxcblxuXG5cdGpvaW46ICAgIF9fYXJyYXlQcm90by5qb2luLFxuXG5cblx0aW5kZXhPZjogX19hcnJheVByb3RvLmluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpXG5cdHtcblx0XHRmb3IgKCB2YXIgaT0oc3RhcnQgfHwgMCksIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldID09PSBvYmogKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0aXRlcmF0b3I6IGZ1bmN0aW9uICggZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldyApIHtcblx0XHR2YXJcblx0XHRcdGEgPSBbXSwgcmV0LFxuXHRcdFx0aSwgaWVuLCBqLCBqZW4sXG5cdFx0XHRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuXHRcdFx0cm93cywgaXRlbXMsIGl0ZW0sXG5cdFx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggdHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0YWx3YXlzTmV3ID0gZm47XG5cdFx0XHRmbiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gZmxhdHRlbjtcblx0XHRcdGZsYXR0ZW4gPSBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKCBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIGFwaUluc3QgPSBuZXcgX0FwaSggY29udGV4dFtpXSApO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09ICd0YWJsZScgKSB7XG5cdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGkgKTtcblxuXHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnY29sdW1ucycgfHwgdHlwZSA9PT0gJ3Jvd3MnICkge1xuXHRcdFx0XHQvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXG5cdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkgKTtcblxuXHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnY29sdW1uJyB8fCB0eXBlID09PSAnY29sdW1uLXJvd3MnIHx8IHR5cGUgPT09ICdyb3cnIHx8IHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0Ly8gY29sdW1ucyBhbmQgcm93cyBzaGFyZSB0aGUgc2FtZSBzdHJ1Y3R1cmUuXG5cdFx0XHRcdC8vICd0aGlzJyBpcyBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyBmb3IgZWFjaCBjb250ZXh0XG5cdFx0XHRcdGl0ZW1zID0gdGhpc1tpXTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjb2x1bW4tcm93cycgKSB7XG5cdFx0XHRcdFx0cm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggY29udGV4dFtpXSwgc2VsZWN0b3Iub3B0cyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaj0wLCBqZW49aXRlbXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGl0ZW1zW2pdO1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdFx0XHRyZXQgPSBmbi5jYWxsKCBhcGlJbnN0LCBjb250ZXh0W2ldLCBpdGVtLnJvdywgaXRlbS5jb2x1bW4sIGksIGogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXQgPSBmbi5jYWxsKCBhcGlJbnN0LCBjb250ZXh0W2ldLCBpdGVtLCBpLCBqLCByb3dzICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBhLmxlbmd0aCB8fCBhbHdheXNOZXcgKSB7XG5cdFx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIGNvbnRleHQsIGZsYXR0ZW4gPyBhLmNvbmNhdC5hcHBseSggW10sIGEgKSA6IGEgKTtcblx0XHRcdHZhciBhcGlTZWxlY3RvciA9IGFwaS5zZWxlY3Rvcjtcblx0XHRcdGFwaVNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvci5yb3dzO1xuXHRcdFx0YXBpU2VsZWN0b3IuY29scyA9IHNlbGVjdG9yLmNvbHM7XG5cdFx0XHRhcGlTZWxlY3Rvci5vcHRzID0gc2VsZWN0b3Iub3B0cztcblx0XHRcdHJldHVybiBhcGk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cblx0bGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydClcblx0e1xuXHRcdC8vIEJpdCBjaGVla3kuLi5cblx0XHRyZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KCB0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMgKTtcblx0fSxcblxuXG5cdGxlbmd0aDogIDAsXG5cblxuXHRtYXA6IGZ1bmN0aW9uICggZm4gKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblxuXHRcdGlmICggX19hcnJheVByb3RvLm1hcCApIHtcblx0XHRcdGEgPSBfX2FycmF5UHJvdG8ubWFwLmNhbGwoIHRoaXMsIGZuLCB0aGlzICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcnMgd2l0aG91dCBFTUNBLTI1Mi01IChKUyAxLjYpXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YS5wdXNoKCBmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpICkgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYSApO1xuXHR9LFxuXG5cblx0cGx1Y2s6IGZ1bmN0aW9uICggcHJvcCApXG5cdHtcblx0XHR2YXIgZm4gPSBEYXRhVGFibGUudXRpbC5nZXQocHJvcCk7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggZWwgKSB7XG5cdFx0XHRyZXR1cm4gZm4oZWwpO1xuXHRcdH0gKTtcblx0fSxcblxuXHRwb3A6ICAgICBfX2FycmF5UHJvdG8ucG9wLFxuXG5cblx0cHVzaDogICAgX19hcnJheVByb3RvLnB1c2gsXG5cblxuXHQvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXG5cdHJlZHVjZTogX19hcnJheVByb3RvLnJlZHVjZSB8fCBmdW5jdGlvbiAoIGZuLCBpbml0IClcblx0e1xuXHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCAwLCB0aGlzLmxlbmd0aCwgMSApO1xuXHR9LFxuXG5cblx0cmVkdWNlUmlnaHQ6IF9fYXJyYXlQcm90by5yZWR1Y2VSaWdodCB8fCBmdW5jdGlvbiAoIGZuLCBpbml0IClcblx0e1xuXHRcdHJldHVybiBfZm5SZWR1Y2UoIHRoaXMsIGZuLCBpbml0LCB0aGlzLmxlbmd0aC0xLCAtMSwgLTEgKTtcblx0fSxcblxuXG5cdHJldmVyc2U6IF9fYXJyYXlQcm90by5yZXZlcnNlLFxuXG5cblx0Ly8gT2JqZWN0IHdpdGggcm93cywgY29sdW1ucyBhbmQgb3B0c1xuXHRzZWxlY3RvcjogbnVsbCxcblxuXG5cdHNoaWZ0OiAgIF9fYXJyYXlQcm90by5zaGlmdCxcblxuXG5cdHNsaWNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMgKTtcblx0fSxcblxuXG5cdHNvcnQ6ICAgIF9fYXJyYXlQcm90by5zb3J0LCAvLyA/IG5hbWUgLSBvcmRlcj9cblxuXG5cdHNwbGljZTogIF9fYXJyYXlQcm90by5zcGxpY2UsXG5cblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIF9fYXJyYXlQcm90by5zbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblxuXHR0byQ6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHR9LFxuXG5cblx0dG9KUXVlcnk6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHR9LFxuXG5cblx0dW5pcXVlOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIF91bmlxdWUodGhpcykgKTtcblx0fSxcblxuXG5cdHVuc2hpZnQ6IF9fYXJyYXlQcm90by51bnNoaWZ0XG59ICk7XG5cblxuX0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoIHNjb3BlLCBvYmosIGV4dCApXG57XG5cdC8vIE9ubHkgZXh0ZW5kIEFQSSBpbnN0YW5jZXMgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBBUElcblx0aWYgKCAhIGV4dC5sZW5ndGggfHwgISBvYmogfHwgKCAhIChvYmogaW5zdGFuY2VvZiBfQXBpKSAmJiAhIG9iai5fX2R0X3dyYXBwZXIgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHRpLCBpZW4sXG5cdFx0c3RydWN0LFxuXHRcdG1ldGhvZFNjb3BpbmcgPSBmdW5jdGlvbiAoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgcmV0ID0gZm4uYXBwbHkoIHNjb3BlLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHQvLyBNZXRob2QgZXh0ZW5zaW9uXG5cdFx0XHRcdF9BcGkuZXh0ZW5kKCByZXQsIHJldCwgc3RydWMubWV0aG9kRXh0ICk7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0Zm9yICggaT0wLCBpZW49ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHN0cnVjdCA9IGV4dFtpXTtcblxuXHRcdC8vIFZhbHVlXG5cdFx0b2JqWyBzdHJ1Y3QubmFtZSBdID0gc3RydWN0LnR5cGUgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0bWV0aG9kU2NvcGluZyggc2NvcGUsIHN0cnVjdC52YWwsIHN0cnVjdCApIDpcblx0XHRcdHN0cnVjdC50eXBlID09PSAnb2JqZWN0JyA/XG5cdFx0XHRcdHt9IDpcblx0XHRcdFx0c3RydWN0LnZhbDtcblxuXHRcdG9ialsgc3RydWN0Lm5hbWUgXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xuXG5cdFx0Ly8gUHJvcGVydHkgZXh0ZW5zaW9uXG5cdFx0X0FwaS5leHRlbmQoIHNjb3BlLCBvYmpbIHN0cnVjdC5uYW1lIF0sIHN0cnVjdC5wcm9wRXh0ICk7XG5cdH1cbn07XG5cblxuLy8gQHRvZG8gLSBJcyB0aGVyZSBuZWVkIGZvciBhbiBhdWdtZW50IGZ1bmN0aW9uP1xuLy8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcbi8vIHtcbi8vIFx0Ly8gRmluZCBzcmMgb2JqZWN0IGluIHRoZSBzdHJ1Y3R1cmUgZnJvbSB0aGUgbmFtZVxuLy8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cbi8vIFx0X0FwaS5leHRlbmQoIGluc3QsIG9iaiApO1xuLy8gfTtcblxuXG4vLyAgICAgW1xuLy8gICAgICAge1xuLy8gICAgICAgICBuYW1lOiAgICAgICdkYXRhJyAgICAgICAgICAgICAgICAtLSBzdHJpbmcgICAtIFByb3BlcnR5IG5hbWVcbi8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcbi8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuLy8gICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF0gICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0eVxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbmFtZTogICAgICdyb3cnXG4vLyAgICAgICAgIHZhbDogICAgICAge30sXG4vLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcbi8vICAgICAgICAgcHJvcEV4dDogICBbXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcbi8vICAgICAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sXG4vLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4vLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cbi8vICAgICAgICAgICB9LFxuLy8gICAgICAgICAgIC4uLlxuLy8gICAgICAgICBdXG4vLyAgICAgICB9XG4vLyAgICAgXVxuXG5fQXBpLnJlZ2lzdGVyID0gX2FwaV9yZWdpc3RlciA9IGZ1bmN0aW9uICggbmFtZSwgdmFsIClcbntcblx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0Zm9yICggdmFyIGo9MCwgamVuPW5hbWUubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRfQXBpLnJlZ2lzdGVyKCBuYW1lW2pdLCB2YWwgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyXG5cdFx0aSwgaWVuLFxuXHRcdGhlaXIgPSBuYW1lLnNwbGl0KCcuJyksXG5cdFx0c3RydWN0ID0gX19hcGlTdHJ1Y3QsXG5cdFx0a2V5LCBtZXRob2Q7XG5cblx0dmFyIGZpbmQgPSBmdW5jdGlvbiAoIHNyYywgbmFtZSApIHtcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c3JjLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBzcmNbaV0ubmFtZSA9PT0gbmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIHNyY1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0Zm9yICggaT0wLCBpZW49aGVpci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRtZXRob2QgPSBoZWlyW2ldLmluZGV4T2YoJygpJykgIT09IC0xO1xuXHRcdGtleSA9IG1ldGhvZCA/XG5cdFx0XHRoZWlyW2ldLnJlcGxhY2UoJygpJywgJycpIDpcblx0XHRcdGhlaXJbaV07XG5cblx0XHR2YXIgc3JjID0gZmluZCggc3RydWN0LCBrZXkgKTtcblx0XHRpZiAoICEgc3JjICkge1xuXHRcdFx0c3JjID0ge1xuXHRcdFx0XHRuYW1lOiAgICAgIGtleSxcblx0XHRcdFx0dmFsOiAgICAgICB7fSxcblx0XHRcdFx0bWV0aG9kRXh0OiBbXSxcblx0XHRcdFx0cHJvcEV4dDogICBbXSxcblx0XHRcdFx0dHlwZTogICAgICAnb2JqZWN0J1xuXHRcdFx0fTtcblx0XHRcdHN0cnVjdC5wdXNoKCBzcmMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGkgPT09IGllbi0xICkge1xuXHRcdFx0c3JjLnZhbCA9IHZhbDtcblx0XHRcdHNyYy50eXBlID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdCdmdW5jdGlvbicgOlxuXHRcdFx0XHQkLmlzUGxhaW5PYmplY3QoIHZhbCApID9cblx0XHRcdFx0XHQnb2JqZWN0JyA6XG5cdFx0XHRcdFx0J290aGVyJztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzdHJ1Y3QgPSBtZXRob2QgP1xuXHRcdFx0XHRzcmMubWV0aG9kRXh0IDpcblx0XHRcdFx0c3JjLnByb3BFeHQ7XG5cdFx0fVxuXHR9XG59O1xuXG5fQXBpLnJlZ2lzdGVyUGx1cmFsID0gX2FwaV9yZWdpc3RlclBsdXJhbCA9IGZ1bmN0aW9uICggcGx1cmFsTmFtZSwgc2luZ3VsYXJOYW1lLCB2YWwgKSB7XG5cdF9BcGkucmVnaXN0ZXIoIHBsdXJhbE5hbWUsIHZhbCApO1xuXG5cdF9BcGkucmVnaXN0ZXIoIHNpbmd1bGFyTmFtZSwgZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZXQgPSB2YWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0aWYgKCByZXQgPT09IHRoaXMgKSB7XG5cdFx0XHQvLyBSZXR1cm5lZCBpdGVtIGlzIHRoZSBBUEkgaW5zdGFuY2UgdGhhdCB3YXMgcGFzc2VkIGluLCByZXR1cm4gaXRcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRlbHNlIGlmICggcmV0IGluc3RhbmNlb2YgX0FwaSApIHtcblx0XHRcdC8vIE5ldyBBUEkgaW5zdGFuY2UgcmV0dXJuZWQsIHdhbnQgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZW1cblx0XHRcdC8vIGluIHRoZSByZXR1cm5lZCBhcnJheSBmb3IgdGhlIHNpbmd1bGFyIHJlc3VsdC5cblx0XHRcdHJldHVybiByZXQubGVuZ3RoID9cblx0XHRcdFx0QXJyYXkuaXNBcnJheSggcmV0WzBdICkgP1xuXHRcdFx0XHRcdG5ldyBfQXBpKCByZXQuY29udGV4dCwgcmV0WzBdICkgOiAvLyBBcnJheSByZXN1bHRzIGFyZSAnZW5oYW5jZWQnXG5cdFx0XHRcdFx0cmV0WzBdIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIE5vbi1BUEkgcmV0dXJuIC0ganVzdCBmaXJlIGl0IGJhY2tcblx0XHRyZXR1cm4gcmV0O1xuXHR9ICk7XG59O1xuXG5cbi8qKlxuICogU2VsZWN0b3IgZm9yIEhUTUwgdGFibGVzLiBBcHBseSB0aGUgZ2l2ZW4gc2VsZWN0b3IgdG8gdGhlIGdpdmUgYXJyYXkgb2ZcbiAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcgb3IgaW50ZWdlclxuICogQHBhcmFtICB7YXJyYXl9IEFycmF5IG9mIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cyB0byBiZSBmaWx0ZXJlZFxuICogQHJldHVybiB7YXJyYXl9XG4gKiBAaWdub3JlXG4gKi9cbnZhciBfX3RhYmxlX3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZWxlY3RvciwgYSApXG57XG5cdGlmICggQXJyYXkuaXNBcnJheShzZWxlY3RvcikgKSB7XG5cdFx0cmV0dXJuICQubWFwKCBzZWxlY3RvciwgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJldHVybiBfX3RhYmxlX3NlbGVjdG9yKGl0ZW0sIGEpO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJyApIHtcblx0XHRyZXR1cm4gWyBhWyBzZWxlY3RvciBdIF07XG5cdH1cblxuXHQvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xuXHR2YXIgbm9kZXMgPSAkLm1hcCggYSwgZnVuY3Rpb24gKGVsLCBpKSB7XG5cdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0fSApO1xuXG5cdHJldHVybiAkKG5vZGVzKVxuXHRcdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQubWFwKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0Ly8gTmVlZCB0byB0cmFuc2xhdGUgYmFjayBmcm9tIHRoZSB0YWJsZSBub2RlIHRvIHRoZSBzZXR0aW5nc1xuXHRcdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggdGhpcywgbm9kZXMgKTtcblx0XHRcdHJldHVybiBhWyBpZHggXTtcblx0XHR9IClcblx0XHQudG9BcnJheSgpO1xufTtcblxuXG5cbi8qKlxuICogQ29udGV4dCBzZWxlY3RvciBmb3IgdGhlIEFQSSdzIGNvbnRleHQgKGkuZS4gdGhlIHRhYmxlcyB0aGUgQVBJIGluc3RhbmNlXG4gKiByZWZlcnMgdG8uXG4gKlxuICogQG5hbWUgICAgRGF0YVRhYmxlLkFwaSN0YWJsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXG4gKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcbiAqICAgdXNlZC4gVGhpcyBjYW4gYmUgZ2l2ZW4gYXMgYSBqUXVlcnkgc2VsZWN0b3IgKGZvciBleGFtcGxlIGAnOmd0KDApJ2ApIHRvXG4gKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cbiAqL1xuX2FwaV9yZWdpc3RlciggJ3RhYmxlcygpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0Ly8gQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBpZiB0aGVyZSB3YXMgYSBzZWxlY3RvciBzcGVjaWZpZWRcblx0cmV0dXJuIHNlbGVjdG9yICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0b3IgIT09IG51bGwgP1xuXHRcdG5ldyBfQXBpKCBfX3RhYmxlX3NlbGVjdG9yKCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkgKSA6XG5cdFx0dGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAndGFibGUoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyggc2VsZWN0b3IgKTtcblx0dmFyIGN0eCA9IHRhYmxlcy5jb250ZXh0O1xuXG5cdC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG5cdHJldHVybiBjdHgubGVuZ3RoID9cblx0XHRuZXcgX0FwaSggY3R4WzBdICkgOlxuXHRcdHRhYmxlcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkubm9kZXMoKScsICd0YWJsZSgpLm5vZGUoKScgLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRyZXR1cm4gY3R4Lm5UYWJsZTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5ib2R5KCknLCAndGFibGUoKS5ib2R5KCknICwgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0cmV0dXJuIGN0eC5uVEJvZHk7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAndGFibGVzKCkuaGVhZGVyKCknLCAndGFibGUoKS5oZWFkZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRyZXR1cm4gY3R4Lm5USGVhZDtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5mb290ZXIoKScsICd0YWJsZSgpLmZvb3RlcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdHJldHVybiBjdHgublRGb290O1xuXHR9LCAxICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdHJldHVybiBjdHgublRhYmxlV3JhcHBlcjtcblx0fSwgMSApO1xufSApO1xuXG5cblxuLyoqXG4gKiBSZWRyYXcgdGhlIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICovXG5fYXBpX3JlZ2lzdGVyKCAnZHJhdygpJywgZnVuY3Rpb24gKCBwYWdpbmcgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggcGFnaW5nID09PSAncGFnZScgKSB7XG5cdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIHBhZ2luZyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHBhZ2luZyA9IHBhZ2luZyA9PT0gJ2Z1bGwtaG9sZCcgP1xuXHRcdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0XHR0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBwYWdpbmc9PT1mYWxzZSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQpXG4gKi8vKipcbiAqIFNldCB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXG4gKiBub3QgdGhyb3cgYW4gZXJyb3IsIGJ1dCByYXRoZXIgcmVzZXQgdGhlIHBhZ2luZy5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxuICogICogYGludGVnZXJgIC0gVGhlIHBhZ2UgaW5kZXggdG8ganVtcCB0b1xuICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcbiAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cbiAqICAgICogYG5leHRgIC0gSnVtcCB0byB0aGUgbmV4dCBwYWdlXG4gKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2VcbiAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdwYWdlKCknLCBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0aWYgKCBhY3Rpb24gPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5wYWdlLmluZm8oKS5wYWdlOyAvLyBub3QgYW4gZXhwZW5zaXZlIGNhbGxcblx0fVxuXG5cdC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5QYWdlQ2hhbmdlKCBzZXR0aW5ncywgYWN0aW9uICk7XG5cdH0gKTtcbn0gKTtcblxuXG4vKipcbiAqIFBhZ2luZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogSWYgeW91IHJlcXVpcmUgcGFnaW5nIGluZm9ybWF0aW9uIGZvciBhbm90aGVyIHRhYmxlLCB1c2UgdGhlIGB0YWJsZSgpYCBtZXRob2RcbiAqIHdpdGggYSBzdWl0YWJsZSBzZWxlY3Rvci5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBzZXQ6XG4gKiAgKiBgcGFnZWAgLSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQgLSBpLmUuIHRoZSBmaXJzdCBwYWdlIGlzIGAwYClcbiAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcbiAqICAqIGBzdGFydGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgZmlyc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAqICAqIGBlbmRgIC0gRGlzcGxheSBpbmRleCBmb3IgdGhlIGxhc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcbiAqICAgICsgbGVuZ3RoID0gZW5kYCwgYnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0cnVlLCBmb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmVcbiAqICAgIG9ubHkgMiByZWNvcmRzIHRvIHNob3cgb24gdGhlIGZpbmFsIHBhZ2UsIHdpdGggYSBsZW5ndGggb2YgMTAuXG4gKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXG4gKiAgKiBgcmVjb3Jkc0Rpc3BsYXlgIC0gRGF0YSBzZXQgbGVuZ3RoIG9uY2UgdGhlIGN1cnJlbnQgZmlsdGVyaW5nIGNyaXRlcmlvblxuICogICAgYXJlIGFwcGxpZWQuXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdwYWdlLmluZm8oKScsIGZ1bmN0aW9uICggYWN0aW9uICkge1xuXHRpZiAoIHRoaXMuY29udGV4dC5sZW5ndGggPT09IDAgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdHZhclxuXHRcdHNldHRpbmdzICAgPSB0aGlzLmNvbnRleHRbMF0sXG5cdFx0c3RhcnQgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlID8gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDogLTEsXG5cdFx0dmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMTtcblxuXHRyZXR1cm4ge1xuXHRcdFwicGFnZVwiOiAgICAgICAgICAgYWxsID8gMCA6IE1hdGguZmxvb3IoIHN0YXJ0IC8gbGVuICksXG5cdFx0XCJwYWdlc1wiOiAgICAgICAgICBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0XCJzdGFydFwiOiAgICAgICAgICBzdGFydCxcblx0XHRcImVuZFwiOiAgICAgICAgICAgIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdFwibGVuZ3RoXCI6ICAgICAgICAgbGVuLFxuXHRcdFwicmVjb3Jkc1RvdGFsXCI6ICAgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRcInJlY29yZHNEaXNwbGF5XCI6IHZpc1JlY29yZHMsXG5cdFx0XCJzZXJ2ZXJTaWRlXCI6ICAgICBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09PSAnc3NwJ1xuXHR9O1xufSApO1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBsZW5ndGguIE5vdGUgYC0xYCBpbmRpY2F0ZXMgdGhhdCBhbGwgcmVjb3Jkc1xuICogICBhcmUgdG8gYmUgc2hvd24uXG4gKi8vKipcbiAqIFNldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAncGFnZS5sZW4oKScsIGZ1bmN0aW9uICggbGVuICkge1xuXHQvLyBOb3RlIHRoYXQgd2UgY2FuJ3QgY2FsbCB0aGlzIGZ1bmN0aW9uICdsZW5ndGgoKScgYmVjYXVzZSBgbGVuZ3RoYFxuXHQvLyBpcyBhIEphdmFzY3JpcHQgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHdoaWNoIGRlZmluZXMgaG93IG1hbnkgYXJndW1lbnRzXG5cdC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzLlxuXHRpZiAoIGxlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwID9cblx0XHRcdHRoaXMuY29udGV4dFswXS5faURpc3BsYXlMZW5ndGggOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gZWxzZSwgc2V0IHRoZSBwYWdlIGxlbmd0aFxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCBsZW4gKTtcblx0fSApO1xufSApO1xuXG5cblxudmFyIF9fcmVsb2FkID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uLCBjYWxsYmFjayApIHtcblx0Ly8gVXNlIHRoZSBkcmF3IGV2ZW50IHRvIHRyaWdnZXIgYSBjYWxsYmFja1xuXHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblxuXHRcdGFwaS5vbmUoICdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2FsbGJhY2soIGFwaS5hamF4Lmpzb24oKSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0fVxuXHRlbHNlIHtcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRcdC8vIENhbmNlbCBhbiBleGlzdGluZyByZXF1ZXN0XG5cdFx0dmFyIHhociA9IHNldHRpbmdzLmpxWEhSO1xuXHRcdGlmICggeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciB4aHJcblx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCBbXSwgZnVuY3Rpb24oIGpzb24gKSB7XG5cdFx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXG5cdFx0XHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdF9mbkFkZERhdGEoIHNldHRpbmdzLCBkYXRhW2ldICk7XG5cdFx0XHR9XG5cblx0XHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiApO1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdH0gKTtcblx0fVxufTtcblxuXG4vKipcbiAqIEdldCB0aGUgSlNPTiByZXNwb25zZSBmcm9tIHRoZSBsYXN0IEFqYXggcmVxdWVzdCB0aGF0IERhdGFUYWJsZXMgbWFkZSB0byB0aGVcbiAqIHNlcnZlci4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgSlNPTiBmcm9tIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudFxuICogY29udGV4dC5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IEpTT04gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRyZXR1cm4gY3R4WzBdLmpzb247XG5cdH1cblxuXHQvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG59ICk7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgc3VibWl0dGVkIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC5wYXJhbXMoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdHJldHVybiBjdHhbMF0ub0FqYXhEYXRhO1xuXHR9XG5cblx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xufSApO1xuXG5cbi8qKlxuICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHJlLWRyYXcgdGhlIHRhYmxlIHdoZW4gdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcbiAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcbiAqICAgY2FsbGVkLCB3aGljaCBpcyB3aHkgdGhlIHBhZ2luYXRpb24gcmVzZXQgaXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdhamF4LnJlbG9hZCgpJywgZnVuY3Rpb24gKCBjYWxsYmFjaywgcmVzZXRQYWdpbmcgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHRfX3JlbG9hZCggc2V0dGluZ3MsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdH0gKTtcbn0gKTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgVVJMIGZyb20gdGhlIGZpcnN0XG4gKiB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBBamF4IHNvdXJjZSBVUkxcbiAqLy8qKlxuICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcbiAqIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCknLCBmdW5jdGlvbiAoIHVybCApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIGdldFxuXHRcdGlmICggY3R4Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGN0eCA9IGN0eFswXTtcblxuXHRcdHJldHVybiBjdHguYWpheCA/XG5cdFx0XHQkLmlzUGxhaW5PYmplY3QoIGN0eC5hamF4ICkgP1xuXHRcdFx0XHRjdHguYWpheC51cmwgOlxuXHRcdFx0XHRjdHguYWpheCA6XG5cdFx0XHRjdHguc0FqYXhTb3VyY2U7XG5cdH1cblxuXHQvLyBzZXRcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKSApIHtcblx0XHRcdHNldHRpbmdzLmFqYXgudXJsID0gdXJsO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNldHRpbmdzLmFqYXggPSB1cmw7XG5cdFx0fVxuXHRcdC8vIE5vIG5lZWQgdG8gY29uc2lkZXIgc0FqYXhTb3VyY2UgaGVyZSBzaW5jZSBEYXRhVGFibGVzIGdpdmVzIHByaW9yaXR5XG5cdFx0Ly8gdG8gYGFqYXhgIG92ZXIgYHNBamF4U291cmNlYC4gU28gc2V0dGluZyBgYWpheGAgaGVyZSwgcmVuZGVycyBhbnlcblx0XHQvLyB2YWx1ZSBvZiBgc0FqYXhTb3VyY2VgIHJlZHVuZGFudC5cblx0fSApO1xufSApO1xuXG5cbi8qKlxuICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAqIGF2YWlsYWJsZSB3aGVuIGBhamF4LnVybCgpYCBpcyB1c2VkIHRvIHNldCBhIFVSTC4gQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZFxuICogaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBjYWxsaW5nIGBhamF4LnJlbG9hZCgpYCBidXQgaXMgcHJvdmlkZWQgZm9yXG4gKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyB0aGUgdGFibGUgb25jZSB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC51cmwoKS5sb2FkKCknLCBmdW5jdGlvbiAoIGNhbGxiYWNrLCByZXNldFBhZ2luZyApIHtcblx0Ly8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcblx0Ly8gdXJsIGNoYW5nZVxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0X19yZWxvYWQoIGN0eCwgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0fSApO1xufSApO1xuXG5cblxuXG52YXIgX3NlbGVjdG9yX3J1biA9IGZ1bmN0aW9uICggdHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cyApXG57XG5cdHZhclxuXHRcdG91dCA9IFtdLCByZXMsXG5cdFx0YSwgaSwgaWVuLCBqLCBqZW4sXG5cdFx0c2VsZWN0b3JUeXBlID0gdHlwZW9mIHNlbGVjdG9yO1xuXG5cdC8vIENhbid0IGp1c3QgY2hlY2sgZm9yIGlzQXJyYXkgaGVyZSwgYXMgYW4gQVBJIG9yIGpRdWVyeSBpbnN0YW5jZSBtaWdodCBiZVxuXHQvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xuXHRpZiAoICEgc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c2VsZWN0b3IgPSBbIHNlbGVjdG9yIF07XG5cdH1cblxuXHRmb3IgKCBpPTAsIGllbj1zZWxlY3Rvci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHQvLyBPbmx5IHNwbGl0IG9uIHNpbXBsZSBzdHJpbmdzIC0gY29tcGxleCBleHByZXNzaW9ucyB3aWxsIGJlIGpRdWVyeSBzZWxlY3RvcnNcblx0XHRhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgJiYgISBzZWxlY3RvcltpXS5tYXRjaCgvW1xcW1xcKDpdLykgP1xuXHRcdFx0c2VsZWN0b3JbaV0uc3BsaXQoJywnKSA6XG5cdFx0XHRbIHNlbGVjdG9yW2ldIF07XG5cblx0XHRmb3IgKCBqPTAsIGplbj1hLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0cmVzID0gc2VsZWN0Rm4oIHR5cGVvZiBhW2pdID09PSAnc3RyaW5nJyA/IChhW2pdKS50cmltKCkgOiBhW2pdICk7XG5cblx0XHRcdGlmICggcmVzICYmIHJlcy5sZW5ndGggKSB7XG5cdFx0XHRcdG91dCA9IG91dC5jb25jYXQoIHJlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIHNlbGVjdG9yIGV4dGVuc2lvbnNcblx0dmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbIHR5cGUgXTtcblx0aWYgKCBleHQubGVuZ3RoICkge1xuXHRcdGZvciAoIGk9MCwgaWVuPWV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdG91dCA9IGV4dFtpXSggc2V0dGluZ3MsIG9wdHMsIG91dCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBfdW5pcXVlKCBvdXQgKTtcbn07XG5cblxudmFyIF9zZWxlY3Rvcl9vcHRzID0gZnVuY3Rpb24gKCBvcHRzIClcbntcblx0aWYgKCAhIG9wdHMgKSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIDEuOS0gd2hpY2ggdXNlZCB0aGUgdGVybWlub2xvZ3kgZmlsdGVyIHJhdGhlclxuXHQvLyB0aGFuIHNlYXJjaFxuXHRpZiAoIG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0b3B0cy5zZWFyY2ggPSBvcHRzLmZpbHRlcjtcblx0fVxuXG5cdHJldHVybiAkLmV4dGVuZCgge1xuXHRcdHNlYXJjaDogJ25vbmUnLFxuXHRcdG9yZGVyOiAnY3VycmVudCcsXG5cdFx0cGFnZTogJ2FsbCdcblx0fSwgb3B0cyApO1xufTtcblxuXG52YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKCBpbnN0IClcbntcblx0Ly8gUmVkdWNlIHRoZSBBUEkgaW5zdGFuY2UgdG8gdGhlIGZpcnN0IGl0ZW0gZm91bmRcblx0Zm9yICggdmFyIGk9MCwgaWVuPWluc3QubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0aWYgKCBpbnN0W2ldLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHQvLyBBc3NpZ24gdGhlIGZpcnN0IGVsZW1lbnQgdG8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGluc3RhbmNlXG5cdFx0XHQvLyBhbmQgdHJ1bmNhdGUgdGhlIGluc3RhbmNlIGFuZCBjb250ZXh0XG5cdFx0XHRpbnN0WzBdID0gaW5zdFtpXTtcblx0XHRcdGluc3RbMF0ubGVuZ3RoID0gMTtcblx0XHRcdGluc3QubGVuZ3RoID0gMTtcblx0XHRcdGluc3QuY29udGV4dCA9IFsgaW5zdC5jb250ZXh0W2ldIF07XG5cblx0XHRcdHJldHVybiBpbnN0O1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vdCBmb3VuZCAtIHJldHVybiBhbiBlbXB0eSBpbnN0YW5jZVxuXHRpbnN0Lmxlbmd0aCA9IDA7XG5cdHJldHVybiBpbnN0O1xufTtcblxuXG52YXIgX3NlbGVjdG9yX3Jvd19pbmRleGVzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApXG57XG5cdHZhclxuXHRcdGksIGllbiwgdG1wLCBhPVtdLFxuXHRcdGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcblx0XHRkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXG5cdHZhclxuXHRcdHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuXHRcdG9yZGVyICA9IG9wdHMub3JkZXIsICAgLy8gYXBwbGllZCwgY3VycmVudCwgaW5kZXggKG9yaWdpbmFsIC0gY29tcGF0aWJpbGl0eSB3aXRoIDEuOSlcblx0XHRwYWdlICAgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxuXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG1vZGUsIG1vc3Qgb3B0aW9ucyBhcmUgaXJyZWxldmFudCBzaW5jZVxuXHRcdC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcblx0XHQvLyBSZW1vdmVkIGlzIGEgc3BlY2lhbCBjYXNlIC0gZm9yIGNvbnNpc3RlbmN5IGp1c3QgcmV0dXJuIGFuIGVtcHR5XG5cdFx0Ly8gYXJyYXlcblx0XHRyZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuXHRcdFx0W10gOlxuXHRcdFx0X3JhbmdlKCAwLCBkaXNwbGF5TWFzdGVyLmxlbmd0aCApO1xuXHR9XG5cdGVsc2UgaWYgKCBwYWdlID09ICdjdXJyZW50JyApIHtcblx0XHQvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpbHRlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xuXHRcdC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxuXHRcdC8vIGFyZVxuXHRcdGZvciAoIGk9c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsIGllbj1zZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0YS5wdXNoKCBkaXNwbGF5RmlsdGVyZWRbaV0gKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcgKSB7XG5cdFx0aWYgKCBzZWFyY2ggPT0gJ25vbmUnKSB7XG5cdFx0XHRhID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2VhcmNoID09ICdhcHBsaWVkJyApIHtcblx0XHRcdGEgPSBkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNlYXJjaCA9PSAncmVtb3ZlZCcgKSB7XG5cdFx0XHQvLyBPKG4rbSkgc29sdXRpb24gYnkgY3JlYXRpbmcgYSBoYXNoIG1hcFxuXHRcdFx0dmFyIGRpc3BsYXlGaWx0ZXJlZE1hcCA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGlzcGxheUZpbHRlcmVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRkaXNwbGF5RmlsdGVyZWRNYXBbZGlzcGxheUZpbHRlcmVkW2ldXSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGEgPSAkLm1hcCggZGlzcGxheU1hc3RlciwgZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdHJldHVybiAhIGRpc3BsYXlGaWx0ZXJlZE1hcC5oYXNPd25Qcm9wZXJ0eShlbCkgP1xuXHRcdFx0XHRcdGVsIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggb3JkZXIgPT0gJ2luZGV4JyB8fCBvcmRlciA9PSAnb3JpZ2luYWwnICkge1xuXHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggc2VhcmNoID09ICdub25lJyApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcblx0XHRcdFx0dG1wID0gJC5pbkFycmF5KCBpLCBkaXNwbGF5RmlsdGVyZWQgKTtcblxuXHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHQodG1wID49IDAgICAmJiBzZWFyY2ggPT0gJ2FwcGxpZWQnKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhO1xufTtcblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIFJvd3NcbiAqXG4gKiB7fSAgICAgICAgICAtIG5vIHNlbGVjdG9yIC0gdXNlIGFsbCBhdmFpbGFibGUgcm93c1xuICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XG4gKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcbiAqIHtzdHJpbmd9ICAgIC0galF1ZXJ5IHNlbGVjdG9yIHRvIGFwcGx5IHRvIHRoZSBUUiBlbGVtZW50c1xuICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xuICpcbiAqL1xudmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxue1xuXHR2YXIgcm93cztcblx0dmFyIHJ1biA9IGZ1bmN0aW9uICggc2VsICkge1xuXHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzZWwgKTtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBhb0RhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cblx0XHQvLyBTaG9ydCBjdXQgLSBzZWxlY3RvciBpcyBhIG51bWJlciBhbmQgbm8gb3B0aW9ucyBwcm92aWRlZCAoZGVmYXVsdCBpc1xuXHRcdC8vIGFsbCByZWNvcmRzLCBzbyBubyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbmRleCBpcyBpbiB0aGVyZSwgc2luY2UgaXRcblx0XHQvLyBtdXN0IGJlIC0gZGV2IGVycm9yIGlmIHRoZSBpbmRleCBkb2Vzbid0IGV4aXN0KS5cblx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCAmJiAhIG9wdHMgKSB7XG5cdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHR9XG5cblx0XHRpZiAoICEgcm93cyApIHtcblx0XHRcdHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgJC5pbkFycmF5KCBzZWxJbnQsIHJvd3MgKSAhPT0gLTEgKSB7XG5cdFx0XHQvLyBTZWxlY3RvciAtIGludGVnZXJcblx0XHRcdHJldHVybiBbIHNlbEludCBdO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdW5kZWZpbmVkIHx8IHNlbCA9PT0gJycgKSB7XG5cdFx0XHQvLyBTZWxlY3RvciAtIG5vbmVcblx0XHRcdHJldHVybiByb3dzO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cblx0XHRpZiAoIHR5cGVvZiBzZWwgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRyZXR1cm4gJC5tYXAoIHJvd3MsIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0dmFyIHJvdyA9IGFvRGF0YVsgaWR4IF07XG5cdFx0XHRcdHJldHVybiBzZWwoIGlkeCwgcm93Ll9hRGF0YSwgcm93Lm5UciApID8gaWR4IDogbnVsbDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBTZWxlY3RvciAtIG5vZGVcblx0XHRpZiAoIHNlbC5ub2RlTmFtZSApIHtcblx0XHRcdHZhciByb3dJZHggPSBzZWwuX0RUX1Jvd0luZGV4OyAgLy8gUHJvcGVydHkgYWRkZWQgYnkgRFQgZm9yIGZhc3QgbG9va3VwXG5cdFx0XHR2YXIgY2VsbElkeCA9IHNlbC5fRFRfQ2VsbEluZGV4O1xuXG5cdFx0XHRpZiAoIHJvd0lkeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcm93IGlzIGFjdHVhbGx5IHN0aWxsIHByZXNlbnQgaW4gdGhlIHRhYmxlXG5cdFx0XHRcdHJldHVybiBhb0RhdGFbIHJvd0lkeCBdICYmIGFvRGF0YVsgcm93SWR4IF0ublRyID09PSBzZWwgP1xuXHRcdFx0XHRcdFsgcm93SWR4IF0gOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGNlbGxJZHggKSB7XG5cdFx0XHRcdHJldHVybiBhb0RhdGFbIGNlbGxJZHgucm93IF0gJiYgYW9EYXRhWyBjZWxsSWR4LnJvdyBdLm5UciA9PT0gc2VsLnBhcmVudE5vZGUgP1xuXHRcdFx0XHRcdFsgY2VsbElkeC5yb3cgXSA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGhvc3QgPSAkKHNlbCkuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcblx0XHRcdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFx0XHRbIGhvc3QuZGF0YSgnZHQtcm93JykgXSA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUQgc2VsZWN0b3IuIFdhbnQgdG8gYWx3YXlzIGJlIGFibGUgdG8gc2VsZWN0IHJvd3MgYnkgaWQsIHJlZ2FyZGxlc3Ncblx0XHQvLyBvZiBpZiB0aGUgdHIgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIG5vdCwgc28gY2FuJ3QgcmVseSB1cG9uXG5cdFx0Ly8galF1ZXJ5IGhlcmUgLSBoZW5jZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gVGhpcyBkb2VzIG5vdCBtYXRjaFxuXHRcdC8vIFNpenpsZSdzIGZhc3Qgc2VsZWN0b3Igb3IgSFRNTDQgLSBpbiBIVE1MNSB0aGUgSUQgY2FuIGJlIGFueXRoaW5nLFxuXHRcdC8vIGJ1dCB0byBzZWxlY3QgaXQgdXNpbmcgYSBDU1Mgc2VsZWN0b3IgZW5naW5lIChsaWtlIFNpenpsZSBvclxuXHRcdC8vIHF1ZXJ5U2VsZWN0KSBpdCB3b3VsZCBuZWVkIHRvIG5lZWQgdG8gYmUgZXNjYXBlZCBmb3Igc29tZSBjaGFyYWN0ZXJzLlxuXHRcdC8vIERhdGFUYWJsZXMgc2ltcGxpZmllcyB0aGlzIGZvciByb3cgc2VsZWN0b3JzIHNpbmNlIHlvdSBjYW4gc2VsZWN0XG5cdFx0Ly8gb25seSBhIHJvdy4gQSAjIGluZGljYXRlcyBhbiBpZCBhbnkgYW55dGhpbmcgdGhhdCBmb2xsb3dzIGlzIHRoZSBpZCAtXG5cdFx0Ly8gdW5lc2NhcGVkLlxuXHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ3N0cmluZycgJiYgc2VsLmNoYXJBdCgwKSA9PT0gJyMnICkge1xuXHRcdFx0Ly8gZ2V0IHJvdyBpbmRleCBmcm9tIGlkXG5cdFx0XHR2YXIgcm93T2JqID0gc2V0dGluZ3MuYUlkc1sgc2VsLnJlcGxhY2UoIC9eIy8sICcnICkgXTtcblx0XHRcdGlmICggcm93T2JqICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBbIHJvd09iai5pZHggXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbmVlZCB0byBmYWxsIHRocm91Z2ggdG8galF1ZXJ5IGluIGNhc2UgdGhlcmUgaXMgRE9NIGlkIHRoYXRcblx0XHRcdC8vIG1hdGNoZXNcblx0XHR9XG5cdFx0XG5cdFx0Ly8gR2V0IG5vZGVzIGluIHRoZSBvcmRlciBmcm9tIHRoZSBgcm93c2AgYXJyYXkgd2l0aCBudWxsIHZhbHVlcyByZW1vdmVkXG5cdFx0dmFyIG5vZGVzID0gX3JlbW92ZUVtcHR5KFxuXHRcdFx0X3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICduVHInIClcblx0XHQpO1xuXG5cdFx0Ly8gU2VsZWN0b3IgLSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nLCBhcnJheSBvZiBub2RlcyBvciBqUXVlcnkgb2JqZWN0L1xuXHRcdC8vIEFzIGpRdWVyeSdzIC5maWx0ZXIoKSBhbGxvd3MgalF1ZXJ5IG9iamVjdHMgdG8gYmUgcGFzc2VkIGluIGZpbHRlcixcblx0XHQvLyBpdCBhbHNvIGFsbG93cyBhcnJheXMsIHNvIHRoaXMgd2lsbCBjb3BlIHdpdGggYWxsIHRocmVlIG9wdGlvbnNcblx0XHRyZXR1cm4gJChub2Rlcylcblx0XHRcdC5maWx0ZXIoIHNlbCApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9EVF9Sb3dJbmRleDtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblx0fTtcblxuXHRyZXR1cm4gX3NlbGVjdG9yX3J1biggJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG59O1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyb3dzKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHQvLyBhcmd1bWVudCBzaGlmdGluZ1xuXHRpZiAoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c2VsZWN0b3IgPSAnJztcblx0fVxuXHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KCBzZWxlY3RvciApICkge1xuXHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRzZWxlY3RvciA9ICcnO1xuXHR9XG5cblx0b3B0cyA9IF9zZWxlY3Rvcl9vcHRzKCBvcHRzICk7XG5cblx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBfX3Jvd19zZWxlY3Rvciggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzICk7XG5cdH0sIDEgKTtcblxuXHQvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9fcm93X3NlbGVjdG9yP1xuXHRpbnN0LnNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvcjtcblx0aW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblxuXHRyZXR1cm4gaW5zdDtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MoKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9EYXRhWyByb3cgXS5uVHIgfHwgdW5kZWZpbmVkO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICdyb3dzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggdHJ1ZSwgJ3Jvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3dzICkge1xuXHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ19hRGF0YScgKTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmNhY2hlKCknLCAncm93KCkuY2FjaGUoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0dmFyIHIgPSBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdO1xuXHRcdHJldHVybiB0eXBlID09PSAnc2VhcmNoJyA/IHIuX2FGaWx0ZXJEYXRhIDogci5fYVNvcnREYXRhO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW52YWxpZGF0ZSgpJywgJ3JvdygpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uICggc3JjICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93LCBzcmMgKTtcblx0fSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmluZGV4ZXMoKScsICdyb3coKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHRyZXR1cm4gcm93O1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaWRzKCknLCAncm93KCkuaWQoKScsIGZ1bmN0aW9uICggaGFzaCApIHtcblx0dmFyIGEgPSBbXTtcblx0dmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0Ly8gYGl0ZXJhdG9yYCB3aWxsIGRyb3AgdW5kZWZpbmVkIHZhbHVlcywgYnV0IGluIHRoaXMgY2FzZSB3ZSB3YW50IHRoZW1cblx0Zm9yICggdmFyIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0Zm9yICggdmFyIGo9MCwgamVuPXRoaXNbaV0ubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHR2YXIgaWQgPSBjb250ZXh0W2ldLnJvd0lkRm4oIGNvbnRleHRbaV0uYW9EYXRhWyB0aGlzW2ldW2pdIF0uX2FEYXRhICk7XG5cdFx0XHRhLnB1c2goIChoYXNoID09PSB0cnVlID8gJyMnIDogJycgKSsgaWQgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3IF9BcGkoIGNvbnRleHQsIGEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5yZW1vdmUoKScsICdyb3coKS5yZW1vdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIHRoYXRJZHggKSB7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHJvd0RhdGEgPSBkYXRhWyByb3cgXTtcblx0XHR2YXIgaSwgaWVuLCBqLCBqZW47XG5cdFx0dmFyIGxvb3BSb3csIGxvb3BDZWxscztcblxuXHRcdGRhdGEuc3BsaWNlKCByb3csIDEgKTtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgY2FjaGVkIGluZGV4ZXNcblx0XHRmb3IgKCBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0bG9vcFJvdyA9IGRhdGFbaV07XG5cdFx0XHRsb29wQ2VsbHMgPSBsb29wUm93LmFuQ2VsbHM7XG5cblx0XHRcdC8vIFJvd3Ncblx0XHRcdGlmICggbG9vcFJvdy5uVHIgIT09IG51bGwgKSB7XG5cdFx0XHRcdGxvb3BSb3cublRyLl9EVF9Sb3dJbmRleCA9IGk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENlbGxzXG5cdFx0XHRpZiAoIGxvb3BDZWxscyAhPT0gbnVsbCApIHtcblx0XHRcdFx0Zm9yICggaj0wLCBqZW49bG9vcENlbGxzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdGxvb3BDZWxsc1tqXS5fRFRfQ2VsbEluZGV4LnJvdyA9IGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHRfZm5EZWxldGVJbmRleCggc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLCByb3cgKTtcblx0XHRfZm5EZWxldGVJbmRleCggc2V0dGluZ3MuYWlEaXNwbGF5LCByb3cgKTtcblx0XHRfZm5EZWxldGVJbmRleCggdGhhdFsgdGhhdElkeCBdLCByb3csIGZhbHNlICk7IC8vIG1haW50YWluIGxvY2FsIGluZGV4ZXNcblxuXHRcdC8vIEZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcyAtIHN1YnRyYWN0IHRoZSBkZWxldGVkIHJvdyBmcm9tIHRoZSBjb3VudFxuXHRcdGlmICggc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA+IDAgKSB7XG5cdFx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5LS07XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIGFuICdvdmVyZmxvdycgdGhleSBjYXNlIGZvciBkaXNwbGF5aW5nIHRoZSB0YWJsZVxuXHRcdF9mbkxlbmd0aE92ZXJmbG93KCBzZXR0aW5ncyApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSByb3cncyBJRCByZWZlcmVuY2UgaWYgdGhlcmUgaXMgb25lXG5cdFx0dmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbiggcm93RGF0YS5fYURhdGEgKTtcblx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkZWxldGUgc2V0dGluZ3MuYUlkc1sgaWQgXTtcblx0XHR9XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRzZXR0aW5ncy5hb0RhdGFbaV0uaWR4ID0gaTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncm93cy5hZGQoKScsIGZ1bmN0aW9uICggcm93cyApIHtcblx0dmFyIG5ld1Jvd3MgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIHJvdywgaSwgaWVuO1xuXHRcdFx0dmFyIG91dCA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXG5cdFx0XHRcdGlmICggcm93Lm5vZGVOYW1lICYmIHJvdy5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVFInICkge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fSwgMSApO1xuXG5cdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCBzbyByb3dzKCkubm9kZXMoKSBldGMgY2FuIGJlIHVzZWRcblx0dmFyIG1vZFJvd3MgPSB0aGlzLnJvd3MoIC0xICk7XG5cdG1vZFJvd3MucG9wKCk7XG5cdCQubWVyZ2UoIG1vZFJvd3MsIG5ld1Jvd3MgKTtcblxuXHRyZXR1cm4gbW9kUm93cztcbn0gKTtcblxuXG5cblxuXG4vKipcbiAqXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdyb3coKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdHJldHVybiBfc2VsZWN0b3JfZmlyc3QoIHRoaXMucm93cyggc2VsZWN0b3IsIG9wdHMgKSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyb3coKS5kYXRhKCknLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gR2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9hRGF0YSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTZXRcblx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXTtcblx0cm93Ll9hRGF0YSA9IGRhdGE7XG5cblx0Ly8gSWYgdGhlIERPTSBoYXMgYW4gaWQsIGFuZCB0aGUgZGF0YSBzb3VyY2UgaXMgYW4gYXJyYXlcblx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhICkgJiYgcm93Lm5UciAmJiByb3cublRyLmlkICkge1xuXHRcdF9mblNldE9iamVjdERhdGFGbiggY3R4WzBdLnJvd0lkICkoIGRhdGEsIHJvdy5uVHIuaWQgKTtcblx0fVxuXG5cdC8vIEF1dG9tYXRpY2FsbHkgaW52YWxpZGF0ZVxuXHRfZm5JbnZhbGlkYXRlKCBjdHhbMF0sIHRoaXNbMF0sICdkYXRhJyApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyb3coKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5uVHIgfHwgbnVsbCA6XG5cdFx0bnVsbDtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncm93LmFkZCgpJywgZnVuY3Rpb24gKCByb3cgKSB7XG5cdC8vIEFsbG93IGEgalF1ZXJ5IG9iamVjdCB0byBiZSBwYXNzZWQgaW4gLSBvbmx5IGEgc2luZ2xlIHJvdyBpcyBhZGRlZCBmcm9tXG5cdC8vIGl0IHRob3VnaCAtIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcblx0aWYgKCByb3cgaW5zdGFuY2VvZiAkICYmIHJvdy5sZW5ndGggKSB7XG5cdFx0cm93ID0gcm93WzBdO1xuXHR9XG5cblx0dmFyIHJvd3MgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggcm93Lm5vZGVOYW1lICYmIHJvdy5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVFInICkge1xuXHRcdFx0cmV0dXJuIF9mbkFkZFRyKCBzZXR0aW5ncywgcm93IClbMF07XG5cdFx0fVxuXHRcdHJldHVybiBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICk7XG5cdH0gKTtcblxuXHQvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgcm93IHNlbGVjdGVkXG5cdHJldHVybiB0aGlzLnJvdyggcm93c1swXSApO1xufSApO1xuXG5cbiQoZG9jdW1lbnQpLm9uKCdwbHVnaW4taW5pdC5kdCcsIGZ1bmN0aW9uIChlLCBjb250ZXh0KSB7XG5cdHZhciBhcGkgPSBuZXcgX0FwaSggY29udGV4dCApO1xuXHR2YXIgbmFtZXNwYWNlID0gJ29uLXBsdWdpbi1pbml0Jztcblx0dmFyIHN0YXRlU2F2ZVBhcmFtc0V2ZW50ID0gJ3N0YXRlU2F2ZVBhcmFtcy4nICsgbmFtZXNwYWNlO1xuXHR2YXIgZGVzdHJveUV2ZW50ID0gJ2Rlc3Ryb3kuICcgKyBuYW1lc3BhY2U7XG5cblx0YXBpLm9uKCBzdGF0ZVNhdmVQYXJhbXNFdmVudCwgZnVuY3Rpb24gKCBlLCBzZXR0aW5ncywgZCApIHtcblx0XHQvLyBUaGlzIGNvdWxkIGJlIG1vcmUgY29tcGFjdCB3aXRoIHRoZSBBUEksIGJ1dCBpdCBpcyBhIGxvdCBmYXN0ZXIgYXMgYSBzaW1wbGVcblx0XHQvLyBpbnRlcm5hbCBsb29wXG5cdFx0dmFyIGlkRm4gPSBzZXR0aW5ncy5yb3dJZEZuO1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdHZhciBpZHMgPSBbXTtcblxuXHRcdGZvciAodmFyIGk9MCA7IGk8ZGF0YS5sZW5ndGggOyBpKyspIHtcblx0XHRcdGlmIChkYXRhW2ldLl9kZXRhaWxzU2hvdykge1xuXHRcdFx0XHRpZHMucHVzaCggJyMnICsgaWRGbihkYXRhW2ldLl9hRGF0YSkgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRkLmNoaWxkUm93cyA9IGlkcztcblx0fSk7XG5cblx0YXBpLm9uKCBkZXN0cm95RXZlbnQsIGZ1bmN0aW9uICgpIHtcblx0XHRhcGkub2ZmKHN0YXRlU2F2ZVBhcmFtc0V2ZW50ICsgJyAnICsgZGVzdHJveUV2ZW50KTtcblx0fSk7XG5cblx0dmFyIGxvYWRlZCA9IGFwaS5zdGF0ZS5sb2FkZWQoKTtcblxuXHRpZiAoIGxvYWRlZCAmJiBsb2FkZWQuY2hpbGRSb3dzICkge1xuXHRcdGFwaVxuXHRcdFx0LnJvd3MoICQubWFwKGxvYWRlZC5jaGlsZFJvd3MsIGZ1bmN0aW9uIChpZCl7XG5cdFx0XHRcdHJldHVybiBpZC5yZXBsYWNlKC86L2csICdcXFxcOicpXG5cdFx0XHR9KSApXG5cdFx0XHQuZXZlcnkoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBjb250ZXh0LCBudWxsLCAncmVxdWVzdENoaWxkJywgWyB0aGlzIF0gKVxuXHRcdFx0fSk7XG5cdH1cbn0pO1xuXG52YXIgX19kZXRhaWxzX2FkZCA9IGZ1bmN0aW9uICggY3R4LCByb3csIGRhdGEsIGtsYXNzIClcbntcblx0Ly8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuXHR2YXIgcm93cyA9IFtdO1xuXHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCByLCBrICkge1xuXHRcdC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCByICkgfHwgciBpbnN0YW5jZW9mICQgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YWRkUm93KCByW2ldLCBrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHQvLyB0byBhZGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMgZXRjXG5cdFx0aWYgKCByLm5vZGVOYW1lICYmIHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJyApIHtcblx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdHZhciBjcmVhdGVkID0gJCgnPHRyPjx0ZD48L3RkPjwvdHI+JykuYWRkQ2xhc3MoIGsgKTtcblx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0LmFkZENsYXNzKCBrIClcblx0XHRcdFx0Lmh0bWwoIHIgKVxuXHRcdFx0XHRbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXG5cdFx0XHRyb3dzLnB1c2goIGNyZWF0ZWRbMF0gKTtcblx0XHR9XG5cdH07XG5cblx0YWRkUm93KCBkYXRhLCBrbGFzcyApO1xuXG5cdGlmICggcm93Ll9kZXRhaWxzICkge1xuXHRcdHJvdy5fZGV0YWlscy5kZXRhY2goKTtcblx0fVxuXG5cdHJvdy5fZGV0YWlscyA9ICQocm93cyk7XG5cblx0Ly8gSWYgdGhlIGNoaWxkcmVuIHdlcmUgYWxyZWFkeSBzaG93biwgdGhhdCBzdGF0ZSBzaG91bGQgYmUgcmV0YWluZWRcblx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHR9XG59O1xuXG5cbi8vIE1ha2Ugc3RhdGUgc2F2aW5nIG9mIGNoaWxkIHJvdyBkZXRhaWxzIGFzeW5jIHRvIGFsbG93IHRoZW0gdG8gYmUgYmF0Y2ggcHJvY2Vzc2VkXG52YXIgX19kZXRhaWxzX3N0YXRlID0gRGF0YVRhYmxlLnV0aWwudGhyb3R0bGUoXG5cdGZ1bmN0aW9uIChjdHgpIHtcblx0XHRfZm5TYXZlU3RhdGUoIGN0eFswXSApXG5cdH0sXG5cdDUwMFxuKTtcblxuXG52YXIgX19kZXRhaWxzX3JlbW92ZSA9IGZ1bmN0aW9uICggYXBpLCBpZHggKVxue1xuXHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoICkge1xuXHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXSBdO1xuXG5cdFx0aWYgKCByb3cgJiYgcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0cm93Ll9kZXRhaWxzLnJlbW92ZSgpO1xuXG5cdFx0XHRyb3cuX2RldGFpbHNTaG93ID0gdW5kZWZpbmVkO1xuXHRcdFx0cm93Ll9kZXRhaWxzID0gdW5kZWZpbmVkO1xuXHRcdFx0JCggcm93Lm5UciApLnJlbW92ZUNsYXNzKCAnZHQtaGFzQ2hpbGQnICk7XG5cdFx0XHRfX2RldGFpbHNfc3RhdGUoIGN0eCApO1xuXHRcdH1cblx0fVxufTtcblxuXG52YXIgX19kZXRhaWxzX2Rpc3BsYXkgPSBmdW5jdGlvbiAoIGFwaSwgc2hvdyApIHtcblx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCAmJiBhcGkubGVuZ3RoICkge1xuXHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyBhcGlbMF0gXTtcblxuXHRcdGlmICggcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHNob3c7XG5cblx0XHRcdGlmICggc2hvdyApIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdCQoIHJvdy5uVHIgKS5hZGRDbGFzcyggJ2R0LWhhc0NoaWxkJyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJvdy5fZGV0YWlscy5kZXRhY2goKTtcblx0XHRcdFx0JCggcm93Lm5UciApLnJlbW92ZUNsYXNzKCAnZHQtaGFzQ2hpbGQnICk7XG5cdFx0XHR9XG5cblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggY3R4WzBdLCBudWxsLCAnY2hpbGRSb3cnLCBbIHNob3csIGFwaS5yb3coIGFwaVswXSApIF0gKVxuXG5cdFx0XHRfX2RldGFpbHNfZXZlbnRzKCBjdHhbMF0gKTtcblx0XHRcdF9fZGV0YWlsc19zdGF0ZSggY3R4ICk7XG5cdFx0fVxuXHR9XG59O1xuXG5cbnZhciBfX2RldGFpbHNfZXZlbnRzID0gZnVuY3Rpb24gKCBzZXR0aW5ncyApXG57XG5cdHZhciBhcGkgPSBuZXcgX0FwaSggc2V0dGluZ3MgKTtcblx0dmFyIG5hbWVzcGFjZSA9ICcuZHQuRFRfZGV0YWlscyc7XG5cdHZhciBkcmF3RXZlbnQgPSAnZHJhdycrbmFtZXNwYWNlO1xuXHR2YXIgY29sdmlzRXZlbnQgPSAnY29sdW1uLXNpemluZycrbmFtZXNwYWNlO1xuXHR2YXIgZGVzdHJveUV2ZW50ID0gJ2Rlc3Ryb3knK25hbWVzcGFjZTtcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cblx0YXBpLm9mZiggZHJhd0V2ZW50ICsnICcrIGNvbHZpc0V2ZW50ICsnICcrIGRlc3Ryb3lFdmVudCApO1xuXG5cdGlmICggX3BsdWNrKCBkYXRhLCAnX2RldGFpbHMnICkubGVuZ3RoID4gMCApIHtcblx0XHQvLyBPbiBlYWNoIGRyYXcsIGluc2VydCB0aGUgcmVxdWlyZWQgZWxlbWVudHMgaW50byB0aGUgZG9jdW1lbnRcblx0XHRhcGkub24oIGRyYXdFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0YXBpLnJvd3MoIHtwYWdlOidjdXJyZW50J30gKS5lcSgwKS5lYWNoKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdC8vIEludGVybmFsIGRhdGEgZ3JhYlxuXHRcdFx0XHR2YXIgcm93ID0gZGF0YVsgaWR4IF07XG5cblx0XHRcdFx0aWYgKCByb3cuX2RldGFpbHNTaG93ICkge1xuXHRcdFx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gQ29sdW1uIHZpc2liaWxpdHkgY2hhbmdlIC0gdXBkYXRlIHRoZSBjb2xzcGFuXG5cdFx0YXBpLm9uKCBjb2x2aXNFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHgsIGlkeCwgdmlzICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgY29sc3BhbiBmb3IgdGhlIGRldGFpbHMgcm93cyAobm90ZSwgb25seSBpZiBpdCBhbHJlYWR5IGhhc1xuXHRcdFx0Ly8gYSBjb2xzcGFuKVxuXHRcdFx0dmFyIHJvdywgdmlzaWJsZSA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cm93ID0gZGF0YVtpXTtcblxuXHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRyb3cuX2RldGFpbHMuY2hpbGRyZW4oJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIHZpc2libGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIFRhYmxlIGRlc3Ryb3llZCAtIG51a2UgYW55IGNoaWxkIHJvd3Ncblx0XHRhcGkub24oIGRlc3Ryb3lFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggZGF0YVtpXS5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRfX2RldGFpbHNfcmVtb3ZlKCBhcGksIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufTtcblxuLy8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxudmFyIF9lbXAgPSAnJztcbnZhciBfY2hpbGRfb2JqID0gX2VtcCsncm93KCkuY2hpbGQnO1xudmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqKycoKSc7XG5cbi8vIGRhdGEgY2FuIGJlOlxuLy8gIHRyXG4vLyAgc3RyaW5nXG4vLyAgalF1ZXJ5IG9yIGFycmF5IG9mIGFueSBvZiB0aGUgYWJvdmVcbl9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9tdGgsIGZ1bmN0aW9uICggZGF0YSwga2xhc3MgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuXHRcdFx0Y3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXHRlbHNlIGlmICggZGF0YSA9PT0gdHJ1ZSApIHtcblx0XHQvLyBzaG93XG5cdFx0dGhpcy5jaGlsZC5zaG93KCk7XG5cdH1cblx0ZWxzZSBpZiAoIGRhdGEgPT09IGZhbHNlICkge1xuXHRcdC8vIHJlbW92ZVxuXHRcdF9fZGV0YWlsc19yZW1vdmUoIHRoaXMgKTtcblx0fVxuXHRlbHNlIGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCApIHtcblx0XHQvLyBzZXRcblx0XHRfX2RldGFpbHNfYWRkKCBjdHhbMF0sIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXSwgZGF0YSwga2xhc3MgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoIFtcblx0X2NoaWxkX29iaisnLnNob3coKScsXG5cdF9jaGlsZF9tdGgrJy5zaG93KCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcbl0sIGZ1bmN0aW9uICggc2hvdyApIHsgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRfX2RldGFpbHNfZGlzcGxheSggdGhpcywgdHJ1ZSApO1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdF9jaGlsZF9vYmorJy5oaWRlKCknLFxuXHRfY2hpbGRfbXRoKycuaGlkZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5dLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoIFtcblx0X2NoaWxkX29iaisnLnJlbW92ZSgpJyxcblx0X2NoaWxkX210aCsnLnJlbW92ZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5dLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9vYmorJy5pc1Nob3duKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICkge1xuXHRcdC8vIF9kZXRhaWxzU2hvd24gYXMgZmFsc2Ugb3IgdW5kZWZpbmVkIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0uX2RldGFpbHNTaG93IHx8IGZhbHNlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn0gKTtcblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogQ29sdW1uc1xuICpcbiAqIHtpbnRlZ2VyfSAgICAgICAgICAgLSBjb2x1bW4gaW5kZXggKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG4gKiBcIntpbnRlZ2VyfTp2aXNJZHhcIiAgLSB2aXNpYmxlIGNvbHVtbiBpbmRleCAoaS5lLiB0cmFuc2xhdGUgdG8gY29sdW1uIGluZGV4KSAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG4gKiBcIntpbnRlZ2VyfTp2aXNpYmxlXCIgLSBhbGlhcyBmb3Ige2ludGVnZXJ9OnZpc0lkeCAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG4gKiBcIntzdHJpbmd9Om5hbWVcIiAgICAgLSBjb2x1bW4gbmFtZVxuICogXCJ7c3RyaW5nfVwiICAgICAgICAgIC0galF1ZXJ5IHNlbGVjdG9yIG9uIGNvbHVtbiBoZWFkZXIgbm9kZXNcbiAqXG4gKi9cblxuLy8gY2FuIGJlIGFuIGFycmF5IG9mIHRoZXNlIGl0ZW1zLCBjb21tYSBzZXBhcmF0ZWQgbGlzdCwgb3IgYW4gYXJyYXkgb2YgY29tbWFcbi8vIHNlcGFyYXRlZCBsaXN0c1xuXG52YXIgX19yZV9jb2x1bW5fc2VsZWN0b3IgPSAvXihbXjpdKyk6KG5hbWV8dmlzSWR4fHZpc2libGUpJC87XG5cblxuLy8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXG4vLyBpdGVyYXRvciBjYWxsYmFjayBpbiBjb2x1bW5zKCkuZGF0YSgpXG52YXIgX19jb2x1bW5EYXRhID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MgKSB7XG5cdHZhciBhID0gW107XG5cdGZvciAoIHZhciByb3c9MCwgaWVuPXJvd3MubGVuZ3RoIDsgcm93PGllbiA7IHJvdysrICkge1xuXHRcdGEucHVzaCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbiApICk7XG5cdH1cblx0cmV0dXJuIGE7XG59O1xuXG5cbnZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcbntcblx0dmFyXG5cdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRuYW1lcyA9IF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApLFxuXHRcdG5vZGVzID0gX3BsdWNrKCBjb2x1bW5zLCAnblRoJyApO1xuXG5cdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHMgKTtcblxuXHRcdC8vIFNlbGVjdG9yIC0gYWxsXG5cdFx0aWYgKCBzID09PSAnJyApIHtcblx0XHRcdHJldHVybiBfcmFuZ2UoIGNvbHVtbnMubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdGlmICggc2VsSW50ICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIFsgc2VsSW50ID49IDAgP1xuXHRcdFx0XHRzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcblx0XHRcdFx0Y29sdW1ucy5sZW5ndGggKyBzZWxJbnQgLy8gQ291bnQgZnJvbSByaWdodCAoKyBiZWNhdXNlIGl0cyBhIG5lZ2F0aXZlIHZhbHVlKVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHQvLyBTZWxlY3RvciA9IGZ1bmN0aW9uXG5cdFx0aWYgKCB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXG5cdFx0XHRyZXR1cm4gJC5tYXAoIGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gcyhcblx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyApLFxuXHRcdFx0XHRcdFx0bm9kZXNbIGlkeCBdXG5cdFx0XHRcdFx0KSA/IGlkeCA6IG51bGw7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxuXHRcdHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XG5cdFx0XHRzLm1hdGNoKCBfX3JlX2NvbHVtbl9zZWxlY3RvciApIDpcblx0XHRcdCcnO1xuXG5cdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdHN3aXRjaCggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdGNhc2UgJ3Zpc0lkeCc6XG5cdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxuXHRcdFx0XHRcdHZhciBpZHggPSBwYXJzZUludCggbWF0Y2hbMV0sIDEwICk7XG5cdFx0XHRcdFx0Ly8gVmlzaWJsZSBpbmRleCBnaXZlbiwgY29udmVydCB0byBjb2x1bW4gaW5kZXhcblx0XHRcdFx0XHRpZiAoIGlkeCA8IDAgKSB7XG5cdFx0XHRcdFx0XHQvLyBDb3VudGluZyBmcm9tIHRoZSByaWdodFxuXHRcdFx0XHRcdFx0dmFyIHZpc0NvbHVtbnMgPSAkLm1hcCggY29sdW1ucywgZnVuY3Rpb24gKGNvbCxpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb2wuYlZpc2libGUgPyBpIDogbnVsbDtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBbIHZpc0NvbHVtbnNbIHZpc0NvbHVtbnMubGVuZ3RoICsgaWR4IF0gXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgbGVmdFxuXHRcdFx0XHRcdHJldHVybiBbIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBzZXR0aW5ncywgaWR4ICkgXTtcblxuXHRcdFx0XHRjYXNlICduYW1lJzpcblx0XHRcdFx0XHQvLyBtYXRjaCBieSBuYW1lLiBgbmFtZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdFx0XHRyZXR1cm4gJC5tYXAoIG5hbWVzLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgPT09IG1hdGNoWzFdID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENlbGwgaW4gdGhlIHRhYmxlIGJvZHlcblx0XHRpZiAoIHMubm9kZU5hbWUgJiYgcy5fRFRfQ2VsbEluZGV4ICkge1xuXHRcdFx0cmV0dXJuIFsgcy5fRFRfQ2VsbEluZGV4LmNvbHVtbiBdO1xuXHRcdH1cblxuXHRcdC8vIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgVEggZWxlbWVudHMgZm9yIHRoZSBjb2x1bW5zXG5cdFx0dmFyIGpxUmVzdWx0ID0gJCggbm9kZXMgKVxuXHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiAkLmluQXJyYXkoIHRoaXMsIG5vZGVzICk7IC8vIGBub2Rlc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0fSApXG5cdFx0XHQudG9BcnJheSgpO1xuXG5cdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSBhIG5vZGUgd2hpY2ggbWlnaHQgaGF2ZSBhIGBkdC1jb2x1bW5gIGRhdGEgYXR0cmlidXRlLCBvciBiZVxuXHRcdC8vIGEgY2hpbGQgb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0dmFyIGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1jb2x1bW5dJyk7XG5cdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFsgaG9zdC5kYXRhKCdkdC1jb2x1bW4nKSBdIDpcblx0XHRcdFtdO1xuXHR9O1xuXG5cdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY29sdW1uJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcbn07XG5cblxudmFyIF9fc2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKSB7XG5cdHZhclxuXHRcdGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0Y29sICA9IGNvbHNbIGNvbHVtbiBdLFxuXHRcdGRhdGEgPSBzZXR0aW5ncy5hb0RhdGEsXG5cdFx0cm93LCBjZWxscywgaSwgaWVuLCB0cjtcblxuXHQvLyBHZXRcblx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gY29sLmJWaXNpYmxlO1xuXHR9XG5cblx0Ly8gU2V0XG5cdC8vIE5vIGNoYW5nZVxuXHRpZiAoIGNvbC5iVmlzaWJsZSA9PT0gdmlzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggdmlzICkge1xuXHRcdC8vIEluc2VydCBjb2x1bW5cblx0XHQvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxuXHRcdHZhciBpbnNlcnRCZWZvcmUgPSAkLmluQXJyYXkoIHRydWUsIF9wbHVjayhjb2xzLCAnYlZpc2libGUnKSwgY29sdW1uKzEgKTtcblxuXHRcdGZvciAoIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR0ciA9IGRhdGFbaV0ublRyO1xuXHRcdFx0Y2VsbHMgPSBkYXRhW2ldLmFuQ2VsbHM7XG5cblx0XHRcdGlmICggdHIgKSB7XG5cdFx0XHRcdC8vIGluc2VydEJlZm9yZSBjYW4gYWN0IGxpa2UgYXBwZW5kQ2hpbGQgaWYgMm5kIGFyZyBpcyBudWxsXG5cdFx0XHRcdHRyLmluc2VydEJlZm9yZSggY2VsbHNbIGNvbHVtbiBdLCBjZWxsc1sgaW5zZXJ0QmVmb3JlIF0gfHwgbnVsbCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHQvLyBSZW1vdmUgY29sdW1uXG5cdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sdW1uICkgKS5kZXRhY2goKTtcblx0fVxuXG5cdC8vIENvbW1vbiBhY3Rpb25zXG5cdGNvbC5iVmlzaWJsZSA9IHZpcztcbn07XG5cblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbnMoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzZWxlY3RvciA9ICcnO1xuXHR9XG5cdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdHNlbGVjdG9yID0gJyc7XG5cdH1cblxuXHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblxuXHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0fSwgMSApO1xuXG5cdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cblx0aW5zdC5zZWxlY3Rvci5jb2xzID0gc2VsZWN0b3I7XG5cdGluc3Quc2VsZWN0b3Iub3B0cyA9IG9wdHM7XG5cblx0cmV0dXJuIGluc3Q7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRoO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRmO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YSgpJywgJ2NvbHVtbigpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIF9fY29sdW1uRGF0YSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmRhdGFTcmMoKScsICdjb2x1bW4oKS5kYXRhU3JjKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5tRGF0YTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmNhY2hlKCknLCAnY29sdW1uKCkuY2FjaGUoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXG5cdFx0XHR0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnLCBjb2x1bW5cblx0XHQpO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzICkge1xuXHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4gKSA7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS52aXNpYmxlKCknLCAnY29sdW1uKCkudmlzaWJsZSgpJywgZnVuY3Rpb24gKCB2aXMsIGNhbGMgKSB7XG5cdHZhciB0aGF0ID0gdGhpcztcblx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbHVtbiBdLmJWaXNpYmxlO1xuXHRcdH0gLy8gZWxzZVxuXHRcdF9fc2V0Q29sdW1uVmlzKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKTtcblx0fSApO1xuXG5cdC8vIEdyb3VwIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2VzXG5cdGlmICggdmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdC8vIFJlZHJhdyB0aGUgaGVhZGVyIGFmdGVyIGNoYW5nZXNcblx0XHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9IZWFkZXIgKTtcblx0XHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblx0XG5cdFx0XHQvLyBVcGRhdGUgY29sc3BhbiBmb3Igbm8gcmVjb3JkcyBkaXNwbGF5LiBDaGlsZCByb3dzIGFuZCBleHRlbnNpb25zIHdpbGwgdXNlIHRoZWlyIG93blxuXHRcdFx0Ly8gbGlzdGVuZXJzIHRvIGRvIHRoaXMgLSBvbmx5IG5lZWQgdG8gdXBkYXRlIHRoZSBlbXB0eSB0YWJsZSBpdGVtIGhlcmVcblx0XHRcdGlmICggISBzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoICkge1xuXHRcdFx0XHQkKHNldHRpbmdzLm5UQm9keSkuZmluZCgndGRbY29sc3Bhbl0nKS5hdHRyKCdjb2xzcGFuJywgX2ZuVmlzYmxlQ29sdW1ucyhzZXR0aW5ncykpO1xuXHRcdFx0fVxuXHRcblx0XHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblxuXHRcdFx0Ly8gU2Vjb25kIGxvb3Agb25jZSB0aGUgZmlyc3QgaXMgZG9uZSBmb3IgZXZlbnRzXG5cdFx0XHR0aGF0Lml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjXSApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjICkge1xuXHRcdFx0XHR0aGF0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gdHlwZSA9PT0gJ3Zpc2libGUnID9cblx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICkgOlxuXHRcdFx0Y29sdW1uO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zLmFkanVzdCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbi5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlLCBpZHggKSB7XG5cdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdFx0aWYgKCB0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnICkge1xuXHRcdFx0cmV0dXJuIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBjdHgsIGlkeCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJyApIHtcblx0XHRcdHJldHVybiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggY3R4LCBpZHggKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbigpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jb2x1bW5zKCBzZWxlY3Rvciwgb3B0cyApICk7XG59ICk7XG5cbnZhciBfX2NlbGxfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG57XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0dmFyIGNlbGxzID0gX3JlbW92ZUVtcHR5KCBfcGx1Y2tfb3JkZXIoIGRhdGEsIHJvd3MsICdhbkNlbGxzJyApICk7XG5cdHZhciBhbGxDZWxscyA9ICQoX2ZsYXR0ZW4oIFtdLCBjZWxscyApKTtcblx0dmFyIHJvdztcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHR2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xuXG5cdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0dmFyIGZuU2VsZWN0b3IgPSB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJztcblxuXHRcdGlmICggcyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQgfHwgZm5TZWxlY3RvciApIHtcblx0XHRcdC8vIEFsbCBjZWxscyBhbmQgZnVuY3Rpb24gc2VsZWN0b3JzXG5cdFx0XHRhID0gW107XG5cblx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cblx0XHRcdFx0Zm9yICggaj0wIDsgajxjb2x1bW5zIDsgaisrICkge1xuXHRcdFx0XHRcdG8gPSB7XG5cdFx0XHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0XHRcdGNvbHVtbjogalxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRob3N0ID0gZGF0YVsgcm93IF07XG5cblx0XHRcdFx0XHRcdGlmICggcyggbywgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgaiksIGhvc3QuYW5DZWxscyA/IGhvc3QuYW5DZWxsc1tqXSA6IG51bGwgKSApIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzICkgKSB7XG5cdFx0XHQvLyBWYWxpZCBjZWxsIGluZGV4IGFuZCBpdHMgaW4gdGhlIGFycmF5IG9mIHNlbGVjdGFibGUgcm93c1xuXHRcdFx0cmV0dXJuIHMuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgcy5yb3cgIT09IHVuZGVmaW5lZCAmJiAkLmluQXJyYXkoIHMucm93LCByb3dzICkgIT09IC0xID9cblx0XHRcdFx0W3NdIDpcblx0XHRcdFx0W107XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBqUXVlcnkgZmlsdGVyZWQgY2VsbHNcblx0XHR2YXIganFSZXN1bHQgPSBhbGxDZWxsc1xuXHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoaSwgZWwpIHtcblx0XHRcdFx0cmV0dXJuIHsgLy8gdXNlIGEgbmV3IG9iamVjdCwgaW4gY2FzZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlc1xuXHRcdFx0XHRcdHJvdzogICAgZWwuX0RUX0NlbGxJbmRleC5yb3csXG5cdFx0XHRcdFx0Y29sdW1uOiBlbC5fRFRfQ2VsbEluZGV4LmNvbHVtblxuIFx0XHRcdFx0fTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblxuXHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdHJldHVybiBqcVJlc3VsdDtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgdGhlIHNlbGVjdG9yIGlzIGEgbm9kZSwgYW5kIHRoZXJlIGlzIG9uZSBsYXN0IG9wdGlvbiAtIHRoZVxuXHRcdC8vIGVsZW1lbnQgbWlnaHQgYmUgYSBjaGlsZCBvZiBhbiBlbGVtZW50IHdoaWNoIGhhcyBkdC1yb3cgYW5kIGR0LWNvbHVtblxuXHRcdC8vIGRhdGEgYXR0cmlidXRlc1xuXHRcdGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1yb3ddJyk7XG5cdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFsge1xuXHRcdFx0XHRyb3c6IGhvc3QuZGF0YSgnZHQtcm93JyksXG5cdFx0XHRcdGNvbHVtbjogaG9zdC5kYXRhKCdkdC1jb2x1bW4nKVxuXHRcdFx0fSBdIDpcblx0XHRcdFtdO1xuXHR9O1xuXG5cdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY2VsbCcsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG59O1xuXG5cblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKScsIGZ1bmN0aW9uICggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkge1xuXHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcm93U2VsZWN0b3IgKSApIHtcblx0XHQvLyBJbmRleGVzXG5cdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIFNlbGVjdG9yIG9wdGlvbnMgaW4gZmlyc3QgcGFyYW1ldGVyXG5cdFx0XHRvcHRzID0gcm93U2VsZWN0b3I7XG5cdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHRcdH1cblx0fVxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggY29sdW1uU2VsZWN0b3IgKSApIHtcblx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHR9XG5cblx0Ly8gQ2VsbCBzZWxlY3RvclxuXHRpZiAoIGNvbHVtblNlbGVjdG9yID09PSBudWxsIHx8IGNvbHVtblNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX19jZWxsX3NlbGVjdG9yKCBzZXR0aW5ncywgcm93U2VsZWN0b3IsIF9zZWxlY3Rvcl9vcHRzKCBvcHRzICkgKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBUaGUgZGVmYXVsdCBidWlsdCBpbiBvcHRpb25zIG5lZWQgdG8gYXBwbHkgdG8gcm93IGFuZCBjb2x1bW5zXG5cdHZhciBpbnRlcm5hbE9wdHMgPSBvcHRzID8ge1xuXHRcdHBhZ2U6IG9wdHMucGFnZSxcblx0XHRvcmRlcjogb3B0cy5vcmRlcixcblx0XHRzZWFyY2g6IG9wdHMuc2VhcmNoXG5cdH0gOiB7fTtcblxuXHQvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3Jcblx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0dmFyIHJvd3MgPSB0aGlzLnJvd3MoIHJvd1NlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0dmFyIGksIGllbiwgaiwgamVuO1xuXG5cdHZhciBjZWxsc05vT3B0cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0Zm9yICggaT0wLCBpZW49cm93c1tpZHhdLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1uc1tpZHhdLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRyb3c6ICAgIHJvd3NbaWR4XVtpXSxcblx0XHRcdFx0XHRjb2x1bW46IGNvbHVtbnNbaWR4XVtqXVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGE7XG5cdH0sIDEgKTtcblxuXHQvLyBUaGVyZSBpcyBjdXJyZW50bHkgb25seSBvbmUgZXh0ZW5zaW9uIHdoaWNoIHVzZXMgYSBjZWxsIHNlbGVjdG9yIGV4dGVuc2lvblxuXHQvLyBJdCBpcyBhIF9tYWpvcl8gcGVyZm9ybWFuY2UgZHJhZyB0byBydW4gdGhpcyBpZiBpdCBpc24ndCBuZWVkZWQsIHNvIHRoaXMgaXNcblx0Ly8gYW4gZXh0ZW5zaW9uIHNwZWNpZmljIGNoZWNrIGF0IHRoZSBtb21lbnRcblx0dmFyIGNlbGxzID0gb3B0cyAmJiBvcHRzLnNlbGVjdGVkID9cblx0XHR0aGlzLmNlbGxzKCBjZWxsc05vT3B0cywgb3B0cyApIDpcblx0XHRjZWxsc05vT3B0cztcblxuXHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRjb2xzOiBjb2x1bW5TZWxlY3Rvcixcblx0XHRyb3dzOiByb3dTZWxlY3Rvcixcblx0XHRvcHRzOiBvcHRzXG5cdH0gKTtcblxuXHRyZXR1cm4gY2VsbHM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkubm9kZXMoKScsICdjZWxsKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cblx0XHRyZXR1cm4gZGF0YSAmJiBkYXRhLmFuQ2VsbHMgP1xuXHRcdFx0ZGF0YS5hbkNlbGxzWyBjb2x1bW4gXSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvdywgY29sdW1uICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jYWNoZSgpJywgJ2NlbGwoKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHR0eXBlID0gdHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJztcblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9EYXRhWyByb3cgXVsgdHlwZSBdWyBjb2x1bW4gXTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUgKTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmluZGV4ZXMoKScsICdjZWxsKCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJvdzogcm93LFxuXHRcdFx0Y29sdW1uOiBjb2x1bW4sXG5cdFx0XHRjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApXG5cdFx0fTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uICk7XG5cdH0gKTtcbn0gKTtcblxuXG5cbl9hcGlfcmVnaXN0ZXIoICdjZWxsKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jZWxscyggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbCgpLmRhdGEoKScsIGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0dmFyIGNlbGwgPSB0aGlzWzBdO1xuXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIEdldFxuXHRcdHJldHVybiBjdHgubGVuZ3RoICYmIGNlbGwubGVuZ3RoID9cblx0XHRcdF9mbkdldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiApIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNldFxuXHRfZm5TZXRDZWxsRGF0YSggY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4sIGRhdGEgKTtcblx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbiApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cblxuLyoqXG4gKiBHZXQgY3VycmVudCBvcmRlcmluZyAoc29ydGluZykgdGhhdCBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSB0YWJsZS5cbiAqXG4gKiBAcmV0dXJucyB7YXJyYXl9IDJEIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvcnRpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdFxuICogICB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBFYWNoIGVsZW1lbnQgaW4gdGhlIHBhcmVudCBhcnJheSByZXByZXNlbnRzXG4gKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG4gKiAgIDIgaW5uZXIgYXJyYXlzKS4gVGhlIGlubmVyIGFycmF5cyBtYXkgaGF2ZSAyIG9yIDMgZWxlbWVudHMuIFRoZSBmaXJzdCBpc1xuICogICB0aGUgY29sdW1uIGluZGV4IHRoYXQgdGhlIHNvcnRpbmcgY29uZGl0aW9uIGFwcGxpZXMgdG8sIHRoZSBzZWNvbmQgaXMgdGhlXG4gKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcbiAqICAgaW5kZXggb2YgdGhlIHNvcnRpbmcgb3JkZXIgZnJvbSB0aGUgYGNvbHVtbi5zb3J0aW5nYCBpbml0aWFsaXNhdGlvbiBhcnJheS5cbiAqLy8qKlxuICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb3JkZXIgQ29sdW1uIGluZGV4IHRvIHNvcnQgdXBvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gb3JkZXIgMUQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gb3JkZXIgMkQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdvcmRlcigpJywgZnVuY3Rpb24gKCBvcmRlciwgZGlyICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggb3JkZXIgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBnZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRjdHhbMF0uYWFTb3J0aW5nIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIHNldFxuXHRpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0Ly8gU2ltcGxlIGNvbHVtbiAvIGRpcmVjdGlvbiBwYXNzZWQgaW5cblx0XHRvcmRlciA9IFsgWyBvcmRlciwgZGlyIF0gXTtcblx0fVxuXHRlbHNlIGlmICggb3JkZXIubGVuZ3RoICYmICEgQXJyYXkuaXNBcnJheSggb3JkZXJbMF0gKSApIHtcblx0XHQvLyBBcmd1bWVudHMgcGFzc2VkIGluIChsaXN0IG9mIDFEIGFycmF5cylcblx0XHRvcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0fVxuXHQvLyBvdGhlcndpc2UgYSAyRCBhcnJheSB3YXMgcGFzc2VkIGluXG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gb3JkZXIuc2xpY2UoKTtcblx0fSApO1xufSApO1xuXG5cbi8qKlxuICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuICpcbiAqIEBwYXJhbSB7bm9kZXxqUXVlcnl8c3RyaW5nfSBub2RlIElkZW50aWZpZXIgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGF0dGFjaCB0aGVcbiAqICAgbGlzdGVuZXIgdG8uIFRoaXMgY2FuIHRha2UgdGhlIGZvcm0gb2YgYSBzaW5nbGUgRE9NIG5vZGUsIGEgalF1ZXJ5XG4gKiAgIGNvbGxlY3Rpb24gb2Ygbm9kZXMgb3IgYSBqUXVlcnkgc2VsZWN0b3Igd2hpY2ggd2lsbCBpZGVudGlmeSB0aGUgbm9kZShzKS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gY29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdvcmRlci5saXN0ZW5lcigpJywgZnVuY3Rpb24gKCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoIHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnb3JkZXIuZml4ZWQoKScsIGZ1bmN0aW9uICggc2V0ICkge1xuXHRpZiAoICEgc2V0ICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFx0dmFyIGZpeGVkID0gY3R4Lmxlbmd0aCA/XG5cdFx0XHRjdHhbMF0uYWFTb3J0aW5nRml4ZWQgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoIGZpeGVkICkgP1xuXHRcdFx0eyBwcmU6IGZpeGVkIH0gOlxuXHRcdFx0Zml4ZWQ7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgc2V0ICk7XG5cdH0gKTtcbn0gKTtcblxuXG4vLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdCdjb2x1bW5zKCkub3JkZXIoKScsXG5cdCdjb2x1bW4oKS5vcmRlcigpJ1xuXSwgZnVuY3Rpb24gKCBkaXIgKSB7XG5cdHZhciB0aGF0ID0gdGhpcztcblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaSApIHtcblx0XHR2YXIgc29ydCA9IFtdO1xuXG5cdFx0JC5lYWNoKCB0aGF0W2ldLCBmdW5jdGlvbiAoaiwgY29sKSB7XG5cdFx0XHRzb3J0LnB1c2goIFsgY29sLCBkaXIgXSApO1xuXHRcdH0gKTtcblxuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IHNvcnQ7XG5cdH0gKTtcbn0gKTtcblxuXG5cbl9hcGlfcmVnaXN0ZXIoICdzZWFyY2goKScsIGZ1bmN0aW9uICggaW5wdXQsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2VuICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggaW5wdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBnZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRjdHhbMF0ub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2ggOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gc2V0XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCB7XG5cdFx0XHRcInNTZWFyY2hcIjogaW5wdXQrXCJcIixcblx0XHRcdFwiYlJlZ2V4XCI6ICByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXG5cdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XCJiQ2FzZUluc2Vuc2l0aXZlXCI6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cblx0XHR9ICksIDEgKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoXG5cdCdjb2x1bW5zKCkuc2VhcmNoKCknLFxuXHQnY29sdW1uKCkuc2VhcmNoKCknLFxuXHRmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHZhciBwcmVTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cblx0XHRcdGlmICggaW5wdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gZ2V0XG5cdFx0XHRcdHJldHVybiBwcmVTZWFyY2hbIGNvbHVtbiBdLnNTZWFyY2g7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldFxuXHRcdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCB7XG5cdFx0XHRcdFwic1NlYXJjaFwiOiBpbnB1dCtcIlwiLFxuXHRcdFx0XHRcImJSZWdleFwiOiAgcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuXHRcdFx0XHRcImJTbWFydFwiOiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0fSApO1xuXG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgMSApO1xuXHRcdH0gKTtcblx0fVxuKTtcblxuLypcbiAqIFN0YXRlIEFQSSBtZXRob2RzXG4gKi9cblxuX2FwaV9yZWdpc3RlciggJ3N0YXRlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cblx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdG51bGw7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3N0YXRlLmNsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdC8vIFNhdmUgYW4gZW1wdHkgb2JqZWN0XG5cdFx0c2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCB7fSApO1xuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3N0YXRlLmxvYWRlZCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0dGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XG5cdFx0bnVsbDtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUuc2F2ZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5TYXZlU3RhdGUoIHNldHRpbmdzICk7XG5cdH0gKTtcbn0gKTtcblxuXG5cbi8qKlxuICogU2V0IHRoZSBqUXVlcnkgb3Igd2luZG93IG9iamVjdCB0byBiZSB1c2VkIGJ5IERhdGFUYWJsZXNcbiAqXG4gKiBAcGFyYW0geyp9IG1vZHVsZSBMaWJyYXJ5IC8gY29udGFpbmVyIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgTGlicmFyeSBvciBjb250YWluZXIgdHlwZSBgbGliYCBvciBgd2luYC5cbiAqL1xuRGF0YVRhYmxlLnVzZSA9IGZ1bmN0aW9uIChtb2R1bGUsIHR5cGUpIHtcblx0aWYgKHR5cGUgPT09ICdsaWInIHx8IG1vZHVsZS5mbikge1xuXHRcdCQgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PSAnd2luJyB8fCBtb2R1bGUuZG9jdW1lbnQpIHtcblx0XHR3aW5kb3cgPSBtb2R1bGU7XG5cdFx0ZG9jdW1lbnQgPSBtb2R1bGUuZG9jdW1lbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBDb21tb25KUyBmYWN0b3J5IGZ1bmN0aW9uIHBhc3MgdGhyb3VnaC4gVGhpcyB3aWxsIGNoZWNrIGlmIHRoZSBhcmd1bWVudHNcbiAqIGdpdmVuIGFyZSBhIHdpbmRvdyBvYmplY3Qgb3IgYSBqUXVlcnkgb2JqZWN0LiBJZiBzbyB0aGV5IGFyZSBzZXRcbiAqIGFjY29yZGluZ2x5LlxuICogQHBhcmFtIHsqfSByb290IFdpbmRvd1xuICogQHBhcmFtIHsqfSBqcSBqUVVlcnlcbiAqIEByZXR1cm5zIHtib29sZWFufSBJbmRpY2F0b3JcbiAqL1xuRGF0YVRhYmxlLmZhY3RvcnkgPSBmdW5jdGlvbiAocm9vdCwganEpIHtcblx0dmFyIGlzID0gZmFsc2U7XG5cblx0Ly8gVGVzdCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgd2luZG93IG9iamVjdFxuXHRpZiAocm9vdCAmJiByb290LmRvY3VtZW50KSB7XG5cdFx0d2luZG93ID0gcm9vdDtcblx0XHRkb2N1bWVudCA9IHJvb3QuZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBUZXN0IGlmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIGEgalF1ZXJ5IG9iamVjdFxuXHRpZiAoanEgJiYganEuZm4gJiYganEuZm4uanF1ZXJ5KSB7XG5cdFx0JCA9IGpxO1xuXHRcdGlzID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBpcztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgY29tbW9uIG1ldGhvZCBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgdGhlIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBiZWluZ1xuICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG4gKlxuICogIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuXG4gKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cbiAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG4gKiAgICB0aGUgcmVxdWlyZWQgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3RcbiAqICAgIHN1aXRhYmxlXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBhbGVydCggJC5mbi5kYXRhVGFibGUudmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcbiAqL1xuRGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uIClcbntcblx0dmFyIGFUaGlzID0gRGF0YVRhYmxlLnZlcnNpb24uc3BsaXQoJy4nKTtcblx0dmFyIGFUaGF0ID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuXHR2YXIgaVRoaXMsIGlUaGF0O1xuXG5cdGZvciAoIHZhciBpPTAsIGlMZW49YVRoYXQubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdGlUaGlzID0gcGFyc2VJbnQoIGFUaGlzW2ldLCAxMCApIHx8IDA7XG5cdFx0aVRoYXQgPSBwYXJzZUludCggYVRoYXRbaV0sIDEwICkgfHwgMDtcblxuXHRcdC8vIFBhcnRzIGFyZSB0aGUgc2FtZSwga2VlcCBjb21wYXJpbmdcblx0XHRpZiAoaVRoaXMgPT09IGlUaGF0KSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBQYXJ0cyBhcmUgZGlmZmVyZW50LCByZXR1cm4gaW1tZWRpYXRlbHlcblx0XHRyZXR1cm4gaVRoaXMgPiBpVGhhdDtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXG4gKlxuICogIEBwYXJhbSB7bm9kZXxqcXVlcnl8c3RyaW5nfSB0YWJsZSBUYWJsZSBub2RlLCBqUXVlcnkgb2JqZWN0IG9yIGpRdWVyeVxuICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxuICogICAgICB0YWJsZSBpcyBwYXNzZWQgb24sIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgY2hlY2tlZFxuICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIHRoZSB0YWJsZSBnaXZlbiBpcyBhIERhdGFUYWJsZSwgb3IgZmFsc2Ugb3RoZXJ3aXNlXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBpZiAoICEgJC5mbi5EYXRhVGFibGUuaXNEYXRhVGFibGUoICcjZXhhbXBsZScgKSApIHtcbiAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAqICAgIH1cbiAqL1xuRGF0YVRhYmxlLmlzRGF0YVRhYmxlID0gRGF0YVRhYmxlLmZuSXNEYXRhVGFibGUgPSBmdW5jdGlvbiAoIHRhYmxlIClcbntcblx0dmFyIHQgPSAkKHRhYmxlKS5nZXQoMCk7XG5cdHZhciBpcyA9IGZhbHNlO1xuXG5cdGlmICggdGFibGUgaW5zdGFuY2VvZiBEYXRhVGFibGUuQXBpICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0JC5lYWNoKCBEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChpLCBvKSB7XG5cdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0dmFyIGZvb3QgPSBvLm5TY3JvbGxGb290ID8gJCgndGFibGUnLCBvLm5TY3JvbGxGb290KVswXSA6IG51bGw7XG5cblx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdGlzID0gdHJ1ZTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gaXM7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBEYXRhVGFibGUgdGFibGVzIHRoYXQgaGF2ZSBiZWVuIGluaXRpYWxpc2VkIC0gb3B0aW9uYWxseSB5b3UgY2FuXG4gKiBzZWxlY3QgdG8gZ2V0IG9ubHkgY3VycmVudGx5IHZpc2libGUgdGFibGVzLlxuICpcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFt2aXNpYmxlPWZhbHNlXSBGbGFnIHRvIGluZGljYXRlIGlmIHlvdSB3YW50IGFsbCAoZGVmYXVsdClcbiAqICAgIG9yIHZpc2libGUgdGFibGVzIG9ubHkuXG4gKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG4gKiAgICBEYXRhVGFibGVzXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuICogICAgICAkKHRhYmxlKS5EYXRhVGFibGUoKS5jb2x1bW5zLmFkanVzdCgpO1xuICogICAgfSApO1xuICovXG5EYXRhVGFibGUudGFibGVzID0gRGF0YVRhYmxlLmZuVGFibGVzID0gZnVuY3Rpb24gKCB2aXNpYmxlIClcbntcblx0dmFyIGFwaSA9IGZhbHNlO1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCB2aXNpYmxlICkgKSB7XG5cdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0dmlzaWJsZSA9IHZpc2libGUudmlzaWJsZTtcblx0fVxuXG5cdHZhciBhID0gJC5tYXAoIERhdGFUYWJsZS5zZXR0aW5ncywgZnVuY3Rpb24gKG8pIHtcblx0XHRpZiAoICF2aXNpYmxlIHx8ICh2aXNpYmxlICYmICQoby5uVGFibGUpLmlzKCc6dmlzaWJsZScpKSApIHtcblx0XHRcdHJldHVybiBvLm5UYWJsZTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gYXBpID9cblx0XHRuZXcgX0FwaSggYSApIDpcblx0XHRhO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuIG5vdGF0aW9uLiBUaGlzIGlzIG1hZGUgcHVibGljXG4gKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcbiAqIGVpdGhlciB0aGUgMS45IHN0eWxlIEh1bmdhcmlhbiBub3RhdGlvbiwgb3IgdGhlIDEuMTArIHN0eWxlIGNhbWVsQ2FzZVxuICogcGFyYW1ldGVycy5cbiAqXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXG4gKiAgICBtYXBwZWQuXG4gKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG4gKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcbiAqICAgIEh1bmdhcmlhbiB2YWx1ZSBpbiB0aGUgYHVzZXJgIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBPdGhlcndpc2UgdGhleVxuICogICAgd29uJ3QgYmUuXG4gKi9cbkRhdGFUYWJsZS5jYW1lbFRvSHVuZ2FyaWFuID0gX2ZuQ2FtZWxUb0h1bmdhcmlhbjtcblxuXG5cbi8qKlxuICpcbiAqL1xuX2FwaV9yZWdpc3RlciggJyQoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdHZhclxuXHRcdHJvd3MgICA9IHRoaXMucm93cyggb3B0cyApLm5vZGVzKCksIC8vIEdldCBhbGwgcm93c1xuXHRcdGpxUm93cyA9ICQocm93cyk7XG5cblx0cmV0dXJuICQoIFtdLmNvbmNhdChcblx0XHRqcVJvd3MuZmlsdGVyKCBzZWxlY3RvciApLnRvQXJyYXkoKSxcblx0XHRqcVJvd3MuZmluZCggc2VsZWN0b3IgKS50b0FycmF5KClcblx0KSApO1xufSApO1xuXG5cbi8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG4kLmVhY2goIFsgJ29uJywgJ29uZScsICdvZmYnIF0sIGZ1bmN0aW9uIChpLCBrZXkpIHtcblx0X2FwaV9yZWdpc3Rlcigga2V5KycoKScsIGZ1bmN0aW9uICggLyogZXZlbnQsIGhhbmRsZXIgKi8gKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdFx0Ly8gQWRkIHRoZSBgZHRgIG5hbWVzcGFjZSBhdXRvbWF0aWNhbGx5IGlmIGl0IGlzbid0IGFscmVhZHkgcHJlc2VudFxuXHRcdGFyZ3NbMF0gPSAkLm1hcCggYXJnc1swXS5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0cmV0dXJuICEgZS5tYXRjaCgvXFwuZHRcXGIvKSA/XG5cdFx0XHRcdGUrJy5kdCcgOlxuXHRcdFx0XHRlO1xuXHRcdFx0fSApLmpvaW4oICcgJyApO1xuXG5cdFx0dmFyIGluc3QgPSAkKCB0aGlzLnRhYmxlcygpLm5vZGVzKCkgKTtcblx0XHRpbnN0W2tleV0uYXBwbHkoIGluc3QsIGFyZ3MgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdjbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnaW5pdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2RhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHR9ICkuZmxhdHRlbigpO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdkZXN0cm95KCknLCBmdW5jdGlvbiAoIHJlbW92ZSApIHtcblx0cmVtb3ZlID0gcmVtb3ZlIHx8IGZhbHNlO1xuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHZhciBjbGFzc2VzICAgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0XHR2YXIgdGFibGUgICAgID0gc2V0dGluZ3MublRhYmxlO1xuXHRcdHZhciB0Ym9keSAgICAgPSBzZXR0aW5ncy5uVEJvZHk7XG5cdFx0dmFyIHRoZWFkICAgICA9IHNldHRpbmdzLm5USGVhZDtcblx0XHR2YXIgdGZvb3QgICAgID0gc2V0dGluZ3MublRGb290O1xuXHRcdHZhciBqcVRhYmxlICAgPSAkKHRhYmxlKTtcblx0XHR2YXIganFUYm9keSAgID0gJCh0Ym9keSk7XG5cdFx0dmFyIGpxV3JhcHBlciA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cdFx0dmFyIHJvd3MgICAgICA9ICQubWFwKCBzZXR0aW5ncy5hb0RhdGEsIGZ1bmN0aW9uIChyKSB7IHJldHVybiByLm5UcjsgfSApO1xuXHRcdHZhciBpLCBpZW47XG5cblx0XHQvLyBGbGFnIHRvIG5vdGUgdGhhdCB0aGUgdGFibGUgaXMgY3VycmVudGx5IGJlaW5nIGRlc3Ryb3llZCAtIG5vIGFjdGlvblxuXHRcdC8vIHNob3VsZCBiZSB0YWtlblxuXHRcdHNldHRpbmdzLmJEZXN0cm95aW5nID0gdHJ1ZTtcblxuXHRcdC8vIEZpcmUgb2ZmIHRoZSBkZXN0cm95IGNhbGxiYWNrcyBmb3IgcGx1Zy1pbnMgZXRjXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSApO1xuXG5cdFx0Ly8gSWYgbm90IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQsIG1ha2UgYWxsIGNvbHVtbnMgdmlzaWJsZVxuXHRcdGlmICggISByZW1vdmUgKSB7XG5cdFx0XHRuZXcgX0FwaSggc2V0dGluZ3MgKS5jb2x1bW5zKCkudmlzaWJsZSggdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEJsaXR6IGFsbCBgRFRgIG5hbWVzcGFjZWQgZXZlbnRzICh0aGVzZSBhcmUgaW50ZXJuYWwgZXZlbnRzLCB0aGVcblx0XHQvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXG5cdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRqcVdyYXBwZXIub2ZmKCcuRFQnKS5maW5kKCc6bm90KHRib2R5ICopJykub2ZmKCcuRFQnKTtcblx0XHQkKHdpbmRvdykub2ZmKCcuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UpO1xuXG5cdFx0Ly8gV2hlbiBzY3JvbGxpbmcgd2UgaGFkIHRvIGJyZWFrIHRoZSB0YWJsZSB1cCAtIHJlc3RvcmUgaXRcblx0XHRpZiAoIHRhYmxlICE9IHRoZWFkLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0anFUYWJsZS5hcHBlbmQoIHRoZWFkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0Zm9vdCAmJiB0YWJsZSAhPSB0Zm9vdC5wYXJlbnROb2RlICkge1xuXHRcdFx0anFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcblx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdH1cblxuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gW107XG5cdFx0X2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzICk7XG5cblx0XHQkKCByb3dzICkucmVtb3ZlQ2xhc3MoIHNldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykgKTtcblxuXHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKS5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zU29ydGFibGUrJyAnK1xuXHRcdFx0Y2xhc3Nlcy5zU29ydGFibGVBc2MrJyAnK2NsYXNzZXMuc1NvcnRhYmxlRGVzYysnICcrY2xhc3Nlcy5zU29ydGFibGVOb25lXG5cdFx0KTtcblxuXHRcdC8vIEFkZCB0aGUgVFIgZWxlbWVudHMgYmFjayBpbnRvIHRoZSB0YWJsZSBpbiB0aGVpciBvcmlnaW5hbCBvcmRlclxuXHRcdGpxVGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0XHRqcVRib2R5LmFwcGVuZCggcm93cyApO1xuXG5cdFx0dmFyIG9yaWcgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XG5cblx0XHQvLyBSZW1vdmUgdGhlIERhdGFUYWJsZXMgZ2VuZXJhdGVkIG5vZGVzLCBldmVudHMgYW5kIGNsYXNzZXNcblx0XHR2YXIgcmVtb3ZlZE1ldGhvZCA9IHJlbW92ZSA/ICdyZW1vdmUnIDogJ2RldGFjaCc7XG5cdFx0anFUYWJsZVsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFx0anFXcmFwcGVyWyByZW1vdmVkTWV0aG9kIF0oKTtcblxuXHRcdC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdGlmICggISByZW1vdmUgJiYgb3JpZyApIHtcblx0XHRcdC8vIGluc2VydEJlZm9yZSBhY3RzIGxpa2UgYXBwZW5kQ2hpbGQgaWYgIWFyZ1sxXVxuXHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSApO1xuXG5cdFx0XHQvLyBSZXN0b3JlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgdGFibGUgLSB3YXMgcmVhZCBmcm9tIHRoZSBzdHlsZSBwcm9wZXJ0eSxcblx0XHRcdC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcblx0XHRcdGpxVGFibGVcblx0XHRcdFx0LmNzcyggJ3dpZHRoJywgc2V0dGluZ3Muc0Rlc3Ryb3lXaWR0aCApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggY2xhc3Nlcy5zVGFibGUgKTtcblxuXHRcdFx0Ly8gSWYgdGhlIHdlcmUgb3JpZ2luYWxseSBzdHJpcGUgY2xhc3NlcyAtIHRoZW4gd2UgYWRkIHRoZW0gYmFjayBoZXJlLlxuXHRcdFx0Ly8gTm90ZSB0aGlzIGlzIG5vdCBmb29sIHByb29mIChmb3IgZXhhbXBsZSBpZiBub3QgYWxsIHJvd3MgaGFkIHN0cmlwZVxuXHRcdFx0Ly8gY2xhc3NlcyAtIGJ1dCBpdCdzIGEgZ29vZCBlZmZvcnQgd2l0aG91dCBnZXR0aW5nIGNhcnJpZWQgYXdheVxuXHRcdFx0aWVuID0gc2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcy5sZW5ndGg7XG5cblx0XHRcdGlmICggaWVuICkge1xuXHRcdFx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZWFjaCggZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKCBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzW2kgJSBpZW5dICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBSZW1vdmUgdGhlIHNldHRpbmdzIG9iamVjdCBmcm9tIHRoZSBzZXR0aW5ncyBhcnJheSAqL1xuXHRcdHZhciBpZHggPSAkLmluQXJyYXkoIHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MgKTtcblx0XHRpZiAoIGlkeCAhPT0gLTEgKSB7XG5cdFx0XHREYXRhVGFibGUuc2V0dGluZ3Muc3BsaWNlKCBpZHgsIDEgKTtcblx0XHR9XG5cdH0gKTtcbn0gKTtcblxuXG4vLyBBZGQgdGhlIGBldmVyeSgpYCBtZXRob2QgZm9yIHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzIGluIGEgY29tcGFjdCBmb3JtXG4kLmVhY2goIFsgJ2NvbHVtbicsICdyb3cnLCAnY2VsbCcgXSwgZnVuY3Rpb24gKCBpLCB0eXBlICkge1xuXHRfYXBpX3JlZ2lzdGVyKCB0eXBlKydzKCkuZXZlcnkoKScsIGZ1bmN0aW9uICggZm4gKSB7XG5cdFx0dmFyIG9wdHMgPSB0aGlzLnNlbGVjdG9yLm9wdHM7XG5cdFx0dmFyIGFwaSA9IHRoaXM7XG5cblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggdHlwZSwgZnVuY3Rpb24gKCBzZXR0aW5ncywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCApIHtcblx0XHRcdC8vIFJvd3MgYW5kIGNvbHVtbnM6XG5cdFx0XHQvLyAgYXJnMSAtIGluZGV4XG5cdFx0XHQvLyAgYXJnMiAtIHRhYmxlIGNvdW50ZXJcblx0XHRcdC8vICBhcmczIC0gbG9vcCBjb3VudGVyXG5cdFx0XHQvLyAgYXJnNCAtIHVuZGVmaW5lZFxuXHRcdFx0Ly8gQ2VsbHM6XG5cdFx0XHQvLyAgYXJnMSAtIHJvdyBpbmRleFxuXHRcdFx0Ly8gIGFyZzIgLSBjb2x1bW4gaW5kZXhcblx0XHRcdC8vICBhcmczIC0gdGFibGUgY291bnRlclxuXHRcdFx0Ly8gIGFyZzQgLSBsb29wIGNvdW50ZXJcblx0XHRcdGZuLmNhbGwoXG5cdFx0XHRcdGFwaVsgdHlwZSBdKFxuXHRcdFx0XHRcdGFyZzEsXG5cdFx0XHRcdFx0dHlwZT09PSdjZWxsJyA/IGFyZzIgOiBvcHRzLFxuXHRcdFx0XHRcdHR5cGU9PT0nY2VsbCcgPyBvcHRzIDogdW5kZWZpbmVkXG5cdFx0XHRcdCksXG5cdFx0XHRcdGFyZzEsIGFyZzIsIGFyZzMsIGFyZzRcblx0XHRcdCk7XG5cdFx0fSApO1xuXHR9ICk7XG59ICk7XG5cblxuLy8gaTE4biBtZXRob2QgZm9yIGV4dGVuc2lvbnMgdG8gYmUgYWJsZSB0byB1c2UgdGhlIGxhbmd1YWdlIG9iamVjdCBmcm9tIHRoZVxuLy8gRGF0YVRhYmxlXG5fYXBpX3JlZ2lzdGVyKCAnaTE4bigpJywgZnVuY3Rpb24gKCB0b2tlbiwgZGVmLCBwbHVyYWwgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXG5cdGlmICggcmVzb2x2ZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXNvbHZlZCA9IGRlZjtcblx0fVxuXG5cdGlmICggcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdHJlc29sdmVkID0gcmVzb2x2ZWRbIHBsdXJhbCBdICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0cmVzb2x2ZWRbIHBsdXJhbCBdIDpcblx0XHRcdHJlc29sdmVkLl87XG5cdH1cblxuXHRyZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICk7IC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxufSApO1xuLyoqXG4gKiBWZXJzaW9uIHN0cmluZyBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgY29tcGF0aWJpbGl0eS4gQWxsb3dlZCBmb3JtYXQgaXNcbiAqIGBhLmIuYy1kYCB3aGVyZTogYTppbnQsIGI6aW50LCBjOmludCwgZDpzdHJpbmcoZGV2fGJldGF8YWxwaGEpLiBgZGAgaXMgdXNlZFxuICogb25seSBmb3Igbm9uLXJlbGVhc2UgYnVpbGRzLiBTZWUgaHR0cDovL3NlbXZlci5vcmcvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogIEBtZW1iZXJcbiAqICBAdHlwZSBzdHJpbmdcbiAqICBAZGVmYXVsdCBWZXJzaW9uIG51bWJlclxuICovXG5EYXRhVGFibGUudmVyc2lvbiA9IFwiMS4xMy40XCI7XG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhIHN0b3JlLCBjb250YWluaW5nIGFsbCBvZiB0aGUgc2V0dGluZ3Mgb2JqZWN0cyB0aGF0IGFyZVxuICogY3JlYXRlZCBmb3IgdGhlIHRhYmxlcyBvbiBhIGdpdmVuIHBhZ2UuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLnNldHRpbmdzYCBvYmplY3QgaXMgYWxpYXNlZCB0b1xuICogYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIHRocm91Z2ggd2hpY2ggaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZFxuICogbWFuaXB1bGF0ZWQsIG9yIGBqUXVlcnkuZm4uZGF0YVRhYmxlLnNldHRpbmdzYC5cbiAqICBAbWVtYmVyXG4gKiAgQHR5cGUgYXJyYXlcbiAqICBAZGVmYXVsdCBbXVxuICogIEBwcml2YXRlXG4gKi9cbkRhdGFUYWJsZS5zZXR0aW5ncyA9IFtdO1xuXG4vKipcbiAqIE9iamVjdCBtb2RlbHMgY29udGFpbmVyLCBmb3IgdGhlIHZhcmlvdXMgbW9kZWxzIHRoYXQgRGF0YVRhYmxlcyBoYXNcbiAqIGF2YWlsYWJsZSB0byBpdC4gVGhlc2UgbW9kZWxzIGRlZmluZSB0aGUgb2JqZWN0cyB0aGF0IGFyZSB1c2VkIHRvIGhvbGRcbiAqIHRoZSBhY3RpdmUgc3RhdGUgYW5kIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHRhYmxlLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLm1vZGVscyA9IHt9O1xuXG5cblxuLyoqXG4gKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxuICogc2VhcmNoIGluZm9ybWF0aW9uIGZvciB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVycy5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCA9IHtcblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGZpbHRlcmluZyBzaG91bGQgYmUgY2FzZSBpbnNlbnNpdGl2ZSBvciBub3Rcblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IHRydWVcblx0ICovXG5cdFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBBcHBsaWVkIHNlYXJjaCB0ZXJtXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cblx0ICovXG5cdFwic1NlYXJjaFwiOiBcIlwiLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuXHQgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcblx0ICogcmVnZXggY2hhcmFjdGVycyBlc2NhcGVkLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdFwiYlJlZ2V4XCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIERhdGFUYWJsZXMgaXMgdG8gdXNlIGl0cyBzbWFydCBmaWx0ZXJpbmcgb3Igbm90LlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKi9cblx0XCJiU21hcnRcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZWFyY2ggd2hlblxuXHQgKiB0aGUgcmV0dXJuIGtleSBpcyBwcmVzc2VkLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdFwicmV0dXJuXCI6IGZhbHNlXG59O1xuXG5cblxuXG4vKipcbiAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG4gKiBlYWNoIGluZGl2aWR1YWwgcm93LiBUaGlzIGlzIHRoZSBvYmplY3QgZm9ybWF0IHVzZWQgZm9yIHRoZSBzZXR0aW5nc1xuICogYW9EYXRhIGFycmF5LlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLm1vZGVscy5vUm93ID0ge1xuXHQvKipcblx0ICogVFIgZWxlbWVudCBmb3IgdGhlIHJvd1xuXHQgKiAgQHR5cGUgbm9kZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJuVHJcIjogbnVsbCxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxuXHQgKiBjcmVhdGVkLlxuXHQgKiAgQHR5cGUgYXJyYXkgbm9kZXNcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcImFuQ2VsbHNcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGF0YSBvYmplY3QgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cuIFRoaXMgaXMgZWl0aGVyXG5cdCAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuXHQgKiB1c2luZyBtRGF0YSBvcHRpb25zLiBUaGUgZXhhY3QgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgcGFzc2VkIGluXG5cdCAqIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UsIG9yIHdpbGwgYmUgYW4gYXJyYXkgaWYgdXNpbmcgRE9NIGEgZGF0YVxuXHQgKiBzb3VyY2UuXG5cdCAqICBAdHlwZSBhcnJheXxvYmplY3Rcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcIl9hRGF0YVwiOiBbXSxcblxuXHQvKipcblx0ICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcblx0ICogbnVtYmVyIG9mIGNvbHVtbnMgKGFsdGhvdWdoIGVhY2ggaW5kZXggaXMgZ2VuZXJhdGVkIG9ubHkgYXMgaXQgaXNcblx0ICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcblx0ICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcblx0ICogdGhlIGZvcm1hdHRpbmcgb2YgdGhlIHNvcnQgZGF0YSBuZWVkIGJlIGRvbmUgb25seSBvbmNlIGZvciBlYWNoIGNlbGxcblx0ICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xuXHQgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRcIl9hU29ydERhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVyIGNlbGwgZmlsdGVyaW5nIGRhdGEgY2FjaGUuIEFzIHBlciB0aGUgc29ydCBkYXRhIGNhY2hlLCB1c2VkIHRvXG5cdCAqIGluY3JlYXNlIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgZmlsdGVyaW5nIGluIERhdGFUYWJsZXNcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0XCJfYUZpbHRlckRhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmlsdGVyaW5nIGRhdGEgY2FjaGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGNlbGwgZmlsdGVyaW5nIGNhY2hlLCBidXRcblx0ICogaW4gdGhpcyBjYXNlIGEgc3RyaW5nIHJhdGhlciB0aGFuIGFuIGFycmF5LiBUaGlzIGlzIGVhc2lseSBjb21wdXRlZCB3aXRoXG5cdCAqIGEgam9pbiBvbiBgX2FGaWx0ZXJEYXRhYCwgYnV0IGlzIHByb3ZpZGVkIGFzIGEgY2FjaGUgc28gdGhlIGpvaW4gaXNuJ3Rcblx0ICogbmVlZGVkIG9uIGV2ZXJ5IHNlYXJjaCAobWVtb3J5IHRyYWRlZCBmb3IgcGVyZm9ybWFuY2UpXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFwiX3NGaWx0ZXJSb3dcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ2FjaGUgb2YgdGhlIGNsYXNzIG5hbWUgdGhhdCBEYXRhVGFibGVzIGhhcyBhcHBsaWVkIHRvIHRoZSByb3csIHNvIHdlXG5cdCAqIGNhbiBxdWlja2x5IGxvb2sgYXQgdGhpcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBuZWVkaW5nIHRvIGRvIGEgRE9NIGNoZWNrXG5cdCAqIG9uIGNsYXNzTmFtZSBmb3IgdGhlIG5UciBwcm9wZXJ0eS5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFwiX3NSb3dTdHJpcGVcIjogXCJcIixcblxuXHQvKipcblx0ICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2Vcblx0ICogb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yIGludmFsaWRhdGluZyBkYXRhLCBzbyBEYXRhVGFibGVzIGNhblxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcblx0ICogb3RoZXJ3aXNlLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0XCJzcmNcIjogbnVsbCxcblxuXHQvKipcblx0ICogSW5kZXggaW4gdGhlIGFvRGF0YSBhcnJheS4gVGhpcyBzYXZlcyBhbiBpbmRleE9mIGxvb2t1cCB3aGVuIHdlIGhhdmUgdGhlXG5cdCAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcblx0ICogIEB0eXBlIGludGVnZXJcblx0ICogIEBkZWZhdWx0IC0xXG5cdCAqICBAcHJpdmF0ZVxuXHQgKi9cblx0XCJpZHhcIjogLTFcbn07XG5cblxuLyoqXG4gKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb2JqZWN0IGluIERhdGFUYWJsZXMuIFRoaXMgb2JqZWN0XG4gKiBpcyBoZWxkIGluIHRoZSBzZXR0aW5ncyBhb0NvbHVtbnMgYXJyYXkgYW5kIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdGhhdFxuICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufVxuICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cbiAqIEl0IHNob3VsZCBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGRcbiAqIGJlIGRvbmUgdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMub0NvbHVtbiA9IHtcblx0LyoqXG5cdCAqIENvbHVtbiBpbmRleC4gVGhpcyBjb3VsZCBiZSB3b3JrZWQgb3V0IG9uLXRoZS1mbHkgd2l0aCAkLmluQXJyYXksIGJ1dCBpdFxuXHQgKiBpcyBmYXN0ZXIgdG8ganVzdCBob2xkIGl0IGFzIGEgdmFyaWFibGVcblx0ICogIEB0eXBlIGludGVnZXJcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwiaWR4XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0ICogaXMgc29ydGVkLiBUaGF0IHRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXkgYWxsb3dzIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdCAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcblx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0ICogY29sdW1ucyB0byBiZSBzb3J0ZWQgb24gKHR5cGljYWxseSBpdCB3aWxsIGJlIGEgc2luZ2xlIGludGVnZXIgcG9pbnRpbmdcblx0ICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICovXG5cdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIERlZmluZSB0aGUgc29ydGluZyBkaXJlY3Rpb25zIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGNvbHVtbiwgaW4gc2VxdWVuY2Vcblx0ICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuXHQgKiBhcyB0aGUgc29ydGluZyBkaXJlY3Rpb24gd2hlbiB0aGUgY29sdW1uIGlmIGZpcnN0IHNvcnRlZCAoY2xpY2tlZCBvbikuXG5cdCAqIFNvcnQgaXQgYWdhaW4gKGNsaWNrIGFnYWluKSBhbmQgaXQgd2lsbCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGluZGV4LlxuXHQgKiBSZXBlYXQgdW50aWwgbG9vcC5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqL1xuXHRcImFzU29ydGluZ1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc2VhcmNoYWJsZSwgYW5kIHRodXMgc2hvdWxkIGJlIGluY2x1ZGVkXG5cdCAqIGluIHRoZSBmaWx0ZXJpbmcgb3Igbm90LlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0XCJiU2VhcmNoYWJsZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc29ydGFibGUgb3Igbm90LlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0XCJiU29ydGFibGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSB0YWJsZSBvciBub3Rcblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdFwiYlZpc2libGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogU3RvcmUgZm9yIG1hbnVhbCB0eXBlIGFzc2lnbm1lbnQgdXNpbmcgdGhlIGBjb2x1bW4udHlwZWAgb3B0aW9uLiBUaGlzXG5cdCAqIGlzIGhlbGQgaW4gc3RvcmUgc28gd2UgY2FuIG1hbmlwdWxhdGUgdGhlIGNvbHVtbidzIGBzVHlwZWAgcHJvcGVydHkuXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRcIl9zTWFudWFsVHlwZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIEhUTUw1IGRhdGEgYXR0cmlidXRlcyBzaG91bGQgYmUgdXNlZCBhcyB0aGUgZGF0YVxuXHQgKiBzb3VyY2UgZm9yIGZpbHRlcmluZyBvciBzb3J0aW5nLiBUcnVlIGlzIGVpdGhlciBhcmUuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFwiX2JBdHRyU3JjXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcblx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHQgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2VsZW1lbnR9IG5UZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcblx0ICogIEBwYXJhbSB7Kn0gc0RhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXG5cdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgZm9yIHRoZSB3aG9sZSByb3dcblx0ICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHQgKiBhY2Nlc3MgZGF0YSBkaXJlY3RseSB0aHJvdWdoIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdCAqIHRoZSBtZXRob2QgYXR0YWNoZWQgdG8gdGhpcyBwcm9wZXJ0eS4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzXG5cdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHQgKiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0ICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxuXHQgKiAgQHBhcmFtIHtzdHJpbmd9IHNTcGVjaWZpYyBUaGUgc3BlY2lmaWMgZGF0YSB0eXBlIHlvdSB3YW50IHRvIGdldCAtXG5cdCAqICAgICdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0J1xuXHQgKiAgQHJldHVybnMgeyp9IFRoZSBkYXRhIGZvciB0aGUgY2VsbCBmcm9tIHRoZSBnaXZlbiByb3cncyBkYXRhXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcImZuR2V0RGF0YVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBzZXQgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XG5cdCAqIHNldCB0aGUgZGF0YSBkaXJlY3RseSB0byBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxuXHQgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXG5cdCAqIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtbiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcblx0ICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxuXHQgKiAgQHBhcmFtIHsqfSBzVmFsdWUgVmFsdWUgdG8gc2V0XG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcImZuU2V0RGF0YVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBQcm9wZXJ0eSB0byByZWFkIHRoZSB2YWx1ZSBmb3IgdGhlIGNlbGxzIGluIHRoZSBjb2x1bW4gZnJvbSB0aGUgZGF0YVxuXHQgKiBzb3VyY2UgYXJyYXkgLyBvYmplY3QuIElmIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgY29udGVudCBpcyB1c2VkLCBpZiBhXG5cdCAqIGZ1bmN0aW9uIGlzIGdpdmVuIHRoZW4gdGhlIHJldHVybiBmcm9tIHRoZSBmdW5jdGlvbiBpcyB1c2VkLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb258aW50fHN0cmluZ3xudWxsXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcIm1EYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBhcnRuZXIgcHJvcGVydHkgdG8gbURhdGEgd2hpY2ggaXMgdXNlZCAob25seSB3aGVuIGRlZmluZWQpIHRvIGdldFxuXHQgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcblx0ICogJ3NldCcgb3B0aW9uLCBhbmQgYWxzbyB0aGUgZGF0YSBmZWQgdG8gaXQgaXMgdGhlIHJlc3VsdCBmcm9tIG1EYXRhLlxuXHQgKiBUaGlzIGlzIHRoZSByZW5kZXJpbmcgbWV0aG9kIHRvIG1hdGNoIHRoZSBkYXRhIG1ldGhvZCBvZiBtRGF0YS5cblx0ICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJtUmVuZGVyXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcblx0ICogbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gKGlmIHNvcnRpbmcgaXMgZW5hYmxlZC4pXG5cdCAqICBAdHlwZSBub2RlXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcIm5UaFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBVbmlxdWUgZm9vdGVyIFRIL1REIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uIChpZiB0aGVyZSBpcyBvbmUpLiBOb3QgdXNlZFxuXHQgKiBpbiBEYXRhVGFibGVzIGFzIHN1Y2gsIGJ1dCBjYW4gYmUgdXNlZCBmb3IgcGx1Zy1pbnMgdG8gcmVmZXJlbmNlIHRoZVxuXHQgKiBmb290ZXIgZm9yIGVhY2ggY29sdW1uLlxuXHQgKiAgQHR5cGUgbm9kZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJuVGZcIjogbnVsbCxcblxuXHQvKipcblx0ICogVGhlIGNsYXNzIHRvIGFwcGx5IHRvIGFsbCBURCBlbGVtZW50cyBpbiB0aGUgdGFibGUncyBUQk9EWSBmb3IgdGhlIGNvbHVtblxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNDbGFzc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0ICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG5cdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0ICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuXHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICovXG5cdFwic0NvbnRlbnRQYWRkaW5nXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgbURhdGFcblx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJzRGVmYXVsdENvbnRlbnRcIjogbnVsbCxcblxuXHQvKipcblx0ICogTmFtZSBmb3IgdGhlIGNvbHVtbiwgYWxsb3dpbmcgcmVmZXJlbmNlIHRvIHRoZSBjb2x1bW4gYnkgbmFtZSBhcyB3ZWxsIGFzXG5cdCAqIGJ5IGluZGV4IChuZWVkcyBhIGxvb2t1cCB0byB3b3JrIGJ5IG5hbWUpLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqL1xuXHRcInNOYW1lXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEN1c3RvbSBzb3J0aW5nIGRhdGEgdHlwZSAtIGRlZmluZXMgd2hpY2ggb2YgdGhlIGF2YWlsYWJsZSBwbHVnLWlucyBpblxuXHQgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgc3RkXG5cdCAqL1xuXHRcInNTb3J0RGF0YVR5cGVcIjogJ3N0ZCcsXG5cblx0LyoqXG5cdCAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtblxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNTb3J0aW5nQ2xhc3NcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uIC1cblx0ICogd2hlbiBqUXVlcnkgVUkgdGhlbWluZyBpcyB1c2VkLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNTb3J0aW5nQ2xhc3NKVUlcIjogbnVsbCxcblxuXHQvKipcblx0ICogVGl0bGUgb2YgdGhlIGNvbHVtbiAtIHdoYXQgaXMgc2VlbiBpbiB0aGUgVEggZWxlbWVudCAoblRoKS5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKi9cblx0XCJzVGl0bGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ29sdW1uIHNvcnRpbmcgYW5kIGZpbHRlcmluZyB0eXBlXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwic1R5cGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogV2lkdGggb2YgdGhlIGNvbHVtblxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNXaWR0aFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNXaWR0aE9yaWdcIjogbnVsbFxufTtcblxuXG4vKlxuICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuICogbm90YXRpb24sIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGludGVyZmFjZSBmb3IgRGF0YVRhYmxlcyBwcmlvciB0byB2MS4xMCwgaG93ZXZlclxuICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxuICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG4gKiB2ZXJzaW9uIGlzIHN0aWxsLCBpbnRlcm5hbGx5IHRoZSBwcmltYXJ5IGludGVyZmFjZSwgYnV0IGlzIGlzIG5vdCBkb2N1bWVudGVkXG4gKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxuICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cbiAqIHdvdWxkIHJlcXVpcmUgZWFjaCBwcm9wZXJ0eSB0byBiZSBsaXN0ZWQsIHdoaWNoIHdvdWxkIGFkZCBhcm91bmQgM0sgdG8gdGhlIHNpemVcbiAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQpLlxuICpcbiAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcbiAqIGNvbXBsZXRlbHksIGJ1dCB0aGF0IGlzIGEgbWFzc2l2ZSBhbW91bnQgb2Ygd29yayBhbmQgd2lsbCBicmVhayBjdXJyZW50XG4gKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxuICovXG5cbi8qKlxuICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXG4gKiB0aW1lLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmRlZmF1bHRzID0ge1xuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG5cdCAqIHdpbGwgYmUgdXNlZCBpbiBwcmVmZXJlbmNlIHRvIGFueSBkYXRhIHdoaWNoIGlzIGFscmVhZHkgaW4gdGhlIERPTS4gVGhpcyBpc1xuXHQgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3Jcblx0ICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGF0YVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYSAyRCBhcnJheSBkYXRhIHNvdXJjZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImRhdGFcIjogW1xuXHQgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNC4wJywgJ1dpbiA5NSsnLCA0LCAnWCddLFxuXHQgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNS4wJywgJ1dpbiA5NSsnLCA1LCAnQyddLFxuXHQgKiAgICAgICAgXSxcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkVuZ2luZVwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiB9LFxuXHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlZlcnNpb25cIiB9LFxuXHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiIH1cblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYXMgYSBkYXRhIHNvdXJjZSAoYGRhdGFgKVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImRhdGFcIjogW1xuXHQgKiAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgXCJlbmdpbmVcIjogICBcIlRyaWRlbnRcIixcblx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNC4wXCIsXG5cdCAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcblx0ICogICAgICAgICAgICBcInZlcnNpb25cIjogIDQsXG5cdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIlhcIlxuXHQgKiAgICAgICAgICB9LFxuXHQgKiAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgXCJlbmdpbmVcIjogICBcIlRyaWRlbnRcIixcblx0ICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNS4wXCIsXG5cdCAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcblx0ICogICAgICAgICAgICBcInZlcnNpb25cIjogIDUsXG5cdCAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIkNcIlxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICBdLFxuXHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiRW5naW5lXCIsICAgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiLCAgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIsIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcblx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiVmVyc2lvblwiLCAgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIsICAgIFwiZGF0YVwiOiBcImdyYWRlXCIgfVxuXHQgKiAgICAgICAgXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJhYURhdGFcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBJZiBvcmRlcmluZyBpcyBlbmFibGVkLCB0aGVuIERhdGFUYWJsZXMgd2lsbCBwZXJmb3JtIGEgZmlyc3QgcGFzcyBzb3J0IG9uXG5cdCAqIGluaXRpYWxpc2F0aW9uLiBZb3UgY2FuIGRlZmluZSB3aGljaCBjb2x1bW4ocykgdGhlIHNvcnQgaXMgcGVyZm9ybWVkXG5cdCAqIHVwb24sIGFuZCB0aGUgc29ydGluZyBkaXJlY3Rpb24sIHdpdGggdGhpcyB2YXJpYWJsZS4gVGhlIGBzb3J0aW5nYCBhcnJheVxuXHQgKiBzaG91bGQgY29udGFpbiBhbiBhcnJheSBmb3IgZWFjaCBjb2x1bW4gdG8gYmUgc29ydGVkIGluaXRpYWxseSBjb250YWluaW5nXG5cdCAqIHRoZSBjb2x1bW4ncyBpbmRleCBhbmQgYSBkaXJlY3Rpb24gc3RyaW5nICgnYXNjJyBvciAnZGVzYycpLlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtbMCwnYXNjJ11dXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFNvcnQgYnkgM3JkIGNvbHVtbiBmaXJzdCwgYW5kIHRoZW4gNHRoIGNvbHVtblxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwib3JkZXJcIjogW1syLCdhc2MnXSwgWzMsJ2Rlc2MnXV1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogICAgLy8gTm8gaW5pdGlhbCBzb3J0aW5nXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJvcmRlclwiOiBbXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJhYVNvcnRpbmdcIjogW1swLCdhc2MnXV0sXG5cblxuXHQvKipcblx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCB0byB0aGUgYHNvcnRpbmdgIHBhcmFtZXRlciwgYnV0XG5cdCAqIGNhbm5vdCBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgdGFibGUuIFdoYXQgdGhpcyBtZWFuc1xuXHQgKiBpcyB0aGF0IHlvdSBjb3VsZCBoYXZlIGEgY29sdW1uICh2aXNpYmxlIG9yIGhpZGRlbikgd2hpY2ggdGhlIHNvcnRpbmdcblx0ICogd2lsbCBhbHdheXMgYmUgZm9yY2VkIG9uIGZpcnN0IC0gYW55IHNvcnRpbmcgYWZ0ZXIgdGhhdCAoZnJvbSB0aGUgdXNlcilcblx0ICogd2lsbCB0aGVuIGJlIHBlcmZvcm1lZCBhcyByZXF1aXJlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBncm91cGluZyByb3dzXG5cdCAqIHRvZ2V0aGVyLlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICpcblx0ICogIEBkdG9wdCBPcHRpb25cblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckZpeGVkXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwib3JkZXJGaXhlZFwiOiBbWzAsJ2FzYyddXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApXG5cdCAqL1xuXHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgY2FuIGJlIGluc3RydWN0ZWQgdG8gbG9hZCBkYXRhIHRvIGRpc3BsYXkgaW4gdGhlIHRhYmxlIGZyb20gYVxuXHQgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXG5cdCAqXG5cdCAqIFRoZSBgYWpheGAgcHJvcGVydHkgaGFzIHRocmVlIGRpZmZlcmVudCBtb2RlcyBvZiBvcGVyYXRpb24sIGRlcGVuZGluZyBvblxuXHQgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxuXHQgKlxuXHQgKiAqIGBzdHJpbmdgIC0gU2V0IHRoZSBVUkwgZnJvbSB3aGVyZSB0aGUgZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20uXG5cdCAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cblx0ICogKiBgZnVuY3Rpb25gIC0gQ3VzdG9tIGRhdGEgZ2V0IGZ1bmN0aW9uXG5cdCAqXG5cdCAqIGBzdHJpbmdgXG5cdCAqIC0tLS0tLS0tXG5cdCAqXG5cdCAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxuXHQgKiBEYXRhVGFibGVzIHdpbGwgbG9hZCBkYXRhLlxuXHQgKlxuXHQgKiBgb2JqZWN0YFxuXHQgKiAtLS0tLS0tLVxuXHQgKlxuXHQgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xuXHQgKiBbalF1ZXJ5LmFqYXhdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxuXHQgKiBvZiB0aGUgQWpheCByZXF1ZXN0LiBEYXRhVGFibGVzIGhhcyBhIG51bWJlciBvZiBkZWZhdWx0IHBhcmFtZXRlcnMgd2hpY2hcblx0ICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcblx0ICogdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGluIERhdGFUYWJsZXMgb3Jcblx0ICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG5cdCAqXG5cdCAqICogYGRhdGFgIC0gQXMgd2l0aCBqUXVlcnksIGBkYXRhYCBjYW4gYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0LCBidXQgaXRcblx0ICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG5cdCAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXG5cdCAqICAgcGFyYW1ldGVycyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCBEYXRhVGFibGVzIGhhcyByZWFkaWVkIGZvciBzZW5kaW5nLiBBblxuXHQgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuXHQgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXG5cdCAqICAgbm90IHJldHVybiBhbnl0aGluZyBmcm9tIHRoZSBmdW5jdGlvbi4gVGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlclBhcmFtc2Bcblx0ICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cblx0ICpcblx0ICogKiBgZGF0YVNyY2AgLSBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvclxuXHQgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG5cdCAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXG5cdCAqICAgYWxsb3dzIHRoYXQgcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWRcblx0ICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuXHQgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXG5cdCAqICAgdGhlIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYXNcblx0ICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG5cdCAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBzdXBlcnNlZGVzIGBzQWpheERhdGFQcm9wYCBmcm9tXG5cdCAqICAgRGF0YVRhYmxlcyAxLjktLlxuXHQgKlxuXHQgKiAqIGBzdWNjZXNzYCAtIFNob3VsZCBub3QgYmUgb3ZlcnJpZGRlbiBpdCBpcyB1c2VkIGludGVybmFsbHkgaW5cblx0ICogICBEYXRhVGFibGVzLiBUbyBtYW5pcHVsYXRlIC8gdHJhbnNmb3JtIHRoZSBkYXRhIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXJcblx0ICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cblx0ICpcblx0ICogYGZ1bmN0aW9uYFxuXHQgKiAtLS0tLS0tLS0tXG5cdCAqXG5cdCAqIEFzIGEgZnVuY3Rpb24sIG1ha2luZyB0aGUgQWpheCBjYWxsIGlzIGxlZnQgdXAgdG8geW91cnNlbGYgYWxsb3dpbmdcblx0ICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXG5cdCAqIHRoYW4gQWpheCBjb3VsZCBiZSB1c2VkIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSwgc3VjaCBhcyBXZWIgc3RvcmFnZVxuXHQgKiBvciBhbiBBSVIgZGF0YWJhc2UuXG5cdCAqXG5cdCAqIFRoZSBmdW5jdGlvbiBpcyBnaXZlbiBmb3VyIHBhcmFtZXRlcnMgYW5kIG5vIHJldHVybiBpcyByZXF1aXJlZC4gVGhlXG5cdCAqIHBhcmFtZXRlcnMgYXJlOlxuXHQgKlxuXHQgKiAxLiBfb2JqZWN0XyAtIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXG5cdCAqIDIuIF9mdW5jdGlvbl8gLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IG11c3QgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgcmVxdWlyZWRcblx0ICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcblx0ICogICAgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXG5cdCAqIDMuIF9vYmplY3RfIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgZm9yIHRoZSB0YWJsZVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlckRhdGFgIGZyb20gRGF0YVRhYmxlcyAxLjktLlxuXHQgKlxuXHQgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvblxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhcblx0ICogIEBzaW5jZSAxLjEwLjBcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LlxuXHQgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXG5cdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgIFwiYWpheFwiOiBcImRhdGEuanNvblwiXG5cdCAqICAgfSApO1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2Vcblx0ICogICAvLyBgZGF0YWAgdG8gYHRhYmxlRGF0YWAgKGkuZS4gYHsgdGFibGVEYXRhOiBbIC4uLmRhdGEuLi4gXSB9YClcblx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgXCJhamF4XCI6IHtcblx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0ICogICAgICAgXCJkYXRhU3JjXCI6IFwidGFibGVEYXRhXCJcblx0ICogICAgIH1cblx0ICogICB9ICk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gR2V0IEpTT04gZGF0YSBmcm9tIGEgZmlsZSB2aWEgQWpheCwgdXNpbmcgYGRhdGFTcmNgIHRvIHJlYWQgZGF0YVxuXHQgKiAgIC8vIGZyb20gYSBwbGFpbiBhcnJheSByYXRoZXIgdGhhbiBhbiBhcnJheSBpbiBhbiBvYmplY3Rcblx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgXCJhamF4XCI6IHtcblx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0ICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcblx0ICogICAgIH1cblx0ICogICB9ICk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gTWFuaXB1bGF0ZSB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgLSBhZGQgYSBsaW5rIHRvIGRhdGFcblx0ICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xuXHQgKiAgIC8vIGlzIGp1c3QgYSBzaW1wbGUgZXhhbXBsZSBvZiBob3cgdGhlIGRhdGEgY2FuIGJlIG1hbmlwdWxhdGVkKS5cblx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgXCJhamF4XCI6IHtcblx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0ICogICAgICAgXCJkYXRhU3JjXCI6IGZ1bmN0aW9uICgganNvbiApIHtcblx0ICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0ICogICAgICAgICAgIGpzb25baV1bMF0gPSAnPGEgaHJlZj1cIi9tZXNzYWdlLycranNvbltpXVswXSsnPlZpZXcgbWVzc2FnZTwvYT4nO1xuXHQgKiAgICAgICAgIH1cblx0ICogICAgICAgICByZXR1cm4ganNvbjtcblx0ICogICAgICAgfVxuXHQgKiAgICAgfVxuXHQgKiAgIH0gKTtcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxuXHQgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICBcImFqYXhcIjoge1xuXHQgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuXHQgKiAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBkICkge1xuXHQgKiAgICAgICAgIHJldHVybiB7XG5cdCAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxuXHQgKiAgICAgICAgIH07XG5cdCAqICAgICAgIH1cblx0ICogICAgIH1cblx0ICogICB9ICk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqICAgLy8gU2VuZCByZXF1ZXN0IGFzIFBPU1Rcblx0ICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgXCJhamF4XCI6IHtcblx0ICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcblx0ICogICAgICAgXCJ0eXBlXCI6IFwiUE9TVFwiXG5cdCAqICAgICB9XG5cdCAqICAgfSApO1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIGxvY2FsU3RvcmFnZSAoY291bGQgaW50ZXJmYWNlIHdpdGggYSBmb3JtIGZvclxuXHQgKiAgIC8vIGFkZGluZywgZWRpdGluZyBhbmQgcmVtb3Zpbmcgcm93cykuXG5cdCAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgIFwiYWpheFwiOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2ssIHNldHRpbmdzKSB7XG5cdCAqICAgICAgIGNhbGxiYWNrKFxuXHQgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcblx0ICogICAgICAgKTtcblx0ICogICAgIH1cblx0ICogICB9ICk7XG5cdCAqL1xuXHRcImFqYXhcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHJlYWRpbHkgc3BlY2lmeSB0aGUgZW50cmllcyBpbiB0aGUgbGVuZ3RoIGRyb3Bcblx0ICogZG93biBtZW51IHRoYXQgRGF0YVRhYmxlcyBzaG93cyB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC4gSXQgY2FuIGJlXG5cdCAqIGVpdGhlciBhIDFEIGFycmF5IG9mIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBib3RoIHRoZSBkaXNwbGF5ZWRcblx0ICogb3B0aW9uIGFuZCB0aGUgdmFsdWUsIG9yIGEgMkQgYXJyYXkgd2hpY2ggd2lsbCB1c2UgdGhlIGFycmF5IGluIHRoZSBmaXJzdFxuXHQgKiBwb3NpdGlvbiBhcyB0aGUgdmFsdWUsIGFuZCB0aGUgYXJyYXkgaW4gdGhlIHNlY29uZCBwb3NpdGlvbiBhcyB0aGVcblx0ICogZGlzcGxheWVkIG9wdGlvbnMgKHVzZWZ1bCBmb3IgbGFuZ3VhZ2Ugc3RyaW5ncyBzdWNoIGFzICdBbGwnKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBgcGFnZUxlbmd0aGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGVcblx0ICogZmlyc3QgdmFsdWUgZ2l2ZW4gaW4gdGhpcyBhcnJheSwgdW5sZXNzIGBwYWdlTGVuZ3RoYCBpcyBhbHNvIHByb3ZpZGVkLlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFsgMTAsIDI1LCA1MCwgMTAwIF1cblx0ICpcblx0ICogIEBkdG9wdCBPcHRpb25cblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhNZW51XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwibGVuZ3RoTWVudVwiOiBbWzEwLCAyNSwgNTAsIC0xXSwgWzEwLCAyNSwgNTAsIFwiQWxsXCJdXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJhTGVuZ3RoTWVudVwiOiBbIDEwLCAyNSwgNTAsIDEwMCBdLFxuXG5cblx0LyoqXG5cdCAqIFRoZSBgY29sdW1uc2Agb3B0aW9uIGluIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBkZWZpbmVcblx0ICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxuXHQgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcblx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LiBOb3RlIHRoYXQgaWYgeW91IHVzZSBgY29sdW1uc2AgdG9cblx0ICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxuXHQgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcblx0ICogdG8gc3BlY2lmeSBhbnkgb3B0aW9ucykuXG5cdCAqICBAbWVtYmVyXG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uXG5cdCAqL1xuXHRcImFvQ29sdW1uc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBWZXJ5IHNpbWlsYXIgdG8gYGNvbHVtbnNgLCBgY29sdW1uRGVmc2AgYWxsb3dzIHlvdSB0byB0YXJnZXQgYSBzcGVjaWZpY1xuXHQgKiBjb2x1bW4sIG11bHRpcGxlIGNvbHVtbnMsIG9yIGFsbCBjb2x1bW5zLCB1c2luZyB0aGUgYHRhcmdldHNgIHByb3BlcnR5IG9mXG5cdCAqIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVGhpcyBhbGxvd3MgZ3JlYXQgZmxleGliaWxpdHkgd2hlbiBjcmVhdGluZ1xuXHQgKiB0YWJsZXMsIGFzIHRoZSBgY29sdW1uRGVmc2AgYXJyYXlzIGNhbiBiZSBvZiBhbnkgbGVuZ3RoLCB0YXJnZXRpbmcgdGhlXG5cdCAqIGNvbHVtbnMgeW91IHNwZWNpZmljYWxseSB3YW50LiBgY29sdW1uRGVmc2AgbWF5IHVzZSBhbnkgb2YgdGhlIGNvbHVtblxuXHQgKiBvcHRpb25zIGF2YWlsYWJsZToge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LCBidXQgaXQgX211c3RfXG5cdCAqIGhhdmUgYHRhcmdldHNgIGRlZmluZWQgaW4gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBWYWx1ZXMgaW4gdGhlIGB0YXJnZXRzYFxuXHQgKiBhcnJheSBtYXkgYmU6XG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPmEgc3RyaW5nIC0gY2xhc3MgbmFtZSB3aWxsIGJlIG1hdGNoZWQgb24gdGhlIFRIIGZvciB0aGUgY29sdW1uPC9saT5cblx0ICogICAgIDxsaT4wIG9yIGEgcG9zaXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSBsZWZ0PC9saT5cblx0ICogICAgIDxsaT5hIG5lZ2F0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgcmlnaHQ8L2xpPlxuXHQgKiAgICAgPGxpPnRoZSBzdHJpbmcgXCJfYWxsXCIgLSBhbGwgY29sdW1ucyAoaS5lLiBhc3NpZ24gYSBkZWZhdWx0KTwvbGk+XG5cdCAqICAgPC91bD5cblx0ICogIEBtZW1iZXJcblx0ICpcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5EZWZzXG5cdCAqL1xuXHRcImFvQ29sdW1uRGVmc1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBgc2VhcmNoYCwgdGhpcyBwYXJhbWV0ZXIgZGVmaW5lcyB0aGUgaW5kaXZpZHVhbCBjb2x1bW5cblx0ICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcblx0ICogYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zLCBhbmQgZWFjaCBlbGVtZW50IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJhbWV0ZXJzXG5cdCAqIGBzZWFyY2hgIGFuZCBgZXNjYXBlUmVnZXhgICh0aGUgbGF0dGVyIGlzIG9wdGlvbmFsKS4gJ251bGwnIGlzIGFsc29cblx0ICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvblxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaENvbHNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzZWFyY2hDb2xzXCI6IFtcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIHsgXCJzZWFyY2hcIjogXCJeWzAtOV1cIiwgXCJlc2NhcGVSZWdleFwiOiBmYWxzZSB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9IClcblx0ICovXG5cdFwiYW9TZWFyY2hDb2xzXCI6IFtdLFxuXG5cblx0LyoqXG5cdCAqIEFuIGFycmF5IG9mIENTUyBjbGFzc2VzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gZGlzcGxheWVkIHJvd3MuIFRoaXNcblx0ICogYXJyYXkgbWF5IGJlIG9mIGFueSBsZW5ndGgsIGFuZCBEYXRhVGFibGVzIHdpbGwgYXBwbHkgZWFjaCBjbGFzc1xuXHQgKiBzZXF1ZW50aWFsbHksIGxvb3Bpbmcgd2hlbiByZXF1aXJlZC5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBudWxsIDxpPldpbGwgdGFrZSB0aGUgdmFsdWVzIGRldGVybWluZWQgYnkgdGhlIGBvQ2xhc3Nlcy5zdHJpcGUqYFxuXHQgKiAgICBvcHRpb25zPC9pPlxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvblxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0cmlwZUNsYXNzZXNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzdHJpcGVDbGFzc2VzXCI6IFsgJ3N0cmlwMScsICdzdHJpcDInLCAnc3RyaXAzJyBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9IClcblx0ICovXG5cdFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgYXV0b21hdGljIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbi4gVGhpcyBjYW4gYmUgZGlzYWJsZWRcblx0ICogYXMgYW4gb3B0aW1pc2F0aW9uIChpdCB0YWtlcyBzb21lIHRpbWUgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aHMpIGlmIHRoZVxuXHQgKiB0YWJsZXMgd2lkdGhzIGFyZSBwYXNzZWQgaW4gdXNpbmcgYGNvbHVtbnNgLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYXV0b1dpZHRoXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImF1dG9XaWR0aFwiOiBmYWxzZVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJiQXV0b1dpZHRoXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3Vcblx0ICogYXJlIHVzaW5nIGFuIEFqYXggb3IgSlMgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBvcHRpb24sIHdoZW4gc2V0IHRvXG5cdCAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxuXHQgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxuXHQgKiB0aW1lLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0ICpcblx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyUmVuZGVyXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxuXHQgKiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJEZWZlclJlbmRlclwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBSZXBsYWNlIGEgRGF0YVRhYmxlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCByZXBsYWNlIGl0IHdpdGhcblx0ICogb25lIHdoaWNoIGhhcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbmV3IGluaXRpYWxpc2F0aW9uIG9iamVjdCBwYXNzZWQuIElmIG5vXG5cdCAqIHRhYmxlIG1hdGNoZXMgdGhlIHNlbGVjdG9yLCB0aGVuIHRoZSBuZXcgRGF0YVRhYmxlIHdpbGwgYmUgY29uc3RydWN0ZWQgYXNcblx0ICogcGVyIG5vcm1hbC5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlc3Ryb3lcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzcm9sbFlcIjogXCIyMDBweFwiLFxuXHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZVxuXHQgKiAgICAgIH0gKTtcblx0ICpcblx0ICogICAgICAvLyBTb21lIHRpbWUgbGF0ZXIuLi4uXG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiZmlsdGVyXCI6IGZhbHNlLFxuXHQgKiAgICAgICAgXCJkZXN0cm95XCI6IHRydWVcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYkRlc3Ryb3lcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9mIGRhdGEuIEZpbHRlcmluZyBpbiBEYXRhVGFibGVzIGlzIFwic21hcnRcIiBpblxuXHQgKiB0aGF0IGl0IGFsbG93cyB0aGUgZW5kIHVzZXIgdG8gaW5wdXQgbXVsdGlwbGUgd29yZHMgKHNwYWNlIHNlcGFyYXRlZCkgYW5kXG5cdCAqIHdpbGwgbWF0Y2ggYSByb3cgY29udGFpbmluZyB0aG9zZSB3b3JkcywgZXZlbiBpZiBub3QgaW4gdGhlIG9yZGVyIHRoYXQgd2FzXG5cdCAqIHNwZWNpZmllZCAodGhpcyBhbGxvdyBtYXRjaGluZyBhY3Jvc3MgbXVsdGlwbGUgY29sdW1ucykuIE5vdGUgdGhhdCBpZiB5b3Vcblx0ICogd2lzaCB0byB1c2UgZmlsdGVyaW5nIGluIERhdGFUYWJsZXMgdGhpcyBtdXN0IHJlbWFpbiAndHJ1ZScgLSB0byByZW1vdmUgdGhlXG5cdCAqIGRlZmF1bHQgZmlsdGVyaW5nIGlucHV0IGJveCBhbmQgcmV0YWluIGZpbHRlcmluZyBhYmlsaXRpZXMsIHBsZWFzZSB1c2Vcblx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5kb219LlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoaW5nXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJiRmlsdGVyXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGRpc3BsYXkuIFRoaXMgc2hvd3MgaW5mb3JtYXRpb25cblx0ICogYWJvdXQgdGhlIGRhdGEgdGhhdCBpcyBjdXJyZW50bHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgaW5jbHVkaW5nIGluZm9ybWF0aW9uXG5cdCAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJpbmZvXCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJJbmZvXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogQWxsb3dzIHRoZSBlbmQgdXNlciB0byBzZWxlY3QgdGhlIHNpemUgb2YgYSBmb3JtYXR0ZWQgcGFnZSBmcm9tIGEgc2VsZWN0XG5cdCAqIG1lbnUgKHNpemVzIGFyZSAxMCwgMjUsIDUwIGFuZCAxMDApLiBSZXF1aXJlcyBwYWdpbmF0aW9uIChgcGFnaW5hdGVgKS5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IHRydWVcblx0ICpcblx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aENoYW5nZVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJsZW5ndGhDaGFuZ2VcIjogZmFsc2Vcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHBhZ2luYXRpb24uXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCB0cnVlXG5cdCAqXG5cdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwicGFnaW5nXCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJQYWdpbmF0ZVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIGEgJ3Byb2Nlc3NpbmcnIGluZGljYXRvciB3aGVuIHRoZSB0YWJsZSBpc1xuXHQgKiBiZWluZyBwcm9jZXNzZWQgKGUuZy4gYSBzb3J0KS4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciB0YWJsZXMgd2l0aFxuXHQgKiBsYXJnZSBhbW91bnRzIG9mIGRhdGEgd2hlcmUgaXQgY2FuIHRha2UgYSBub3RpY2VhYmxlIGFtb3VudCBvZiB0aW1lIHRvIHNvcnRcblx0ICogdGhlIGVudHJpZXMuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJvY2Vzc2luZ1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJwcm9jZXNzaW5nXCI6IHRydWVcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIE5vdGUgdGhhdCBpZiB0aGVcblx0ICogdGFibGUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCwgdGhpcyBwYXJhbWV0ZXIgd2lsbCBjYXVzZSBEYXRhVGFibGVzXG5cdCAqIHRvIHNpbXBseSByZXR1cm4gdGhlIG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2V0IHVwIC0gaXQgd2lsbCBub3QgdGFrZVxuXHQgKiBhY2NvdW50IG9mIGFueSBjaGFuZ2VzIHlvdSBtaWdodCBoYXZlIG1hZGUgdG8gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdFxuXHQgKiBwYXNzZWQgdG8gRGF0YVRhYmxlcyAoc2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlzIGFuIGFja25vd2xlZGdlbWVudFxuXHQgKiB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoaXMpLiBgZGVzdHJveWAgY2FuIGJlIHVzZWQgdG8gcmVpbml0aWFsaXNlIGEgdGFibGUgaWZcblx0ICogeW91IG5lZWQuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yZXRyaWV2ZVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgIGluaXRUYWJsZSgpO1xuXHQgKiAgICAgIHRhYmxlQWN0aW9ucygpO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICAgIGZ1bmN0aW9uIGluaXRUYWJsZSAoKVxuXHQgKiAgICB7XG5cdCAqICAgICAgcmV0dXJuICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuXHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcblx0ICogICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfVxuXHQgKlxuXHQgKiAgICBmdW5jdGlvbiB0YWJsZUFjdGlvbnMgKClcblx0ICogICAge1xuXHQgKiAgICAgIHZhciB0YWJsZSA9IGluaXRUYWJsZSgpO1xuXHQgKiAgICAgIC8vIHBlcmZvcm0gQVBJIG9wZXJhdGlvbnMgd2l0aCBvVGFibGVcblx0ICogICAgfVxuXHQgKi9cblx0XCJiUmV0cmlldmVcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogV2hlbiB2ZXJ0aWNhbCAoeSkgc2Nyb2xsaW5nIGlzIGVuYWJsZWQsIERhdGFUYWJsZXMgd2lsbCBmb3JjZSB0aGUgaGVpZ2h0IG9mXG5cdCAqIHRoZSB0YWJsZSdzIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBoZWlnaHQgYXQgYWxsIHRpbWVzICh1c2VmdWwgZm9yIGxheW91dCkuXG5cdCAqIEhvd2V2ZXIsIHRoaXMgY2FuIGxvb2sgb2RkIHdoZW4gZmlsdGVyaW5nIGRhdGEgZG93biB0byBhIHNtYWxsIGRhdGEgc2V0LFxuXHQgKiBhbmQgdGhlIGZvb3RlciBpcyBsZWZ0IFwiZmxvYXRpbmdcIiBmdXJ0aGVyIGRvd24uIFRoaXMgcGFyYW1ldGVyICh3aGVuXG5cdCAqIGVuYWJsZWQpIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBjb2xsYXBzZSB0aGUgdGFibGUncyB2aWV3cG9ydCBkb3duIHdoZW5cblx0ICogdGhlIHJlc3VsdCBzZXQgd2lsbCBmaXQgd2l0aGluIHRoZSBnaXZlbiBZIGhlaWdodC5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbENvbGxhcHNlXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMFwiLFxuXHQgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJTY3JvbGxDb2xsYXBzZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxuXHQgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxuXHQgKiBzb3VyY2UgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhIGZvciBlYWNoIGRyYXcuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJTaWRlXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwiYWpheFwiOiBcInhoci5waHBcIlxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzb3J0aW5nIG9mIGNvbHVtbnMuIFNvcnRpbmcgb2YgaW5kaXZpZHVhbCBjb2x1bW5zIGNhbiBiZVxuXHQgKiBkaXNhYmxlZCBieSB0aGUgYHNvcnRhYmxlYCBvcHRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJpbmdcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwib3JkZXJpbmdcIjogZmFsc2Vcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYlNvcnRcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzcGxheSBEYXRhVGFibGVzJyBhYmlsaXR5IHRvIHNvcnQgbXVsdGlwbGUgY29sdW1ucyBhdCB0aGVcblx0ICogc2FtZSB0aW1lIChhY3RpdmF0ZWQgYnkgc2hpZnQtY2xpY2sgYnkgdGhlIHVzZXIpLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlck11bHRpXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBEaXNhYmxlIG11bHRpcGxlIGNvbHVtbiBzb3J0aW5nIGFiaWxpdHlcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJvcmRlck11bHRpXCI6IGZhbHNlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJTb3J0TXVsdGlcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgY29udHJvbCBvdmVyIHdoZXRoZXIgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRoZSB0b3AgKHRydWUpIHVuaXF1ZVxuXHQgKiBjZWxsIHRoYXQgaXMgZm91bmQgZm9yIGEgc2luZ2xlIGNvbHVtbiwgb3IgdGhlIGJvdHRvbSAoZmFsc2UgLSBkZWZhdWx0KS5cblx0ICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNlbGxzVG9wXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwib3JkZXJDZWxsc1RvcFwiOiB0cnVlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJTb3J0Q2VsbHNUb3BcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGFkZGl0aW9uIG9mIHRoZSBjbGFzc2VzIGBzb3J0aW5nXFxfMWAsIGBzb3J0aW5nXFxfMmAgYW5kXG5cdCAqIGBzb3J0aW5nXFxfM2AgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBzb3J0ZWQgb24uIFRoaXMgaXNcblx0ICogcHJlc2VudGVkIGFzIGEgZmVhdHVyZSBzd2l0Y2ggYXMgaXQgY2FuIGluY3JlYXNlIHByb2Nlc3NpbmcgdGltZSAod2hpbGVcblx0ICogY2xhc3NlcyBhcmUgcmVtb3ZlZCBhbmQgYWRkZWQpIHNvIGZvciBsYXJnZSBkYXRhIHNldHMgeW91IG1pZ2h0IHdhbnQgdG9cblx0ICogdHVybiB0aGlzIG9mZi5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IHRydWVcblx0ICpcblx0ICogIEBkdG9wdCBGZWF0dXJlc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2xhc3Nlc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJvcmRlckNsYXNzZXNcIjogZmFsc2Vcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYlNvcnRDbGFzc2VzXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxuXHQgKiB1c2VkIHRvIHNhdmUgdGFibGUgZGlzcGxheSBpbmZvcm1hdGlvbiBzdWNoIGFzIHBhZ2luYXRpb24gaW5mb3JtYXRpb24sXG5cdCAqIGRpc3BsYXkgbGVuZ3RoLCBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuIEFzIHN1Y2ggd2hlbiB0aGUgZW5kIHVzZXIgcmVsb2Fkc1xuXHQgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxuXHQgKlxuXHQgKiBEdWUgdG8gdGhlIHVzZSBvZiBgbG9jYWxTdG9yYWdlYCB0aGUgZGVmYXVsdCBzdGF0ZSBzYXZpbmcgaXMgbm90IHN1cHBvcnRlZFxuXHQgKiBpbiBJRTYgb3IgNy4gSWYgc3RhdGUgc2F2aW5nIGlzIHJlcXVpcmVkIGluIHRob3NlIGJyb3dzZXJzLCB1c2Vcblx0ICogYHN0YXRlU2F2ZUNhbGxiYWNrYCB0byBwcm92aWRlIGEgc3RvcmFnZSBzb2x1dGlvbiBzdWNoIGFzIGNvb2tpZXMuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJTdGF0ZVNhdmVcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFRSIGVsZW1lbnQgaXMgY3JlYXRlZCAoYW5kIGFsbCBURCBjaGlsZFxuXHQgKiBlbGVtZW50cyBoYXZlIGJlZW4gaW5zZXJ0ZWQpLCBvciByZWdpc3RlcmVkIGlmIHVzaW5nIGEgRE9NIHNvdXJjZSwgYWxsb3dpbmdcblx0ICogbWFuaXB1bGF0aW9uIG9mIHRoZSBUUiBlbGVtZW50IChhZGRpbmcgY2xhc3NlcyBldGMpLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcblx0ICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgUmF3IGRhdGEgYXJyYXkgZm9yIHRoaXMgcm93XG5cdCAqICBAcGFyYW0ge2ludH0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGlzIHJvdyBpbiB0aGUgaW50ZXJuYWwgYW9EYXRhIGFycmF5XG5cdCAqXG5cdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY3JlYXRlZFJvd1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHQgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xuXHQgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKVxuXHQgKiAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmbkNyZWF0ZWRSb3dcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXG5cdCAqIGR5bmFtaWNhbGx5IG1vZGlmeSBhbnkgYXNwZWN0IHlvdSB3YW50IGFib3V0IHRoZSBjcmVhdGVkIERPTS5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICpcblx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kcmF3Q2FsbGJhY2tcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJkcmF3Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHQgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIHJlZHJhd24gdGhlIHRhYmxlJyApO1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmbkRyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0byBmbkhlYWRlckNhbGxiYWNrKCkgYnV0IGZvciB0aGUgdGFibGUgZm9vdGVyIHRoaXMgZnVuY3Rpb25cblx0ICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKiAgQHBhcmFtIHtub2RlfSBmb290IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgZm9vdGVyXG5cdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuXHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxuXHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdCAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcblx0ICogICAgZGlzcGxheSBhcnJheVxuXHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0ICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvb3RlckNhbGxiYWNrXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiZm9vdGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHRmb290LCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHQgKiAgICAgICAgICB0Zm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIlN0YXJ0aW5nIGluZGV4IGlzIFwiK3N0YXJ0O1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApXG5cdCAqL1xuXHRcImZuRm9vdGVyQ2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcblx0ICogKGkuZS4gXCJTaG93aW5nIDEgdG8gMTAgb2YgNTcgZW50cmllc1wiKSBEYXRhVGFibGVzIHdpbGwgcmVuZGVyIGxhcmdlIG51bWJlcnNcblx0ICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xuXHQgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcblx0ICogZnVuY3Rpb24gd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2QgRGF0YVRhYmxlcyB1c2VzLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJcblx0ICogIEBwYXJhbSB7aW50fSB0b0Zvcm1hdCBudW1iZXIgdG8gYmUgZm9ybWF0dGVkXG5cdCAqICBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBEYXRhVGFibGVzIHRvIHNob3cgdGhlIG51bWJlclxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvcm1hdE51bWJlclxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIGEgc2luZ2xlIHF1b3RlIGZvciB0aGUgc2VwYXJhdG9yIChub3RlIHRoYXRcblx0ICogICAgLy8gdGhpcyBjYW4gYWxzbyBiZSBkb25lIHdpdGggdGhlIGxhbmd1YWdlLnRob3VzYW5kcyBvcHRpb24pXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJmb3JtYXROdW1iZXJcIjogZnVuY3Rpb24gKCB0b0Zvcm1hdCApIHtcblx0ICogICAgICAgICAgcmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0ICogICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCInXCJcblx0ICogICAgICAgICAgKTtcblx0ICogICAgICAgIH07XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XG5cdFx0cmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFxuXHRcdFx0dGhpcy5vTGFuZ3VhZ2Uuc1Rob3VzYW5kc1xuXHRcdCk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHQgKiBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGhlYWRlciByb3cuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGFuZFxuXHQgKiBkaXNwbGF5IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUuXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKiAgQHBhcmFtIHtub2RlfSBoZWFkIFwiVFJcIiBlbGVtZW50IGZvciB0aGUgaGVhZGVyXG5cdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuXHQgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxuXHQgKiAgICBkaXNwbGF5IGFycmF5XG5cdCAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcblx0ICogICAgZGlzcGxheSBhcnJheVxuXHQgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cblx0ICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmhlYWRlckNhbGxiYWNrXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiZmhlYWRlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCBoZWFkLCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuXHQgKiAgICAgICAgICBoZWFkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiRGlzcGxheWluZyBcIisoZW5kLXN0YXJ0KStcIiByZWNvcmRzXCI7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9IClcblx0ICovXG5cdFwiZm5IZWFkZXJDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGNvbnZleSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudFxuXHQgKiBzdGF0ZSBvZiB0aGUgdGFibGUuIEFsdGhvdWdoIHRoZSBpbnRlcm5hdGlvbmFsaXNhdGlvbiBvcHRpb25zIHByZXNlbnRlZCBieVxuXHQgKiBEYXRhVGFibGVzIGFyZSBxdWl0ZSBjYXBhYmxlIG9mIGRlYWxpbmcgd2l0aCBtb3N0IGN1c3RvbWlzYXRpb25zLCB0aGVyZSBtYXlcblx0ICogYmUgdGltZXMgd2hlcmUgeW91IHdpc2ggdG8gY3VzdG9taXNlIHRoZSBzdHJpbmcgZnVydGhlci4gVGhpcyBjYWxsYmFja1xuXHQgKiBhbGxvd3MgeW91IHRvIGRvIGV4YWN0bHkgdGhhdC5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge2ludH0gc3RhcnQgU3RhcnRpbmcgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcblx0ICogIEBwYXJhbSB7aW50fSBlbmQgRW5kIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XG5cdCAqICBAcGFyYW0ge2ludH0gbWF4IFRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSB0YWJsZSAocmVnYXJkbGVzcyBvZlxuXHQgKiAgICBmaWx0ZXJpbmcpXG5cdCAqICBAcGFyYW0ge2ludH0gdG90YWwgVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0ICogIEBwYXJhbSB7c3RyaW5nfSBwcmUgVGhlIHN0cmluZyB0aGF0IERhdGFUYWJsZXMgaGFzIGZvcm1hdHRlZCB1c2luZyBpdCdzXG5cdCAqICAgIG93biBydWxlc1xuXHQgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQuXG5cdCAqXG5cdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb0NhbGxiYWNrXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgIFwiaW5mb0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgcHJlICkge1xuXHQgKiAgICAgICAgcmV0dXJuIHN0YXJ0ICtcIiB0byBcIisgZW5kO1xuXHQgKiAgICAgIH1cblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC4gTm9ybWFsbHkgRGF0YVRhYmxlcyB3aWxsXG5cdCAqIGluaXRpYWxpc2Ugc2VxdWVudGlhbGx5IGFuZCB0aGVyZSB3aWxsIGJlIG5vIG5lZWQgZm9yIHRoaXMgZnVuY3Rpb24sXG5cdCAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cblx0ICogc2luY2UgdGhhdCBpcyBvYnRhaW5lZCB1c2luZyBhbiBhc3luYyBYSFIgY2FsbC5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcblx0ICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkXG5cdCAqXG5cdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5pdENvbXBsZXRlXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiaW5pdENvbXBsZXRlXCI6IGZ1bmN0aW9uKHNldHRpbmdzLCBqc29uKSB7XG5cdCAqICAgICAgICAgIGFsZXJ0KCAnRGF0YVRhYmxlcyBoYXMgZmluaXNoZWQgaXRzIGluaXRpYWxpc2F0aW9uLicgKTtcblx0ICogICAgICAgIH1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKVxuXHQgKi9cblx0XCJmbkluaXRDb21wbGV0ZVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCB0aGUgdmVyeSBzdGFydCBvZiBlYWNoIHRhYmxlIGRyYXcgYW5kIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGVcblx0ICogZHJhdyBieSByZXR1cm5pbmcgZmFsc2UsIGFueSBvdGhlciByZXR1cm4gKGluY2x1ZGluZyB1bmRlZmluZWQpIHJlc3VsdHMgaW5cblx0ICogdGhlIGZ1bGwgZHJhdyBvY2N1cnJpbmcpLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIHdpbGwgY2FuY2VsIHRoZSBkcmF3LCBhbnl0aGluZyBlbHNlIChpbmNsdWRpbmcgbm9cblx0ICogICAgcmV0dXJuKSB3aWxsIGFsbG93IGl0IHRvIGNvbXBsZXRlLlxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByZURyYXdDYWxsYmFja1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInByZURyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdCAqICAgICAgICAgIGlmICggJCgnI3Rlc3QnKS52YWwoKSA9PSAxICkge1xuXHQgKiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmblByZURyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byAncG9zdCBwcm9jZXNzJyBlYWNoIHJvdyBhZnRlciBpdCBoYXZlIGJlZW5cblx0ICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXG5cdCAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG5cdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuXHQgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleCBUaGUgZGlzcGxheSBpbmRleCBmb3IgdGhlIGN1cnJlbnQgdGFibGUgZHJhd1xuXHQgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleEZ1bGwgVGhlIGluZGV4IG9mIHRoZSBkYXRhIGluIHRoZSBmdWxsIGxpc3Qgb2Zcblx0ICogICAgcm93cyAoYWZ0ZXIgZmlsdGVyaW5nKVxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0NhbGxiYWNrXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwicm93Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGlzcGxheUluZGV4LCBkaXNwbGF5SW5kZXhGdWxsICkge1xuXHQgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xuXHQgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKSB7XG5cdCAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmblJvd0NhbGxiYWNrXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0ICpcblx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBvYnRhaW5zXG5cdCAqIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciBzbyBzb21ldGhpbmcgbW9yZSBzdWl0YWJsZSBmb3IgeW91ciBhcHBsaWNhdGlvbi5cblx0ICogRm9yIGV4YW1wbGUgeW91IGNvdWxkIHVzZSBQT1NUIGRhdGEsIG9yIHB1bGwgaW5mb3JtYXRpb24gZnJvbSBhIEdlYXJzIG9yXG5cdCAqIEFJUiBkYXRhYmFzZS5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAbWVtYmVyXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gc291cmNlIEhUVFAgc291cmNlIHRvIG9idGFpbiB0aGUgZGF0YSBmcm9tIChgYWpheGApXG5cdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEEga2V5L3ZhbHVlIHBhaXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gc2VuZFxuXHQgKiAgICB0byB0aGUgc2VydmVyXG5cdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbiBvZiB0aGUgZGF0YSBnZXRcblx0ICogICAgcHJvY2VzcyB0aGF0IHdpbGwgZHJhdyB0aGUgZGF0YSBvbiB0aGUgcGFnZS5cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyRGF0YVxuXHQgKlxuXHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdCAqL1xuXHRcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdCAqXG5cdCAqICBJdCBpcyBvZnRlbiB1c2VmdWwgdG8gc2VuZCBleHRyYSBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBtYWtpbmcgYW4gQWpheFxuXHQgKiByZXF1ZXN0IC0gZm9yIGV4YW1wbGUgY3VzdG9tIGZpbHRlcmluZyBpbmZvcm1hdGlvbiwgYW5kIHRoaXMgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24gbWFrZXMgaXQgdHJpdmlhbCB0byBzZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBzZXJ2ZXIuIFRoZVxuXHQgKiBwYXNzZWQgaW4gcGFyYW1ldGVyIGlzIHRoZSBkYXRhIHNldCB0aGF0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGJ5XG5cdCAqIERhdGFUYWJsZXMsIGFuZCB5b3UgY2FuIGFkZCB0byB0aGlzIG9yIG1vZGlmeSBpdCBhcyB5b3UgcmVxdWlyZS5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgYXJyYXkgKGFycmF5IG9mIG9iamVjdHMgd2hpY2ggYXJlIG5hbWUvdmFsdWVcblx0ICogICAgcGFpcnMpIHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnkgRGF0YVRhYmxlcyBhbmQgd2lsbCBiZSBzZW50IHRvIHRoZVxuXHQgKiAgICBzZXJ2ZXIuIEluIHRoZSBjYXNlIG9mIEFqYXggc291cmNlZCBkYXRhIHdpdGggc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHQgKiAgICB0aGlzIHdpbGwgYmUgYW4gZW1wdHkgYXJyYXksIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZXJlIHdpbGwgYmUgYVxuXHQgKiAgICBzaWduaWZpY2FudCBudW1iZXIgb2YgcGFyYW1ldGVycyFcblx0ICogIEByZXR1cm5zIHt1bmRlZmluZWR9IEVuc3VyZSB0aGF0IHlvdSBtb2RpZnkgdGhlIGRhdGEgYXJyYXkgcGFzc2VkIGluLFxuXHQgKiAgICBhcyB0aGlzIGlzIHBhc3NlZCBieSByZWZlcmVuY2UuXG5cdCAqXG5cdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdCAqICBAZHRvcHQgU2VydmVyLXNpZGVcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJQYXJhbXNcblx0ICpcblx0ICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuXHQgKi9cblx0XCJmblNlcnZlclBhcmFtc1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXG5cdCAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcblx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKiAgQG1lbWJlclxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG5cdCAqICBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCBjYW4gYmUgZXhlY3V0ZWQgd2hlbiBkb25lLiBJdFxuXHQgKiAgICBzaG91bGQgYmUgcGFzc2VkIHRoZSBsb2FkZWQgc3RhdGUgb2JqZWN0LlxuXHQgKiAgQHJldHVybiB7b2JqZWN0fSBUaGUgRGF0YVRhYmxlcyBzdGF0ZSBvYmplY3QgdG8gYmUgbG9hZGVkXG5cdCAqXG5cdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkQ2FsbGJhY2tcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwic3RhdGVMb2FkQ2FsbGJhY2tcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBjYWxsYmFjaykge1xuXHQgKiAgICAgICAgICAkLmFqYXgoIHtcblx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9sb2FkXCIsXG5cdCAqICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcblx0ICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcblx0ICogICAgICAgICAgICAgIGNhbGxiYWNrKCBqc29uICk7XG5cdCAqICAgICAgICAgICAgfVxuXHQgKiAgICAgICAgICB9ICk7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImZuU3RhdGVMb2FkQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoXG5cdFx0XHRcdChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuZ2V0SXRlbShcblx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWVcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIHByaW9yIHRvIGxvYWRpbmcgdGhhdCBzdGF0ZS5cblx0ICogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWQgZGF0YSwgYnV0XG5cdCAqIHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlLiBOb3RlIHRoYXQgZm9yXG5cdCAqIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZCB1c2UgdGhlIGBzdGF0ZUxvYWRQYXJhbXNgIGV2ZW50IHRvIGxvYWQgcGFyYW1ldGVycyBmb3Jcblx0ICogYSBwbHVnLWluLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IGlzIHRvIGJlIGxvYWRlZFxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZFBhcmFtc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgbG9hZGVkXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBEaXNhbGxvdyBzdGF0ZSBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdCAqICAgICAgICBcInN0YXRlTG9hZFBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcblx0ICogICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmblN0YXRlTG9hZFBhcmFtc1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzdGF0ZSBzYXZpbmcgbWV0aG9kXG5cdCAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCB3YXMgbG9hZGVkXG5cdCAqXG5cdCAqICBAZHRvcHQgQ2FsbGJhY2tzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkZWRcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFNob3cgYW4gYWxlcnQgd2l0aCB0aGUgZmlsdGVyaW5nIHZhbHVlIHRoYXQgd2FzIHNhdmVkXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwic3RhdGVMb2FkZWRcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XG5cdCAqICAgICAgICAgIGFsZXJ0KCAnU2F2ZWQgZmlsdGVyIHdhczogJytkYXRhLm9TZWFyY2guc1NlYXJjaCApO1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmblN0YXRlTG9hZGVkXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogU2F2ZSB0aGUgdGFibGUgc3RhdGUuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBkZWZpbmUgd2hlcmUgYW5kIGhvdyB0aGUgc3RhdGVcblx0ICogaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZSBpcyBzdG9yZWQgQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgdXNlIGBsb2NhbFN0b3JhZ2VgXG5cdCAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBtZW1iZXJcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHQgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuXHQgKlxuXHQgKiAgQGR0b3B0IENhbGxiYWNrc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZUNhbGxiYWNrXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG5cdCAqICAgICAgICBcInN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHQgKiAgICAgICAgICAvLyBTZW5kIGFuIEFqYXggcmVxdWVzdCB0byB0aGUgc2VydmVyIHdpdGggdGhlIHN0YXRlIG9iamVjdFxuXHQgKiAgICAgICAgICAkLmFqYXgoIHtcblx0ICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9zYXZlXCIsXG5cdCAqICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGEsXG5cdCAqICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcblx0ICogICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIlxuXHQgKiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmdW5jdGlvbiAoKSB7fVxuXHQgKiAgICAgICAgICB9ICk7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncywgZGF0YSApIHtcblx0XHR0cnkge1xuXHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5zZXRJdGVtKFxuXHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWUsXG5cdFx0XHRcdEpTT04uc3RyaW5naWZ5KCBkYXRhIClcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXG5cdCAqIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIGFsbG93cyBtb2RpZmljYXRpb24gb2Zcblx0ICogdGhlIHN0YXRlIHNhdmluZyBvYmplY3QgcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvclxuXHQgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcblx0ICogdXNlIHRoZSBgc3RhdGVTYXZlUGFyYW1zYCBldmVudCB0byBzYXZlIHBhcmFtZXRlcnMgZm9yIGEgcGx1Zy1pbi5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0ICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcblx0ICpcblx0ICogIEBkdG9wdCBDYWxsYmFja3Ncblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVQYXJhbXNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIHNhdmVkXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwic3RhdGVTYXZlUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuXHQgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImZuU3RhdGVTYXZlUGFyYW1zXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogRHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvbiBpcyBjb25zaWRlcmVkIHZhbGlkLiBBZnRlciB0aGlzIHBlcmlvZFxuXHQgKiBoYXMgZWxhcHNlZCB0aGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgZGVmYXVsdC5cblx0ICogVmFsdWUgaXMgZ2l2ZW4gaW4gc2Vjb25kcy5cblx0ICogIEB0eXBlIGludFxuXHQgKiAgQGRlZmF1bHQgNzIwMCA8aT4oMiBob3Vycyk8L2k+XG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlRHVyYXRpb25cblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzdGF0ZUR1cmF0aW9uXCI6IDYwKjYwKjI0OyAvLyAxIGRheVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApXG5cdCAqL1xuXHRcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXG5cblxuXHQvKipcblx0ICogV2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbCBub3QgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciBmb3IgdGhlIGZpcnN0XG5cdCAqIHBhZ2UgZHJhdyAtIHJhdGhlciBpdCB3aWxsIHVzZSB0aGUgZGF0YSBhbHJlYWR5IG9uIHRoZSBwYWdlIChubyBzb3J0aW5nIGV0Y1xuXHQgKiB3aWxsIGJlIGFwcGxpZWQgdG8gaXQpLCB0aHVzIHNhdmluZyBvbiBhbiBYSFIgYXQgbG9hZCB0aW1lLiBgZGVmZXJMb2FkaW5nYFxuXHQgKiBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgZGVmZXJyZWQgbG9hZGluZyBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIGFsc28gdXNlZFxuXHQgKiB0byB0ZWxsIERhdGFUYWJsZXMgaG93IG1hbnkgcmVjb3JkcyB0aGVyZSBhcmUgaW4gdGhlIGZ1bGwgdGFibGUgKGFsbG93aW5nXG5cdCAqIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGFuZCBwYWdpbmF0aW9uIHRvIGJlIGRpc3BsYXllZCBjb3JyZWN0bHkpLiBJbiB0aGUgY2FzZVxuXHQgKiB3aGVyZSBhIGZpbHRlcmluZyBpcyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBvbiBpbml0aWFsIGxvYWQsIHRoaXMgY2FuIGJlXG5cdCAqIGluZGljYXRlZCBieSBnaXZpbmcgdGhlIHBhcmFtZXRlciBhcyBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcblx0ICogdGhlIG51bWJlciBvZiByZWNvcmRzIGF2YWlsYWJsZSBhZnRlciBmaWx0ZXJpbmcgYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyB0aGVcblx0ICogbnVtYmVyIG9mIHJlY29yZHMgd2l0aG91dCBmaWx0ZXJpbmcgKGFsbG93aW5nIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50XG5cdCAqIHRvIGJlIHNob3duIGNvcnJlY3RseSkuXG5cdCAqICBAdHlwZSBpbnQgfCBhcnJheVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZWZlckxvYWRpbmdcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIDU3IHJlY29yZHMgYXZhaWxhYmxlIGluIHRoZSB0YWJsZSwgbm8gZmlsdGVyaW5nIGFwcGxpZWRcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdCAqICAgICAgICBcImRlZmVyTG9hZGluZ1wiOiA1N1xuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gNTcgcmVjb3JkcyBhZnRlciBmaWx0ZXJpbmcsIDEwMCB3aXRob3V0IGZpbHRlcmluZyAoYW4gaW5pdGlhbCBmaWx0ZXIgYXBwbGllZClcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcblx0ICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG5cdCAqICAgICAgICBcImRlZmVyTG9hZGluZ1wiOiBbIDU3LCAxMDAgXSxcblx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcblx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJteV9maWx0ZXJcIlxuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJpRGVmZXJMb2FkaW5nXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSBvbiBhIHNpbmdsZSBwYWdlIHdoZW4gdXNpbmcgcGFnaW5hdGlvbi4gSWZcblx0ICogZmVhdHVyZSBlbmFibGVkIChgbGVuZ3RoQ2hhbmdlYCkgdGhlbiB0aGUgZW5kIHVzZXIgd2lsbCBiZSBhYmxlIHRvIG92ZXJyaWRlXG5cdCAqIHRoaXMgdG8gYSBjdXN0b20gc2V0dGluZyB1c2luZyBhIHBvcC11cCBtZW51LlxuXHQgKiAgQHR5cGUgaW50XG5cdCAqICBAZGVmYXVsdCAxMFxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdlTGVuZ3RoXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwicGFnZUxlbmd0aFwiOiA1MFxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApXG5cdCAqL1xuXHRcImlEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXG5cblx0LyoqXG5cdCAqIERlZmluZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGRhdGEgZGlzcGxheSB3aGVuIHVzaW5nIERhdGFUYWJsZXMgd2l0aFxuXHQgKiBwYWdpbmF0aW9uLiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiByZWNvcmRzLCByYXRoZXIgdGhhblxuXHQgKiB0aGUgcGFnZSBudW1iZXIsIHNvIGlmIHlvdSBoYXZlIDEwIHJlY29yZHMgcGVyIHBhZ2UgYW5kIHdhbnQgdG8gc3RhcnQgb25cblx0ICogdGhlIHRoaXJkIHBhZ2UsIGl0IHNob3VsZCBiZSBcIjIwXCIuXG5cdCAqICBAdHlwZSBpbnRcblx0ICogIEBkZWZhdWx0IDBcblx0ICpcblx0ICogIEBkdG9wdCBPcHRpb25zXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGlzcGxheVN0YXJ0XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiZGlzcGxheVN0YXJ0XCI6IDIwXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9IClcblx0ICovXG5cdFwiaURpc3BsYXlTdGFydFwiOiAwLFxuXG5cblx0LyoqXG5cdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcblx0ICogYW5kIGZpbHRlcmluZykgYnkgYWRkaW5nIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUgdG8gdGhlIHJlcXVpcmVkIGVsZW1lbnRzLiBUaGlzXG5cdCAqIGFsbG93cyB5b3UgdG8gdGFiIHRocm91Z2ggdGhlIGNvbnRyb2xzIGFuZCBwcmVzcyB0aGUgZW50ZXIga2V5IHRvIGFjdGl2YXRlIHRoZW0uXG5cdCAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuXHQgKiBZb3UgY2FuIG92ZXJydWxlIHRoaXMgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaWYgeW91IHdpc2guIFVzZSBhIHZhbHVlIG9mIC0xIHRvXG5cdCAqIGRpc2FibGUgYnVpbHQtaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbi5cblx0ICogIEB0eXBlIGludFxuXHQgKiAgQGRlZmF1bHQgMFxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy50YWJJbmRleFxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInRhYkluZGV4XCI6IDFcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiaVRhYkluZGV4XCI6IDAsXG5cblxuXHQvKipcblx0ICogQ2xhc3NlcyB0aGF0IERhdGFUYWJsZXMgYXNzaWducyB0byB0aGUgdmFyaW91cyBjb21wb25lbnRzIGFuZCBmZWF0dXJlc1xuXHQgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxuXHQgKiBkdXJpbmcgaW5pdGlhbGlzYXRpb24gaW4gYWRkaXRpb24gdG8gdGhyb3VnaCB0aGUgc3RhdGljXG5cdCAqIHtAbGluayBEYXRhVGFibGUuZXh0Lm9TdGRDbGFzc2VzfSBvYmplY3QpLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNsYXNzZXNcblx0ICovXG5cdFwib0NsYXNzZXNcIjoge30sXG5cblxuXHQvKipcblx0ICogQWxsIHN0cmluZ3MgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW4gdGhlIHVzZXIgaW50ZXJmYWNlIHRoYXQgaXQgY3JlYXRlc1xuXHQgKiBhcmUgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIG1vZGlmaWVkIHRoZW0gaW5kaXZpZHVhbGx5IG9yXG5cdCAqIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGVtIGFsbCBhcyByZXF1aXJlZC5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZVxuXHQgKi9cblx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdC8qKlxuXHRcdCAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG5cdFx0ICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xuXHRcdCAqIG11c3QgYmUgaW50ZXJuYXRpb25hbGlzZWQgYXMgd2VsbCkuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWFcblx0XHQgKi9cblx0XHRcIm9BcmlhXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcblx0XHRcdCAqIHNvcnRlZCBhc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG5cdFx0XHQgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaXMgcHJlZml4ZWQgdG8gdGhpcyBzdHJpbmcuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydEFzY2VuZGluZ1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJhcmlhXCI6IHtcblx0XHRcdCAqICAgICAgICAgICAgXCJzb3J0QXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgYXNjZW5kaW5nXCJcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzU29ydEFzY2VuZGluZ1wiOiBcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcblx0XHRcdCAqIHNvcnRlZCBkZXNjZW5kaW5nIGJ5IGFjdGl2aW5nIHRoZSBjb2x1bW4gKGNsaWNrIG9yIHJldHVybiB3aGVuIGZvY3VzZWQpLlxuXHRcdFx0ICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IDogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhLnNvcnREZXNjZW5kaW5nXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcImFyaWFcIjoge1xuXHRcdFx0ICogICAgICAgICAgICBcInNvcnREZXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgZGVzY2VuZGluZ1wiXG5cdFx0XHQgKiAgICAgICAgICB9XG5cdFx0XHQgKiAgICAgICAgfVxuXHRcdFx0ICogICAgICB9ICk7XG5cdFx0XHQgKiAgICB9ICk7XG5cdFx0XHQgKi9cblx0XHRcdFwic1NvcnREZXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBkZXNjZW5kaW5nXCJcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGFnaW5hdGlvbiBzdHJpbmcgdXNlZCBieSBEYXRhVGFibGVzIGZvciB0aGUgYnVpbHQtaW4gcGFnaW5hdGlvblxuXHRcdCAqIGNvbnRyb2wgdHlwZXMuXG5cdFx0ICogIEBuYW1lc3BhY2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlXG5cdFx0ICovXG5cdFx0XCJvUGFnaW5hdGVcIjoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxuXHRcdFx0ICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGZpcnN0IHBhZ2UuXG5cdFx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0XHQgKiAgQGRlZmF1bHQgRmlyc3Rcblx0XHRcdCAqXG5cdFx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmZpcnN0XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdCAqICAgICAgICAgICAgXCJmaXJzdFwiOiBcIkZpcnN0IHBhZ2VcIlxuXHRcdFx0ICogICAgICAgICAgfVxuXHRcdFx0ICogICAgICAgIH1cblx0XHRcdCAqICAgICAgfSApO1xuXHRcdFx0ICogICAgfSApO1xuXHRcdFx0ICovXG5cdFx0XHRcInNGaXJzdFwiOiBcIkZpcnN0XCIsXG5cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxuXHRcdFx0ICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGxhc3QgcGFnZS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBMYXN0XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5sYXN0XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdCAqICAgICAgICAgICAgXCJsYXN0XCI6IFwiTGFzdCBwYWdlXCJcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzTGFzdFwiOiBcIkxhc3RcIixcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ25leHQnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvIHRoZVxuXHRcdFx0ICogbmV4dCBwYWdlKS5cblx0XHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHRcdCAqICBAZGVmYXVsdCBOZXh0XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5uZXh0XG5cdFx0XHQgKlxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcblx0XHRcdCAqICAgICAgICAgICAgXCJuZXh0XCI6IFwiTmV4dCBwYWdlXCJcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzTmV4dFwiOiBcIk5leHRcIixcblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ3ByZXZpb3VzJyBwYWdpbmF0aW9uIGJ1dHRvbiAodG8gdGFrZSB0aGUgdXNlciB0b1xuXHRcdFx0ICogdGhlIHByZXZpb3VzIHBhZ2UpLlxuXHRcdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdFx0ICogIEBkZWZhdWx0IFByZXZpb3VzXG5cdFx0XHQgKlxuXHRcdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5wcmV2aW91c1xuXHRcdFx0ICpcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdFx0ICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XG5cdFx0XHQgKiAgICAgICAgICAgIFwicHJldmlvdXNcIjogXCJQcmV2aW91cyBwYWdlXCJcblx0XHRcdCAqICAgICAgICAgIH1cblx0XHRcdCAqICAgICAgICB9XG5cdFx0XHQgKiAgICAgIH0gKTtcblx0XHRcdCAqICAgIH0gKTtcblx0XHRcdCAqL1xuXHRcdFx0XCJzUHJldmlvdXNcIjogXCJQcmV2aW91c1wiXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3RyaW5nIGlzIHNob3duIGluIHByZWZlcmVuY2UgdG8gYHplcm9SZWNvcmRzYCB3aGVuIHRoZSB0YWJsZSBpc1xuXHRcdCAqIGVtcHR5IG9mIGRhdGEgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS4gTm90ZSB0aGF0IHRoaXMgaXMgYW4gb3B0aW9uYWxcblx0XHQgKiBwYXJhbWV0ZXIgLSBpZiBpdCBpcyBub3QgZ2l2ZW4sIHRoZSB2YWx1ZSBvZiBgemVyb1JlY29yZHNgIHdpbGwgYmUgdXNlZFxuXHRcdCAqIGluc3RlYWQgKGVpdGhlciB0aGUgZGVmYXVsdCBvciBnaXZlbiB2YWx1ZSkuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZW1wdHlUYWJsZVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0ICogICAgICAgICAgXCJlbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIlxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0VtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHN0cmluZyBnaXZlcyBpbmZvcm1hdGlvbiB0byB0aGUgZW5kIHVzZXIgYWJvdXQgdGhlIGluZm9ybWF0aW9uXG5cdFx0ICogdGhhdCBpcyBjdXJyZW50IG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UuIFRoZSBmb2xsb3dpbmcgdG9rZW5zIGNhbiBiZVxuXHRcdCAqIHVzZWQgaW4gdGhlIHN0cmluZyBhbmQgd2lsbCBiZSBkeW5hbWljYWxseSByZXBsYWNlZCBhcyB0aGUgdGFibGVcblx0XHQgKiBkaXNwbGF5IHVwZGF0ZXMuIFRoaXMgdG9rZW5zIGNhbiBiZSBwbGFjZWQgYW55d2hlcmUgaW4gdGhlIHN0cmluZywgb3Jcblx0XHQgKiByZW1vdmVkIGFzIG5lZWRlZCBieSB0aGUgbGFuZ3VhZ2UgcmVxdWlyZXM6XG5cdFx0ICpcblx0XHQgKiAqIGBcXF9TVEFSVFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBmaXJzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdCAqICogYFxcX0VORFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBsYXN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG5cdFx0ICogKiBgXFxfVE9UQUxcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICogYFxcX01BWFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgd2l0aG91dCBmaWx0ZXJpbmdcblx0XHQgKiAqIGBcXF9QQUdFXFxfYCAtIEN1cnJlbnQgcGFnZSBudW1iZXJcblx0XHQgKiAqIGBcXF9QQUdFU1xcX2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXMgb2YgZGF0YSBpbiB0aGUgdGFibGVcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1xuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0ICogICAgICAgICAgXCJpbmZvXCI6IFwiU2hvd2luZyBwYWdlIF9QQUdFXyBvZiBfUEFHRVNfXCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNJbmZvXCI6IFwiU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gZW50cmllc1wiLFxuXG5cblx0XHQvKipcblx0XHQgKiBEaXNwbGF5IGluZm9ybWF0aW9uIHN0cmluZyBmb3Igd2hlbiB0aGUgdGFibGUgaXMgZW1wdHkuIFR5cGljYWxseSB0aGVcblx0XHQgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IFNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1xuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0VtcHR5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHQgKiAgICAgICAgICBcImluZm9FbXB0eVwiOiBcIk5vIGVudHJpZXMgdG8gc2hvd1wiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzSW5mb0VtcHR5XCI6IFwiU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gYSB1c2VyIGZpbHRlcnMgdGhlIGluZm9ybWF0aW9uIGluIGEgdGFibGUsIHRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkXG5cdFx0ICogdG8gdGhlIGluZm9ybWF0aW9uIChgaW5mb2ApIHRvIGdpdmUgYW4gaWRlYSBvZiBob3cgc3Ryb25nIHRoZSBmaWx0ZXJpbmdcblx0XHQgKiBpcy4gVGhlIHZhcmlhYmxlIF9NQVhfIGlzIGR5bmFtaWNhbGx5IHVwZGF0ZWQuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCAoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0ZpbHRlcmVkXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHQgKiAgICAgICAgICBcImluZm9GaWx0ZXJlZFwiOiBcIiAtIGZpbHRlcmluZyBmcm9tIF9NQVhfIHJlY29yZHNcIlxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0luZm9GaWx0ZXJlZFwiOiBcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIElmIGNhbiBiZSB1c2VmdWwgdG8gYXBwZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBpbmZvIHN0cmluZyBhdCB0aW1lcyxcblx0XHQgKiBhbmQgdGhpcyB2YXJpYWJsZSBkb2VzIGV4YWN0bHkgdGhhdC4gVGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGFwcGVuZGVkIHRvXG5cdFx0ICogdGhlIGBpbmZvYCAoYGluZm9FbXB0eWAgYW5kIGBpbmZvRmlsdGVyZWRgIGluIHdoYXRldmVyIGNvbWJpbmF0aW9uIHRoZXkgYXJlXG5cdFx0ICogYmVpbmcgdXNlZCkgYXQgYWxsIHRpbWVzLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb1Bvc3RGaXhcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdCAqICAgICAgICAgIFwiaW5mb1Bvc3RGaXhcIjogXCJBbGwgcmVjb3JkcyBzaG93biBhcmUgZGVyaXZlZCBmcm9tIHJlYWwgaW5mb3JtYXRpb24uXCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNJbmZvUG9zdEZpeFwiOiBcIlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGRlY2ltYWwgcGxhY2Ugb3BlcmF0b3IgaXMgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIG90aGVyXG5cdFx0ICogbGFuZ3VhZ2Ugb3B0aW9ucyBzaW5jZSBEYXRhVGFibGVzIGRvZXNuJ3Qgb3V0cHV0IGZsb2F0aW5nIHBvaW50XG5cdFx0ICogbnVtYmVycywgc28gaXQgd29uJ3QgZXZlciB1c2UgdGhpcyBmb3IgZGlzcGxheSBvZiBhIG51bWJlci4gUmF0aGVyLFxuXHRcdCAqIHdoYXQgdGhpcyBwYXJhbWV0ZXIgZG9lcyBpcyBtb2RpZnkgdGhlIHNvcnQgbWV0aG9kcyBvZiB0aGUgdGFibGUgc29cblx0XHQgKiB0aGF0IG51bWJlcnMgd2hpY2ggYXJlIGluIGEgZm9ybWF0IHdoaWNoIGhhcyBhIGNoYXJhY3RlciBvdGhlciB0aGFuXG5cdFx0ICogYSBwZXJpb2QgKGAuYCkgYXMgYSBkZWNpbWFsIHBsYWNlIHdpbGwgYmUgc29ydGVkIG51bWVyaWNhbGx5LlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IG51bWJlcnMgd2l0aCBkaWZmZXJlbnQgZGVjaW1hbCBwbGFjZXMgY2Fubm90IGJlIHNob3duIGluXG5cdFx0ICogdGhlIHNhbWUgdGFibGUgYW5kIHN0aWxsIGJlIHNvcnRhYmxlLCB0aGUgdGFibGUgbXVzdCBiZSBjb25zaXN0ZW50LlxuXHRcdCAqIEhvd2V2ZXIsIG11bHRpcGxlIGRpZmZlcmVudCB0YWJsZXMgb24gdGhlIHBhZ2UgY2FuIHVzZSBkaWZmZXJlbnRcblx0XHQgKiBkZWNpbWFsIHBsYWNlIGNoYXJhY3RlcnMuXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmRlY2ltYWxcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdCAqICAgICAgICAgIFwiZGVjaW1hbFwiOiBcIixcIlxuXHRcdCAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiLlwiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzRGVjaW1hbFwiOiBcIlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBEYXRhVGFibGVzIGhhcyBhIGJ1aWxkIGluIG51bWJlciBmb3JtYXR0ZXIgKGBmb3JtYXROdW1iZXJgKSB3aGljaCBpc1xuXHRcdCAqIHVzZWQgdG8gZm9ybWF0IGxhcmdlIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUgaW5mb3JtYXRpb24uXG5cdFx0ICogQnkgZGVmYXVsdCBhIGNvbW1hIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSB0cml2aWFsbHkgY2hhbmdlZCB0byBhbnlcblx0XHQgKiBjaGFyYWN0ZXIgeW91IHdpc2ggd2l0aCB0aGlzIHBhcmFtZXRlci5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0ICxcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnRob3VzYW5kc1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0ICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCInXCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNUaG91c2FuZHNcIjogXCIsXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIERldGFpbCB0aGUgYWN0aW9uIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSBkcm9wIGRvd24gbWVudSBmb3IgdGhlXG5cdFx0ICogcGFnaW5hdGlvbiBsZW5ndGggb3B0aW9uIGlzIGNoYW5nZWQuIFRoZSAnX01FTlVfJyB2YXJpYWJsZSBpcyByZXBsYWNlZFxuXHRcdCAqIHdpdGggYSBkZWZhdWx0IHNlbGVjdCBsaXN0IG9mIDEwLCAyNSwgNTAgYW5kIDEwMCwgYW5kIGNhbiBiZSByZXBsYWNlZFxuXHRcdCAqIHdpdGggYSBjdXN0b20gc2VsZWN0IGJveCBpZiByZXF1aXJlZC5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IFNob3cgX01FTlVfIGVudHJpZXNcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmxlbmd0aE1lbnVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIExhbmd1YWdlIGNoYW5nZSBvbmx5XG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0ICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6IFwiRGlzcGxheSBfTUVOVV8gcmVjb3Jkc1wiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBMYW5ndWFnZSBhbmQgb3B0aW9ucyBjaGFuZ2Vcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHQgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogJ0Rpc3BsYXkgPHNlbGVjdD4nK1xuXHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIxMFwiPjEwPC9vcHRpb24+Jytcblx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMjBcIj4yMDwvb3B0aW9uPicrXG5cdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjMwXCI+MzA8L29wdGlvbj4nK1xuXHRcdCAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI0MFwiPjQwPC9vcHRpb24+Jytcblx0XHQgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNTBcIj41MDwvb3B0aW9uPicrXG5cdFx0ICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIi0xXCI+QWxsPC9vcHRpb24+Jytcblx0XHQgKiAgICAgICAgICAgICc8L3NlbGVjdD4gcmVjb3Jkcydcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNMZW5ndGhNZW51XCI6IFwiU2hvdyBfTUVOVV8gZW50cmllc1wiLFxuXG5cblx0XHQvKipcblx0XHQgKiBXaGVuIHVzaW5nIEFqYXggc291cmNlZCBkYXRhIGFuZCBkdXJpbmcgdGhlIGZpcnN0IGRyYXcgd2hlbiBEYXRhVGFibGVzIGlzXG5cdFx0ICogZ2F0aGVyaW5nIHRoZSBkYXRhLCB0aGlzIG1lc3NhZ2UgaXMgc2hvd24gaW4gYW4gZW1wdHkgcm93IGluIHRoZSB0YWJsZSB0b1xuXHRcdCAqIGluZGljYXRlIHRvIHRoZSBlbmQgdXNlciB0aGUgdGhlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLiBOb3RlIHRoYXQgdGhpc1xuXHRcdCAqIHBhcmFtZXRlciBpcyBub3QgdXNlZCB3aGVuIGxvYWRpbmcgZGF0YSBieSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCBqdXN0XG5cdFx0ICogQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nLlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgTG9hZGluZy4uLlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubG9hZGluZ1JlY29yZHNcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdCAqICAgICAgICAgIFwibG9hZGluZ1JlY29yZHNcIjogXCJQbGVhc2Ugd2FpdCAtIGxvYWRpbmcuLi5cIlxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTG9hZGluZy4uLlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBUZXh0IHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWJsZSBpcyBwcm9jZXNzaW5nIGEgdXNlciBhY3Rpb25cblx0XHQgKiAodXN1YWxseSBhIHNvcnQgY29tbWFuZCBvciBzaW1pbGFyKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wcm9jZXNzaW5nXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHQgKiAgICAgICAgICBcInByb2Nlc3NpbmdcIjogXCJEYXRhVGFibGVzIGlzIGN1cnJlbnRseSBidXN5XCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNQcm9jZXNzaW5nXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIERldGFpbHMgdGhlIGFjdGlvbnMgdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW50byB0aGVcblx0XHQgKiBmaWx0ZXJpbmcgaW5wdXQgdGV4dCBib3guIFRoZSB2YXJpYWJsZSBcIl9JTlBVVF9cIiwgaWYgdXNlZCBpbiB0aGUgc3RyaW5nLFxuXHRcdCAqIGlzIHJlcGxhY2VkIHdpdGggdGhlIEhUTUwgdGV4dCBib3ggZm9yIHRoZSBmaWx0ZXJpbmcgaW5wdXQgYWxsb3dpbmdcblx0XHQgKiBjb250cm9sIG92ZXIgd2hlcmUgaXQgYXBwZWFycyBpbiB0aGUgc3RyaW5nLiBJZiBcIl9JTlBVVF9cIiBpcyBub3QgZ2l2ZW5cblx0XHQgKiB0aGVuIHRoZSBpbnB1dCBib3ggaXMgYXBwZW5kZWQgdG8gdGhlIHN0cmluZyBhdXRvbWF0aWNhbGx5LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgU2VhcmNoOlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBJbnB1dCB0ZXh0IGJveCB3aWxsIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQgYXV0b21hdGljYWxseVxuXHRcdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0XHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdFx0ICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuXHRcdCAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiRmlsdGVyIHJlY29yZHM6XCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIFNwZWNpZnkgd2hlcmUgdGhlIGZpbHRlciBzaG91bGQgYXBwZWFyXG5cdFx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0XHQgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG5cdFx0ICogICAgICAgICAgXCJzZWFyY2hcIjogXCJBcHBseSBmaWx0ZXIgX0lOUFVUXyB0byB0YWJsZVwiXG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgIH0gKTtcblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0XCJzU2VhcmNoXCI6IFwiU2VhcmNoOlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hQbGFjZWhvbGRlclxuXHRcdCAqL1xuXHRcdFwic1NlYXJjaFBsYWNlaG9sZGVyXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBvZiB0aGUgbGFuZ3VhZ2UgaW5mb3JtYXRpb24gY2FuIGJlIHN0b3JlZCBpbiBhIGZpbGUgb24gdGhlXG5cdFx0ICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cblx0XHQgKiBJdCBtdXN0IHN0b3JlIHRoZSBVUkwgb2YgdGhlIGxhbmd1YWdlIGZpbGUsIHdoaWNoIGlzIGluIGEgSlNPTiBmb3JtYXQsXG5cdFx0ICogYW5kIHRoZSBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9MYW5ndWFnZSBvYmplY3QgaW4gdGhlXG5cdFx0ICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxuXHRcdCAqIHRoZSBleGFtcGxlIGxhbmd1YWdlIGZpbGVzIHRvIHNlZSBob3cgdGhpcyB3b3JrcyBpbiBhY3Rpb24uXG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHRcdCAqXG5cdFx0ICogIEBkdG9wdCBMYW5ndWFnZVxuXHRcdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudXJsXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHQgKiAgICAgICAgICBcInVybFwiOiBcImh0dHA6Ly93d3cuc3ByeW1lZGlhLmNvLnVrL2RhdGFUYWJsZXMvbGFuZy50eHRcIlxuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICB9ICk7XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdFwic1VybFwiOiBcIlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBUZXh0IHNob3duIGluc2lkZSB0aGUgdGFibGUgcmVjb3JkcyB3aGVuIHRoZSBpcyBubyBpbmZvcm1hdGlvbiB0byBiZVxuXHRcdCAqIGRpc3BsYXllZCBhZnRlciBmaWx0ZXJpbmcuIGBlbXB0eVRhYmxlYCBpcyBzaG93biB3aGVuIHRoZXJlIGlzIHNpbXBseSBub1xuXHRcdCAqIGluZm9ybWF0aW9uIGluIHRoZSB0YWJsZSBhdCBhbGwgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS5cblx0XHQgKiAgQHR5cGUgc3RyaW5nXG5cdFx0ICogIEBkZWZhdWx0IE5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnplcm9SZWNvcmRzXG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHRcdCAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcblx0XHQgKiAgICAgICAgICBcInplcm9SZWNvcmRzXCI6IFwiTm8gcmVjb3JkcyB0byBkaXNwbGF5XCJcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgfSApO1xuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRcInNaZXJvUmVjb3Jkc1wiOiBcIk5vIG1hdGNoaW5nIHJlY29yZHMgZm91bmRcIlxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gaGF2ZSBkZWZpbmUgdGhlIGdsb2JhbCBmaWx0ZXJpbmcgc3RhdGUgYXRcblx0ICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuXHQgKiBkZWZpbmVkLCBidXQgYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBXaGVuIGByZWdleGAgaXMgdHJ1ZSxcblx0ICogdGhlIHNlYXJjaCBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIGZhbHNlXG5cdCAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuXHQgKiBEYXRhVGFibGVzIHdpbGwgdXNlIGl0J3Mgc21hcnQgZmlsdGVyaW5nIG1ldGhvZHMgKHRvIHdvcmQgbWF0Y2ggYXRcblx0ICogYW55IHBvaW50IGluIHRoZSBkYXRhKSwgd2hlbiBmYWxzZSB0aGlzIHdpbGwgbm90IGJlIGRvbmUuXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcblx0ICpcblx0ICogIEBkdG9wdCBPcHRpb25zXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9IClcblx0ICovXG5cdFwib1NlYXJjaFwiOiAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCApLFxuXG5cblx0LyoqXG5cdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdCAqXG5cdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yIGBhYURhdGFgIGZvclxuXHQgKiBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhIGZyb20gYW4gQWpheFxuXHQgKiBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlciBhbGxvd3MgdGhhdFxuXHQgKiBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZCBvYmplY3Qgbm90YXRpb24gdG9cblx0ICogZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBkYXRhXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheERhdGFQcm9wXG5cdCAqXG5cdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0ICovXG5cdFwic0FqYXhEYXRhUHJvcFwiOiBcImRhdGFcIixcblxuXG5cdC8qKlxuXHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBZb3UgY2FuIGluc3RydWN0IERhdGFUYWJsZXMgdG8gbG9hZCBkYXRhIGZyb20gYW4gZXh0ZXJuYWxcblx0ICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxuXHQgKiBhbHJlYWR5IGhhdmUpLiBTaW1wbHkgcHJvdmlkZSBhIHVybCBhIEpTT04gb2JqZWN0IGNhbiBiZSBvYnRhaW5lZCBmcm9tLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFNvdXJjZVxuXHQgKlxuXHQgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG5cdCAqL1xuXHRcInNBamF4U291cmNlXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBpbml0aWFsaXNhdGlvbiB2YXJpYWJsZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgZXhhY3RseSB3aGVyZSBpbiB0aGVcblx0ICogRE9NIHlvdSB3YW50IERhdGFUYWJsZXMgdG8gaW5qZWN0IHRoZSB2YXJpb3VzIGNvbnRyb2xzIGl0IGFkZHMgdG8gdGhlIHBhZ2Vcblx0ICogKGZvciBleGFtcGxlIHlvdSBtaWdodCB3YW50IHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIGF0IHRoZSB0b3Agb2YgdGhlXG5cdCAqIHRhYmxlKS4gRElWIGVsZW1lbnRzICh3aXRoIG9yIHdpdGhvdXQgYSBjdXN0b20gY2xhc3MpIGNhbiBhbHNvIGJlIGFkZGVkIHRvXG5cdCAqIGFpZCBzdHlsaW5nLiBUaGUgZm9sbG93IHN5bnRheCBpcyB1c2VkOlxuXHQgKiAgIDx1bD5cblx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGFsbG93ZWQ6XG5cdCAqICAgICAgIDx1bD5cblx0ICogICAgICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cblx0ICogICAgICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0ICogICAgICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XG5cdCAqICAgICAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cblx0ICogICAgICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdCAqICAgICAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxuXHQgKiAgICAgICA8L3VsPlxuXHQgKiAgICAgPC9saT5cblx0ICogICAgIDxsaT5UaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgYWxsb3dlZDpcblx0ICogICAgICAgPHVsPlxuXHQgKiAgICAgICAgIDxsaT4nSCcgLSBqUXVlcnlVSSB0aGVtZSBcImhlYWRlclwiIGNsYXNzZXMgKCdmZy10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10ciB1aS1oZWxwZXItY2xlYXJmaXgnKTwvbGk+XG5cdCAqICAgICAgICAgPGxpPidGJyAtIGpRdWVyeVVJIHRoZW1lIFwiZm9vdGVyXCIgY2xhc3NlcyAoJ2ZnLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYmwgdWktY29ybmVyLWJyIHVpLWhlbHBlci1jbGVhcmZpeCcpPC9saT5cblx0ICogICAgICAgPC91bD5cblx0ICogICAgIDwvbGk+XG5cdCAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBzeW50YXggaXMgZXhwZWN0ZWQ6XG5cdCAqICAgICAgIDx1bD5cblx0ICogICAgICAgICA8bGk+JyZsdDsnIGFuZCAnJmd0OycgLSBkaXYgZWxlbWVudHM8L2xpPlxuXHQgKiAgICAgICAgIDxsaT4nJmx0O1wiY2xhc3NcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYSBjbGFzczwvbGk+XG5cdCAqICAgICAgICAgPGxpPicmbHQ7XCIjaWRcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYW4gSUQ8L2xpPlxuXHQgKiAgICAgICA8L3VsPlxuXHQgKiAgICAgPC9saT5cblx0ICogICAgIDxsaT5FeGFtcGxlczpcblx0ICogICAgICAgPHVsPlxuXHQgKiAgICAgICAgIDxsaT4nJmx0O1wid3JhcHBlclwiZmxpcHQmZ3Q7JzwvbGk+XG5cdCAqICAgICAgICAgPGxpPicmbHQ7bGYmbHQ7dCZndDtpcCZndDsnPC9saT5cblx0ICogICAgICAgPC91bD5cblx0ICogICAgIDwvbGk+XG5cdCAqICAgPC91bD5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgbGZydGlwIDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgZmFsc2UpPC9pPiA8Yj5vcjwvYj5cblx0ICogICAgPFwiSFwibGZyPnQ8XCJGXCJpcD4gPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyB0cnVlKTwvaT5cblx0ICpcblx0ICogIEBkdG9wdCBPcHRpb25zXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZG9tXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiZG9tXCI6ICcmbHQ7XCJ0b3BcImkmZ3Q7cnQmbHQ7XCJib3R0b21cImZscCZndDsmbHQ7XCJjbGVhclwiJmd0Oydcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwic0RvbVwiOiBcImxmcnRpcFwiLFxuXG5cblx0LyoqXG5cdCAqIFNlYXJjaCBkZWxheSBvcHRpb24uIFRoaXMgd2lsbCB0aHJvdHRsZSBmdWxsIHRhYmxlIHNlYXJjaGVzIHRoYXQgdXNlIHRoZVxuXHQgKiBEYXRhVGFibGVzIHByb3ZpZGVkIHNlYXJjaCBpbnB1dCBlbGVtZW50IChpdCBkb2VzIG5vdCBlZmZlY3QgY2FsbHMgdG9cblx0ICogYGR0LWFwaSBzZWFyY2goKWAsIHByb3ZpZGluZyBhIGRlbGF5IGJlZm9yZSB0aGUgc2VhcmNoIGlzIG1hZGUuXG5cdCAqICBAdHlwZSBpbnRlZ2VyXG5cdCAqICBAZGVmYXVsdCAwXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaERlbGF5XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic2VhcmNoRGVsYXlcIjogMjAwXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9IClcblx0ICovXG5cdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIGZlYXR1cmVzIHNpeCBkaWZmZXJlbnQgYnVpbHQtaW4gb3B0aW9ucyBmb3IgdGhlIGJ1dHRvbnMgdG9cblx0ICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxuXHQgKlxuXHQgKiAqIGBudW1iZXJzYCAtIFBhZ2UgbnVtYmVyIGJ1dHRvbnMgb25seVxuXHQgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxuXHQgKiAqICdzaW1wbGVfbnVtYmVyc2AgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0ICogKiBgZnVsbGAgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zXG5cdCAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHQgKiAqIGBmaXJzdF9sYXN0X251bWJlcnNgIC0gJ0ZpcnN0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG5cdCAqICBcblx0ICogRnVydGhlciBtZXRob2RzIGNhbiBiZSBhZGRlZCB1c2luZyB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vUGFnaW5hdGlvbn0uXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IHNpbXBsZV9udW1iZXJzXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1R5cGVcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJwYWdpbmdUeXBlXCI6IFwiZnVsbF9udW1iZXJzXCJcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKVxuXHQgKi9cblx0XCJzUGFnaW5hdGlvblR5cGVcIjogXCJzaW1wbGVfbnVtYmVyc1wiLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZy4gV2hlbiBhIHRhYmxlIGlzIHRvbyB3aWRlIHRvIGZpdCBpbnRvIGFcblx0ICogY2VydGFpbiBsYXlvdXQsIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCB5b3Vcblx0ICogY2FuIGVuYWJsZSB4LXNjcm9sbGluZyB0byBzaG93IHRoZSB0YWJsZSBpbiBhIHZpZXdwb3J0LCB3aGljaCBjYW4gYmVcblx0ICogc2Nyb2xsZWQuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGB0cnVlYCB3aGljaCB3aWxsIGFsbG93IHRoZSB0YWJsZSB0b1xuXHQgKiBzY3JvbGwgaG9yaXpvbnRhbGx5IHdoZW4gbmVlZGVkLCBvciBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaFxuXHQgKiBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS4gU2V0dGluZyBhcyBzaW1wbHkgYHRydWVgXG5cdCAqIGlzIHJlY29tbWVuZGVkLlxuXHQgKiAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcblx0ICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG5cdCAqXG5cdCAqICBAZHRvcHQgRmVhdHVyZXNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxYXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuXHQgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcInNTY3JvbGxYXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBmb3JjZSBhIERhdGFUYWJsZSB0byB1c2UgbW9yZSB3aWR0aCB0aGFuIGl0XG5cdCAqIG1pZ2h0IG90aGVyd2lzZSBkbyB3aGVuIHgtc2Nyb2xsaW5nIGlzIGVuYWJsZWQuIEZvciBleGFtcGxlIGlmIHlvdSBoYXZlIGFcblx0ICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3Jcblx0ICogXCJvdmVyLXNpemluZ1wiIHRoZSB0YWJsZSwgYW5kIHRodXMgZm9yY2luZyBzY3JvbGxpbmcuIFRoaXMgcHJvcGVydHkgY2FuIGJ5XG5cdCAqIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWxcblx0ICogbWVhc3VyZW1lbnQpLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHQgKlxuXHQgKiAgQGR0b3B0IE9wdGlvbnNcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxYSW5uZXJcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJzY3JvbGxYXCI6IFwiMTAwJVwiLFxuXHQgKiAgICAgICAgXCJzY3JvbGxYSW5uZXJcIjogXCIxMTAlXCJcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwic1Njcm9sbFhJbm5lclwiOiBcIlwiLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyB3aWxsIGNvbnN0cmFpbiB0aGUgRGF0YVRhYmxlXG5cdCAqIHRvIHRoZSBnaXZlbiBoZWlnaHQsIGFuZCBlbmFibGUgc2Nyb2xsaW5nIGZvciBhbnkgZGF0YSB3aGljaCBvdmVyZmxvd3MgdGhlXG5cdCAqIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFnaW5nIHRvIGRpc3BsYXlcblx0ICogYSBsb3Qgb2YgZGF0YSBpbiBhIHNtYWxsIGFyZWEgKGFsdGhvdWdoIHBhZ2luZyBhbmQgc2Nyb2xsaW5nIGNhbiBib3RoIGJlXG5cdCAqIGVuYWJsZWQgYXQgdGhlIHNhbWUgdGltZSkuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXJcblx0ICogKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuXHQgKlxuXHQgKiAgQGR0b3B0IEZlYXR1cmVzXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuXHQgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJzU2Nyb2xsWVwiOiBcIlwiLFxuXG5cblx0LyoqXG5cdCAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuXHQgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG5cdCAqXG5cdCAqIFNldCB0aGUgSFRUUCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG1ha2UgdGhlIEFqYXggY2FsbCBmb3Igc2VydmVyLXNpZGVcblx0ICogcHJvY2Vzc2luZyBvciBBamF4IHNvdXJjZWQgZGF0YS5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgR0VUXG5cdCAqXG5cdCAqICBAZHRvcHQgT3B0aW9uc1xuXHQgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyTWV0aG9kXG5cdCAqXG5cdCAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cblx0ICovXG5cdFwic1NlcnZlck1ldGhvZFwiOiBcIkdFVFwiLFxuXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgbWFrZXMgdXNlIG9mIHJlbmRlcmVycyB3aGVuIGRpc3BsYXlpbmcgSFRNTCBlbGVtZW50cyBmb3Jcblx0ICogYSB0YWJsZS4gVGhlc2UgcmVuZGVyZXJzIGNhbiBiZSBhZGRlZCBvciBtb2RpZmllZCBieSBwbHVnLWlucyB0b1xuXHQgKiBnZW5lcmF0ZSBzdWl0YWJsZSBtYXJrLXVwIGZvciBhIHNpdGUuIEZvciBleGFtcGxlIHRoZSBCb290c3RyYXBcblx0ICogaW50ZWdyYXRpb24gcGx1Zy1pbiBmb3IgRGF0YVRhYmxlcyB1c2VzIGEgcGFnaW5nIGJ1dHRvbiByZW5kZXJlciB0b1xuXHQgKiBkaXNwbGF5IHBhZ2luYXRpb24gYnV0dG9ucyBpbiB0aGUgbWFyay11cCByZXF1aXJlZCBieSBCb290c3RyYXAuXG5cdCAqXG5cdCAqIEZvciBmdXJ0aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlcnMgYXZhaWxhYmxlIHNlZVxuXHQgKiBEYXRhVGFibGUuZXh0LnJlbmRlcmVyXG5cdCAqICBAdHlwZSBzdHJpbmd8b2JqZWN0XG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmVuZGVyZXJcblx0ICpcblx0ICovXG5cdFwicmVuZGVyZXJcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRhdGEgcHJvcGVydHkgbmFtZSB0aGF0IERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0byBnZXQgYSByb3cncyBpZFxuXHQgKiB0byBzZXQgYXMgdGhlIGBpZGAgcHJvcGVydHkgaW4gdGhlIG5vZGUuXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IERUX1Jvd0lkXG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucm93SWRcblx0ICovXG5cdFwicm93SWRcIjogXCJEVF9Sb3dJZFwiXG59O1xuXG5fZm5IdW5nYXJpYW5NYXAoIERhdGFUYWJsZS5kZWZhdWx0cyApO1xuXG5cblxuLypcbiAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cbiAqIG5vdGF0aW9uIGFuZCBjYW1lbCBjYXNlLlxuICovXG5cbi8qKlxuICogQ29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiA9IHtcblx0LyoqXG5cdCAqIERlZmluZSB3aGljaCBjb2x1bW4ocykgYW4gb3JkZXIgd2lsbCBvY2N1ciBvbiBmb3IgdGhpcyBjb2x1bW4uIFRoaXNcblx0ICogYWxsb3dzIGEgY29sdW1uJ3Mgb3JkZXJpbmcgdG8gdGFrZSBtdWx0aXBsZSBjb2x1bW5zIGludG8gYWNjb3VudCB3aGVuXG5cdCAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XG5cdCAqIG5hbWUgLyBsYXN0IG5hbWUgY29sdW1ucyBtYWtlIHNlbnNlIHRvIGRvIGEgbXVsdGktY29sdW1uIHNvcnQgb3ZlciB0aGVcblx0ICogdHdvIGNvbHVtbnMuXG5cdCAqICBAdHlwZSBhcnJheXxpbnRcblx0ICogIEBkZWZhdWx0IG51bGwgPGk+VGFrZXMgdGhlIHZhbHVlIG9mIHRoZSBjb2x1bW4gaW5kZXggYXV0b21hdGljYWxseTwvaT5cblx0ICpcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuXHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IDIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMCwgMSBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0gfSxcblx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyIH0sXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGxcblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cdFwiaURhdGFTb3J0XCI6IC0xLFxuXG5cblx0LyoqXG5cdCAqIFlvdSBjYW4gY29udHJvbCB0aGUgZGVmYXVsdCBvcmRlcmluZyBkaXJlY3Rpb24sIGFuZCBldmVuIGFsdGVyIHRoZVxuXHQgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXG5cdCAqIHVzaW5nIHRoaXMgcGFyYW1ldGVyLlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFsgJ2FzYycsICdkZXNjJyBdXG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyU2VxdWVuY2Vcblx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiYXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMiBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMyBdIH1cblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSB9LFxuXHQgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0gfSxcblx0ICogICAgICAgICAgbnVsbFxuXHQgKiAgICAgICAgXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJhc1NvcnRpbmdcIjogWyAnYXNjJywgJ2Rlc2MnIF0sXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9uIHRoZSBkYXRhIGluIHRoaXMgY29sdW1uLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5zZWFyY2hhYmxlXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcInNlYXJjaGFibGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdCAqICAgICAgICBdIH0gKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgeyBcInNlYXJjaGFibGVcIjogZmFsc2UgfSxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbFxuXHQgKiAgICAgICAgXSB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYlNlYXJjaGFibGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBvcmRlcmluZyBvbiB0aGlzIGNvbHVtbi5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IHRydWVcblx0ICpcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJhYmxlXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcIm9yZGVyYWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0ICogICAgICAgIF0gfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHQgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlIH0sXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGxcblx0ICogICAgICAgIF0gfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcImJTb3J0YWJsZVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIHRoaXMgY29sdW1uLlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgdHJ1ZVxuXHQgKlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi52aXNpYmxlXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdCAqICAgICAgICBdIH0gKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UgfSxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbFxuXHQgKiAgICAgICAgXSB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwiYlZpc2libGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcblx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHQgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAcGFyYW0ge2VsZW1lbnR9IHRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuXHQgKiAgQHBhcmFtIHsqfSBjZWxsRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcblx0ICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSByb3dEYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XG5cdCAqICBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuXHQgKiAgQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIGluZGV4IGZvciBhb0NvbHVtbnNcblx0ICpcblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY3JlYXRlZENlbGxcblx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFszXSxcblx0ICogICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhLCByb3csIGNvbCkge1xuXHQgKiAgICAgICAgICAgIGlmICggY2VsbERhdGEgPT0gXCIxLjdcIiApIHtcblx0ICogICAgICAgICAgICAgICQodGQpLmNzcygnY29sb3InLCAnYmx1ZScpXG5cdCAqICAgICAgICAgICAgfVxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICB9IF1cblx0ICogICAgICB9KTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVwbGFjZWQgYnkgYGRhdGFgIGluIERhdGFUYWJsZXMgdG8gZW5zdXJlIG5hbWluZ1xuXHQgKiBjb25zaXN0ZW5jeS4gYGRhdGFQcm9wYCBjYW4gc3RpbGwgYmUgdXNlZCwgYXMgdGhlcmUgaXMgYmFja3dhcmRzXG5cdCAqIGNvbXBhdGliaWxpdHkgaW4gRGF0YVRhYmxlcyBmb3IgdGhpcyBvcHRpb24sIGJ1dCBpdCBpcyBzdHJvbmdseVxuXHQgKiByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgYGRhdGFgIGluIHByZWZlcmVuY2UgdG8gYGRhdGFQcm9wYC5cblx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uZGF0YVByb3Bcblx0ICovXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXG5cdCAqIGluY2x1ZGluZyBkZWVwbHkgbmVzdGVkIG9iamVjdHMgLyBwcm9wZXJ0aWVzLiBgZGF0YWAgY2FuIGJlIGdpdmVuIGluIGFcblx0ICogbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHdoaWNoIGVmZmVjdCBpdHMgYmVoYXZpb3VyOlxuXHQgKlxuXHQgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcblx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHQgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcblx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHQgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcblx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHQgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG5cdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdCAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcblx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0ICogICAgICByZXR1cm5lZC5cblx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdCAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuXHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XG5cdCAqICAgICAgZnVuY3Rpb24gbm90YXRpb24gaXMgcmVjb21tZW5kZWQgZm9yIHVzZSBpbiBgcmVuZGVyYCByYXRoZXIgdGhhblxuXHQgKiAgICAgIGBkYXRhYCBhcyBpdCBpcyBtdWNoIHNpbXBsZXIgdG8gdXNlIGFzIGEgcmVuZGVyZXIuXG5cdCAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xuXHQgKiAgIGRhdGEgZGlyZWN0bHkgZnJvbSBpdC4gVGhpcyBhY3Rpb24gaGFzIGVmZmVjdHMgb24gdHdvIG90aGVyXG5cdCAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9uczpcblx0ICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxuXHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgdmFsdWUgZGVmaW5lZCBieVxuXHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgd2lsbCBiZSB1c2VkIGZvciB0aGUgY2VsbC5cblx0ICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXG5cdCAqICAgICAgb3B0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHdob2xlIGRhdGEgc291cmNlIGZvciB0aGVcblx0ICogICAgICByb3cgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLlxuXHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdCAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxuXHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdCAqICAgICogUGFyYW1ldGVyczpcblx0ICogICAgICAqIGB7YXJyYXl8b2JqZWN0fWAgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93XG5cdCAqICAgICAgKiBge3N0cmluZ31gIFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ3NldCcgd2hlblxuXHQgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxuXHQgKiAgICAgICAgd2hlbiBnYXRoZXJpbmcgZGF0YS4gTm90ZSB0aGF0IHdoZW4gYHVuZGVmaW5lZGAgaXMgZ2l2ZW4gZm9yIHRoZVxuXHQgKiAgICAgICAgdHlwZSBEYXRhVGFibGVzIGV4cGVjdHMgdG8gZ2V0IHRoZSByYXcgZGF0YSBmb3IgdGhlIG9iamVjdCBiYWNrPFxuXHQgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cblx0ICogICAgKiBSZXR1cm46XG5cdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuICdzZXQnIGlzXG5cdCAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcblx0ICogICAgICAgIGZvciB0aGUgZGF0YSByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcblx0ICogZm9ybWF0dGluZyBvZiBkYXRhIGZvciBvdXRwdXQsIHlvdSB3aWxsIGxpa2VseSB3YW50IHRvIHVzZSBgcmVuZGVyYCB3aGljaFxuXHQgKiBpcyBzaW1wbHkgYSBnZXR0ZXIgYW5kIHRodXMgc2ltcGxlciB0byB1c2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBwcmlvciB0byBEYXRhVGFibGVzIDEuOS4yIGBkYXRhYCB3YXMgY2FsbGVkIGBtRGF0YVByb3BgLiBUaGVcblx0ICogbmFtZSBjaGFuZ2UgcmVmbGVjdHMgdGhlIGZsZXhpYmlsaXR5IG9mIHRoaXMgcHJvcGVydHkgYW5kIGlzIGNvbnNpc3RlbnRcblx0ICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcblx0ICogYmUgdXNlZCBieSBEYXRhVGFibGVzLCBhcyBpdCBhdXRvbWF0aWNhbGx5IG1hcHMgdGhlIG9sZCBuYW1lIHRvIHRoZSBuZXdcblx0ICogaWYgcmVxdWlyZWQuXG5cdCAqXG5cdCAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG51bGxcblx0ICogIEBkZWZhdWx0IG51bGwgPGk+VXNlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBjb2x1bW4gaW5kZXg8L2k+XG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFcblx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBSZWFkIHRhYmxlIGRhdGEgZnJvbSBvYmplY3RzXG5cdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0ICogICAgLy8gICB7XG5cdCAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcblx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0ICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHt2YWx1ZX0sXG5cdCAqICAgIC8vICAgICAgXCJ2ZXJzaW9uXCI6IHt2YWx1ZX0sXG5cdCAqICAgIC8vICAgICAgXCJncmFkZVwiOiB7dmFsdWV9XG5cdCAqICAgIC8vICAgfVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvb2JqZWN0cy50eHRcIixcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcblx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybVwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBSZWFkIGluZm9ybWF0aW9uIGZyb20gZGVlcGx5IG5lc3RlZCBvYmplY3RzXG5cdCAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcblx0ICogICAgLy8gICB7XG5cdCAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcblx0ICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcblx0ICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHtcblx0ICogICAgLy8gICAgICAgICBcImlubmVyXCI6IHt2YWx1ZX1cblx0ICogICAgLy8gICAgICB9LFxuXHQgKiAgICAvLyAgICAgIFwiZGV0YWlsc1wiOiBbXG5cdCAqICAgIC8vICAgICAgICAge3ZhbHVlfSwge3ZhbHVlfVxuXHQgKiAgICAvLyAgICAgIF1cblx0ICogICAgLy8gICB9XG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuXHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuXHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuXHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmlubmVyXCIgfSxcblx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJkZXRhaWxzLjBcIiB9LFxuXHQgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImRldGFpbHMuMVwiIH1cblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBkYXRhYCBhcyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGlmZmVyZW50IGluZm9ybWF0aW9uIGZvclxuXHQgKiAgICAvLyBzb3J0aW5nLCBmaWx0ZXJpbmcgYW5kIGRpc3BsYXkuIEluIHRoaXMgY2FzZSwgY3VycmVuY3kgKHByaWNlKVxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHQgKiAgICAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBzb3VyY2UsIHR5cGUsIHZhbCApIHtcblx0ICogICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NldCcpIHtcblx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZSA9IHZhbDtcblx0ICogICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wdXRlZCBkaXNwbGF5IGFuZCBmaWx0ZXIgdmFsdWVzIGZvciBlZmZpY2llbmN5XG5cdCAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZGlzcGxheSA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKTtcblx0ICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9maWx0ZXIgID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpK1wiIFwiK3ZhbDtcblx0ICogICAgICAgICAgICAgIHJldHVybjtcblx0ICogICAgICAgICAgICB9XG5cdCAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Rpc3BsYXknKSB7XG5cdCAqICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnByaWNlX2Rpc3BsYXk7XG5cdCAqICAgICAgICAgICAgfVxuXHQgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmaWx0ZXInKSB7XG5cdCAqICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnByaWNlX2ZpbHRlcjtcblx0ICogICAgICAgICAgICB9XG5cdCAqICAgICAgICAgICAgLy8gJ3NvcnQnLCAndHlwZScgYW5kIHVuZGVmaW5lZCBhbGwganVzdCB1c2UgdGhlIGludGVnZXJcblx0ICogICAgICAgICAgICByZXR1cm4gc291cmNlLnByaWNlO1xuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICB9IF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGRlZmF1bHQgY29udGVudFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcblx0ICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuXHQgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCxcblx0ICogICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkNsaWNrIHRvIGVkaXRcIlxuXHQgKiAgICAgICAgfSBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBhcnJheSBub3RhdGlvbiAtIG91dHB1dHRpbmcgYSBsaXN0IGZyb20gYW4gYXJyYXlcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0ICogICAgICAgICAgXCJkYXRhXCI6IFwibmFtZVssIF1cIlxuXHQgKiAgICAgICAgfSBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqL1xuXHRcIm1EYXRhXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxuXHQgKiB3aGVuIHlvdSB3YW50IHRvIG1hbmlwdWxhdGUgZGF0YSBmb3IgZGlzcGxheSAoaW5jbHVkaW5nIGZpbHRlcmluZyxcblx0ICogc29ydGluZyBldGMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBmb3IgdGhlIHRhYmxlLCB1c2UgdGhpc1xuXHQgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXG5cdCAqIGBkYXRhYCB3aGljaCBpcyByZWFkIC8gd3JpdGUgKHRoZW4gYXMgc3VjaCBtb3JlIGNvbXBsZXgpLiBMaWtlIGBkYXRhYFxuXHQgKiB0aGlzIG9wdGlvbiBjYW4gYmUgZ2l2ZW4gaW4gYSBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgdG8gZWZmZWN0IGl0c1xuXHQgKiBiZWhhdmlvdXI6XG5cdCAqXG5cdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHQgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG5cdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHQgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcblx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHQgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuXHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0ICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG5cdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHQgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuXHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHQgKiAgICAgIHJldHVybmVkLlxuXHQgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG5cdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdCAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuXHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LlxuXHQgKiAqIGBvYmplY3RgIC0gdXNlIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IGRhdGEgdHlwZXMgcmVxdWVzdGVkIGJ5XG5cdCAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xuXHQgKiAgIG9mIHRoZSBvYmplY3QgaXMgdGhlIGRhdGEgdHlwZSB0aGUgcHJvcGVydHkgcmVmZXJzIHRvIGFuZCB0aGUgdmFsdWUgY2FuXG5cdCAqICAgZGVmaW5lZCB1c2luZyBhbiBpbnRlZ2VyLCBzdHJpbmcgb3IgZnVuY3Rpb24gdXNpbmcgdGhlIHNhbWUgcnVsZXMgYXNcblx0ICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxuXHQgKiAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHlvdSBoYXZlbid0IHNwZWNpZmllZCBhIHZhbHVlIGZvclxuXHQgKiAgIHRoZSBkYXRhIHR5cGUgcmVxdWVzdGVkIGJ5IERhdGFUYWJsZXMuXG5cdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdCAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcblx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChiYXNlZCBvbiBgZGF0YWApXG5cdCAqICAgICAgKiB7c3RyaW5nfSBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdmaWx0ZXInLFxuXHQgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxuXHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGZ1bGwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKG5vdCBiYXNlZCBvblxuXHQgKiAgICAgICAgYGRhdGFgKVxuXHQgKiAgICAqIFJldHVybjpcblx0ICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgd2hhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZVxuXHQgKiAgICAgICAgZGF0YSByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG9iamVjdHxudWxsXG5cdCAqICBAZGVmYXVsdCBudWxsIFVzZSB0aGUgZGF0YSBzb3VyY2UgdmFsdWUuXG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnJlbmRlclxuXHQgKiAgQGR0b3B0IENvbHVtbnNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIENyZWF0ZSBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvZGVlcC50eHRcIixcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcblx0ICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcblx0ICogICAgICAgICAge1xuXHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIsXG5cdCAqICAgICAgICAgICAgXCJyZW5kZXJcIjogXCJbLCBdLm5hbWVcIlxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIGRhdGFcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxuXHQgKiAgICAgICAgICBcInJlbmRlclwiOiBcImJyb3dzZXJOYW1lKClcIlxuXHQgKiAgICAgICAgfSBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBBcyBhbiBvYmplY3QsIGV4dHJhY3RpbmcgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgdHlwZXNcblx0ICogICAgLy8gVGhpcyB3b3VsZCBiZSB1c2VkIHdpdGggYSBkYXRhIHNvdXJjZSBzdWNoIGFzOlxuXHQgKiAgICAvLyAgIHsgXCJwaG9uZVwiOiA1NTUyMzY4LCBcInBob25lX2ZpbHRlclwiOiBcIjU1NTIzNjggNTU1LTIzNjhcIiwgXCJwaG9uZV9kaXNwbGF5XCI6IFwiNTU1LTIzNjhcIiB9XG5cdCAqICAgIC8vIEhlcmUgdGhlIGBwaG9uZWAgaW50ZWdlciBpcyB1c2VkIGZvciBzb3J0aW5nIGFuZCB0eXBlIGRldGVjdGlvbiwgd2hpbGUgYHBob25lX2ZpbHRlcmBcblx0ICogICAgLy8gKHdoaWNoIGhhcyBib3RoIGZvcm1zKSBpcyB1c2VkIGZvciBmaWx0ZXJpbmcgZm9yIGlmIGEgdXNlciBpbnB1dHMgZWl0aGVyIGZvcm1hdCwgd2hpbGVcblx0ICogICAgLy8gdGhlIGZvcm1hdHRlZCBwaG9uZSBudW1iZXIgaXMgdGhlIG9uZSB0aGF0IGlzIHNob3duIGluIHRoZSB0YWJsZS5cblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0ICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxuXHQgKiAgICAgICAgICBcInJlbmRlclwiOiB7XG5cdCAqICAgICAgICAgICAgXCJfXCI6IFwicGhvbmVcIixcblx0ICogICAgICAgICAgICBcImZpbHRlclwiOiBcInBob25lX2ZpbHRlclwiLFxuXHQgKiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcInBob25lX2Rpc3BsYXlcIlxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICB9IF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzZSBhcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGUgZGF0YSBzb3VyY2Vcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0ICogICAgICAgICAgXCJkYXRhXCI6IFwiZG93bmxvYWRfbGlua1wiLFxuXHQgKiAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoIGRhdGEsIHR5cGUsIGZ1bGwgKSB7XG5cdCAqICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJytkYXRhKydcIj5Eb3dubG9hZDwvYT4nO1xuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICB9IF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwibVJlbmRlclwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgY2VsbCB0eXBlIGNyZWF0ZWQgZm9yIHRoZSBjb2x1bW4gLSBlaXRoZXIgVEQgY2VsbHMgb3IgVEggY2VsbHMuIFRoaXNcblx0ICogY2FuIGJlIHVzZWZ1bCBhcyBUSCBjZWxscyBoYXZlIHNlbWFudGljIG1lYW5pbmcgaW4gdGhlIHRhYmxlIGJvZHksIGFsbG93aW5nIHRoZW1cblx0ICogdG8gYWN0IGFzIGEgaGVhZGVyIGZvciBhIHJvdyAoeW91IG1heSB3aXNoIHRvIGFkZCBzY29wZT0ncm93JyB0byB0aGUgVEggZWxlbWVudHMpLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCB0ZFxuXHQgKlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jZWxsVHlwZVxuXHQgKiAgQGR0b3B0IENvbHVtbnNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIE1ha2UgdGhlIGZpcnN0IGNvbHVtbiB1c2UgVEggY2VsbHNcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG5cdCAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcblx0ICogICAgICAgICAgXCJjZWxsVHlwZVwiOiBcInRoXCJcblx0ICogICAgICAgIH0gXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJzQ2VsbFR5cGVcIjogXCJ0ZFwiLFxuXG5cblx0LyoqXG5cdCAqIENsYXNzIHRvIGdpdmUgdG8gZWFjaCBjZWxsIGluIHRoaXMgY29sdW1uLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNsYXNzXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcImNsYXNzXCI6IFwibXlfY2xhc3NcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIgfSxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbFxuXHQgKiAgICAgICAgXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJzQ2xhc3NcIjogXCJcIixcblxuXHQvKipcblx0ICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuXHQgKiBpdCBmaW5kcyB0aGUgbG9uZ2VzdCBzdHJpbmcgaW4gZWFjaCBjb2x1bW4gYW5kIHRoZW4gY29uc3RydWN0cyBhXG5cdCAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuXHQgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuXHQgKiBzdHJpbmcgLSB0aHVzIHRoZSBjYWxjdWxhdGlvbiBjYW4gZ28gd3JvbmcgKGRvaW5nIGl0IHByb3Blcmx5IGFuZCBwdXR0aW5nXG5cdCAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcblx0ICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuXHQgKiB0ZXh0IHRoYXQgaXMgZm91bmQgdG8gYmUgdGhlIGxvbmdlc3Qgc3RyaW5nIGZvciB0aGUgY29sdW1uIC0gaS5lLiBwYWRkaW5nLlxuXHQgKiBHZW5lcmFsbHkgeW91IHNob3VsZG4ndCBuZWVkIHRoaXMhXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzxpPlxuXHQgKlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jb250ZW50UGFkZGluZ1xuXHQgKiAgQGR0b3B0IENvbHVtbnNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIHtcblx0ICogICAgICAgICAgICBcImNvbnRlbnRQYWRkaW5nXCI6IFwibW1tXCJcblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgICAgXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJzQ29udGVudFBhZGRpbmdcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcblx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIGBkYXRhYFxuXHQgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRlZmF1bHRDb250ZW50XG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAge1xuXHQgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuXHQgKiAgICAgICAgICAgIFwiZGVmYXVsdENvbnRlbnRcIjogXCJFZGl0XCIsXG5cdCAqICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgLTEgXVxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICB7XG5cdCAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG5cdCAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIlxuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpbiBEYXRhVGFibGVzJyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLiBJdCBjYW5cblx0ICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcblx0ICogY2xpZW50IHNpZGUsIGFuZCB0byBtYXAgdGhlc2UgdG8gZGF0YWJhc2UgZmllbGRzLiBXaGVuIGRlZmluZWQsIHRoZSBuYW1lc1xuXHQgKiBhbHNvIGFsbG93IERhdGFUYWJsZXMgdG8gcmVvcmRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaWYgaXQgY29tZXNcblx0ICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcblx0ICogY2xpZW50LXNpZGUsIHlvdXIgc2VydmVyLXNpZGUgY29kZSBkb2VzIG5vdCBhbHNvIG5lZWQgdXBkYXRpbmcpLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm5hbWVcblx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfSxcblx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIsIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuXHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuXHQgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH1cblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIgfSxcblx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIgfSxcblx0ICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiIH0sXG5cdCAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcInNOYW1lXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogRGVmaW5lcyBhIGRhdGEgc291cmNlIHR5cGUgZm9yIHRoZSBvcmRlcmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkXG5cdCAqIHJlYWwtdGltZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0YWJsZSAodXBkYXRpbmcgdGhlIGludGVybmFsbHkgY2FjaGVkXG5cdCAqIHZlcnNpb24pIHByaW9yIHRvIG9yZGVyaW5nLiBUaGlzIGFsbG93cyBvcmRlcmluZyB0byBvY2N1ciBvbiB1c2VyXG5cdCAqIGVkaXRhYmxlIGVsZW1lbnRzIHN1Y2ggYXMgZm9ybSBpbnB1dHMuXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IHN0ZFxuXHQgKlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFUeXBlXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInRhcmdldHNcIjogWyAyLCAzIF0gfSxcblx0ICogICAgICAgICAgeyBcInR5cGVcIjogXCJudW1lcmljXCIsIFwidGFyZ2V0c1wiOiBbIDMgXSB9LFxuXHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1zZWxlY3RcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH0sXG5cdCAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLWNoZWNrYm94XCIsIFwidGFyZ2V0c1wiOiBbIDUgXSB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIgfSxcblx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInR5cGVcIjogXCJudW1lcmljXCIgfSxcblx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIgfSxcblx0ICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcInNTb3J0RGF0YVR5cGVcIjogXCJzdGRcIixcblxuXG5cdC8qKlxuXHQgKiBUaGUgdGl0bGUgb2YgdGhpcyBjb2x1bW4uXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IG51bGwgPGk+RGVyaXZlZCBmcm9tIHRoZSAnVEgnIHZhbHVlIGZvciB0aGlzIGNvbHVtbiBpbiB0aGVcblx0ICogICAgb3JpZ2luYWwgSFRNTCB0YWJsZS48L2k+XG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnRpdGxlXG5cdCAqICBAZHRvcHQgQ29sdW1uc1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcblx0ICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiTXkgY29sdW1uIHRpdGxlXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbnNcIjogW1xuXHQgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiB9LFxuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICBudWxsLFxuXHQgKiAgICAgICAgICBudWxsXG5cdCAqICAgICAgICBdXG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9ICk7XG5cdCAqL1xuXHRcInNUaXRsZVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoZSB0eXBlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlIGRhdGEgZm9yIHRoaXMgY29sdW1uIHdpbGwgYmVcblx0ICogb3JkZXJlZC4gRm91ciB0eXBlcyAoc3RyaW5nLCBudW1lcmljLCBkYXRlIGFuZCBodG1sICh3aGljaCB3aWxsIHN0cmlwXG5cdCAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxuXHQgKiBmb3JtYXRzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCdzIERhdGUoKSBvYmplY3Qgd2lsbCBiZSBhY2NlcHRlZCBhcyB0eXBlXG5cdCAqIGRhdGUuIEZvciBleGFtcGxlOiBcIk1hciAyNiwgMjAwOCA1OjAzIFBNXCIuIE1heSB0YWtlIHRoZSB2YWx1ZXM6ICdzdHJpbmcnLFxuXHQgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcblx0ICogdGhyb3VnaCBwbHVnLWlucy5cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvLWRldGVjdGVkIGZyb20gcmF3IGRhdGE8L2k+XG5cdCAqXG5cdCAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnR5cGVcblx0ICogIEBkdG9wdCBDb2x1bW5zXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2Bcblx0ICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuXHQgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG5cdCAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuXHQgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiIH0sXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGwsXG5cdCAqICAgICAgICAgIG51bGxcblx0ICogICAgICAgIF1cblx0ICogICAgICB9ICk7XG5cdCAqICAgIH0gKTtcblx0ICovXG5cdFwic1R5cGVcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBEZWZpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiwgdGhpcyBwYXJhbWV0ZXIgbWF5IHRha2UgYW55IENTUyB2YWx1ZVxuXHQgKiAoM2VtLCAyMHB4IGV0YykuIERhdGFUYWJsZXMgYXBwbGllcyAnc21hcnQnIHdpZHRocyB0byBjb2x1bW5zIHdoaWNoIGhhdmUgbm90XG5cdCAqIGJlZW4gZ2l2ZW4gYSBzcGVjaWZpYyB3aWR0aCB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlIGVuc3VyaW5nIHRoYXQgdGhlIHRhYmxlXG5cdCAqIHJlbWFpbnMgcmVhZGFibGUuXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IG51bGwgPGk+QXV0b21hdGljPC9pPlxuXHQgKlxuXHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi53aWR0aFxuXHQgKiAgQGR0b3B0IENvbHVtbnNcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuXHQgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcblx0ICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG5cdCAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuXHQgKiAgICAgICAgXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG5cdCAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcblx0ICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuXHQgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcblx0ICogICAgICAgICAgeyBcIndpZHRoXCI6IFwiMjAlXCIgfSxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbCxcblx0ICogICAgICAgICAgbnVsbFxuXHQgKiAgICAgICAgXVxuXHQgKiAgICAgIH0gKTtcblx0ICogICAgfSApO1xuXHQgKi9cblx0XCJzV2lkdGhcIjogbnVsbFxufTtcblxuX2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uICk7XG5cblxuXG4vKipcbiAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IC0gdGhpcyBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYVxuICogZ2l2ZW4gdGFibGUsIGluY2x1ZGluZyBjb25maWd1cmF0aW9uLCBkYXRhIGFuZCBjdXJyZW50IGFwcGxpY2F0aW9uIG9mIHRoZVxuICogdGFibGUgb3B0aW9ucy4gRGF0YVRhYmxlcyBkb2VzIG5vdCBoYXZlIGEgc2luZ2xlIGluc3RhbmNlIGZvciBlYWNoIERhdGFUYWJsZVxuICogd2l0aCB0aGUgc2V0dGluZ3MgYXR0YWNoZWQgdG8gdGhhdCBpbnN0YW5jZSwgYnV0IHJhdGhlciBpbnN0YW5jZXMgb2YgdGhlXG4gKiBEYXRhVGFibGUgXCJjbGFzc1wiIGFyZSBjcmVhdGVkIG9uLXRoZS1mbHkgYXMgbmVlZGVkICh0eXBpY2FsbHkgYnkgYVxuICogJCgpLmRhdGFUYWJsZSgpIGNhbGwpIGFuZCB0aGUgc2V0dGluZ3Mgb2JqZWN0IGlzIHRoZW4gYXBwbGllZCB0byB0aGF0XG4gKiBpbnN0YW5jZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfSBidXQgdGhpc1xuICogb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy4gSXQgc2hvdWxkXG4gKiBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGQgYmUgZG9uZVxuICogdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cbiAqICBAbmFtZXNwYWNlXG4gKiAgQHRvZG8gUmVhbGx5IHNob3VsZCBhdHRhY2ggdGhlIHNldHRpbmdzIG9iamVjdCB0byBpbmRpdmlkdWFsIGluc3RhbmNlcyBzbyB3ZVxuICogICAgZG9uJ3QgbmVlZCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvbiBlYWNoICQoKS5kYXRhVGFibGUoKSBjYWxsIChpZiB0aGVcbiAqICAgIHRhYmxlIGFscmVhZHkgZXhpc3RzKS4gSXQgd291bGQgYWxzbyBzYXZlIHBhc3Npbmcgb1NldHRpbmdzIGFyb3VuZCBhbmRcbiAqICAgIGludG8gZXZlcnkgc2luZ2xlIGZ1bmN0aW9uLiBIb3dldmVyLCB0aGlzIGlzIGEgdmVyeSBzaWduaWZpY2FudFxuICogICAgYXJjaGl0ZWN0dXJlIGNoYW5nZSBmb3IgRGF0YVRhYmxlcyBhbmQgd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJyZWFrXG4gKiAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMuIFRoaXMgaXMgc29tZXRoaW5nIHRoYXRcbiAqICAgIHdpbGwgYmUgZG9uZSBpbiAyLjAuXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzID0ge1xuXHQvKipcblx0ICogUHJpbWFyeSBmZWF0dXJlcyBvZiBEYXRhVGFibGVzIGFuZCB0aGVpciBlbmFibGVtZW50IHN0YXRlLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0XCJvRmVhdHVyZXNcIjoge1xuXG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBzYXkgaWYgRGF0YVRhYmxlcyBzaG91bGQgYXV0b21hdGljYWxseSB0cnkgdG8gY2FsY3VsYXRlIHRoZVxuXHRcdCAqIG9wdGltdW0gdGFibGUgYW5kIGNvbHVtbnMgd2lkdGhzICh0cnVlKSBvciBub3QgKGZhbHNlKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJBdXRvV2lkdGhcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIERlbGF5IHRoZSBjcmVhdGlvbiBvZiBUUiBhbmQgVEQgZWxlbWVudHMgdW50aWwgdGhleSBhcmUgYWN0dWFsbHlcblx0XHQgKiBuZWVkZWQgYnkgYSBkcml2ZW4gcGFnZSBkcmF3LiBUaGlzIGNhbiBnaXZlIGEgc2lnbmlmaWNhbnQgc3BlZWRcblx0XHQgKiBpbmNyZWFzZSBmb3IgQWpheCBzb3VyY2UgYW5kIEphdmFzY3JpcHQgc291cmNlIGRhdGEsIGJ1dCBtYWtlcyBub1xuXHRcdCAqIGRpZmZlcmVuY2UgYXQgYWxsIGZvciBET00gYW5kIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYkRlZmVyUmVuZGVyXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBFbmFibGUgZmlsdGVyaW5nIG9uIHRoZSB0YWJsZSBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkXG5cdFx0ICogdGhlbiB0aGVyZSBpcyBubyBmaWx0ZXJpbmcgYXQgYWxsIG9uIHRoZSB0YWJsZSwgaW5jbHVkaW5nIGZuRmlsdGVyLlxuXHRcdCAqIFRvIGp1c3QgcmVtb3ZlIHRoZSBmaWx0ZXJpbmcgaW5wdXQgdXNlIHNEb20gYW5kIHJlbW92ZSB0aGUgJ2YnIG9wdGlvbi5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJGaWx0ZXJcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnQgKHRoZSAnU2hvd2luZyB4IG9mIHkgcmVjb3JkcycgZGl2KSBlbmFibGVcblx0XHQgKiBmbGFnLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYkluZm9cIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFByZXNlbnQgYSB1c2VyIGNvbnRyb2wgYWxsb3dpbmcgdGhlIGVuZCB1c2VyIHRvIGNoYW5nZSB0aGUgcGFnZSBzaXplXG5cdFx0ICogd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiTGVuZ3RoQ2hhbmdlXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBQYWdpbmF0aW9uIGVuYWJsZWQgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZCB0aGVuIGxlbmd0aFxuXHRcdCAqIGNoYW5naW5nIG11c3QgYWxzbyBiZSBkaXNhYmxlZC5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJQYWdpbmF0ZVwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogUHJvY2Vzc2luZyBpbmRpY2F0b3IgZW5hYmxlIGZsYWcgd2hlbmV2ZXIgRGF0YVRhYmxlcyBpcyBlbmFjdGluZyBhXG5cdFx0ICogdXNlciByZXF1ZXN0IC0gdHlwaWNhbGx5IGFuIEFqYXggcmVxdWVzdCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJQcm9jZXNzaW5nXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGVuYWJsZWQgZmxhZyAtIHdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGxcblx0XHQgKiBnZXQgYWxsIGRhdGEgZnJvbSB0aGUgc2VydmVyIGZvciBldmVyeSBkcmF3IC0gdGhlcmUgaXMgbm8gZmlsdGVyaW5nLFxuXHRcdCAqIHNvcnRpbmcgb3IgcGFnaW5nIGRvbmUgb24gdGhlIGNsaWVudC1zaWRlLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNlcnZlclNpZGVcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFNvcnRpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNvcnRcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIE11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0XCJiU29ydE11bHRpXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBhIGNsYXNzIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBiZWluZyBzb3J0ZWQgdG8gcHJvdmlkZSBhXG5cdFx0ICogdmlzdWFsIGhpZ2hsaWdodCBvciBub3QuIFRoaXMgY2FuIHNsb3cgdGhpbmdzIGRvd24gd2hlbiBlbmFibGVkIHNpbmNlXG5cdFx0ICogdGhlcmUgaXMgYSBsb3Qgb2YgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlNvcnRDbGFzc2VzXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBTdGF0ZSBzYXZpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdFwiYlN0YXRlU2F2ZVwiOiBudWxsXG5cdH0sXG5cblxuXHQvKipcblx0ICogU2Nyb2xsaW5nIHNldHRpbmdzIGZvciBhIHRhYmxlLlxuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0XCJvU2Nyb2xsXCI6IHtcblx0XHQvKipcblx0XHQgKiBXaGVuIHRoZSB0YWJsZSBpcyBzaG9ydGVyIGluIGhlaWdodCB0aGFuIHNTY3JvbGxZLCBjb2xsYXBzZSB0aGVcblx0XHQgKiB0YWJsZSBjb250YWluZXIgZG93biB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSAod2hlbiB0cnVlKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHRcImJDb2xsYXBzZVwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogV2lkdGggb2YgdGhlIHNjcm9sbGJhciBmb3IgdGhlIHdlYi1icm93c2VyJ3MgcGxhdGZvcm0uIENhbGN1bGF0ZWRcblx0XHQgKiBkdXJpbmcgdGFibGUgaW5pdGlhbGlzYXRpb24uXG5cdFx0ICogIEB0eXBlIGludFxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJpQmFyV2lkdGhcIjogMCxcblxuXHRcdC8qKlxuXHRcdCAqIFZpZXdwb3J0IHdpZHRoIGZvciBob3Jpem9udGFsIHNjcm9sbGluZy4gSG9yaXpvbnRhbCBzY3JvbGxpbmcgaXNcblx0XHQgKiBkaXNhYmxlZCBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNYXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBXaWR0aCB0byBleHBhbmQgdGhlIHRhYmxlIHRvIHdoZW4gdXNpbmcgeC1zY3JvbGxpbmcuIFR5cGljYWxseSB5b3Vcblx0XHQgKiBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoaXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcInNYSW5uZXJcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFZpZXdwb3J0IGhlaWdodCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nLiBWZXJ0aWNhbCBzY3JvbGxpbmcgaXMgZGlzYWJsZWRcblx0XHQgKiBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKi9cblx0XHRcInNZXCI6IG51bGxcblx0fSxcblxuXHQvKipcblx0ICogTGFuZ3VhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZS5cblx0ICogIEBuYW1lc3BhY2Vcblx0ICogIEBleHRlbmRzIERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2Vcblx0ICovXG5cdFwib0xhbmd1YWdlXCI6IHtcblx0XHQvKipcblx0XHQgKiBJbmZvcm1hdGlvbiBjYWxsYmFjayBmdW5jdGlvbi4gU2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5mbkluZm9DYWxsYmFja31cblx0XHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCcm93c2VyIHN1cHBvcnQgcGFyYW1ldGVyc1xuXHQgKiAgQG5hbWVzcGFjZVxuXHQgKi9cblx0XCJvQnJvd3NlclwiOiB7XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGUgaWYgdGhlIGJyb3dzZXIgaW5jb3JyZWN0bHkgY2FsY3VsYXRlcyB3aWR0aDoxMDAlIGluc2lkZSBhXG5cdFx0ICogc2Nyb2xsaW5nIGVsZW1lbnQgKElFNi83KVxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiU2Nyb2xsT3ZlcnNpemVcIjogZmFsc2UsXG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyBvbiB0aGUgcmlnaHQgb3IgbGVmdCBvZiB0aGVcblx0XHQgKiBzY3JvbGxpbmcgY29udGFpbmVyIC0gbmVlZGVkIGZvciBydGwgbGFuZ3VhZ2UgbGF5b3V0LCBhbHRob3VnaCBub3Rcblx0XHQgKiBhbGwgYnJvd3NlcnMgbW92ZSB0aGUgc2Nyb2xsYmFyIChTYWZhcmkpLlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0XCJiU2Nyb2xsYmFyTGVmdFwiOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgZm9yIGlmIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIGlzIGZ1bGx5IHN1cHBvcnRlZCBvciBub3Rcblx0XHQgKiAgQHR5cGUgYm9vbGVhblxuXHRcdCAqICBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdFwiYkJvdW5kaW5nXCI6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0ICogQnJvd3NlciBzY3JvbGxiYXIgd2lkdGhcblx0XHQgKiAgQHR5cGUgaW50ZWdlclxuXHRcdCAqICBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0XCJiYXJXaWR0aFwiOiAwXG5cdH0sXG5cblxuXHRcImFqYXhcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBBcnJheSByZWZlcmVuY2luZyB0aGUgbm9kZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHRoZSBmZWF0dXJlcy4gVGhlXG5cdCAqIHBhcmFtZXRlcnMgb2YgdGhpcyBvYmplY3QgbWF0Y2ggd2hhdCBpcyBhbGxvd2VkIGJ5IHNEb20gLSBpLmUuXG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG5cdCAqICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0ICogICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0ICogICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG5cdCAqICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdCAqICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdCAqICAgPC91bD5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhYW5GZWF0dXJlc1wiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcblx0ICogaW5mb3JtYXRpb24uXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9EYXRhXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBpbmRleGVzIHdoaWNoIGFyZSBpbiB0aGUgY3VycmVudCBkaXNwbGF5IChhZnRlciBmaWx0ZXJpbmcgZXRjKVxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcImFpRGlzcGxheVwiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgaW5kZXhlcyBmb3IgZGlzcGxheSAtIG5vIGZpbHRlcmluZ1xuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcImFpRGlzcGxheU1hc3RlclwiOiBbXSxcblxuXHQvKipcblx0ICogTWFwIG9mIHJvdyBpZHMgdG8gZGF0YSBpbmRleGVzXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IHt9XG5cdCAqL1xuXHRcImFJZHNcIjoge30sXG5cblx0LyoqXG5cdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggY29sdW1uIHRoYXQgaXMgaW4gdXNlXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9Db2x1bW5zXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBoZWFkZXJcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhb0hlYWRlclwiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgZm9vdGVyXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9Gb290ZXJcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0b3JlIHRoZSBhcHBsaWVkIGdsb2JhbCBzZWFyY2ggaW5mb3JtYXRpb24gaW4gY2FzZSB3ZSB3YW50IHRvIGZvcmNlIGFcblx0ICogcmVzZWFyY2ggb3IgY29tcGFyZSB0aGUgb2xkIHNlYXJjaCB0byBhIG5ldyBvbmUuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqICBAbmFtZXNwYWNlXG5cdCAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcblx0ICovXG5cdFwib1ByZXZpb3VzU2VhcmNoXCI6IHt9LFxuXG5cdC8qKlxuXHQgKiBTdG9yZSB0aGUgYXBwbGllZCBzZWFyY2ggZm9yIGVhY2ggY29sdW1uIC0gc2VlXG5cdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2h9IGZvciB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlXG5cdCAqIGZpbHRlcmluZyBpbmZvcm1hdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9QcmVTZWFyY2hDb2xzXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxuXHQgKiB1c2VkIGluIHRoZSBmb2xsb3dpbmcgbWFubmVyOlxuXHQgKiA8dWw+XG5cdCAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cblx0ICogICA8bGk+SW5kZXggMSAtIGN1cnJlbnQgc29ydGluZyBkaXJlY3Rpb248L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcblx0ICovXG5cdFwiYWFTb3J0aW5nXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFNvcnRpbmcgdGhhdCBpcyBhbHdheXMgYXBwbGllZCB0byB0aGUgdGFibGUgKGkuZS4gcHJlZml4ZWQgaW4gZnJvbnQgb2Zcblx0ICogYWFTb3J0aW5nKS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhYVNvcnRpbmdGaXhlZFwiOiBbXSxcblxuXHQvKipcblx0ICogQ2xhc3NlcyB0byB1c2UgZm9yIHRoZSBzdHJpcGluZyBvZiBhIHRhYmxlLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcImFzU3RyaXBlQ2xhc3Nlc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhc0Rlc3Ryb3lTdHJpcGVzXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyB3aWR0aFxuXHQgKiAgQHR5cGUgaW50XG5cdCAqICBAZGVmYXVsdCAwXG5cdCAqL1xuXHRcInNEZXN0cm95V2lkdGhcIjogMCxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGFycmF5IGZvciBldmVyeSB0aW1lIGEgcm93IGlzIGluc2VydGVkIChpLmUuIG9uIGEgZHJhdykuXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9Sb3dDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhb0hlYWRlckNhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGZvb3RlciBvbiBlYWNoIGRyYXcuXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9Gb290ZXJDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBkcmF3IGNhbGxiYWNrIGZ1bmN0aW9uc1xuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcImFvRHJhd0NhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9Sb3dDcmVhdGVkQ2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IganVzdCBiZWZvcmUgdGhlIHRhYmxlIGlzIHJlZHJhd24uIEEgcmV0dXJuIG9mXG5cdCAqIGZhbHNlIHdpbGwgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9QcmVEcmF3Q2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9Jbml0Q29tcGxldGVcIjogW10sXG5cblxuXHQvKipcblx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRvIGJlIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nLCBwcmlvciB0b1xuXHQgKiBzYXZpbmcgc3RhdGUuXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9TdGF0ZVNhdmVQYXJhbXNcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0aGF0IGhhdmUgYmVlbiBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZ1xuXHQgKiBwcmlvciB0byB1c2luZyB0aGUgc3RvcmVkIHZhbHVlcyB0byByZXN0b3JlIHRoZSBzdGF0ZS5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhb1N0YXRlTG9hZFBhcmFtc1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxuXHQgKiBsb2FkZWRcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhb1N0YXRlTG9hZGVkXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWNoZSB0aGUgdGFibGUgSUQgZm9yIHF1aWNrIGFjY2Vzc1xuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG5cdCAqL1xuXHRcInNUYWJsZUlkXCI6IFwiXCIsXG5cblx0LyoqXG5cdCAqIFRoZSBUQUJMRSBub2RlIGZvciB0aGUgbWFpbiB0YWJsZVxuXHQgKiAgQHR5cGUgbm9kZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJuVGFibGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGhlYWQgZWxlbWVudFxuXHQgKiAgQHR5cGUgbm9kZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJuVEhlYWRcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGZvb3QgZWxlbWVudCAtIGlmIGl0IGV4aXN0c1xuXHQgKiAgQHR5cGUgbm9kZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJuVEZvb3RcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGVybWFuZW50IHJlZiB0byB0aGUgdGJvZHkgZWxlbWVudFxuXHQgKiAgQHR5cGUgbm9kZVxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJuVEJvZHlcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ2FjaGUgdGhlIHdyYXBwZXIgbm9kZSAoY29udGFpbnMgYWxsIERhdGFUYWJsZXMgY29udHJvbGxlZCBlbGVtZW50cylcblx0ICogIEB0eXBlIG5vZGVcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwiblRhYmxlV3JhcHBlclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZSBpZiB3aGVuIHVzaW5nIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGhlIGxvYWRpbmcgb2YgZGF0YVxuXHQgKiBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIHNlY29uZCBkcmF3LlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKiAgQHR5cGUgYm9vbGVhblxuXHQgKiAgQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdFwiYkRlZmVyTG9hZGluZ1wiOiBmYWxzZSxcblxuXHQvKipcblx0ICogSW5kaWNhdGUgaWYgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGhhcyBiZWVuIHJlYWQgaW5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRcImJJbml0aWFsaXNlZFwiOiBmYWxzZSxcblxuXHQvKipcblx0ICogSW5mb3JtYXRpb24gYWJvdXQgb3BlbiByb3dzLiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIHRoZSBwYXJhbWV0ZXJzXG5cdCAqICduVHInIGFuZCAnblBhcmVudCdcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhb09wZW5Sb3dzXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBEaWN0YXRlIHRoZSBwb3NpdGlvbmluZyBvZiBEYXRhVGFibGVzJyBjb250cm9sIGVsZW1lbnRzIC0gc2VlXG5cdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWwub0luaXQuc0RvbX0uXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwic0RvbVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZGVsYXkgKGluIG1TKVxuXHQgKiAgQHR5cGUgaW50ZWdlclxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaGljaCB0eXBlIG9mIHBhZ2luYXRpb24gc2hvdWxkIGJlIHVzZWQuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICogIEBkZWZhdWx0IHR3b19idXR0b25cblx0ICovXG5cdFwic1BhZ2luYXRpb25UeXBlXCI6IFwidHdvX2J1dHRvblwiLFxuXG5cdC8qKlxuXHQgKiBUaGUgc3RhdGUgZHVyYXRpb24gKGZvciBgc3RhdGVTYXZlYCkgaW4gc2Vjb25kcy5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICogIEB0eXBlIGludFxuXHQgKiAgQGRlZmF1bHQgMFxuXHQgKi9cblx0XCJpU3RhdGVEdXJhdGlvblwiOiAwLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIHNhdmluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG5cdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0ICogICA8dWw+XG5cdCAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG5cdCAqICAgICAgIGFuZCB0aGUgSlNPTiBzdHJpbmcgdG8gc2F2ZSB0aGF0IGhhcyBiZWVuIHRodXMgZmFyIGNyZWF0ZWQuIFJldHVybnNcblx0ICogICAgICAgYSBKU09OIHN0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIGEganNvbiBvYmplY3Rcblx0ICogICAgICAgKGkuZS4gJ1wicGFyYW1cIjogWyAwLCAxLCAyXScpPC9saT5cblx0ICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cblx0ICogICA8L3VsPlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqL1xuXHRcImFvU3RhdGVTYXZlXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIGxvYWRpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHQgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxuXHQgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxuXHQgKiAgIDwvdWw+XG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9TdGF0ZUxvYWRcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0YXRlIHRoYXQgd2FzIHNhdmVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwib1NhdmVkU3RhdGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogU3RhdGUgdGhhdCB3YXMgbG9hZGVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwib0xvYWRlZFN0YXRlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFNvdXJjZSB1cmwgZm9yIEFKQVggZGF0YSBmb3IgdGhlIHRhYmxlLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNBamF4U291cmNlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFByb3BlcnR5IGZyb20gYSBnaXZlbiBvYmplY3QgZnJvbSB3aGljaCB0byByZWFkIHRoZSB0YWJsZSBkYXRhIGZyb20uIFRoaXNcblx0ICogY2FuIGJlIGFuIGVtcHR5IHN0cmluZyAod2hlbiBub3Qgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyksIGluIHdoaWNoIGNhc2Vcblx0ICogaXQgaXMgIGFzc3VtZWQgYW4gYW4gYXJyYXkgaXMgZ2l2ZW4gZGlyZWN0bHkuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICovXG5cdFwic0FqYXhEYXRhUHJvcFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaGUgbGFzdCBqUXVlcnkgWEhSIG9iamVjdCB0aGF0IHdhcyB1c2VkIGZvciBzZXJ2ZXItc2lkZSBkYXRhIGdhdGhlcmluZy5cblx0ICogVGhpcyBjYW4gYmUgdXNlZCBmb3Igd29ya2luZyB3aXRoIHRoZSBYSFIgaW5mb3JtYXRpb24gaW4gb25lIG9mIHRoZVxuXHQgKiBjYWxsYmFja3Ncblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJqcVhIUlwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXG5cdCAqL1xuXHRcImpzb25cIjogdW5kZWZpbmVkLFxuXG5cdC8qKlxuXHQgKiBEYXRhIHN1Ym1pdHRlZCBhcyBwYXJ0IG9mIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqICBAZGVmYXVsdCB1bmRlZmluZWRcblx0ICovXG5cdFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcblxuXHQvKipcblx0ICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICovXG5cdFwiZm5TZXJ2ZXJEYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9ucyB3aGljaCBhcmUgY2FsbGVkIHByaW9yIHRvIHNlbmRpbmcgYW4gQWpheCByZXF1ZXN0IHNvIGV4dHJhXG5cdCAqIHBhcmFtZXRlcnMgY2FuIGVhc2lseSBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhb1NlcnZlclBhcmFtc1wiOiBbXSxcblxuXHQvKipcblx0ICogU2VuZCB0aGUgWEhSIEhUVFAgbWV0aG9kIC0gR0VUIG9yIFBPU1QgKGNvdWxkIGJlIFBVVCBvciBERUxFVEUgaWZcblx0ICogcmVxdWlyZWQpLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqL1xuXHRcInNTZXJ2ZXJNZXRob2RcIjogbnVsbCxcblxuXHQvKipcblx0ICogRm9ybWF0IG51bWJlcnMgZm9yIGRpc3BsYXkuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKi9cblx0XCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBMaXN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHVzZXIgc2VsZWN0YWJsZSBsZW5ndGggbWVudS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICogIEB0eXBlIGFycmF5XG5cdCAqICBAZGVmYXVsdCBbXVxuXHQgKi9cblx0XCJhTGVuZ3RoTWVudVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3Jcblx0ICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHQgKiAgQHR5cGUgaW50XG5cdCAqICBAZGVmYXVsdCAwXG5cdCAqL1xuXHRcImlEcmF3XCI6IDAsXG5cblx0LyoqXG5cdCAqIEluZGljYXRlIGlmIGEgcmVkcmF3IGlzIGJlaW5nIGRvbmUgLSB1c2VmdWwgZm9yIEFqYXhcblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRcImJEcmF3aW5nXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBEcmF3IGluZGV4IChpRHJhdykgb2YgdGhlIGxhc3QgZXJyb3Igd2hlbiBwYXJzaW5nIHRoZSByZXR1cm5lZCBkYXRhXG5cdCAqICBAdHlwZSBpbnRcblx0ICogIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHRcImlEcmF3RXJyb3JcIjogLTEsXG5cblx0LyoqXG5cdCAqIFBhZ2luZyBkaXNwbGF5IGxlbmd0aFxuXHQgKiAgQHR5cGUgaW50XG5cdCAqICBAZGVmYXVsdCAxMFxuXHQgKi9cblx0XCJfaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cblx0LyoqXG5cdCAqIFBhZ2luZyBzdGFydCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxuXHQgKiAgQHR5cGUgaW50XG5cdCAqICBAZGVmYXVsdCAwXG5cdCAqL1xuXHRcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cblx0LyoqXG5cdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgcmVzdWx0IHNldFxuXHQgKiAoaS5lLiBiZWZvcmUgZmlsdGVyaW5nKSwgVXNlIGZuUmVjb3Jkc1RvdGFsIHJhdGhlciB0aGFuXG5cdCAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2Zcblx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0ICogIEB0eXBlIGludFxuXHQgKiAgQGRlZmF1bHQgMFxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdFwiX2lSZWNvcmRzVG90YWxcIjogMCxcblxuXHQvKipcblx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgc2V0XG5cdCAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXG5cdCAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2Zcblx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IDBcblx0ICogIEBwcml2YXRlXG5cdCAqL1xuXHRcIl9pUmVjb3Jkc0Rpc3BsYXlcIjogMCxcblxuXHQvKipcblx0ICogVGhlIGNsYXNzZXMgdG8gdXNlIGZvciB0aGUgdGFibGVcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQge31cblx0ICovXG5cdFwib0NsYXNzZXNcIjoge30sXG5cblx0LyoqXG5cdCAqIEZsYWcgYXR0YWNoZWQgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBzbyB5b3UgY2FuIGNoZWNrIGluIHRoZSBkcmF3XG5cdCAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHQgKiBldmVudHMuXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqICBAZGVmYXVsdCBmYWxzZVxuXHQgKiAgQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHQgKiBjYWxsYmFjayBpZiBzb3J0aW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXG5cdCAqIGV2ZW50cy5cblx0ICogIEB0eXBlIGJvb2xlYW5cblx0ICogIEBkZWZhdWx0IGZhbHNlXG5cdCAqICBAZGVwcmVjYXRlZFxuXHQgKi9cblx0XCJiU29ydGVkXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZSB0aGF0IGlmIG11bHRpcGxlIHJvd3MgYXJlIGluIHRoZSBoZWFkZXIgYW5kIHRoZXJlIGlzIG1vcmUgdGhhblxuXHQgKiBvbmUgdW5pcXVlIGNlbGwgcGVyIGNvbHVtbiwgaWYgdGhlIHRvcCBvbmUgKHRydWUpIG9yIGJvdHRvbSBvbmUgKGZhbHNlKVxuXHQgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqICBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHRcImJTb3J0Q2VsbHNUb3BcIjogbnVsbCxcblxuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24gb2JqZWN0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIHRhYmxlXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwib0luaXRcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGVzdHJveSBjYWxsYmFjayBmdW5jdGlvbnMgLSBmb3IgcGx1Zy1pbnMgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG8gdGhlXG5cdCAqIGRlc3Ryb3kgc28gdGhleSBjYW4gY2xlYW4gdXAgbWFya3VwIGFuZCBldmVudHMuXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYW9EZXN0cm95Q2FsbGJhY2tcIjogW10sXG5cblxuXHQvKipcblx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKi9cblx0XCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIF9mbkRhdGFTb3VyY2UoIHRoaXMgKSA9PSAnc3NwJyA/XG5cdFx0XHR0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XG5cdFx0XHR0aGlzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYWZ0ZXIgZmlsdGVyaW5nXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKi9cblx0XCJmblJlY29yZHNEaXNwbGF5XCI6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdHRoaXMuX2lSZWNvcmRzRGlzcGxheSAqIDEgOlxuXHRcdFx0dGhpcy5haURpc3BsYXkubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRpc3BsYXkgZW5kIHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKi9cblx0XCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhclxuXHRcdFx0bGVuICAgICAgPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdHN0YXJ0ICAgID0gdGhpcy5faURpc3BsYXlTdGFydCxcblx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRyZWNvcmRzICA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcblx0XHRcdGZlYXR1cmVzID0gdGhpcy5vRmVhdHVyZXMsXG5cdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblxuXHRcdGlmICggZmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRzdGFydCArIHJlY29yZHMgOlxuXHRcdFx0XHRNYXRoLm1pbiggc3RhcnQrbGVuLCB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gISBwYWdpbmF0ZSB8fCBjYWxjPnJlY29yZHMgfHwgbGVuPT09LTEgP1xuXHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0Y2FsYztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcIm9JbnN0YW5jZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBVbmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCBpbnN0YW5jZSBvZiB0aGUgRGF0YVRhYmxlcyBvYmplY3QuIElmIHRoZXJlXG5cdCAqIGlzIGFuIElEIG9uIHRoZSB0YWJsZSBub2RlLCB0aGVuIGl0IHRha2VzIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBhblxuXHQgKiBpbmNyZW1lbnRpbmcgaW50ZXJuYWwgY291bnRlciBpcyB1c2VkLlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRcInNJbnN0YW5jZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byBEYXRhVGFibGVzIGNvbnRyb2wgZWxlbWVudHMsIGFsbG93aW5nXG5cdCAqIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIGFuZCBpdHMgY29udHJvbHMuXG5cdCAqL1xuXHRcImlUYWJJbmRleFwiOiAwLFxuXG5cdC8qKlxuXHQgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcblx0ICovXG5cdFwiblNjcm9sbEhlYWRcIjogbnVsbCxcblxuXHQvKipcblx0ICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXG5cdCAqL1xuXHRcIm5TY3JvbGxGb290XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIExhc3QgYXBwbGllZCBzb3J0XG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICovXG5cdFwiYUxhc3RTb3J0XCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQge31cblx0ICovXG5cdFwib1BsdWdpbnNcIjoge30sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IGEgcm93J3MgaWQgZnJvbSB0aGUgcm93J3MgZGF0YVxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdFwicm93SWRGblwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBEYXRhIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIGEgcm93J3MgaWRcblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0XCJyb3dJZFwiOiBudWxsXG59O1xuXG4vKipcbiAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuICogb3B0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcbiAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlLmV4dGAgd2hlcmUgaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZC4gSXQgaXNcbiAqIGFsc28gYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGhpc3RvcmljIHJlYXNvbnMuXG4gKiAgQG5hbWVzcGFjZVxuICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMuZXh0XG4gKi9cblxuXG4vKipcbiAqIERhdGFUYWJsZXMgZXh0ZW5zaW9uc1xuICogXG4gKiBUaGlzIG5hbWVzcGFjZSBhY3RzIGFzIGEgY29sbGVjdGlvbiBhcmVhIGZvciBwbHVnLWlucyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gKiBleHRlbmQgRGF0YVRhYmxlcyBjYXBhYmlsaXRpZXMuIEluZGVlZCBtYW55IG9mIHRoZSBidWlsZCBpbiBtZXRob2RzXG4gKiB1c2UgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSB0aGVpciBvd24gY2FwYWJpbGl0aWVzIChzb3J0aW5nIG1ldGhvZHMgZm9yXG4gKiBleGFtcGxlKS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBuYW1lc3BhY2UgaXMgYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGxlZ2FjeVxuICogcmVhc29uc1xuICpcbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5leHQgPSBfZXh0ID0ge1xuXHQvKipcblx0ICogQnV0dG9ucy4gRm9yIHVzZSB3aXRoIHRoZSBCdXR0b25zIGV4dGVuc2lvbiBmb3IgRGF0YVRhYmxlcy4gVGhpcyBpc1xuXHQgKiBkZWZpbmVkIGhlcmUgc28gb3RoZXIgZXh0ZW5zaW9ucyBjYW4gZGVmaW5lIGJ1dHRvbnMgcmVnYXJkbGVzcyBvZiBsb2FkXG5cdCAqIG9yZGVyLiBJdCBpcyBfbm90XyB1c2VkIGJ5IERhdGFUYWJsZXMgY29yZS5cblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQge31cblx0ICovXG5cdGJ1dHRvbnM6IHt9LFxuXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgY2xhc3MgbmFtZXNcblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQge31cblx0ICovXG5cdGNsYXNzZXM6IHt9LFxuXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgYnVpbGQgdHlwZSAoZXhwYW5kZWQgYnkgdGhlIGRvd25sb2FkIGJ1aWxkZXIpXG5cdCAqXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICovXG5cdGJ1aWxkZXI6IFwiLXNvdXJjZS1cIixcblxuXG5cdC8qKlxuXHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdCAqIFxuXHQgKiBIb3cgc2hvdWxkIERhdGFUYWJsZXMgcmVwb3J0IGFuIGVycm9yLiBDYW4gdGFrZSB0aGUgdmFsdWUgJ2FsZXJ0Jyxcblx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdCAqXG5cdCAqICBAdHlwZSBzdHJpbmd8ZnVuY3Rpb25cblx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdCAqL1xuXHRlcnJNb2RlOiBcImFsZXJ0XCIsXG5cblxuXHQvKipcblx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0ICogXG5cdCAqIFRoaXMgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBkZXNjcmliZSB0aGUgZmVhdHVyZSBwbHVnLWlucyB0aGF0IGFyZVxuXHQgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG5cdCAqIHVzZSB0aHJvdWdoIHRoZSBgZG9tYCBpbml0aWFsaXNhdGlvbiBvcHRpb24uXG5cdCAqIFxuXHQgKiBFYWNoIGZlYXR1cmUgcGx1Zy1pbiBpcyBkZXNjcmliZWQgYnkgYW4gb2JqZWN0IHdoaWNoIG11c3QgaGF2ZSB0aGVcblx0ICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdCAqIFxuXHQgKiAqIGBmbkluaXRgIC0gZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHBsdWctaW4sXG5cdCAqICogYGNGZWF0dXJlYCAtIGEgY2hhcmFjdGVyIHNvIHRoZSBmZWF0dXJlIGNhbiBiZSBlbmFibGVkIGJ5IHRoZSBgZG9tYFxuXHQgKiAgIGluc3RpbGxhdGlvbiBvcHRpb24uIFRoaXMgaXMgY2FzZSBzZW5zaXRpdmUuXG5cdCAqXG5cdCAqIFRoZSBgZm5Jbml0YCBmdW5jdGlvbiBoYXMgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxuXHQgKlxuXHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKlxuXHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdCAqIFxuXHQgKiAqIHtub2RlfG51bGx9IFRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHlvdXIgZmVhdHVyZS4gTm90ZSB0aGF0IHRoZVxuXHQgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcblx0ICogICBET00gZWxlbWVudHMgaW50byBEYXRhVGFibGVzIGNvbnRyb2wgKGBkb21gKSAtIGZvciBleGFtcGxlIHRoaXMgbWlnaHRcblx0ICogICBiZSB1c2VmdWwgd2hlbiBkZXZlbG9waW5nIGEgcGx1Zy1pbiB3aGljaCBhbGxvd3MgdGFibGUgY29udHJvbCB2aWFcblx0ICogICBrZXlib2FyZCBlbnRyeVxuXHQgKlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5mZWF0dXJlcy5wdXNoKCB7XG5cdCAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcblx0ICogICAgICAgIHJldHVybiBuZXcgVGFibGVUb29scyggeyBcIm9EVFNldHRpbmdzXCI6IG9TZXR0aW5ncyB9ICk7XG5cdCAqICAgICAgfSxcblx0ICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG5cdCAqICAgIH0gKTtcblx0ICovXG5cdGZlYXR1cmU6IFtdLFxuXG5cblx0LyoqXG5cdCAqIFJvdyBzZWFyY2hpbmcuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdCAqIHNlYXJjaGluZywgYW5kIGEgbG90IG1vcmUgY29tcHJlaGVuc2l2ZSBhcyBpdCBhbGxvd3MgeW91IGNvbXBsZXRlIGNvbnRyb2xcblx0ICogb3ZlciB0aGUgc2VhcmNoaW5nIGxvZ2ljLiBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBpcyBhIGZ1bmN0aW9uXG5cdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdCAqIGFuZCB5b3VyIGxvZ2ljIGRlY2lkZXMgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBzZWFyY2hpbmcgZGF0YSBzZXRcblx0ICogb3Igbm90LlxuXHQgKlxuXHQgKiBTZWFyY2hpbmcgZnVuY3Rpb25zIGhhdmUgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxuXHQgKlxuXHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAyLiBge2FycmF5fG9iamVjdH1gIERhdGEgZm9yIHRoZSByb3cgdG8gYmUgcHJvY2Vzc2VkIChzYW1lIGFzIHRoZVxuXHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0ICogICAgZnJvbSBhIERPTSBkYXRhIHNvdXJjZVxuXHQgKiAzLiBge2ludH1gIFJvdyBpbmRleCAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLmFvRGF0YX0pLCB3aGljaFxuXHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdCAqXG5cdCAqICoge2Jvb2xlYW59IEluY2x1ZGUgdGhlIHJvdyBpbiB0aGUgc2VhcmNoZWQgcmVzdWx0IHNldCAodHJ1ZSkgb3Igbm90XG5cdCAqICAgKGZhbHNlKVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgYXMgd2l0aCB0aGUgbWFpbiBzZWFyY2ggYWJpbGl0eSBpbiBEYXRhVGFibGVzLCB0ZWNobmljYWxseSB0aGlzXG5cdCAqIGlzIFwiZmlsdGVyaW5nXCIsIHNpbmNlIGl0IGlzIHN1YnRyYWN0aXZlLiBIb3dldmVyLCBmb3IgY29uc2lzdGVuY3kgaW5cblx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdCAqXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdCAqICAgIC8vIGZvdXJ0aCBjb2x1bW4gKGkuZS4gdGhlIGRhdGFbM10gaW5kZXgpIGJhc2VkIG9uIHR3byBpbnB1dCB2YWx1ZXNcblx0ICogICAgLy8gZnJvbSB0aGUgZW5kLXVzZXIsIG1hdGNoaW5nIHRoZSBkYXRhIGluIGEgY2VydGFpbiByYW5nZS5cblx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHQgKiAgICAgIGZ1bmN0aW9uKCBzZXR0aW5ncywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHQgKiAgICAgICAgdmFyIG1pbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW4nKS52YWx1ZSAqIDE7XG5cdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0ICogICAgICAgIHZhciB2ZXJzaW9uID0gZGF0YVszXSA9PSBcIi1cIiA/IDAgOiBkYXRhWzNdKjE7XG5cdCAqXG5cdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgKiAgICAgIH1cblx0ICogICAgKTtcblx0ICovXG5cdHNlYXJjaDogW10sXG5cblxuXHQvKipcblx0ICogU2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHQgKlxuXHQgKiBUaGUgYHNlbGVjdG9yYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlXG5cdCAqIHNlbGVjdG9yIG1vZGlmaWVyIG9wdGlvbnMgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IGRhdGEgdHlwZSkgdGhhdFxuXHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHQgKiB0aGVpciBwbHVyYWwgY291bnRlcnBhcnRzKS4gRm9yIGV4YW1wbGUgdGhlIFNlbGVjdCBleHRlbnNpb24gdXNlcyB0aGlzXG5cdCAqIG1lY2hhbmlzbSB0byBwcm92aWRlIGFuIG9wdGlvbiB0byBzZWxlY3Qgb25seSByb3dzLCBjb2x1bW5zIGFuZCBjZWxsc1xuXHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHQgKiB3aGljaCBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBleGlzdGluZyBidWlsdCBpbiBzZWxlY3RvclxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBFYWNoIHByb3BlcnR5IGlzIGFuIGFycmF5IHRvIHdoaWNoIGZ1bmN0aW9ucyBjYW4gYmUgcHVzaGVkLiBUaGUgZnVuY3Rpb25zXG5cdCAqIHRha2UgdGhyZWUgYXR0cmlidXRlczpcblx0ICpcblx0ICogKiBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXG5cdCAqICogT3B0aW9ucyBvYmplY3QgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IHR5cGUpXG5cdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdCAqXG5cdCAqIFRoZSByZXR1cm4gaXMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdGluZyBpdGVtIGluZGV4ZXMgYWZ0ZXIgdGhlIGN1c3RvbVxuXHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqL1xuXHRzZWxlY3Rvcjoge1xuXHRcdGNlbGw6IFtdLFxuXHRcdGNvbHVtbjogW10sXG5cdFx0cm93OiBbXVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9ucywgZXhwb3NlZCBmb3IgdXNlZCBpbiBwbHVnLWlucy5cblx0ICogXG5cdCAqIFBsZWFzZSBub3RlIHRoYXQgeW91IHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhlIGludGVybmFsIG1ldGhvZHMgZm9yXG5cdCAqIGFueXRoaW5nIG90aGVyIHRoYW4gYSBwbHVnLWluIChhbmQgZXZlbiB0aGVuLCB0cnkgdG8gYXZvaWQgaWYgcG9zc2libGUpLlxuXHQgKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gbWF5IGNoYW5nZSBiZXR3ZWVuIHJlbGVhc2VzLlxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqICBAZGVmYXVsdCB7fVxuXHQgKi9cblx0aW50ZXJuYWw6IHt9LFxuXG5cblx0LyoqXG5cdCAqIExlZ2FjeSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEVuYWJsZSBhbmQgZGlzYWJsZSBsZWdhY3kgb3B0aW9ucyB0aGF0XG5cdCAqIGFyZSBhdmFpbGFibGUgaW4gRGF0YVRhYmxlcy5cblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKi9cblx0bGVnYWN5OiB7XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIC8gZGlzYWJsZSBEYXRhVGFibGVzIDEuOSBjb21wYXRpYmxlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHQgKiByZXF1ZXN0c1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdGFqYXg6IG51bGxcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBQYWdpbmF0aW9uIHBsdWctaW4gbWV0aG9kcy5cblx0ICogXG5cdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHQgKiBiZSBzaG93biBieSB0aGUgcGFnaW5hdGlvbiByZW5kZXJpbmcgbWV0aG9kIHRoYXQgaXMgdXNlZCBmb3IgdGhlIHRhYmxlOlxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5yZW5kZXJlci5wYWdlQnV0dG9ufS4gVGhlIHJlbmRlcmVyIGFkZHJlc3NlcyBob3cgdGhlXG5cdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdCAqIHdoYXQgYnV0dG9ucyB0byBkaXNwbGF5LiBUaGlzIGlzIGRvbmUgYnkgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGJ1dHRvblxuXHQgKiBkZXNjcmlwdGlvbnMgKHdoYXQgZWFjaCBidXR0b24gd2lsbCBkbykuXG5cdCAqXG5cdCAqIFBhZ2luYXRpb24gdHlwZXMgKHRoZSBmb3VyIGJ1aWx0IGluIG9wdGlvbnMgYW5kIGFueSBhZGRpdGlvbmFsIHBsdWctaW5cblx0ICogb3B0aW9ucyBkZWZpbmVkIGhlcmUpIGNhbiBiZSB1c2VkIHRocm91Z2ggdGhlIGBwYWdpbmF0aW9uVHlwZWBcblx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0ICpcblx0ICogMS4gYHtpbnR9IHBhZ2VgIFRoZSBjdXJyZW50IHBhZ2UgaW5kZXhcblx0ICogMi4gYHtpbnR9IHBhZ2VzYCBUaGUgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSB0YWJsZVxuXHQgKlxuXHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgb2YgdGhlXG5cdCAqIGFycmF5IGNhbiBiZSBvbmUgb2Y6XG5cdCAqXG5cdCAqICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBsYXN0YCAtIEp1bXAgdG8gbGFzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBuZXh0YCAtIFNob3cgbmV4dCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdCAqICogYHtpbnR9YCAtIFNob3cgcGFnZSBvZiB0aGUgaW5kZXggZ2l2ZW5cblx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHQgKiAgIGNvbnRhaW5pbmcgJ0RJVicgZWxlbWVudCAobWlnaHQgYmUgdXNlZnVsIGZvciBzdHlsaW5nKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdCAqIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMgd291bGQgYmUgZGVmaW5lZCBmb3IgZWFjaCBwbHVnLWluLiBUaGF0XG5cdCAqIGFiaWxpdHkgaXMgc3RpbGwgc3VwcG9ydGVkIGJ5IERhdGFUYWJsZXMgMS4xMCsgdG8gcHJvdmlkZSBiYWNrd2FyZHNcblx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHQgKiBkb2N1bWVudGVkIGluIERhdGFUYWJsZXMgMS4xMCsuXG5cdCAqXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IHt9XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBTaG93IHByZXZpb3VzLCBuZXh0IGFuZCBjdXJyZW50IHBhZ2UgYnV0dG9ucyBvbmx5XG5cdCAqICAgICQuZm4uZGF0YVRhYmxlRXh0Lm9QYWdpbmF0aW9uLmN1cnJlbnQgPSBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHQgKiAgICB9O1xuXHQgKi9cblx0cGFnZXI6IHt9LFxuXG5cblx0cmVuZGVyZXI6IHtcblx0XHRwYWdlQnV0dG9uOiB7fSxcblx0XHRoZWFkZXI6IHt9XG5cdH0sXG5cblxuXHQvKipcblx0ICogT3JkZXJpbmcgcGx1Zy1pbnMgLSBjdXN0b20gZGF0YSBzb3VyY2Vcblx0ICogXG5cdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdCAqIHRvIHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb3JkZXJpbmcgdGhhdCBEYXRhVGFibGVzIHR5cGljYWxseSB1c2VzLiBJdFxuXHQgKiBhbGxvd3MgbXVjaCBncmVhdGVyIGNvbnRyb2wgb3ZlciB0aGUgdGhlIGRhdGEgdGhhdCBpcyBiZWluZyB1c2VkIHRvXG5cdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0ICogXG5cdCAqIFRoaXMgdHlwZSBvZiBvcmRlcmluZyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZG8gb3JkZXJpbmcgYmFzZWQgb24gZGF0YVxuXHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdCAqIHRoYW4ganVzdCB0aGUgc3RhdGljIHN0cmluZyB0aGF0IERhdGFUYWJsZXMga25vd3Mgb2YuXG5cdCAqIFxuXHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdCAqIHdpc2ggdG8gYmUgb3JkZXJpbmcgZm9yIHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gYW5kIHRoZW4gcmV0dXJuIHRoYXRcblx0ICogYXJyYXkuIFRoZSBkYXRhIGluIHRoZSBhcnJheSBtdWNoIGJlIGluIHRoZSBpbmRleCBvcmRlciBvZiB0aGUgcm93cyBpblxuXHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdCAqIGZ1bmN0aW9uIGlzIHJ1biBoZXJlIGRlcGVuZHMgb24gdGhlIGBkdC1pbml0IGNvbHVtbnMub3JkZXJEYXRhVHlwZWBcblx0ICogcGFyYW1ldGVyIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGNvbHVtbiAoaWYgYW55KS5cblx0ICpcblx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdCAqXG5cdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqIDIuIGB7aW50fWAgVGFyZ2V0IGNvbHVtbiBpbmRleFxuXHQgKlxuXHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheTpcblx0ICpcblx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdCAqXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gT3JkZXJpbmcgdXNpbmcgYGlucHV0YCBub2RlIHZhbHVlc1xuXHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0ICogICAge1xuXHQgKiAgICAgIHJldHVybiB0aGlzLmFwaSgpLmNvbHVtbiggY29sLCB7b3JkZXI6J2luZGV4J30gKS5ub2RlcygpLm1hcCggZnVuY3Rpb24gKCB0ZCwgaSApIHtcblx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH1cblx0ICovXG5cdG9yZGVyOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBUeXBlIGJhc2VkIHBsdWctaW5zLlxuXHQgKlxuXHQgKiBFYWNoIGNvbHVtbiBpbiBEYXRhVGFibGVzIGhhcyBhIHR5cGUgYXNzaWduZWQgdG8gaXQsIGVpdGhlciBieSBhdXRvbWF0aWNcblx0ICogZGV0ZWN0aW9uIG9yIGJ5IGRpcmVjdCBhc3NpZ25tZW50IHVzaW5nIHRoZSBgdHlwZWAgb3B0aW9uIGZvciB0aGUgY29sdW1uLlxuXHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0ICogY2FuIGFsc28gbWFrZSB1c2Ugb2YgdGhlIGNvbHVtbiB0eXBlIGlmIHJlcXVpcmVkKS5cblx0ICpcblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0dHlwZToge1xuXHRcdC8qKlxuXHRcdCAqIFR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuXHRcdCAqIGEgY29sdW1uJ3MgdHlwZSwgbWFraW5nIGluaXRpYWxpc2F0aW9uIG9mIERhdGFUYWJsZXMgc3VwZXIgZWFzeSwgZXZlblxuXHRcdCAqIHdoZW4gY29tcGxleCBkYXRhIGlzIGluIHRoZSB0YWJsZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBhbmFseXNlZFxuXHQgICAgICogIDIuIGB7c2V0dGluZ3N9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuXHQgICAgICogICAgIHBlcmZvcm0gY29udGV4dCBzcGVjaWZpYyB0eXBlIGRldGVjdGlvbiAtIGZvciBleGFtcGxlIGRldGVjdGlvblxuXHQgICAgICogICAgIGJhc2VkIG9uIGxhbmd1YWdlIHNldHRpbmdzIHN1Y2ggYXMgdXNpbmcgYSBjb21tYSBmb3IgYSBkZWNpbWFsXG5cdCAgICAgKiAgICAgcGxhY2UuIEdlbmVyYWxseSBzcGVha2luZyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBzZXR0aW5ncyB3aWxsIG5vdFxuXHQgICAgICogICAgIGJlIHJlcXVpcmVkXG5cdFx0ICpcblx0XHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybjpcblx0XHQgKlxuXHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuXHRcdCAqICAgcGFzcyBpdCBvbiB0byB0aGUgb3RoZXIgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGFycmF5XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuXHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdC5wdXNoKFxuXHRcdCAqICAgICAgZnVuY3Rpb24gKCBkYXRhLCBzZXR0aW5ncyApIHtcblx0XHQgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuXHRcdCAqICAgICAgICBpZiAoICEgZGF0YS5zdWJzdHJpbmcoMSkubWF0Y2goL1swLTldLykgKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKlxuXHRcdCAqICAgICAgICAvLyBDaGVjayBwcmVmaXhlZCBieSBjdXJyZW5jeVxuXHRcdCAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG5cdFx0ICogICAgICAgICAgcmV0dXJuICdjdXJyZW5jeSc7XG5cdFx0ICogICAgICAgIH1cblx0XHQgKiAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICogICAgICB9XG5cdFx0ICogICAgKTtcblx0XHQgKi9cblx0XHRkZXRlY3Q6IFtdLFxuXG5cblx0XHQvKipcblx0XHQgKiBUeXBlIGJhc2VkIHNlYXJjaCBmb3JtYXR0aW5nLlxuXHRcdCAqXG5cdFx0ICogVGhlIHR5cGUgYmFzZWQgc2VhcmNoaW5nIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0byBwcmUtZm9ybWF0IHRoZVxuXHRcdCAqIGRhdGEgdG8gYmUgc2VhcmNoIG9uLiBGb3IgZXhhbXBsZSwgaXQgY2FuIGJlIHVzZWQgdG8gc3RyaXAgSFRNTFxuXHRcdCAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGlzIGEgc2VhcmNoIGlzIG5vdCBkZWZpbmVkIGZvciBhIGNvbHVtbiBvZiBhIGdpdmVuIHR5cGUsXG5cdFx0ICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG5cdFx0ICogXG5cdFx0ICogUHJlLXByb2Nlc3Npbmcgb2Ygc2VhcmNoaW5nIGRhdGEgcGx1Zy1pbnMgLSBXaGVuIHlvdSBhc3NpZ24gdGhlIHNUeXBlXG5cdFx0ICogZm9yIGEgY29sdW1uIChvciBoYXZlIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQgZm9yIHlvdSBieSBEYXRhVGFibGVzXG5cdFx0ICogb3IgYSB0eXBlIGRldGVjdGlvbiBwbHVnLWluKSwgeW91IHdpbGwgdHlwaWNhbGx5IGJlIHVzaW5nIHRoaXMgZm9yXG5cdFx0ICogY3VzdG9tIHNvcnRpbmcsIGJ1dCBpdCBjYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGUgY3VzdG9tIHNlYXJjaGluZ1xuXHRcdCAqIGJ5IGFsbG93aW5nIHlvdSB0byBwcmUtcHJvY2Vzc2luZyB0aGUgZGF0YSBhbmQgcmV0dXJuaW5nIHRoZSBkYXRhIGluXG5cdFx0ICogdGhlIGZvcm1hdCB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCB1cG9uLiBUaGlzIGlzIGRvbmUgYnkgYWRkaW5nXG5cdFx0ICogZnVuY3Rpb25zIHRoaXMgb2JqZWN0IHdpdGggYSBwYXJhbWV0ZXIgbmFtZSB3aGljaCBtYXRjaGVzIHRoZSBzVHlwZVxuXHRcdCAqIGZvciB0aGF0IHRhcmdldCBjb2x1bW4uIFRoaXMgaXMgdGhlIGNvcm9sbGFyeSBvZiA8aT5hZm5Tb3J0RGF0YTwvaT5cblx0XHQgKiBmb3Igc2VhcmNoaW5nIGRhdGEuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0ICpcblx0ICAgICAqICAxLiBgeyp9YCBEYXRhIGZyb20gdGhlIGNvbHVtbiBjZWxsIHRvIGJlIHByZXBhcmVkIGZvciBzZWFyY2hpbmdcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdCAqXG5cdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuXHRcdCAqICAgICAgcmV0dXJuIGQucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICk7XG5cdFx0ICogICAgfVxuXHRcdCAqL1xuXHRcdHNlYXJjaDoge30sXG5cblxuXHRcdC8qKlxuXHRcdCAqIFR5cGUgYmFzZWQgb3JkZXJpbmcuXG5cdFx0ICpcblx0XHQgKiBUaGUgY29sdW1uIHR5cGUgdGVsbHMgRGF0YVRhYmxlcyB3aGF0IG9yZGVyaW5nIHRvIGFwcGx5IHRvIHRoZSB0YWJsZVxuXHRcdCAqIHdoZW4gYSBjb2x1bW4gaXMgc29ydGVkIHVwb24uIFRoZSBvcmRlciBmb3IgZWFjaCB0eXBlIHRoYXQgaXMgZGVmaW5lZCxcblx0XHQgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogRWFjaCBvcmRlcmluZyBvcHRpb24gY2FuIGJlIGRlc2NyaWJlZCBieSB0aHJlZSBwcm9wZXJ0aWVzIGFkZGVkIHRvXG5cdFx0ICogdGhpcyBvYmplY3Q6XG5cdFx0ICpcblx0XHQgKiAqIGB7dHlwZX0tcHJlYCAtIFByZS1mb3JtYXR0aW5nIGZ1bmN0aW9uXG5cdFx0ICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHQgKiAqIGB7dHlwZX0tZGVzY2AgLSBEZXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcblx0XHQgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2AgdG9nZXRoZXIuIEl0IGlzIGdlbmVyYWxseSByZWNvbW1lbmRlZFxuXHRcdCAqIHRoYXQgb25seSBge3R5cGV9LXByZWAgaXMgdXNlZCwgYXMgdGhpcyBwcm92aWRlcyB0aGUgb3B0aW1hbFxuXHRcdCAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuXHRcdCAqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgSmF2YXNjcmlwdCBzb3J0IGZ1bmN0aW9ucy5cblx0XHQgKlxuXHRcdCAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG5cdFx0ICpcblx0ICAgICAqICAxLiBgeyp9YCBEYXRhIGZyb20gdGhlIGNvbHVtbiBjZWxsIHRvIGJlIHByZXBhcmVkIGZvciBvcmRlcmluZ1xuXHRcdCAqXG5cdFx0ICogQW5kIHJldHVybjpcblx0XHQgKlxuXHRcdCAqICogYHsqfWAgRGF0YSB0byBiZSBzb3J0ZWQgdXBvblxuXHRcdCAqXG5cdFx0ICogYHt0eXBlfS1hc2NgIGFuZCBge3R5cGV9LWRlc2NgOiBGdW5jdGlvbnMgYXJlIHR5cGljYWwgSmF2YXNjcmlwdCBzb3J0XG5cdFx0ICogZnVuY3Rpb25zLCB0YWtpbmcgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0ICAgICAqICAxLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIHNlY29uZCBwYXJhbWV0ZXJcblx0ICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRcdCAqXG5cdFx0ICogQW5kIHJldHVybmluZzpcblx0XHQgKlxuXHRcdCAqICogYHsqfWAgT3JkZXJpbmcgbWF0Y2g6IDwwIGlmIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGxvd2VyXG5cdFx0ICogICB0aGFuIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCA9PT0wIGlmIHRoZSB0d28gcGFyYW1ldGVycyBhcmUgZXF1YWwgYW5kXG5cdFx0ICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuXHRcdCAqICAgcGFyYW1ldGVyLlxuXHRcdCAqIFxuXHRcdCAqICBAdHlwZSBvYmplY3Rcblx0XHQgKiAgQGRlZmF1bHQge31cblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIE51bWVyaWMgb3JkZXJpbmcgb2YgZm9ybWF0dGVkIG51bWJlcnMgd2l0aCBhIHByZS1mb3JtYXR0ZXJcblx0XHQgKiAgICAkLmV4dGVuZCggJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsIHtcblx0XHQgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XG5cdFx0ICogICAgICAgIGEgPSAoYSA9PT0gXCItXCIgfHwgYSA9PT0gXCJcIikgPyAwIDogYS5yZXBsYWNlKCAvW15cXGRcXC1cXC5dL2csIFwiXCIgKTtcblx0XHQgKiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoIGEgKTtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICB9ICk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBDYXNlLXNlbnNpdGl2ZSBzdHJpbmcgb3JkZXJpbmcsIHdpdGggbm8gcHJlLWZvcm1hdHRpbmcgbWV0aG9kXG5cdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC5vcmRlciwge1xuXHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0ICogICAgICAgIHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xuXHRcdCAqICAgICAgfSxcblx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gMSA6ICgoeCA+IHkpID8gLTEgOiAwKSk7XG5cdFx0ICogICAgICB9XG5cdFx0ICogICAgfSApO1xuXHRcdCAqL1xuXHRcdG9yZGVyOiB7fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXG5cdCAqXG5cdCAqIEB0eXBlIGludFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3VuaXF1ZTogMCxcblxuXG5cdC8vXG5cdC8vIERlcHJlY2lhdGVkXG5cdC8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IG9ubHkuXG5cdC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcblx0Ly8gdmVyc2lvblxuXHQvL1xuXG5cdC8qKlxuXHQgKiBWZXJzaW9uIGNoZWNrIGZ1bmN0aW9uLlxuXHQgKiAgQHR5cGUgZnVuY3Rpb25cblx0ICogIEBkZXByZWNpYXRlZCBTaW5jZSAxLjEwXG5cdCAqL1xuXHRmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxuXG5cblx0LyoqXG5cdCAqIEluZGV4IGZvciB3aGF0ICd0aGlzJyBpbmRleCBBUEkgZnVuY3Rpb25zIHNob3VsZCB1c2Vcblx0ICogIEB0eXBlIGludFxuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICovXG5cdGlBcGlJbmRleDogMCxcblxuXG5cdC8qKlxuXHQgKiBqUXVlcnkgVUkgY2xhc3MgY29udGFpbmVyXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqL1xuXHRvSlVJQ2xhc3Nlczoge30sXG5cblxuXHQvKipcblx0ICogU29mdHdhcmUgdmVyc2lvblxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKi9cblx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG59O1xuXG5cbi8vXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gQWxpYXMgdG8gcHJlIDEuMTAgSHVuZ2FyaWFuIG5vdGF0aW9uIGNvdW50ZXIgcGFydHNcbi8vXG4kLmV4dGVuZCggX2V4dCwge1xuXHRhZm5GaWx0ZXJpbmc6IF9leHQuc2VhcmNoLFxuXHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdG9mblNlYXJjaDogICAgX2V4dC50eXBlLnNlYXJjaCxcblx0b1NvcnQ6ICAgICAgICBfZXh0LnR5cGUub3JkZXIsXG5cdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0YW9GZWF0dXJlczogICBfZXh0LmZlYXR1cmUsXG5cdG9BcGk6ICAgICAgICAgX2V4dC5pbnRlcm5hbCxcblx0b1N0ZENsYXNzZXM6ICBfZXh0LmNsYXNzZXMsXG5cdG9QYWdpbmF0aW9uOiAgX2V4dC5wYWdlclxufSApO1xuXG5cbiQuZXh0ZW5kKCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcblx0XCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcblx0XCJzTm9Gb290ZXJcIjogXCJuby1mb290ZXJcIixcblxuXHQvKiBQYWdpbmcgYnV0dG9ucyAqL1xuXHRcInNQYWdlQnV0dG9uXCI6IFwicGFnaW5hdGVfYnV0dG9uXCIsXG5cdFwic1BhZ2VCdXR0b25BY3RpdmVcIjogXCJjdXJyZW50XCIsXG5cdFwic1BhZ2VCdXR0b25EaXNhYmxlZFwiOiBcImRpc2FibGVkXCIsXG5cblx0LyogU3RyaXBpbmcgY2xhc3NlcyAqL1xuXHRcInNTdHJpcGVPZGRcIjogXCJvZGRcIixcblx0XCJzU3RyaXBlRXZlblwiOiBcImV2ZW5cIixcblxuXHQvKiBFbXB0eSByb3cgKi9cblx0XCJzUm93RW1wdHlcIjogXCJkYXRhVGFibGVzX2VtcHR5XCIsXG5cblx0LyogRmVhdHVyZXMgKi9cblx0XCJzV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfd3JhcHBlclwiLFxuXHRcInNGaWx0ZXJcIjogXCJkYXRhVGFibGVzX2ZpbHRlclwiLFxuXHRcInNJbmZvXCI6IFwiZGF0YVRhYmxlc19pbmZvXCIsXG5cdFwic1BhZ2luZ1wiOiBcImRhdGFUYWJsZXNfcGFnaW5hdGUgcGFnaW5nX1wiLCAvKiBOb3RlIHRoYXQgdGhlIHR5cGUgaXMgcG9zdGZpeGVkICovXG5cdFwic0xlbmd0aFwiOiBcImRhdGFUYWJsZXNfbGVuZ3RoXCIsXG5cdFwic1Byb2Nlc3NpbmdcIjogXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmdcIixcblxuXHQvKiBTb3J0aW5nICovXG5cdFwic1NvcnRBc2NcIjogXCJzb3J0aW5nX2FzY1wiLFxuXHRcInNTb3J0RGVzY1wiOiBcInNvcnRpbmdfZGVzY1wiLFxuXHRcInNTb3J0YWJsZVwiOiBcInNvcnRpbmdcIiwgLyogU29ydGFibGUgaW4gYm90aCBkaXJlY3Rpb25zICovXG5cdFwic1NvcnRhYmxlQXNjXCI6IFwic29ydGluZ19kZXNjX2Rpc2FibGVkXCIsXG5cdFwic1NvcnRhYmxlRGVzY1wiOiBcInNvcnRpbmdfYXNjX2Rpc2FibGVkXCIsXG5cdFwic1NvcnRhYmxlTm9uZVwiOiBcInNvcnRpbmdfZGlzYWJsZWRcIixcblx0XCJzU29ydENvbHVtblwiOiBcInNvcnRpbmdfXCIsIC8qIE5vdGUgdGhhdCBhbiBpbnQgaXMgcG9zdGZpeGVkIGZvciB0aGUgc29ydGluZyBvcmRlciAqL1xuXG5cdC8qIEZpbHRlcmluZyAqL1xuXHRcInNGaWx0ZXJJbnB1dFwiOiBcIlwiLFxuXG5cdC8qIFBhZ2UgbGVuZ3RoICovXG5cdFwic0xlbmd0aFNlbGVjdFwiOiBcIlwiLFxuXG5cdC8qIFNjcm9sbGluZyAqL1xuXHRcInNTY3JvbGxXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxcIixcblx0XCJzU2Nyb2xsSGVhZFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZFwiLFxuXHRcInNTY3JvbGxIZWFkSW5uZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWRJbm5lclwiLFxuXHRcInNTY3JvbGxCb2R5XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxCb2R5XCIsXG5cdFwic1Njcm9sbEZvb3RcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RcIixcblx0XCJzU2Nyb2xsRm9vdElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290SW5uZXJcIixcblxuXHQvKiBNaXNjICovXG5cdFwic0hlYWRlclRIXCI6IFwiXCIsXG5cdFwic0Zvb3RlclRIXCI6IFwiXCIsXG5cblx0Ly8gRGVwcmVjYXRlZFxuXHRcInNTb3J0SlVJQXNjXCI6IFwiXCIsXG5cdFwic1NvcnRKVUlEZXNjXCI6IFwiXCIsXG5cdFwic1NvcnRKVUlcIjogXCJcIixcblx0XCJzU29ydEpVSUFzY0FsbG93ZWRcIjogXCJcIixcblx0XCJzU29ydEpVSURlc2NBbGxvd2VkXCI6IFwiXCIsXG5cdFwic1NvcnRKVUlXcmFwcGVyXCI6IFwiXCIsXG5cdFwic1NvcnRJY29uXCI6IFwiXCIsXG5cdFwic0pVSUhlYWRlclwiOiBcIlwiLFxuXHRcInNKVUlGb290ZXJcIjogXCJcIlxufSApO1xuXG5cbnZhciBleHRQYWdpbmF0aW9uID0gRGF0YVRhYmxlLmV4dC5wYWdlcjtcblxuZnVuY3Rpb24gX251bWJlcnMgKCBwYWdlLCBwYWdlcyApIHtcblx0dmFyXG5cdFx0bnVtYmVycyA9IFtdLFxuXHRcdGJ1dHRvbnMgPSBleHRQYWdpbmF0aW9uLm51bWJlcnNfbGVuZ3RoLFxuXHRcdGhhbGYgPSBNYXRoLmZsb29yKCBidXR0b25zIC8gMiApLFxuXHRcdGkgPSAxO1xuXG5cdGlmICggcGFnZXMgPD0gYnV0dG9ucyApIHtcblx0XHRudW1iZXJzID0gX3JhbmdlKCAwLCBwYWdlcyApO1xuXHR9XG5cdGVsc2UgaWYgKCBwYWdlIDw9IGhhbGYgKSB7XG5cdFx0bnVtYmVycyA9IF9yYW5nZSggMCwgYnV0dG9ucy0yICk7XG5cdFx0bnVtYmVycy5wdXNoKCAnZWxsaXBzaXMnICk7XG5cdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdH1cblx0ZWxzZSBpZiAoIHBhZ2UgPj0gcGFnZXMgLSAxIC0gaGFsZiApIHtcblx0XHRudW1iZXJzID0gX3JhbmdlKCBwYWdlcy0oYnV0dG9ucy0yKSwgcGFnZXMgKTtcblx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgJ2VsbGlwc2lzJyApOyAvLyBubyB1bnNoaWZ0IGluIGllNlxuXHRcdG51bWJlcnMuc3BsaWNlKCAwLCAwLCAwICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0bnVtYmVycyA9IF9yYW5nZSggcGFnZS1oYWxmKzIsIHBhZ2UraGFsZi0xICk7XG5cdFx0bnVtYmVycy5wdXNoKCAnZWxsaXBzaXMnICk7XG5cdFx0bnVtYmVycy5wdXNoKCBwYWdlcy0xICk7XG5cdFx0bnVtYmVycy5zcGxpY2UoIDAsIDAsICdlbGxpcHNpcycgKTtcblx0XHRudW1iZXJzLnNwbGljZSggMCwgMCwgMCApO1xuXHR9XG5cblx0bnVtYmVycy5EVF9lbCA9ICdzcGFuJztcblx0cmV0dXJuIG51bWJlcnM7XG59XG5cblxuJC5leHRlbmQoIGV4dFBhZ2luYXRpb24sIHtcblx0c2ltcGxlOiBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHRcdHJldHVybiBbICdwcmV2aW91cycsICduZXh0JyBdO1xuXHR9LFxuXG5cdGZ1bGw6IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG5cdFx0cmV0dXJuIFsgICdmaXJzdCcsICdwcmV2aW91cycsICduZXh0JywgJ2xhc3QnIF07XG5cdH0sXG5cblx0bnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRyZXR1cm4gWyBfbnVtYmVycyhwYWdlLCBwYWdlcykgXTtcblx0fSxcblxuXHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRyZXR1cm4gWyAncHJldmlvdXMnLCBfbnVtYmVycyhwYWdlLCBwYWdlcyksICduZXh0JyBdO1xuXHR9LFxuXG5cdGZ1bGxfbnVtYmVyczogZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0XHRyZXR1cm4gWyAnZmlyc3QnLCAncHJldmlvdXMnLCBfbnVtYmVycyhwYWdlLCBwYWdlcyksICduZXh0JywgJ2xhc3QnIF07XG5cdH0sXG5cdFxuXHRmaXJzdF9sYXN0X251bWJlcnM6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xuIFx0XHRyZXR1cm4gWydmaXJzdCcsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ2xhc3QnXTtcbiBcdH0sXG5cblx0Ly8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxuXHRfbnVtYmVyczogX251bWJlcnMsXG5cblx0Ly8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIChpbmNsdWRpbmcgZWxsaXBzaXMpIHRvIHNob3cuIF9NdXN0IGJlIG9kZCFfXG5cdG51bWJlcnNfbGVuZ3RoOiA3XG59ICk7XG5cblxuJC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcblx0cGFnZUJ1dHRvbjoge1xuXHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMgKSB7XG5cdFx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdFx0dmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHRcdFx0dmFyIGFyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWEucGFnaW5hdGUgfHwge307XG5cdFx0XHR2YXIgYnRuRGlzcGxheSwgYnRuQ2xhc3M7XG5cblx0XHRcdHZhciBhdHRhY2ggPSBmdW5jdGlvbiggY29udGFpbmVyLCBidXR0b25zICkge1xuXHRcdFx0XHR2YXIgaSwgaWVuLCBub2RlLCBidXR0b24sIHRhYkluZGV4O1xuXHRcdFx0XHR2YXIgZGlzYWJsZWRDbGFzcyA9IGNsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZDtcblx0XHRcdFx0dmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICggZSApIHtcblx0XHRcdFx0XHRfZm5QYWdlQ2hhbmdlKCBzZXR0aW5ncywgZS5kYXRhLmFjdGlvbiwgdHJ1ZSApO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0YnV0dG9uID0gYnV0dG9uc1tpXTtcblxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggYnV0dG9uICkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5uZXIgPSAkKCAnPCcrKGJ1dHRvbi5EVF9lbCB8fCAnZGl2JykrJy8+JyApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyggY29udGFpbmVyICk7XG5cdFx0XHRcdFx0XHRhdHRhY2goIGlubmVyLCBidXR0b24gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbnVsbDtcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uO1xuXHRcdFx0XHRcdFx0dGFiSW5kZXggPSBzZXR0aW5ncy5pVGFiSW5kZXg7XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoIGJ1dHRvbiApIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAnZWxsaXBzaXMnOlxuXHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj4mI3gyMDI2Ozwvc3Bhbj4nKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc0ZpcnN0O1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBwYWdlID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFiSW5kZXggPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRcdGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zUHJldmlvdXM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2UgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgKz0gJyAnICsgZGlzYWJsZWRDbGFzcztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnbmV4dCc6XG5cdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc05leHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgKz0gJyAnICsgZGlzYWJsZWRDbGFzcztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc0xhc3Q7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnRuQ2xhc3MgKz0gJyAnICsgZGlzYWJsZWRDbGFzcztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGJ1dHRvbiArIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRidG5DbGFzcyA9IHBhZ2UgPT09IGJ1dHRvbiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNQYWdlQnV0dG9uQWN0aXZlIDogJyc7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggYnRuRGlzcGxheSAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRhZyA9IHNldHRpbmdzLm9Jbml0LnBhZ2luZ1RhZyB8fCAnYSc7XG5cdFx0XHRcdFx0XHRcdHZhciBkaXNhYmxlZCA9IGJ0bkNsYXNzLmluZGV4T2YoZGlzYWJsZWRDbGFzcykgIT09IC0xO1xuXHRcdFxuXG5cdFx0XHRcdFx0XHRcdG5vZGUgPSAkKCc8Jyt0YWcrJz4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNQYWdlQnV0dG9uKycgJytidG5DbGFzcyxcblx0XHRcdFx0XHRcdFx0XHRcdCdhcmlhLWNvbnRyb2xzJzogc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkID8gJ3RydWUnIDogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRcdCdhcmlhLWxhYmVsJzogYXJpYVsgYnV0dG9uIF0sXG5cdFx0XHRcdFx0XHRcdFx0XHQnYXJpYS1yb2xlJzogJ2xpbmsnLFxuXHRcdFx0XHRcdFx0XHRcdFx0J2FyaWEtY3VycmVudCc6IGJ0bkNsYXNzID09PSBjbGFzc2VzLnNQYWdlQnV0dG9uQWN0aXZlID8gJ3BhZ2UnIDogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRcdCdkYXRhLWR0LWlkeCc6IGJ1dHRvbixcblx0XHRcdFx0XHRcdFx0XHRcdCd0YWJpbmRleCc6IHRhYkluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdFx0J2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3Muc1RhYmxlSWQgKydfJysgYnV0dG9uIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRcdC5odG1sKCBidG5EaXNwbGF5IClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdFx0XHRcdF9mbkJpbmRBY3Rpb24oXG5cdFx0XHRcdFx0XHRcdFx0bm9kZSwge2FjdGlvbjogYnV0dG9ufSwgY2xpY2tIYW5kbGVyXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcblx0XHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuIFRyeSAvIGNhdGNoIHRoZSBlcnJvci4gTm90IGdvb2QgZm9yXG5cdFx0XHQvLyBhY2Nlc3NpYmlsaXR5LCBidXQgbmVpdGhlciBhcmUgZnJhbWVzLlxuXHRcdFx0dmFyIGFjdGl2ZUVsO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBCZWNhdXNlIHRoaXMgYXBwcm9hY2ggaXMgZGVzdHJveWluZyBhbmQgcmVjcmVhdGluZyB0aGUgcGFnaW5nXG5cdFx0XHRcdC8vIGVsZW1lbnRzLCBmb2N1cyBpcyBsb3N0IG9uIHRoZSBzZWxlY3QgYnV0dG9uIHdoaWNoIGlzIGJhZCBmb3Jcblx0XHRcdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0XHRcdC8vIGNvbXBsZXRlZFxuXHRcdFx0XHRhY3RpdmVFbCA9ICQoaG9zdCkuZmluZChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5kYXRhKCdkdC1pZHgnKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7fVxuXG5cdFx0XHRhdHRhY2goICQoaG9zdCkuZW1wdHkoKSwgYnV0dG9ucyApO1xuXG5cdFx0XHRpZiAoIGFjdGl2ZUVsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdCQoaG9zdCkuZmluZCggJ1tkYXRhLWR0LWlkeD0nK2FjdGl2ZUVsKyddJyApLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuXG4vLyBCdWlsdCBpbiB0eXBlIGRldGVjdGlvbi4gU2VlIG1vZGVsLmV4dC5hVHlwZXMgZm9yIGluZm9ybWF0aW9uIGFib3V0XG4vLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhpcyBtZXRob2RzLlxuJC5leHRlbmQoIERhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QsIFtcblx0Ly8gUGxhaW4gbnVtYmVycyAtIGZpcnN0IHNpbmNlIFY4IGRldGVjdHMgc29tZSBwbGFpbiBudW1iZXJzIGFzIGRhdGVzXG5cdC8vIGUuZy4gRGF0ZS5wYXJzZSgnNTUnKSAoYnV0IG5vdCBhbGwsIGUuZy4gRGF0ZS5wYXJzZSgnMjInKS4uLikuXG5cdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCApID8gJ251bScrZGVjaW1hbCA6IG51bGw7XG5cdH0sXG5cblx0Ly8gRGF0ZXMgKG9ubHkgdGhvc2UgcmVjb2duaXNlZCBieSB0aGUgYnJvd3NlcidzIERhdGUucGFyc2UpXG5cdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHR7XG5cdFx0Ly8gVjggdHJpZXMgX3ZlcnlfIGhhcmQgdG8gbWFrZSBhIHN0cmluZyBwYXNzZWQgaW50byBgRGF0ZS5wYXJzZSgpYFxuXHRcdC8vIHZhbGlkLCBzbyB3ZSBuZWVkIHRvIHVzZSBhIHJlZ2V4IHRvIHJlc3RyaWN0IGRhdGUgZm9ybWF0cy4gVXNlIGFcblx0XHQvLyBwbHVnLWluIGZvciBhbnl0aGluZyBvdGhlciB0aGFuIElTTzg2MDEgc3R5bGUgc3RyaW5nc1xuXHRcdGlmICggZCAmJiAhKGQgaW5zdGFuY2VvZiBEYXRlKSAmJiAhIF9yZV9kYXRlLnRlc3QoZCkgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0dmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZCk7XG5cdFx0cmV0dXJuIChwYXJzZWQgIT09IG51bGwgJiYgIWlzTmFOKHBhcnNlZCkpIHx8IF9lbXB0eShkKSA/ICdkYXRlJyA6IG51bGw7XG5cdH0sXG5cblx0Ly8gRm9ybWF0dGVkIG51bWJlcnNcblx0ZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApXG5cdHtcblx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlICkgPyAnbnVtLWZtdCcrZGVjaW1hbCA6IG51bGw7XG5cdH0sXG5cblx0Ly8gSFRNTCBudW1lcmljXG5cdGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKVxuXHR7XG5cdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCApID8gJ2h0bWwtbnVtJytkZWNpbWFsIDogbnVsbDtcblx0fSxcblxuXHQvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxuXHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0e1xuXHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIHRydWUgKSA/ICdodG1sLW51bS1mbXQnK2RlY2ltYWwgOiBudWxsO1xuXHR9LFxuXG5cdC8vIEhUTUwgKHRoaXMgaXMgc3RyaWN0IGNoZWNraW5nIC0gdGhlcmUgbXVzdCBiZSBodG1sKVxuXHRmdW5jdGlvbiAoIGQsIHNldHRpbmdzIClcblx0e1xuXHRcdHJldHVybiBfZW1wdHkoIGQgKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQuaW5kZXhPZignPCcpICE9PSAtMSkgP1xuXHRcdFx0J2h0bWwnIDogbnVsbDtcblx0fVxuXSApO1xuXG5cblxuLy8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcbi8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGVzZSBtZXRob2RzLlxuLy8gXG4vLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXG4vLyBodG1sIGZvcm1hdHRlZCBudW1iZXJzIGJ5IGBfYWRkTnVtZXJpY1NvcnQoKWAgd2hlbiB3ZSBrbm93IHdoYXQgdGhlIGRlY2ltYWxcbi8vIHBsYWNlIGlzXG5cblxuJC5leHRlbmQoIERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2gsIHtcblx0aHRtbDogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHJldHVybiBfZW1wdHkoZGF0YSkgP1xuXHRcdFx0ZGF0YSA6XG5cdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRkYXRhXG5cdFx0XHRcdFx0LnJlcGxhY2UoIF9yZV9uZXdfbGluZXMsIFwiIFwiIClcblx0XHRcdFx0XHQucmVwbGFjZSggX3JlX2h0bWwsIFwiXCIgKSA6XG5cdFx0XHRcdCcnO1xuXHR9LFxuXG5cdHN0cmluZzogZnVuY3Rpb24gKCBkYXRhICkge1xuXHRcdHJldHVybiBfZW1wdHkoZGF0YSkgP1xuXHRcdFx0ZGF0YSA6XG5cdFx0XHR0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRkYXRhLnJlcGxhY2UoIF9yZV9uZXdfbGluZXMsIFwiIFwiICkgOlxuXHRcdFx0XHRkYXRhO1xuXHR9XG59ICk7XG5cblxuXG52YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0aWYgKCBkICE9PSAwICYmICghZCB8fCBkID09PSAnLScpICkge1xuXHRcdHJldHVybiAtSW5maW5pdHk7XG5cdH1cblx0XG5cdGxldCB0eXBlID0gdHlwZW9mIGQ7XG5cblx0aWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0cmV0dXJuIGQ7XG5cdH1cblxuXHQvLyBJZiBhIGRlY2ltYWwgcGxhY2Ugb3RoZXIgdGhhbiBgLmAgaXMgdXNlZCwgaXQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlXG5cdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHQvLyBkZWNpbWFsIHBsYWNlIEphdmFzY3JpcHQgcmVjb2duaXNlcyAtIGl0IGlzIG5vdCBsb2NhbGUgYXdhcmUuXG5cdGlmICggZGVjaW1hbFBsYWNlICkge1xuXHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0fVxuXG5cdGlmICggZC5yZXBsYWNlICkge1xuXHRcdGlmICggcmUxICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggcmUxLCAnJyApO1xuXHRcdH1cblxuXHRcdGlmICggcmUyICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkICogMTtcbn07XG5cblxuLy8gQWRkIHRoZSBudW1lcmljICdkZWZvcm1hdHRpbmcnIGZ1bmN0aW9ucyBmb3Igc29ydGluZyBhbmQgc2VhcmNoLiBUaGlzIGlzIGRvbmVcbi8vIGluIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBhbiBlYXN5IGFiaWxpdHkgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb25zIHRvIGFkZFxuLy8gYWRkaXRpb25hbCBtZXRob2RzIGlmIGEgbm9uLXBlcmlvZCBkZWNpbWFsIHBsYWNlIGlzIHVzZWQuXG5mdW5jdGlvbiBfYWRkTnVtZXJpY1NvcnQgKCBkZWNpbWFsUGxhY2UgKSB7XG5cdCQuZWFjaChcblx0XHR7XG5cdFx0XHQvLyBQbGFpbiBudW1iZXJzXG5cdFx0XHRcIm51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvcm1hdHRlZCBudW1iZXJzXG5cdFx0XHRcIm51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEhUTUwgbnVtZXJpY1xuXHRcdFx0XCJodG1sLW51bVwiOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sICk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxuXHRcdFx0XCJodG1sLW51bS1mbXRcIjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCwgX3JlX2Zvcm1hdHRlZF9udW1lcmljICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRmdW5jdGlvbiAoIGtleSwgZm4gKSB7XG5cdFx0XHQvLyBBZGQgdGhlIG9yZGVyaW5nIG1ldGhvZFxuXHRcdFx0X2V4dC50eXBlLm9yZGVyWyBrZXkrZGVjaW1hbFBsYWNlKyctcHJlJyBdID0gZm47XG5cblx0XHRcdC8vIEZvciBIVE1MIHR5cGVzIGFkZCBhIHNlYXJjaCBmb3JtYXR0ZXIgdGhhdCB3aWxsIHN0cmlwIHRoZSBIVE1MXG5cdFx0XHRpZiAoIGtleS5tYXRjaCgvXmh0bWxcXC0vKSApIHtcblx0XHRcdFx0X2V4dC50eXBlLnNlYXJjaFsga2V5K2RlY2ltYWxQbGFjZSBdID0gX2V4dC50eXBlLnNlYXJjaC5odG1sO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn1cblxuXG4vLyBEZWZhdWx0IHNvcnQgbWV0aG9kc1xuJC5leHRlbmQoIF9leHQudHlwZS5vcmRlciwge1xuXHQvLyBEYXRlc1xuXHRcImRhdGUtcHJlXCI6IGZ1bmN0aW9uICggZCApIHtcblx0XHR2YXIgdHMgPSBEYXRlLnBhcnNlKCBkICk7XG5cdFx0cmV0dXJuIGlzTmFOKHRzKSA/IC1JbmZpbml0eSA6IHRzO1xuXHR9LFxuXG5cdC8vIGh0bWxcblx0XCJodG1sLXByZVwiOiBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHQnJyA6XG5cdFx0XHRhLnJlcGxhY2UgP1xuXHRcdFx0XHRhLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICkudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdGErJyc7XG5cdH0sXG5cblx0Ly8gc3RyaW5nXG5cdFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0Ly8gVGhpcyBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgZmFzdGVyIHRoYW4gYWx3YXlzIGNhbGxpbmcgdG9TdHJpbmcsXG5cdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdG9zdHJpbmctdi1jaGVja1xuXHRcdHJldHVybiBfZW1wdHkoYSkgP1xuXHRcdFx0JycgOlxuXHRcdFx0dHlwZW9mIGEgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0YS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHQnJyA6XG5cdFx0XHRcdFx0YS50b1N0cmluZygpO1xuXHR9LFxuXG5cdC8vIHN0cmluZy1hc2MgYW5kIC1kZXNjIGFyZSByZXRhaW5lZCBvbmx5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZFxuXHQvLyBzb3J0IG1ldGhvZHNcblx0XCJzdHJpbmctYXNjXCI6IGZ1bmN0aW9uICggeCwgeSApIHtcblx0XHRyZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcblx0fSxcblxuXHRcInN0cmluZy1kZXNjXCI6IGZ1bmN0aW9uICggeCwgeSApIHtcblx0XHRyZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0fVxufSApO1xuXG5cbi8vIE51bWVyaWMgc29ydGluZyB0eXBlcyAtIG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGhlcmVcbl9hZGROdW1lcmljU29ydCggJycgKTtcblxuXG4kLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRoZWFkZXI6IHtcblx0XHRfOiBmdW5jdGlvbiAoIHNldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXMgKSB7XG5cdFx0XHQvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcblx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnQgLSBub3RlIHRoYXQgdXNpbmcgdGhlXG5cdFx0XHQvLyBgRFRgIG5hbWVzcGFjZSB3aWxsIGFsbG93IHRoZSBldmVudCB0byBiZSByZW1vdmVkIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcblx0XHRcdC8vIGxpc3RlbmluZyBmb3Jcblx0XHRcdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ29yZGVyLmR0LkRUJywgZnVuY3Rpb24gKCBlLCBjdHgsIHNvcnRpbmcsIGNvbHVtbnMgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRyZXR1cm47ICAgICAgICAgICAgICAgLy8gdGFibGUsIG5vdCBhIG5lc3RlZCBvbmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xuXG5cdFx0XHRcdGNlbGxcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjICsnICcrXG5cdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzY1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNvbHVtbnNbIGNvbElkeCBdID09ICdhc2MnID9cblx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zWyBjb2xJZHggXSA9PSAnZGVzYycgP1xuXHRcdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0RGVzYyA6XG5cdFx0XHRcdFx0XHRcdGNvbHVtbi5zU29ydGluZ0NsYXNzXG5cdFx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0anF1ZXJ5dWk6IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3NlcyApIHtcblx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdC5hZGRDbGFzcyggY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIgKVxuXHRcdFx0XHQuYXBwZW5kKCBjZWxsLmNvbnRlbnRzKCkgKVxuXHRcdFx0XHQuYXBwZW5kKCAkKCc8c3Bhbi8+Jylcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIGNsYXNzZXMuc1NvcnRJY29uKycgJytjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSSApXG5cdFx0XHRcdClcblx0XHRcdFx0LmFwcGVuZFRvKCBjZWxsICk7XG5cblx0XHRcdC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnRcblx0XHRcdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ29yZGVyLmR0LkRUJywgZnVuY3Rpb24gKCBlLCBjdHgsIHNvcnRpbmcsIGNvbHVtbnMgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29sSWR4ID0gY29sdW1uLmlkeDtcblxuXHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjbGFzc2VzLnNTb3J0QXNjICtcIiBcIitjbGFzc2VzLnNTb3J0RGVzYyApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBjb2x1bW5zWyBjb2xJZHggXSA9PSAnYXNjJyA/XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1sgY29sSWR4IF0gPT0gJ2Rlc2MnID9cblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydERlc2MgOlxuXHRcdFx0XHRcdFx0XHRjb2x1bW4uc1NvcnRpbmdDbGFzc1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0Y2VsbFxuXHRcdFx0XHRcdC5maW5kKCAnc3Bhbi4nK2NsYXNzZXMuc1NvcnRJY29uIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRjbGFzc2VzLnNTb3J0SlVJQXNjICtcIiBcIitcblx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjICtcIiBcIitcblx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUkgK1wiIFwiK1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzY0FsbG93ZWQgK1wiIFwiK1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggY29sdW1uc1sgY29sSWR4IF0gPT0gJ2FzYycgP1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5zU29ydEpVSUFzYyA6IGNvbHVtbnNbIGNvbElkeCBdID09ICdkZXNjJyA/XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMuc1NvcnRKVUlEZXNjIDpcblx0XHRcdFx0XHRcdFx0Y29sdW1uLnNTb3J0aW5nQ2xhc3NKVUlcblx0XHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxufSApO1xuXG4vKlxuICogUHVibGljIGhlbHBlciBmdW5jdGlvbnMuIFRoZXNlIGFyZW4ndCB1c2VkIGludGVybmFsbHkgYnkgRGF0YVRhYmxlcywgb3JcbiAqIGNhbGxlZCBieSBhbnkgb2YgdGhlIG9wdGlvbnMgcGFzc2VkIGludG8gRGF0YVRhYmxlcywgYnV0IHRoZXkgY2FuIGJlIHVzZWRcbiAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xuICogdG8gbWFrZSB3b3JraW5nIHdpdGggRGF0YVRhYmxlcyBhIGxpdHRsZSBiaXQgZWFzaWVyLlxuICovXG5cbnZhciBfX2h0bWxFc2NhcGVFbnRpdGllcyA9IGZ1bmN0aW9uICggZCApIHtcblx0aWYgKEFycmF5LmlzQXJyYXkoZCkpIHtcblx0XHRkID0gZC5qb2luKCcsJyk7XG5cdH1cblxuXHRyZXR1cm4gdHlwZW9mIGQgPT09ICdzdHJpbmcnID9cblx0XHRkXG5cdFx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdFx0LnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuXHRcdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSA6XG5cdFx0ZDtcbn07XG5cbi8vIENvbW1vbiBsb2dpYyBmb3IgbW9tZW50LCBsdXhvbiBvciBhIGRhdGUgYWN0aW9uXG5mdW5jdGlvbiBfX21sZCggZHQsIG1vbWVudEZuLCBsdXhvbkZuLCBkYXRlRm4sIGFyZzEgKSB7XG5cdGlmICh3aW5kb3cubW9tZW50KSB7XG5cdFx0cmV0dXJuIGR0W21vbWVudEZuXSggYXJnMSApO1xuXHR9XG5cdGVsc2UgaWYgKHdpbmRvdy5sdXhvbikge1xuXHRcdHJldHVybiBkdFtsdXhvbkZuXSggYXJnMSApO1xuXHR9XG5cdFxuXHRyZXR1cm4gZGF0ZUZuID8gZHRbZGF0ZUZuXSggYXJnMSApIDogZHQ7XG59XG5cblxudmFyIF9fbWxXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBfX21sZE9iaiAoZCwgZm9ybWF0LCBsb2NhbGUpIHtcblx0dmFyIGR0O1xuXG5cdGlmICh3aW5kb3cubW9tZW50KSB7XG5cdFx0ZHQgPSB3aW5kb3cubW9tZW50LnV0YyggZCwgZm9ybWF0LCBsb2NhbGUsIHRydWUgKTtcblxuXHRcdGlmICghIGR0LmlzVmFsaWQoKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKHdpbmRvdy5sdXhvbikge1xuXHRcdGR0ID0gZm9ybWF0ICYmIHR5cGVvZiBkID09PSAnc3RyaW5nJ1xuXHRcdFx0PyB3aW5kb3cubHV4b24uRGF0ZVRpbWUuZnJvbUZvcm1hdCggZCwgZm9ybWF0IClcblx0XHRcdDogd2luZG93Lmx1eG9uLkRhdGVUaW1lLmZyb21JU08oIGQgKTtcblxuXHRcdGlmICghIGR0LmlzVmFsaWQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGR0LnNldExvY2FsZShsb2NhbGUpO1xuXHR9XG5cdGVsc2UgaWYgKCEgZm9ybWF0KSB7XG5cdFx0Ly8gTm8gZm9ybWF0IGdpdmVuLCBtdXN0IGJlIElTT1xuXHRcdGR0ID0gbmV3IERhdGUoZCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0aWYgKCEgX19tbFdhcm5pbmcpIHtcblx0XHRcdGFsZXJ0KCdEYXRhVGFibGVzIHdhcm5pbmc6IEZvcm1hdHRlZCBkYXRlIHdpdGhvdXQgTW9tZW50LmpzIG9yIEx1eG9uIC0gaHR0cHM6Ly9kYXRhdGFibGVzLm5ldC90bi8xNycpO1xuXHRcdH1cblxuXHRcdF9fbWxXYXJuaW5nID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBkdDtcbn1cblxuLy8gV3JhcHBlciBmb3IgZGF0ZSwgZGF0ZXRpbWUgYW5kIHRpbWUgd2hpY2ggYWxsIG9wZXJhdGUgdGhlIHNhbWUgd2F5IHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuLy8gdGhlIG91dHB1dCBzdHJpbmcgZm9yIGF1dG8gbG9jYWxlIHN1cHBvcnRcbmZ1bmN0aW9uIF9fbWxIZWxwZXIgKGxvY2FsZVN0cmluZykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKCBmcm9tLCB0bywgbG9jYWxlLCBkZWYgKSB7XG5cdFx0Ly8gTHV4b24gYW5kIE1vbWVudCBzdXBwb3J0XG5cdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRsb2NhbGUgPSAnZW4nO1xuXHRcdFx0dG8gPSBudWxsOyAvLyBtZWFucyB0b0xvY2FsZVN0cmluZ1xuXHRcdFx0ZnJvbSA9IG51bGw7IC8vIG1lYW5zIGlzbzg2MDFcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRsb2NhbGUgPSAnZW4nO1xuXHRcdFx0dG8gPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAyICkge1xuXHRcdFx0bG9jYWxlID0gdG87XG5cdFx0XHR0byA9IGZyb207XG5cdFx0XHRmcm9tID0gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgdHlwZU5hbWUgPSAnZGF0ZXRpbWUtJyArIHRvO1xuXG5cdFx0Ly8gQWRkIHR5cGUgZGV0ZWN0aW9uIGFuZCBzb3J0aW5nIHNwZWNpZmljIHRvIHRoaXMgZGF0ZSBmb3JtYXQgLSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gaWRlbnRpZnlcblx0XHQvLyBkYXRlIHR5cGUgY29sdW1ucyBhcyBzdWNoLCByYXRoZXIgdGhhbiBhcyBudW1iZXJzIGluIGV4dGVuc2lvbnMuIEhlbmNlIHRoZSBuZWVkIGZvciB0aGlzLlxuXHRcdGlmICghIERhdGFUYWJsZS5leHQudHlwZS5vcmRlclt0eXBlTmFtZV0pIHtcblx0XHRcdC8vIFRoZSByZW5kZXJlciB3aWxsIGdpdmUgdGhlIHZhbHVlIHRvIHR5cGUgZGV0ZWN0IGFzIHRoZSB0eXBlIVxuXHRcdFx0RGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdC51bnNoaWZ0KGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdHJldHVybiBkID09PSB0eXBlTmFtZSA/IHR5cGVOYW1lIDogZmFsc2U7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVGhlIHJlbmRlcmVyIGdpdmVzIHVzIE1vbWVudCwgTHV4b24gb3IgRGF0ZSBvYmVjdHMgZm9yIHRoZSBzb3J0aW5nLCBhbGwgb2Ygd2hpY2ggaGF2ZSBhXG5cdFx0XHQvLyBgdmFsdWVPZmAgd2hpY2ggZ2l2ZXMgbWlsbGlzZWNvbmRzIGVwb2NoXG5cdFx0XHREYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbdHlwZU5hbWUgKyAnLWFzYyddID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0dmFyIHggPSBhLnZhbHVlT2YoKTtcblx0XHRcdFx0dmFyIHkgPSBiLnZhbHVlT2YoKTtcblxuXHRcdFx0XHRyZXR1cm4geCA9PT0geVxuXHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdDogeCA8IHlcblx0XHRcdFx0XHRcdD8gLTFcblx0XHRcdFx0XHRcdDogMTtcblx0XHRcdH1cblxuXHRcdFx0RGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyW3R5cGVOYW1lICsgJy1kZXNjJ10gPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHR2YXIgeCA9IGEudmFsdWVPZigpO1xuXHRcdFx0XHR2YXIgeSA9IGIudmFsdWVPZigpO1xuXG5cdFx0XHRcdHJldHVybiB4ID09PSB5XG5cdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0OiB4ID4geVxuXHRcdFx0XHRcdFx0PyAtMVxuXHRcdFx0XHRcdFx0OiAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZCwgdHlwZSApIHtcblx0XHRcdC8vIEFsbG93IGZvciBhIGRlZmF1bHQgdmFsdWVcblx0XHRcdGlmIChkID09PSBudWxsIHx8IGQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoZGVmID09PSAnLS1ub3cnKSB7XG5cdFx0XHRcdFx0Ly8gV2UgdHJlYXQgZXZlcnl0aGluZyBhcyBVVEMgZnVydGhlciBkb3duLCBzbyBubyBjaGFuZ2VzIGFyZVxuXHRcdFx0XHRcdC8vIG1hZGUsIGFzIHN1Y2ggbmVlZCB0byBnZXQgdGhlIGxvY2FsIGRhdGUgLyB0aW1lIGFzIGlmIGl0IHdlcmVcblx0XHRcdFx0XHQvLyBVVENcblx0XHRcdFx0XHR2YXIgbG9jYWwgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSggRGF0ZS5VVEMoXG5cdFx0XHRcdFx0XHRsb2NhbC5nZXRGdWxsWWVhcigpLCBsb2NhbC5nZXRNb250aCgpLCBsb2NhbC5nZXREYXRlKCksXG5cdFx0XHRcdFx0XHRsb2NhbC5nZXRIb3VycygpLCBsb2NhbC5nZXRNaW51dGVzKCksIGxvY2FsLmdldFNlY29uZHMoKVxuXHRcdFx0XHRcdCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGUgPT09ICd0eXBlJykge1xuXHRcdFx0XHQvLyBUeXBpbmcgdXNlcyB0aGUgdHlwZSBuYW1lIGZvciBmYXN0IG1hdGNoaW5nXG5cdFx0XHRcdHJldHVybiB0eXBlTmFtZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGQgPT09ICcnKSB7XG5cdFx0XHRcdHJldHVybiB0eXBlICE9PSAnc29ydCdcblx0XHRcdFx0XHQ/ICcnXG5cdFx0XHRcdFx0OiBfX21sZE9iaignMDAwMC0wMS0wMSAwMDowMDowMCcsIG51bGwsIGxvY2FsZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3J0Y3V0LiBJZiBgZnJvbWAgYW5kIGB0b2AgYXJlIHRoZSBzYW1lLCB3ZSBhcmUgdXNpbmcgdGhlIHJlbmRlcmVyIHRvXG5cdFx0XHQvLyBmb3JtYXQgZm9yIG9yZGVyaW5nLCBub3QgZGlzcGxheSAtIGl0cyBhbHJlYWR5IGluIHRoZSBkaXNwbGF5IGZvcm1hdC5cblx0XHRcdGlmICggdG8gIT09IG51bGwgJiYgZnJvbSA9PT0gdG8gJiYgdHlwZSAhPT0gJ3NvcnQnICYmIHR5cGUgIT09ICd0eXBlJyAmJiAhIChkIGluc3RhbmNlb2YgRGF0ZSkgKSB7XG5cdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZHQgPSBfX21sZE9iaihkLCBmcm9tLCBsb2NhbGUpO1xuXG5cdFx0XHRpZiAoZHQgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlID09PSAnc29ydCcpIHtcblx0XHRcdFx0cmV0dXJuIGR0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgZm9ybWF0dGVkID0gdG8gPT09IG51bGxcblx0XHRcdFx0PyBfX21sZChkdCwgJ3RvRGF0ZScsICd0b0pTRGF0ZScsICcnKVtsb2NhbGVTdHJpbmddKClcblx0XHRcdFx0OiBfX21sZChkdCwgJ2Zvcm1hdCcsICd0b0Zvcm1hdCcsICd0b0lTT1N0cmluZycsIHRvKTtcblxuXHRcdFx0Ly8gWFNTIHByb3RlY3Rpb25cblx0XHRcdHJldHVybiB0eXBlID09PSAnZGlzcGxheScgP1xuXHRcdFx0XHRfX2h0bWxFc2NhcGVFbnRpdGllcyggZm9ybWF0dGVkICkgOlxuXHRcdFx0XHRmb3JtYXR0ZWQ7XG5cdFx0fTtcblx0fVxufVxuXG4vLyBCYXNlZCBvbiBsb2NhbGUsIGRldGVybWluZSBzdGFuZGFyZCBudW1iZXIgZm9ybWF0dGluZ1xuLy8gRmFsbGJhY2sgZm9yIGxlZ2FjeSBicm93c2VycyBpcyBVUyBFbmdsaXNoXG52YXIgX190aG91c2FuZHMgPSAnLCc7XG52YXIgX19kZWNpbWFsID0gJy4nO1xuXG5pZiAoSW50bCkge1xuXHR0cnkge1xuXHRcdHZhciBudW0gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKS5mb3JtYXRUb1BhcnRzKDEwMDAwMC4xKTtcblx0XG5cdFx0Zm9yICh2YXIgaT0wIDsgaTxudW0ubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRpZiAobnVtW2ldLnR5cGUgPT09ICdncm91cCcpIHtcblx0XHRcdFx0X190aG91c2FuZHMgPSBudW1baV0udmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChudW1baV0udHlwZSA9PT0gJ2RlY2ltYWwnKSB7XG5cdFx0XHRcdF9fZGVjaW1hbCA9IG51bVtpXS52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y2F0Y2ggKGUpIHtcblx0XHQvLyBub29wXG5cdH1cbn1cblxuLy8gRm9ybWF0dGVkIGRhdGUgdGltZSBkZXRlY3Rpb24gLSB1c2UgYnkgZGVjbGFyaW5nIHRoZSBmb3JtYXRzIHlvdSBhcmUgZ29pbmcgdG8gdXNlXG5EYXRhVGFibGUuZGF0ZXRpbWUgPSBmdW5jdGlvbiAoIGZvcm1hdCwgbG9jYWxlICkge1xuXHR2YXIgdHlwZU5hbWUgPSAnZGF0ZXRpbWUtZGV0ZWN0LScgKyBmb3JtYXQ7XG5cblx0aWYgKCEgbG9jYWxlKSB7XG5cdFx0bG9jYWxlID0gJ2VuJztcblx0fVxuXG5cdGlmICghIERhdGFUYWJsZS5leHQudHlwZS5vcmRlclt0eXBlTmFtZV0pIHtcblx0XHREYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnVuc2hpZnQoZnVuY3Rpb24gKGQpIHtcblx0XHRcdHZhciBkdCA9IF9fbWxkT2JqKGQsIGZvcm1hdCwgbG9jYWxlKTtcblx0XHRcdHJldHVybiBkID09PSAnJyB8fCBkdCA/IHR5cGVOYW1lIDogZmFsc2U7XG5cdFx0fSk7XG5cblx0XHREYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbdHlwZU5hbWUgKyAnLXByZSddID0gZnVuY3Rpb24gKGQpIHtcblx0XHRcdHJldHVybiBfX21sZE9iaihkLCBmb3JtYXQsIGxvY2FsZSkgfHwgMDtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBIZWxwZXJzIGZvciBgY29sdW1ucy5yZW5kZXJgLlxuICpcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXG4gKiBvcHRpb24gdG8gcHJvdmlkZSBhIGRpc3BsYXkgcmVuZGVyZXIuIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBkZWZpbmVkOlxuICpcbiAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxuICogICBkaXNwbGF5LCByZXRhaW5pbmcgdGhlIG9yaWdpbmFsIHVuZm9ybWF0dGVkIGRhdGEgZm9yIHNvcnRpbmcgYW5kIGZpbHRlcmluZy5cbiAqICAgSXQgdGFrZXMgNSBwYXJhbWV0ZXJzOlxuICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxuICogICAqIGBzdHJpbmdgIC0gRGVjaW1hbCBwb2ludCBpbmRpY2F0b3JcbiAqICAgKiBgaW50ZWdlcmAgLSBOdW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdG8gc2hvd1xuICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXG4gKiAgICogYHN0cmluZ2AgKG9wdGlvbmFsKSAtIFBvc3RmaXggKC9zdWZmaXgpLlxuICogKiBgdGV4dGAgLSBFc2NhcGUgSFRNTCB0byBoZWxwIHByZXZlbnQgWFNTIGF0dGFja3MuIEl0IGhhcyBubyBvcHRpb25hbFxuICogICBwYXJhbWV0ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIENvbHVtbiBkZWZpbml0aW9uIHVzaW5nIHRoZSBudW1iZXIgcmVuZGVyZXJcbiAqICAge1xuICogICAgIGRhdGE6IFwic2FsYXJ5XCIsXG4gKiAgICAgcmVuZGVyOiAkLmZuLmRhdGFUYWJsZS5yZW5kZXIubnVtYmVyKCAnXFwnJywgJy4nLCAwLCAnJCcgKVxuICogICB9XG4gKlxuICogQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUucmVuZGVyID0ge1xuXHRkYXRlOiBfX21sSGVscGVyKCd0b0xvY2FsZURhdGVTdHJpbmcnKSxcblx0ZGF0ZXRpbWU6IF9fbWxIZWxwZXIoJ3RvTG9jYWxlU3RyaW5nJyksXG5cdHRpbWU6IF9fbWxIZWxwZXIoJ3RvTG9jYWxlVGltZVN0cmluZycpLFxuXHRudW1iZXI6IGZ1bmN0aW9uICggdGhvdXNhbmRzLCBkZWNpbWFsLCBwcmVjaXNpb24sIHByZWZpeCwgcG9zdGZpeCApIHtcblx0XHQvLyBBdXRvIGxvY2FsZSBkZXRlY3Rpb25cblx0XHRpZiAodGhvdXNhbmRzID09PSBudWxsIHx8IHRob3VzYW5kcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aG91c2FuZHMgPSBfX3Rob3VzYW5kcztcblx0XHR9XG5cblx0XHRpZiAoZGVjaW1hbCA9PT0gbnVsbCB8fCBkZWNpbWFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGRlY2ltYWwgPSBfX2RlY2ltYWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRpc3BsYXk6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGQgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGQgPT09ICcnIHx8IGQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBuZWdhdGl2ZSA9IGQgPCAwID8gJy0nIDogJyc7XG5cdFx0XHRcdHZhciBmbG8gPSBwYXJzZUZsb2F0KCBkICk7XG5cblx0XHRcdFx0Ly8gSWYgTmFOIHRoZW4gdGhlcmUgaXNuJ3QgbXVjaCBmb3JtYXR0aW5nIHRoYXQgd2UgY2FuIGRvIC0ganVzdFxuXHRcdFx0XHQvLyByZXR1cm4gaW1tZWRpYXRlbHksIGVzY2FwaW5nIGFueSBIVE1MICh0aGlzIHdhcyBzdXBwb3NlZCB0b1xuXHRcdFx0XHQvLyBiZSBhIG51bWJlciBhZnRlciBhbGwpXG5cdFx0XHRcdGlmICggaXNOYU4oIGZsbyApICkge1xuXHRcdFx0XHRcdHJldHVybiBfX2h0bWxFc2NhcGVFbnRpdGllcyggZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmxvID0gZmxvLnRvRml4ZWQoIHByZWNpc2lvbiApO1xuXHRcdFx0XHRkID0gTWF0aC5hYnMoIGZsbyApO1xuXG5cdFx0XHRcdHZhciBpbnRQYXJ0ID0gcGFyc2VJbnQoIGQsIDEwICk7XG5cdFx0XHRcdHZhciBmbG9hdFBhcnQgPSBwcmVjaXNpb24gP1xuXHRcdFx0XHRcdGRlY2ltYWwrKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKCBwcmVjaXNpb24gKS5zdWJzdHJpbmcoIDIgKTpcblx0XHRcdFx0XHQnJztcblxuXHRcdFx0XHQvLyBJZiB6ZXJvLCB0aGVuIGNhbid0IGhhdmUgYSBuZWdhdGl2ZSBwcmVmaXhcblx0XHRcdFx0aWYgKGludFBhcnQgPT09IDAgJiYgcGFyc2VGbG9hdChmbG9hdFBhcnQpID09PSAwKSB7XG5cdFx0XHRcdFx0bmVnYXRpdmUgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZWdhdGl2ZSArIChwcmVmaXh8fCcnKSArXG5cdFx0XHRcdFx0aW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgdGhvdXNhbmRzXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0ZmxvYXRQYXJ0ICtcblx0XHRcdFx0XHQocG9zdGZpeHx8JycpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkaXNwbGF5OiBfX2h0bWxFc2NhcGVFbnRpdGllcyxcblx0XHRcdGZpbHRlcjogX19odG1sRXNjYXBlRW50aXRpZXNcblx0XHR9O1xuXHR9XG59O1xuXG5cbi8qXG4gKiBUaGlzIGlzIHJlYWxseSBhIGdvb2QgYml0IHJ1YmJpc2ggdGhpcyBtZXRob2Qgb2YgZXhwb3NpbmcgdGhlIGludGVybmFsIG1ldGhvZHNcbiAqIHB1YmxpY2x5Li4uIC0gVG8gYmUgZml4ZWQgaW4gMi4wIHVzaW5nIG1ldGhvZHMgb24gdGhlIHByb3RvdHlwZVxuICovXG5cblxuLyoqXG4gKiBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBleHBvcnRpbmcgYW4gaW50ZXJuYWwgZnVuY3Rpb25zIHRvIGFuIGV4dGVybmFsIEFQSS5cbiAqICBAcGFyYW0ge3N0cmluZ30gZm4gQVBJIGZ1bmN0aW9uIG5hbWVcbiAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI2ludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9mbkV4dGVybkFwaUZ1bmMgKGZuKVxue1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBbX2ZuU2V0dGluZ3NGcm9tTm9kZSggdGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0gKV0uY29uY2F0KFxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXHRcdCk7XG5cdFx0cmV0dXJuIERhdGFUYWJsZS5leHQuaW50ZXJuYWxbZm5dLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdH07XG59XG5cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcbiAqIHRoZXNlIG1ldGhvZHMgYXJlIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGFuZCBhcmUgY29uc2lkZXJlZCB0byBiZVxuICogcHJpdmF0ZS4gSWYgeW91IHVzZSB0aGVzZSBtZXRob2RzLCBiZSBhd2FyZSB0aGF0IHRoZXkgYXJlIGxpYWJsZSB0byBjaGFuZ2VcbiAqIGJldHdlZW4gdmVyc2lvbnMuXG4gKiAgQG5hbWVzcGFjZVxuICovXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xuXHRfZm5FeHRlcm5BcGlGdW5jOiBfZm5FeHRlcm5BcGlGdW5jLFxuXHRfZm5CdWlsZEFqYXg6IF9mbkJ1aWxkQWpheCxcblx0X2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcblx0X2ZuQWpheFBhcmFtZXRlcnM6IF9mbkFqYXhQYXJhbWV0ZXJzLFxuXHRfZm5BamF4VXBkYXRlRHJhdzogX2ZuQWpheFVwZGF0ZURyYXcsXG5cdF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcblx0X2ZuQWRkQ29sdW1uOiBfZm5BZGRDb2x1bW4sXG5cdF9mbkNvbHVtbk9wdGlvbnM6IF9mbkNvbHVtbk9wdGlvbnMsXG5cdF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxuXHRfZm5WaXNpYmxlVG9Db2x1bW5JbmRleDogX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgsXG5cdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxcblx0X2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcblx0X2ZuR2V0Q29sdW1uczogX2ZuR2V0Q29sdW1ucyxcblx0X2ZuQ29sdW1uVHlwZXM6IF9mbkNvbHVtblR5cGVzLFxuXHRfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcblx0X2ZuSHVuZ2FyaWFuTWFwOiBfZm5IdW5nYXJpYW5NYXAsXG5cdF9mbkNhbWVsVG9IdW5nYXJpYW46IF9mbkNhbWVsVG9IdW5nYXJpYW4sXG5cdF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcblx0X2ZuQnJvd3NlckRldGVjdDogX2ZuQnJvd3NlckRldGVjdCxcblx0X2ZuQWRkRGF0YTogX2ZuQWRkRGF0YSxcblx0X2ZuQWRkVHI6IF9mbkFkZFRyLFxuXHRfZm5Ob2RlVG9EYXRhSW5kZXg6IF9mbk5vZGVUb0RhdGFJbmRleCxcblx0X2ZuTm9kZVRvQ29sdW1uSW5kZXg6IF9mbk5vZGVUb0NvbHVtbkluZGV4LFxuXHRfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXG5cdF9mblNldENlbGxEYXRhOiBfZm5TZXRDZWxsRGF0YSxcblx0X2ZuU3BsaXRPYmpOb3RhdGlvbjogX2ZuU3BsaXRPYmpOb3RhdGlvbixcblx0X2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXG5cdF9mblNldE9iamVjdERhdGFGbjogX2ZuU2V0T2JqZWN0RGF0YUZuLFxuXHRfZm5HZXREYXRhTWFzdGVyOiBfZm5HZXREYXRhTWFzdGVyLFxuXHRfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxuXHRfZm5EZWxldGVJbmRleDogX2ZuRGVsZXRlSW5kZXgsXG5cdF9mbkludmFsaWRhdGU6IF9mbkludmFsaWRhdGUsXG5cdF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcblx0X2ZuQ3JlYXRlVHI6IF9mbkNyZWF0ZVRyLFxuXHRfZm5CdWlsZEhlYWQ6IF9mbkJ1aWxkSGVhZCxcblx0X2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxuXHRfZm5EcmF3OiBfZm5EcmF3LFxuXHRfZm5SZURyYXc6IF9mblJlRHJhdyxcblx0X2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxuXHRfZm5EZXRlY3RIZWFkZXI6IF9mbkRldGVjdEhlYWRlcixcblx0X2ZuR2V0VW5pcXVlVGhzOiBfZm5HZXRVbmlxdWVUaHMsXG5cdF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcblx0X2ZuRmlsdGVyQ29tcGxldGU6IF9mbkZpbHRlckNvbXBsZXRlLFxuXHRfZm5GaWx0ZXJDdXN0b206IF9mbkZpbHRlckN1c3RvbSxcblx0X2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXG5cdF9mbkZpbHRlcjogX2ZuRmlsdGVyLFxuXHRfZm5GaWx0ZXJDcmVhdGVTZWFyY2g6IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxcblx0X2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxuXHRfZm5GaWx0ZXJEYXRhOiBfZm5GaWx0ZXJEYXRhLFxuXHRfZm5GZWF0dXJlSHRtbEluZm86IF9mbkZlYXR1cmVIdG1sSW5mbyxcblx0X2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcblx0X2ZuSW5mb01hY3JvczogX2ZuSW5mb01hY3Jvcyxcblx0X2ZuSW5pdGlhbGlzZTogX2ZuSW5pdGlhbGlzZSxcblx0X2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXG5cdF9mbkxlbmd0aENoYW5nZTogX2ZuTGVuZ3RoQ2hhbmdlLFxuXHRfZm5GZWF0dXJlSHRtbExlbmd0aDogX2ZuRmVhdHVyZUh0bWxMZW5ndGgsXG5cdF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXG5cdF9mblBhZ2VDaGFuZ2U6IF9mblBhZ2VDaGFuZ2UsXG5cdF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZzogX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nLFxuXHRfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXG5cdF9mbkZlYXR1cmVIdG1sVGFibGU6IF9mbkZlYXR1cmVIdG1sVGFibGUsXG5cdF9mblNjcm9sbERyYXc6IF9mblNjcm9sbERyYXcsXG5cdF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxuXHRfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHM6IF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxcblx0X2ZuVGhyb3R0bGU6IF9mblRocm90dGxlLFxuXHRfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXG5cdF9mbkdldFdpZGVzdE5vZGU6IF9mbkdldFdpZGVzdE5vZGUsXG5cdF9mbkdldE1heExlblN0cmluZzogX2ZuR2V0TWF4TGVuU3RyaW5nLFxuXHRfZm5TdHJpbmdUb0NzczogX2ZuU3RyaW5nVG9Dc3MsXG5cdF9mblNvcnRGbGF0dGVuOiBfZm5Tb3J0RmxhdHRlbixcblx0X2ZuU29ydDogX2ZuU29ydCxcblx0X2ZuU29ydEFyaWE6IF9mblNvcnRBcmlhLFxuXHRfZm5Tb3J0TGlzdGVuZXI6IF9mblNvcnRMaXN0ZW5lcixcblx0X2ZuU29ydEF0dGFjaExpc3RlbmVyOiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIsXG5cdF9mblNvcnRpbmdDbGFzc2VzOiBfZm5Tb3J0aW5nQ2xhc3Nlcyxcblx0X2ZuU29ydERhdGE6IF9mblNvcnREYXRhLFxuXHRfZm5TYXZlU3RhdGU6IF9mblNhdmVTdGF0ZSxcblx0X2ZuTG9hZFN0YXRlOiBfZm5Mb2FkU3RhdGUsXG5cdF9mbkltcGxlbWVudFN0YXRlOiBfZm5JbXBsZW1lbnRTdGF0ZSxcblx0X2ZuU2V0dGluZ3NGcm9tTm9kZTogX2ZuU2V0dGluZ3NGcm9tTm9kZSxcblx0X2ZuTG9nOiBfZm5Mb2csXG5cdF9mbk1hcDogX2ZuTWFwLFxuXHRfZm5CaW5kQWN0aW9uOiBfZm5CaW5kQWN0aW9uLFxuXHRfZm5DYWxsYmFja1JlZzogX2ZuQ2FsbGJhY2tSZWcsXG5cdF9mbkNhbGxiYWNrRmlyZTogX2ZuQ2FsbGJhY2tGaXJlLFxuXHRfZm5MZW5ndGhPdmVyZmxvdzogX2ZuTGVuZ3RoT3ZlcmZsb3csXG5cdF9mblJlbmRlcmVyOiBfZm5SZW5kZXJlcixcblx0X2ZuRGF0YVNvdXJjZTogX2ZuRGF0YVNvdXJjZSxcblx0X2ZuUm93QXR0cmlidXRlczogX2ZuUm93QXR0cmlidXRlcyxcblx0X2ZuRXh0ZW5kOiBfZm5FeHRlbmQsXG5cdF9mbkNhbGN1bGF0ZUVuZDogZnVuY3Rpb24gKCkge30gLy8gVXNlZCBieSBhIGxvdCBvZiBwbHVnLWlucywgYnV0IHJlZHVuZGFudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIDEuMTAsIHNvIHRoaXMgZGVhZC1lbmQgZnVuY3Rpb24gaXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRlZCB0byBwcmV2ZW50IGVycm9yc1xufSApO1xuXG5cbi8vIGpRdWVyeSBhY2Nlc3NcbiQuZm4uZGF0YVRhYmxlID0gRGF0YVRhYmxlO1xuXG4vLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG5EYXRhVGFibGUuJCA9ICQ7XG5cbi8vIExlZ2FjeSBhbGlhc2VzXG4kLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuJC5mbi5kYXRhVGFibGVFeHQgPSBEYXRhVGFibGUuZXh0O1xuXG4vLyBXaXRoIGEgY2FwaXRhbCBgRGAgd2UgcmV0dXJuIGEgRGF0YVRhYmxlcyBBUEkgaW5zdGFuY2UgcmF0aGVyIHRoYW4gYVxuLy8galF1ZXJ5IG9iamVjdFxuJC5mbi5EYXRhVGFibGUgPSBmdW5jdGlvbiAoIG9wdHMgKSB7XG5cdHJldHVybiAkKHRoaXMpLmRhdGFUYWJsZSggb3B0cyApLmFwaSgpO1xufTtcblxuLy8gQWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvICQuZm4uZGF0YVRhYmxlIHNob3VsZCBhbHNvIGJlXG4vLyBhdmFpbGFibGUgb24gJC5mbi5EYXRhVGFibGVcbiQuZWFjaCggRGF0YVRhYmxlLCBmdW5jdGlvbiAoIHByb3AsIHZhbCApIHtcblx0JC5mbi5EYXRhVGFibGVbIHByb3AgXSA9IHZhbDtcbn0gKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/datatables.net/js/jquery.dataTables.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/bootstrap.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;